---
date: 2021-03-17
description: "战略上藐视技术，战术上重视技术——闪客"
image: "images/recommend_site/xingyouji.jpg"
title: "数组"
author: 诸葛青
authorEmoji: 🤖
pinned: false
tags:
- 数据结构
series:
-   
---

## 数组的定义

根据 [维基百科](https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84) 的定义，在计算机科学中，``数组数据结构``（英语：``array data structure``），简称``数组``（英语：``Array``），是由``相同类型``的``元素（element）的集合``所组成的数据结构，分配一块``连续``的内存来存储。利用元素的``索引（index）``可以计算出该元素对应的``存储地址``

---

## 数组的分类

``数组`` 分为两种类型：``一维数组`` 和 ``多维数组``。

``一维数组``：``一维（或单维）数组``是一种线性数组，其中元素的访问是以行或列索引的``单一下标``表示。

``多维数组``：``多维数组``是由多个低维数组组成的一种数组，其中元素的访问是以``多个下标``为索引来表示。

![](/images/dataStructure/array/array1.png)

``多维数组``的``存储空间``本质上跟``一维数组``一样，都是``连续存储``的，只不过``多维数组``将一个大容量的数组``分隔``开来，分成多个小的数组，比如二维数组是由0个或多个一维数组组成的数组，三维数组是由0个或多个二维数组组成数组，以此类推....

---

## 数组的查找

1. 当计算机需要随机访问``数组``中的``某个元素``时，它会首先通过下面的``寻址公式``，计算出该元素存储的``内存地址``：

```
a[i]_address = base_address + i * data_type_size
```
其中 ``data_type_size`` 表示数组中``每个元素的大小``（即``存储数据类型的大小``），假如数组中存放的是``int类型``，那么data_type_size就是4个字节，``a[i]_address``就是需要查找的元素的``内存地址``，``base_address``就是``数组的首地址``（即：``a[0]的内存地址``）

2. 通过一个简单的例子来明白``数组元素``的``内存地址的计算``

从``数组``存储的``内存模型``上来看，``“下标”``最确切的定义应该是``“偏移（offset）”``。前面也讲到，如果用 ``a`` 来表示数组的首地址，``a[0]`` 就是偏移为 ``0`` 的位置，也就是``首地址``，``a[k]`` 就表示偏移 ``k`` 个 data_type_size 的位置，所以计算 ``a[k]`` 的内存地址只需要用这个公式：
```
a[k]_address = base_address + k * data_type_size
```

```c
#include <stdio.h>

int main()
{
    int a[3] = {0};
    int k = 2; //（这里k应该在区间[0,3)内）
    if (&a[k] == (a + k))
        printf("a[k]_address = base_address + k * type_size式子成立~");
    else
        printf("a[k]_address = base_address + k * type_size式子不成立！");

    return 0;
}
```
{{< alert theme="info" >}}
  因为当一个地址与一个整型数相加时，在进行加法运算之前会自动将整型数转换k*data_type_size的形式，所以当请不要尝试k+sizeof(int)，以免混淆记忆。
{{< /alert >}}

3. 为什么大多数编程语言中，数组要从 ``0`` 开始``编号``，而不是从 ``1`` 开始呢？

{{< notice success >}}
答案：从刚才那个``计算公式``就可以知道，倘若从数组1开始编号，那么计算数组元素 ``a[k]`` 的``内存地址``就会变为：

 ``a[k]_address = base_address + (k-1)*type_size``

``对比两个公式``，我们不难发现，从 1 开始编号，每次随机访问数组元素都``多了一次减法运算``，对于 ``CPU`` 来说，就是``多了一次减法指令``。

``数组``作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，``效率的优化``就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 ``0`` 开始编号，而不是从 ``1`` 开始。

不过我认为，上面解释得再多其实都算不上压倒性的证明，说数组起始编号非 0 开始不可。所以我觉得最主要的原因可能是``历史原因  ``。

``C 语言设计者``用 ``0`` 开始计数数组下标，之后的 ``Java、JavaScript 等高级语言``都效仿了`` C 语言``，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。实际上，很多语言中数组也并不是从 0 开始计数的，比如 ``Matlab``。甚至还有一些语言支持负数下标，比如 ``Python``。

> 数据结构与算法之美作者——王争 的原话
{{< /notice >}}

<font color=LightSeaGreen size=3 >  </font>

总结：数组根据下标随机访问的时间复杂度为 ``O(1)``，用给定元素查找的时间复杂度为``O(n)``。（上述内容虽然未涉及到查找操作，但理解的可以自行尝试，``最好的情况``，从``下标0``开始就找到，``最坏情况``，在``最后一个下标``才找到）

---

## 数组的插入

假设数组的``长度``为 ``n``，现在，如果我们需要将``一个数据``插入到数组中的第 ``k`` 个位置。为了把第 ``k`` 个位置腾出来，给新来的数据，我们需要将第 ``k～n`` 这部分的元素都顺序地往``后挪一位``。那``插入操作``的``时间复杂度``是多少呢？

如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为我们在每个位置插入元素的概率是一样的，所以``平均情况时间复杂度为 (1+2+…n)/n=O(n)``。

![](/images/dataStructure/array/array2.png)

如果数组中的数据是``有序的``，我们在某个位置``插入一个新的元素``时，就必须按照刚才的方法搬移 ``k`` 之后的数据。但是，如果数组中存储的``数据并没有任何规律``，数组只是被当作``一个存储数据的集合``。在这种情况下，如果要将某个数组插入到``第 k 个位置``，``为了避免大规模的数据搬移``，我们还有一个简单的办法就是，直接将``第 k 位的数据``搬移到``数组元素的最后``，``把新的元素直接放入第 k 个位置``。

![](/images/dataStructure/array/array3.png)

利用这种处理技巧，在特定场景下，``在第 k 个位置``插入一个元素的``时间复杂度``就会降为 ``O(1)``

总结：数组在``需要保持有序``的状态下，将元素插入到第k个位置的时间复杂度``O(n)``，数组在``无需保持有序``的状态下，将元素插入到第k个位置的时间复杂度为``O(1)``

---

## 数组的删除

跟``插入数据``类似，如果我们要``删除``第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，``内存就不连续了``。

和插入类似，如果``删除数组末尾的数据``，则最好情况时间复杂度为 ``O(1)``；如果``删除开头的数据``，则最坏情况时间复杂度为 ``O(n)``；平均情况时间复杂度也为 ``O(n)``

![](/images/dataStructure/array/array4.png)


## 警惕数组的访问越界问题

请分析如下代码
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
    int i = 0;
    int arr[3] = {0};
    for (; i <= 3; i++)
    {
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

你发现问题了吗？这段代码的``运行结果``并非是``打印三行``“hello word”，而是会``无限``打印“hello world”，这是为什么呢？

``因为，数组大小为 3，a[0]，a[1]，a[2]，而我们的代码因为书写错误，导致 for 循环的结束条件错写为了 i<=3 而非 i<3，所以当 i=3 时，数组 a[3] 访问越界。``

我们知道，在 C 语言中，``只要不是访问受限的内存``，``所有的内存空间都是可以自由访问的``。根据我们前面讲的数组寻址公式，``a[3] 也会被定位到某块不属于数组的内存地址上``，而这个地址正好是存储变量 ``i`` 的内存地址，那么 ``a[3]=0 就相当于 i=0``，所以就会``导致代码无限循环``。

所有只需再随便加一个变量即可，使得i不再变为0，就可解决无限循环问题，因为它会将j变为0
```c
#include <stdio.h>

int main(int argc, char *argv[])
{
    int i = 0;
    int j = 99;
    int arr[3] = {0};
    for (; i <= 3; i++)
    {
        arr[i] = 0;
        printf("hello world\n");
    }

    printf("j = %d", j);
    return 0;
}
```

``数组越界``在 ``C 语言``中是一种``未决行为``，并没有规定``数组访问越界``时编译器应该如何处理。因为，访问数组的``本质``就是访问一段连续内存，``只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。

这种情况下，一般都会出现莫名其妙的``逻辑错误``，而且，很多``计算机病毒``也正是利用到了代码中的``数组越界``可以访问``非法地址``的``漏洞``，来``攻击系统``，所以写代码的时候一定要``警惕数组越界``。

{{< alert theme="info" >}}
目前的主流的语言如java这样的会自己检查数组越界，而无须程序员自己检查。 
{{< /alert >}}
