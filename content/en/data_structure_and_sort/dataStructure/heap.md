---
date: 2021-03-16
description: "æˆ˜ç•¥ä¸Šè—è§†æŠ€æœ¯ï¼Œæˆ˜æœ¯ä¸Šé‡è§†æŠ€æœ¯â€”â€”é—ªå®¢"
image: "images/recommend_site/xingyouji.jpg"
title: "å †"
author: è¯¸è‘›é’
authorEmoji: ğŸ¤–
pinned: true
tags:
- æ•°æ®ç»“æ„
series:
-   
---
## å †çš„å®šä¹‰

æ ¹æ® [ç»´åŸºç™¾ç§‘](https://zh.wikipedia.org/wiki/%E5%A0%86%E7%A9%8D) çš„å®šä¹‰ï¼Œ``å †`` æ˜¯ä¸€ç§ç‰¹åˆ«çš„äºŒå‰æ ‘ï¼Œæ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„äºŒå‰æ ‘ï¼Œå¯ä»¥ç§°ä¹‹ä¸º ``å †``ï¼š
* 1.å®Œå…¨äºŒå‰æ ‘ï¼›
* 2.æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½å¿…é¡» å¤§äºç­‰äºæˆ–è€…å°äºç­‰äº å…¶å­©å­èŠ‚ç‚¹çš„å€¼ã€‚

``å †`` å…·æœ‰ä»¥ä¸‹çš„ç‰¹ç‚¹ï¼š

* 1.å¯ä»¥åœ¨ ``O(logN)`` çš„æ—¶é—´å¤æ‚åº¦å†…å‘ ``å †`` ä¸­æ’å…¥å…ƒç´ ï¼›
* 2.å¯ä»¥åœ¨ ``O(logN)`` çš„æ—¶é—´å¤æ‚åº¦å†…å‘ ``å †`` ä¸­åˆ é™¤å…ƒç´ ï¼›
* 3.å¯ä»¥åœ¨ ``O(1)`` çš„æ—¶é—´å¤æ‚åº¦å†…è·å– ``å †`` ä¸­çš„æœ€å¤§å€¼æˆ–æœ€å°å€¼ã€‚

## å †çš„åˆ†ç±»
``å †`` åˆ†ä¸ºä¸¤ç§ç±»å‹ï¼š``æœ€å¤§å †`` å’Œ ``æœ€å°å †``ã€‚

``æœ€å¤§å †ï¼ˆå¤§é¡¶å †ï¼‰``ï¼šå †ä¸­æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„å€¼ ``éƒ½å¤§äºç­‰äº`` å…¶å­©å­èŠ‚ç‚¹çš„å€¼ã€‚``æœ€å¤§å †``çš„ç‰¹æ€§æ˜¯ ``å †é¡¶å…ƒç´ ï¼ˆæ ¹èŠ‚ç‚¹ï¼‰æ˜¯å †ä¸­çš„æœ€å¤§å€¼``ã€‚

``æœ€å°å †ï¼ˆå°é¡¶å †ï¼‰``ï¼šå †ä¸­æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„å€¼ ``éƒ½å°äºç­‰äº`` å…¶å­©å­èŠ‚ç‚¹çš„å€¼ã€‚``æœ€å°å †``çš„ç‰¹æ€§æ˜¯ ``å †é¡¶å…ƒç´ ï¼ˆæ ¹èŠ‚ç‚¹ï¼‰æ˜¯å †ä¸­çš„æœ€å°å€¼``ã€‚

![](/images/dataStructure/heap/heap1.png)

## å †çš„å­˜å‚¨
``å †``çš„é€»è¾‘ç»“æ„æ˜¯ä¸€æ£µäºŒå‰æ ‘ï¼Œæ‰€ä»¥å¯ä»¥è€ƒè™‘ä½¿ç”¨äºŒå‰æ ‘çš„è¡¨ç¤ºæ–¹æ³•æ¥è¡¨ç¤ºå †ã€‚ä½†æ˜¯å› ä¸º``å †ä¸­``å…ƒç´ æŒ‰ç…§ä¸€å®šçš„ä¼˜å…ˆé¡ºåºæ’åˆ—ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨ ``æ•°ç»„``æ¥è¡¨ç¤ºï¼Œè¿™æ ·å¯ä»¥èŠ‚çœå­èŠ‚ç‚¹æŒ‡é’ˆç©ºé—´ï¼Œå¹¶ä¸”å¯ä»¥``å¿«é€Ÿè®¿é—®``æ¯ä¸ªèŠ‚ç‚¹ã€‚``å †``çš„æ•°ç»„è¡¨ç¤ºå…¶å®å°±æ˜¯å †å±‚çº§éå†çš„ç»“æœï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

![](/images/dataStructure/heap/heap2.png)

## å †çš„æ“ä½œ
åœ¨``å †``çš„æ•°æ®ç»“æ„ä¸­ï¼Œæˆ‘ä»¬å¸¸ç”¨å †çš„`åˆå§‹åŒ–`ã€``æ’å…¥``ã€``åˆ é™¤``ã€``è·å–å †é¡¶å…ƒç´ ``çš„æ“ä½œã€‚
æ¥ä¸‹æ¥æˆ‘ä»¬ä¸€ä¸€è¿›è¡Œå­¦ä¹ ï¼š

## å †åˆå§‹åŒ–æ“ä½œ
* 1.``ç¡®å®šå †åŒ…å«çš„å±æ€§``ï¼š``å †çš„æœ€å¤§ç©ºé—´``ï¼Œ``å †çš„å½“å‰å¤§å°``ï¼Œ``å †çš„å­˜æ”¾æ•°ç»„``
* 2.``åˆå§‹åŒ–å †ï¼Œä¸ºå…¶åˆ†é…å†…å­˜ç©ºé—´``

ä»£ç å®ç°å¦‚ä¸‹ï¼ˆå¤§é¡¶å †ï¼‰ï¼š
{{< codes golang c>}}

  {{< code >}}

  ```golang
type MaxHeap struct {
	// ä½¿ç”¨æ•°ç»„åˆ›å»ºå®Œå…¨äºŒå‰æ ‘çš„ç»“æ„ï¼Œç„¶åä½¿ç”¨äºŒå‰æ ‘æ„å»ºä¸€ä¸ªã€Œå †ã€
	maxHeap []int
	// heapSizeç”¨äºæ•°ç»„çš„å¤§å°ï¼Œå› ä¸ºæ•°ç»„åœ¨åˆ›å»ºçš„æ—¶å€™è‡³å°‘éœ€è¦æŒ‡æ˜æ•°ç»„çš„å…ƒç´ ä¸ªæ•°
	heapSize int
	// realSizeç”¨äºè®°å½•ã€Œå †ã€çš„å…ƒç´ ä¸ªæ•°
	realSize int
}

//å¤§é¡¶å †åˆå§‹åŒ–å‡½æ•°
func MaxHeapInit(size int)MaxHeap{
	return MaxHeap{
		maxHeap: make([]int, size+1),
		heapSize: size,
		realSize: 0,
	}
}
  ```
  {{< /code >}}

  {{< code >}}

  ```c
typedef struct
{
    //å †çš„æ•°ç»„
    int *maxHeap;
    //å †çš„å…ƒç´ ä¸ªæ•°
    int realSize;
    //å †çš„å¤§å°
    int MaxSize;
} MaxHeap;

//åˆå§‹åŒ–å †å‡½æ•°
void initMaxHeap(MaxHeap *mh, int size)
{
    mh->MaxSize = size;
    mh->maxHeap = (int *)malloc((mh->MaxSize + 1) * sizeof(int)); //ä»1å¼€å§‹å­˜å‚¨
    mh->realSize = 0;
}
  ```
  {{< /code >}}
{{< /codes >}}

## å †æ’å…¥æ“ä½œ

``å †``å¯ä»¥çœ‹æˆä¸€ä¸ªå®Œå…¨äºŒå‰æ ‘ï¼Œæ¯æ¬¡æ€»æ˜¯å…ˆå¡«æ»¡``ä¸Šä¸€å±‚``ï¼Œå†ä»``ä¸‹ä¸€å±‚ä»å·¦å¾€å³``ä¾æ¬¡æ’å…¥ã€‚å †æ’å…¥æ“ä½œçš„æ­¥éª¤ï¼ˆå¤§é¡¶å †ï¼‰ï¼š

* 1.``å°†æ–°å…ƒç´ å¢åŠ åˆ°å †çš„æœ«å°¾``
* 2.``æŒ‰ç…§ä¼˜å…ˆé¡ºåºï¼Œå°†æ–°å…ƒç´ ä¸å…¶çˆ¶èŠ‚ç‚¹æ¯”è¾ƒï¼Œå¦‚æœæ–°å…ƒç´ å°äºçˆ¶èŠ‚ç‚¹åˆ™å°†ä¸¤è€…äº¤æ¢ä½ç½®``
* 3.``ä¸æ–­è¿›è¡Œç¬¬2æ­¥æ“ä½œï¼Œç›´åˆ°ä¸éœ€è¦äº¤æ¢æ–°å…ƒç´ å’Œçˆ¶èŠ‚ç‚¹ï¼Œæˆ–è€…è¾¾åˆ°å †é¡¶``
* 4.``æœ€åé€šè¿‡å¾—åˆ°ä¸€ä¸ªå¤§é¡¶å †``

ä»£ç å®ç°å¦‚ä¸‹ï¼ˆå¤§é¡¶å †ï¼‰ï¼š

{{< codes golang c>}}

  {{< code >}}

  ```golang
//æ·»åŠ å…ƒç´ å‡½æ•°
func (Maxheap *MaxHeap)insert(element int){
	//å¦‚æœå½“å‰å…ƒç´ ä¸ªæ•°å·²ç»å’Œå †æƒ³ç­‰ï¼Œé‚£å°±è¾“å‡ºé”™è¯¯ä¿¡æ¯
	if Maxheap.realSize+1 > Maxheap.heapSize{
		fmt.Println("Add too many elements!")
		return
	}
	Maxheap.realSize++
	//æ–°å¢åŠ å…ƒç´ çš„ä¸‹æ ‡
	index := Maxheap.realSize
	//çˆ¶èŠ‚ç‚¹ä¸‹æ ‡
	parent := index / 2
	Maxheap.maxHeap[index] = element

	//å¦‚æœå¤§äºçˆ¶èŠ‚ç‚¹å°±ä¸æ–­å‘ä¸Šäº¤æ¢
	for Maxheap.maxHeap[index] > Maxheap.maxHeap[parent] && index > 1{ //å› ä¸ºä¸‹æ ‡1æ²¡æœ‰çˆ¶èŠ‚ç‚¹ï¼Œæ‰€æœ‰indexä¸èƒ½ç­‰äºæˆ–è€…å°äº1
		//è¿›è¡Œäº¤æ¢
		Maxheap.maxHeap[index],Maxheap.maxHeap[parent] = Maxheap.maxHeap[parent],Maxheap.maxHeap[index]
		index = parent
		parent = index / 2
		//ç»§ç»­æ¯”è¾ƒ
	}
}
  ```
  {{< /code >}}

  {{< code >}}

  ```c
//æ·»åŠ å…ƒç´ å‡½æ•°
void insert(MaxHeap *mh, int element)
{
    //å¦‚æœå½“å‰å…ƒç´ ä¸ªæ•°å·²ç»æ»¡äº†ï¼Œé‚£å°±è¾“å‡ºé”™è¯¯ä¿¡æ¯
    if (mh->realSize + 1 > mh->MaxSize)
    {
        printf("Add too many elements!");
        return;
    }

    mh->realSize++;
    //æ’å…¥å…ƒç´ åˆ°å †çš„æœ«å°¾
    mh->maxHeap[mh->realSize] = element;
    //è°ƒæ•´å †
    int index = mh->realSize;
    //çˆ¶èŠ‚ç‚¹çš„ä¸‹æ ‡
    int parent = index / 2;
    while (mh->maxHeap[index] > mh->maxHeap[parent] && index > 1) //å †ä¸‹æ ‡ä»1å¼€å§‹ï¼Œ1æ²¡æœ‰çˆ¶èŠ‚ç‚¹
    {
        //äº¤æ¢å…ƒç´ 
        int temp = mh->maxHeap[index];
        mh->maxHeap[index] = mh->maxHeap[parent];
        mh->maxHeap[parent] = temp;
        //ä¸ºäº†ä¸æ–­å‘ä¸Šè°ƒæ•´
        index = parent;
        parent = index / 2;
    }
}
  ```
  {{< /code >}}
{{< /codes >}}

## å †åˆ é™¤æ“ä½œ
``å †``çš„``åˆ é™¤æ“ä½œ``ä¸``æ’å…¥æ“ä½œ``ç›¸åï¼Œ``æ’å…¥æ“ä½œ``æ˜¯``ä»ä¸‹å¾€ä¸Š``è°ƒæ•´``å †``ï¼Œè€Œ``åˆ é™¤æ“ä½œ``å´æ˜¯``ä»ä¸Šå¾€ä¸‹``è°ƒæ•´``å †``ï¼Œå †åˆ é™¤æ“ä½œçš„æ­¥éª¤ï¼ˆå¤§é¡¶å †ï¼‰ï¼š

* 1.``åˆ é™¤å †é¡¶å…ƒç´ ï¼ˆé€šå¸¸æ˜¯å°†å †é¡¶å…ƒç´ æ”¾ç½®åœ¨æ•°ç»„çš„æœ«å°¾ï¼‰``
* 2.``æ¯”è¾ƒå·¦å³å­èŠ‚ç‚¹ï¼Œå°†å¤§çš„å…ƒç´ ä¸Šè°ƒ``
* 3.``ä¸æ–­è¿›è¡Œæ­¥éª¤2ï¼Œç›´åˆ°ä¸éœ€è¦è°ƒæ•´æˆ–è€…è°ƒæ•´åˆ°å †åº•``

ä»£ç å®ç°å¦‚ä¸‹ï¼šï¼ˆå¤§é¡¶å †ï¼‰
{{< codes golang c>}}

  {{< code >}}

  ```golang
//åˆ é™¤å †é¡¶å…ƒç´ å‡½æ•°
func (Maxheap *MaxHeap)delete()int{
	// å¦‚æœå½“å‰ã€Œå †ã€çš„å…ƒç´ ä¸ªæ•°ä¸º0ï¼Œ åˆ™è¿”å›ã€ŒDon't have any elementã€
	removeElement := Maxheap.maxHeap[1]
	if Maxheap.realSize < 1{
		fmt.Println("Don't have any element!")
		return math.MaxInt64
	}else {
		//å½“å‰å †ä¸­æœ‰å…ƒç´ ï¼ŒMaxheap.realSize >= 1
		// å°†ã€Œå †ã€ä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ èµ‹å€¼ç»™å †é¡¶å…ƒç´ 
		Maxheap.maxHeap[1] = Maxheap.maxHeap[Maxheap.realSize]
		//å»é™¤æœ€åä¸€ä¸ªå…ƒç´ 
		Maxheap.maxHeap[Maxheap.realSize] = math.MinInt64
		Maxheap.realSize--
		index := 1
		// ä¸æ–­å‘ä¸‹è°ƒæ•´å †
		// å½“åˆ é™¤çš„å…ƒç´ ä¸æ˜¯å­©å­èŠ‚ç‚¹æ—¶
		for index < Maxheap.realSize && index <= Maxheap.realSize/2 {
			// è¢«åˆ é™¤èŠ‚ç‚¹çš„å·¦å­©å­èŠ‚ç‚¹
			left := index * 2;
			// è¢«åˆ é™¤èŠ‚ç‚¹çš„å³å­©å­èŠ‚ç‚¹
			right := (index * 2) + 1;
			// å½“åˆ é™¤èŠ‚ç‚¹çš„å…ƒç´ å°äº å·¦å­©å­èŠ‚ç‚¹æˆ–è€…å³å­©å­èŠ‚ç‚¹ï¼Œä»£è¡¨è¯¥å…ƒç´ çš„å€¼å°ï¼Œæ­¤æ—¶éœ€è¦å°†è¯¥å…ƒç´ ä¸å·¦ã€å³å­©å­èŠ‚ç‚¹ä¸­æœ€å¤§çš„å€¼è¿›è¡Œäº¤æ¢
			if Maxheap.maxHeap[index] < Maxheap.maxHeap[left] ||  Maxheap.maxHeap[index] < Maxheap.maxHeap[right] {
				if Maxheap.maxHeap[left] > Maxheap.maxHeap[right] {
					temp := Maxheap.maxHeap[left]
					Maxheap.maxHeap[left] = Maxheap.maxHeap[index]
					Maxheap.maxHeap[index] = temp
					index = left
				} else {
					// maxHeap[left] <= maxHeap[right]
					temp := Maxheap.maxHeap[right]
					Maxheap.maxHeap[right] = Maxheap.maxHeap[index]
					Maxheap.maxHeap[index] = temp
					index = right
				}
			} else {
				break
			}
		}

	}

	return removeElement
}
  ```
  {{< /code >}}

  {{< code >}}

  ```c
//å †å…ƒç´ åˆ é™¤å‡½æ•°
int delete (MaxHeap *mh)
{
    // å¦‚æœå½“å‰ã€Œå †ã€çš„å…ƒç´ ä¸ªæ•°ä¸º0ï¼Œ åˆ™è¿”å›ã€ŒDon't have any elementã€
    if (mh->realSize < 1)
    {
        printf("Don't have any element!");
        return intMIN;
    }

    //ä¿ç•™åˆ é™¤çš„å…ƒç´ ï¼Œä»¥ä¾¿è¿”å›
    int removeElement = mh->maxHeap[1];
    //åˆ é™¤å †é¡¶å…ƒç´ ï¼ŒæŠŠæœ€åä¸€ä¸ªå…ƒç´ ç§»è‡³å †é¡¶
    mh->maxHeap[1] = mh->maxHeap[mh->realSize];
    //æŠŠæœ€åä¸€ä¸ªå…ƒç´ ç½®ä¸ºæœ€å°(å·²ç»å®å®šä¹‰IntMinä¸º4å­—èŠ‚intç±»å‹æœ€å°å€¼)
    mh->maxHeap[mh->realSize] = intMIN;
    //å…ƒç´ é•¿åº¦å¤§å°å‡1
    mh->realSize--;
    //å‘ä¸‹è°ƒæ•´
    int index = 1;

    while (index < mh->realSize && index <= mh->realSize / 2)
    {
        //å·¦èŠ‚ç‚¹
        int left = index * 2;
        //å³èŠ‚ç‚¹
        int right = index * 2 + 1;

        if (mh->maxHeap[index] < mh->maxHeap[left] || mh->maxHeap[index] < mh->maxHeap[right])
        {
            if (mh->maxHeap[left] > mh->maxHeap[right])
            {
                int temp = mh->maxHeap[index];
                mh->maxHeap[index] = mh->maxHeap[left];
                mh->maxHeap[left] = temp;
                index = left;
            }
            else
            {
                int temp = mh->maxHeap[index];
                mh->maxHeap[index] = mh->maxHeap[right];
                mh->maxHeap[right] = temp;
                index = right;
            }
        }
        else
        {
            break;
        }
    }
    return removeElement;
}
  ```
  {{< /code >}}
{{< /codes >}}

## è·å–å †é¡¶å…ƒç´ æ“ä½œ

ç›´æ¥è¿”å›å †é¡¶å…ƒç´ å°±è¡Œ

ä»£ç å¦‚ä¸‹ï¼šï¼ˆå¤§é¡¶å †ï¼‰
{{< codes golang c>}}

  {{< code >}}

  ```golang
//è·å–å †é¡¶å…ƒç´ å‡½æ•°
func (Maxheap MaxHeap)peek()int{
	return Maxheap.maxHeap[1]
}
  ```
  {{< /code >}}

  {{< code >}}

  ```c
//è·å–å †é¡¶å…ƒç´ å‡½æ•°
int peek(MaxHeap mh)
{
    return mh.maxHeap[1];
}

  ```
  {{< /code >}}
{{< /codes >}}

## æ€»ç»“
å¯¹äº``å †``è¿™ç§æ•°æ®ç»“æ„ï¼Œæˆ‘ä»¬åªéœ€è¦æŒæ¡å¦‚ä½•æ¥``åˆå§‹åŒ–``ï¼Œ``åˆ é™¤å…ƒç´ ``ï¼Œ``æ·»åŠ å…ƒç´ ``ï¼Œå †çš„åº”ç”¨ååˆ†å¹¿æ³›ï¼Œå¦‚ä¸‹ï¼š

* 1.``å †æ’åº``
* 2.``å¿«é€Ÿæ‰¾å‡ºä¸€ä¸ªé›†åˆä¸­çš„æœ€å°å€¼ï¼ˆæˆ–è€…æœ€å¤§å€¼ï¼‰``
* 3.``æ„å»ºä¼˜å…ˆé˜Ÿåˆ—``
* 4.``åœ¨æœ‹å‹é¢å‰è£…é€¼ï¼ˆå¼€ä¸ªç©ç¬‘ï¼‰``

æ€»ä½“ä»£ç å¦‚ä¸‹ï¼ˆåŒ…å«å¤§é¡¶å †å’Œå°é¡¶å †ï¼‰ï¼š

{{< codes go go c c>}}

  {{< code >}}

  ```golang
package main

import (
	"fmt"
	"math"
)

//æ„å»ºå¤§é¡¶å †
type MaxHeap struct {
	// ä½¿ç”¨æ•°ç»„åˆ›å»ºå®Œå…¨äºŒå‰æ ‘çš„ç»“æ„ï¼Œç„¶åä½¿ç”¨äºŒå‰æ ‘æ„å»ºä¸€ä¸ªã€Œå †ã€
	maxHeap []int
	// heapSizeç”¨äºæ•°ç»„çš„å¤§å°ï¼Œå› ä¸ºæ•°ç»„åœ¨åˆ›å»ºçš„æ—¶å€™è‡³å°‘éœ€è¦æŒ‡æ˜æ•°ç»„çš„å…ƒç´ ä¸ªæ•°
	heapSize int
	// realSizeç”¨äºè®°å½•ã€Œå †ã€çš„å…ƒç´ ä¸ªæ•°
	realSize int
}

//æ·»åŠ å…ƒç´ å‡½æ•°
func (Maxheap *MaxHeap)insert(element int){
	//å¦‚æœå½“å‰å…ƒç´ ä¸ªæ•°å·²ç»å’Œå †æƒ³ç­‰ï¼Œé‚£å°±è¾“å‡ºé”™è¯¯ä¿¡æ¯
	if Maxheap.realSize+1 > Maxheap.heapSize{
		fmt.Println("Add too many elements!")
		return
	}
	Maxheap.realSize++
	//æ–°å¢åŠ å…ƒç´ çš„ä¸‹æ ‡
	index := Maxheap.realSize
	//çˆ¶èŠ‚ç‚¹ä¸‹æ ‡
	parent := index / 2
	Maxheap.maxHeap[index] = element

	//å¦‚æœå¤§äºçˆ¶èŠ‚ç‚¹å°±ä¸æ–­å‘ä¸Šäº¤æ¢
	for Maxheap.maxHeap[index] > Maxheap.maxHeap[parent] && index > 1{ //å› ä¸ºä¸‹æ ‡1æ²¡æœ‰çˆ¶èŠ‚ç‚¹ï¼Œæ‰€æœ‰indexä¸èƒ½ç­‰äºæˆ–è€…å°äº1
		//è¿›è¡Œäº¤æ¢
		Maxheap.maxHeap[index],Maxheap.maxHeap[parent] = Maxheap.maxHeap[parent],Maxheap.maxHeap[index]
		index = parent
		parent = index / 2
		//ç»§ç»­æ¯”è¾ƒ
	}
}

//è·å–å †é¡¶å…ƒç´ å‡½æ•°
func (Maxheap MaxHeap)peek()int{
	return Maxheap.maxHeap[1]
}

//åˆ é™¤å †é¡¶å…ƒç´ å‡½æ•°
func (Maxheap *MaxHeap)delete()int{
	// å¦‚æœå½“å‰ã€Œå †ã€çš„å…ƒç´ ä¸ªæ•°ä¸º0ï¼Œ åˆ™è¿”å›ã€ŒDon't have any elementã€
	removeElement := Maxheap.maxHeap[1]
	if Maxheap.realSize < 1{
		fmt.Println("Don't have any element!")
		return math.MaxInt64
	}else {
		//å½“å‰å †ä¸­æœ‰å…ƒç´ ï¼ŒMaxheap.realSize >= 1
		// å°†ã€Œå †ã€ä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ èµ‹å€¼ç»™å †é¡¶å…ƒç´ 
		Maxheap.maxHeap[1] = Maxheap.maxHeap[Maxheap.realSize]
		//å»é™¤æœ€åä¸€ä¸ªå…ƒç´ 
		Maxheap.maxHeap[Maxheap.realSize] = math.MinInt64
		Maxheap.realSize--
		index := 1
		// ä¸æ–­å‘ä¸‹è°ƒæ•´å †
		// å½“åˆ é™¤çš„å…ƒç´ ä¸æ˜¯å­©å­èŠ‚ç‚¹æ—¶
		for index < Maxheap.realSize && index <= Maxheap.realSize/2 {
			// è¢«åˆ é™¤èŠ‚ç‚¹çš„å·¦å­©å­èŠ‚ç‚¹
			left := index * 2;
			// è¢«åˆ é™¤èŠ‚ç‚¹çš„å³å­©å­èŠ‚ç‚¹
			right := (index * 2) + 1;
			// å½“åˆ é™¤èŠ‚ç‚¹çš„å…ƒç´ å°äº å·¦å­©å­èŠ‚ç‚¹æˆ–è€…å³å­©å­èŠ‚ç‚¹ï¼Œä»£è¡¨è¯¥å…ƒç´ çš„å€¼å°ï¼Œæ­¤æ—¶éœ€è¦å°†è¯¥å…ƒç´ ä¸å·¦ã€å³å­©å­èŠ‚ç‚¹ä¸­æœ€å¤§çš„å€¼è¿›è¡Œäº¤æ¢
			if Maxheap.maxHeap[index] < Maxheap.maxHeap[left] ||  Maxheap.maxHeap[index] < Maxheap.maxHeap[right] {
				if Maxheap.maxHeap[left] > Maxheap.maxHeap[right] {
					temp := Maxheap.maxHeap[left]
					Maxheap.maxHeap[left] = Maxheap.maxHeap[index]
					Maxheap.maxHeap[index] = temp
					index = left
				} else {
					// maxHeap[left] <= maxHeap[right]
					temp := Maxheap.maxHeap[right]
					Maxheap.maxHeap[right] = Maxheap.maxHeap[index]
					Maxheap.maxHeap[index] = temp
					index = right
				}
			} else {
				break
			}
		}

	}

	return removeElement
}

// è¿”å›ã€Œå †ã€çš„å…ƒç´ ä¸ªæ•°
func (Maxheap MaxHeap)size()int{
	return Maxheap.realSize
}

//å¤§é¡¶å †åˆå§‹åŒ–å‡½æ•°
func MaxHeapInit(size int)MaxHeap{

	return MaxHeap{
		maxHeap: make([]int, size+1),
		heapSize: size,
		realSize: 0,
	}

}


func main(){
	//æŒ‡æ˜éœ€è¦æ„å»ºå †çš„å¤§å°
	size := 5
	var MaxHeap MaxHeap = MaxHeapInit(size)
	//æ­¤å †çš„ä¸‹æ ‡ä»1å¼€å§‹ï¼Œæœ‰äº›æ˜¯ä»0å¼€å§‹
	for i:=0;i<MaxHeap.heapSize+1;i++{ //å¤§é¡¶å †ï¼Œå…ˆæŠŠæ‰€æœ‰å…ƒç´ åˆå§‹åŒ–ä¸ºæœ€å°å€¼
		MaxHeap.maxHeap[i] = math.MinInt64
	}
	//å½“å‰å †ä¸­å…ƒç´ ä¸ªæ•°ä¸º0
	MaxHeap.realSize = 0
	//æ·»åŠ 1
	MaxHeap.insert(1)
	fmt.Println(MaxHeap.maxHeap)
	fmt.Println(MaxHeap.realSize)
	//æ·»åŠ 2
	MaxHeap.insert(2)
	//æ·»åŠ 3
	MaxHeap.insert(3)
	fmt.Println(MaxHeap.maxHeap)

	//æ·»åŠ 5
	MaxHeap.insert(5)
	//åˆ é™¤å †é¡¶
	fmt.Println(MaxHeap.delete())
	fmt.Println(MaxHeap.maxHeap)
	//å–å †é¡¶
	fmt.Println(MaxHeap.peek())

	//å–å †å…ƒç´ ä¸ªæ•°
	fmt.Println(MaxHeap.size())
}
  ```
  {{< /code >}}

  {{< code >}}

  ```golang
package main

import (
	"fmt"
	"math"
)

//æ„å»ºå°é¡¶å †
type MinHeap struct {
	// ä½¿ç”¨æ•°ç»„åˆ›å»ºå®Œå…¨äºŒå‰æ ‘çš„ç»“æ„ï¼Œç„¶åä½¿ç”¨äºŒå‰æ ‘æ„å»ºä¸€ä¸ªã€Œå †ã€
	minHeap []int
	// heapSizeç”¨äºæ•°ç»„çš„å¤§å°ï¼Œå› ä¸ºæ•°ç»„åœ¨åˆ›å»ºçš„æ—¶å€™è‡³å°‘éœ€è¦æŒ‡æ˜æ•°ç»„çš„å…ƒç´ ä¸ªæ•°
	heapSize int
	// realSizeç”¨äºè®°å½•ã€Œå †ã€çš„å…ƒç´ ä¸ªæ•°
	realSize int
}

//æ·»åŠ å…ƒç´ å‡½æ•°
func (Minheap *MinHeap)insert(element int){
	//å¦‚æœå½“å‰å…ƒç´ ä¸ªæ•°å·²ç»å’Œå †æƒ³ç­‰ï¼Œé‚£å°±è¾“å‡ºé”™è¯¯ä¿¡æ¯
	if Minheap.realSize+1 > Minheap.heapSize{
		fmt.Println("Add too many elements!")
		return
	}
	Minheap.realSize++
	//æ–°å¢åŠ å…ƒç´ çš„ä¸‹æ ‡
	index := Minheap.realSize
	//çˆ¶èŠ‚ç‚¹ä¸‹æ ‡
	parent := index / 2
	Minheap.minHeap[index] = element

	//å¦‚æœå¤§äºçˆ¶èŠ‚ç‚¹å°±ä¸æ–­å‘ä¸Šäº¤æ¢
	for Minheap.minHeap[index] < Minheap.minHeap[parent] && index > 1{ //å› ä¸ºä¸‹æ ‡1æ²¡æœ‰çˆ¶èŠ‚ç‚¹ï¼Œæ‰€æœ‰indexä¸èƒ½ç­‰äºæˆ–è€…å°äº1
		//è¿›è¡Œäº¤æ¢
		Minheap.minHeap[index],Minheap.minHeap[parent] = Minheap.minHeap[parent],Minheap.minHeap[index]
		index = parent
		parent = index / 2
		//ç»§ç»­æ¯”è¾ƒ
	}
}

//è·å–å †é¡¶å…ƒç´ å‡½æ•°
func (Minheap MinHeap)peek()int{
	return Minheap.minHeap[1]
}

//åˆ é™¤å †é¡¶å…ƒç´ å‡½æ•°
func (Minheap *MinHeap)delete()int{
	// å¦‚æœå½“å‰ã€Œå †ã€çš„å…ƒç´ ä¸ªæ•°ä¸º0ï¼Œ åˆ™è¿”å›ã€ŒDon't have any elementã€
	removeElement := Minheap.minHeap[1]
	if Minheap.realSize < 1{
		fmt.Println("Don't have any element!")
		return math.MaxInt64
	}else {
		//å½“å‰å †ä¸­æœ‰å…ƒç´ ï¼ŒMinheap.realSize >= 1
		// å°†ã€Œå †ã€ä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ èµ‹å€¼ç»™å †é¡¶å…ƒç´ 
		Minheap.minHeap[1] = Minheap.minHeap[Minheap.realSize]
		//å»é™¤æœ€åä¸€ä¸ªå…ƒç´ 
		Minheap.minHeap[Minheap.realSize] = math.MinInt64
		Minheap.realSize--
		index := 1
		// ä¸æ–­å‘ä¸‹è°ƒæ•´å †
		// å½“åˆ é™¤çš„å…ƒç´ ä¸æ˜¯å­©å­èŠ‚ç‚¹æ—¶
		for index < Minheap.realSize && index <= Minheap.realSize/2 {
			// è¢«åˆ é™¤èŠ‚ç‚¹çš„å·¦å­©å­èŠ‚ç‚¹
			left := index * 2;
			// è¢«åˆ é™¤èŠ‚ç‚¹çš„å³å­©å­èŠ‚ç‚¹
			right := (index * 2) + 1;
			// å½“åˆ é™¤èŠ‚ç‚¹çš„å…ƒç´ å°äº å·¦å­©å­èŠ‚ç‚¹æˆ–è€…å³å­©å­èŠ‚ç‚¹ï¼Œä»£è¡¨è¯¥å…ƒç´ çš„å€¼å°ï¼Œæ­¤æ—¶éœ€è¦å°†è¯¥å…ƒç´ ä¸å·¦ã€å³å­©å­èŠ‚ç‚¹ä¸­æœ€å¤§çš„å€¼è¿›è¡Œäº¤æ¢
			if Minheap.minHeap[index] > Minheap.minHeap[left] ||  Minheap.minHeap[index] > Minheap.minHeap[right] {
				if Minheap.minHeap[left] < Minheap.minHeap[right] {
					temp := Minheap.minHeap[left]
					Minheap.minHeap[left] = Minheap.minHeap[index]
					Minheap.minHeap[index] = temp
					index = left
				} else {
					// MinHeap[left] >= MinHeap[right]
					temp := Minheap.minHeap[right]
					Minheap.minHeap[right] = Minheap.minHeap[index]
					Minheap.minHeap[index] = temp
					index = right
				}
			} else {
				break
			}
		}

	}

	return removeElement
}

// è¿”å›ã€Œå †ã€çš„å…ƒç´ ä¸ªæ•°
func (Minheap MinHeap)size()int{
	return Minheap.realSize
}

//å°é¡¶å †åˆå§‹åŒ–å‡½æ•°
func MinHeapInit(size int)MinHeap{
	return MinHeap{
		minHeap: make([]int, size+1),
		heapSize: size,
		realSize: 0,
	}
}



func main(){

	//æŒ‡æ˜éœ€è¦æ„å»ºå †çš„å¤§å°
	size := 5
	var MinHeap MinHeap = MinHeapInit(size)
	//æ­¤å †çš„ä¸‹æ ‡ä»1å¼€å§‹ï¼Œæœ‰äº›æ˜¯ä»0å¼€å§‹
	for i:=0;i<MinHeap.heapSize+1;i++{ //å¤§é¡¶å †ï¼Œå…ˆæŠŠæ‰€æœ‰å…ƒç´ åˆå§‹åŒ–ä¸ºæœ€å°å€¼
		MinHeap.minHeap[i] = math.MinInt64
	}
	//å½“å‰å †ä¸­å…ƒç´ ä¸ªæ•°ä¸º0
	MinHeap.realSize = 0
	//æ·»åŠ 1
	MinHeap.insert(1)
	fmt.Println(MinHeap.minHeap)
	fmt.Println(MinHeap.realSize)
	//æ·»åŠ 2
	MinHeap.insert(2)
	//æ·»åŠ 3
	MinHeap.insert(3)
	fmt.Println(MinHeap.minHeap)

	//æ·»åŠ 5
	MinHeap.insert(5)
	//åˆ é™¤å †é¡¶
	fmt.Println(MinHeap.delete())
	fmt.Println(MinHeap.minHeap)
	//å–å †é¡¶
	fmt.Println(MinHeap.peek())

	//å–å †å…ƒç´ ä¸ªæ•°
	fmt.Println(MinHeap.size())
}
  ```
  {{< /code >}}

    {{< code >}}

  ```c
#include <stdio.h>
#include <stdlib.h>
// å®å®šä¹‰æœ€å°å€¼
#define intMIN 0x80000000;

typedef struct
{
    //å †çš„æ•°ç»„
    int *maxHeap;
    //å †çš„å…ƒç´ ä¸ªæ•°
    int realSize;
    //å †çš„å¤§å°
    int MaxSize;
} MaxHeap;

void insert(MaxHeap *mh, int element)
{
    //å¦‚æœå½“å‰å…ƒç´ ä¸ªæ•°å·²ç»æ»¡äº†ï¼Œé‚£å°±è¾“å‡ºé”™è¯¯ä¿¡æ¯
    if (mh->realSize + 1 > mh->MaxSize)
    {
        printf("Add too many elements!");
        return;
    }

    mh->realSize++;
    //æ’å…¥å…ƒç´ åˆ°å †çš„æœ«å°¾
    mh->maxHeap[mh->realSize] = element;
    //è°ƒæ•´å †
    int index = mh->realSize;
    //çˆ¶èŠ‚ç‚¹çš„ä¸‹æ ‡
    int parent = index / 2;
    while (mh->maxHeap[index] > mh->maxHeap[parent] && index > 1) //å †ä¸‹æ ‡ä»1å¼€å§‹ï¼Œ1æ²¡æœ‰çˆ¶èŠ‚ç‚¹
    {
        //äº¤æ¢å…ƒç´ 
        int temp = mh->maxHeap[index];
        mh->maxHeap[index] = mh->maxHeap[parent];
        mh->maxHeap[parent] = temp;
        //ä¸ºäº†ä¸æ–­å‘ä¸Šè°ƒæ•´
        index = parent;
        parent = index / 2;
    }
}

//å †å…ƒç´ åˆ é™¤å‡½æ•°
int delete (MaxHeap *mh)
{
    // å¦‚æœå½“å‰ã€Œå †ã€çš„å…ƒç´ ä¸ªæ•°ä¸º0ï¼Œ åˆ™è¿”å›ã€ŒDon't have any elementã€
    if (mh->realSize < 1)
    {
        printf("Don't have any element!");
        return intMIN;
    }

    //ä¿ç•™åˆ é™¤çš„å…ƒç´ ï¼Œä»¥ä¾¿è¿”å›
    int removeElement = mh->maxHeap[1];
    //åˆ é™¤å †é¡¶å…ƒç´ ï¼ŒæŠŠæœ€åä¸€ä¸ªå…ƒç´ ç§»è‡³å †é¡¶
    mh->maxHeap[1] = mh->maxHeap[mh->realSize];
    //æŠŠæœ€åä¸€ä¸ªå…ƒç´ ç½®ä¸ºæœ€å°(å·²ç»å®å®šä¹‰IntMinä¸º4å­—èŠ‚intç±»å‹æœ€å°å€¼)
    mh->maxHeap[mh->realSize] = intMIN;
    //å…ƒç´ é•¿åº¦å¤§å°å‡1
    mh->realSize--;
    //å‘ä¸‹è°ƒæ•´
    int index = 1;

    while (index < mh->realSize && index <= mh->realSize / 2)
    {
        //å·¦èŠ‚ç‚¹
        int left = index * 2;
        //å³èŠ‚ç‚¹
        int right = index * 2 + 1;

        if (mh->maxHeap[index] < mh->maxHeap[left] || mh->maxHeap[index] < mh->maxHeap[right])
        {
            if (mh->maxHeap[left] > mh->maxHeap[right])
            {
                int temp = mh->maxHeap[index];
                mh->maxHeap[index] = mh->maxHeap[left];
                mh->maxHeap[left] = temp;
                index = left;
            }
            else
            {
                int temp = mh->maxHeap[index];
                mh->maxHeap[index] = mh->maxHeap[right];
                mh->maxHeap[right] = temp;
                index = right;
            }
        }
        else
        {
            break;
        }
    }
    return removeElement;
}

//åˆå§‹åŒ–å †å‡½æ•°
void initMaxHeap(MaxHeap *mh, int size)
{
    mh->MaxSize = size;
    mh->maxHeap = (int *)malloc((mh->MaxSize + 1) * sizeof(int)); //ä»1å¼€å§‹å­˜å‚¨
    mh->realSize = 0;
}

//è·å–å †çš„å¤§å°å‡½æ•°
int size(MaxHeap *mh)
{
    return mh->MaxSize;
}

//éå†å †å‡½æ•°
void traversal(MaxHeap mh)
{
    for (int i = 1; i <= mh.realSize; i++)
    {
        printf("%d\n", mh.maxHeap[i]);
    }
}

//è·å–å †é¡¶å…ƒç´ å‡½æ•°
int peek(MaxHeap mh)
{
    return mh.maxHeap[1];
}

int main()
{
    MaxHeap mh;
    initMaxHeap(&mh, 5);
    insert(&mh, 3);
    insert(&mh, 1);
    insert(&mh, 5);
    insert(&mh, 8);
    traversal(mh);
    printf("\nåˆ é™¤å †é¡¶çš„å…ƒç´ ä¸º%d\n\n", delete (&mh));
    traversal(mh);
    system("pause");
}

  ```
  {{< /code >}}

    {{< code >}}

  ```c
#include <stdio.h>
#include <stdlib.h>
// å®å®šä¹‰æœ€å¤§å€¼
#define intMax 0x1fffffff;

//æ„å»ºå°é¡¶å †
typedef struct
{
    //å †çš„æ•°ç»„
    int *minHeap;
    //å †çš„å…ƒç´ ä¸ªæ•°
    int realSize;
    //å †çš„å¤§å°
    int MinSize;
} MinHeap;

void insert(MinHeap *mh, int element)
{
    //å¦‚æœå½“å‰å…ƒç´ ä¸ªæ•°å·²ç»æ»¡äº†ï¼Œé‚£å°±è¾“å‡ºé”™è¯¯ä¿¡æ¯
    if (mh->realSize + 1 > mh->MinSize)
    {
        printf("Add too many elements!");
        return;
    }

    mh->realSize++;
    //æ’å…¥å…ƒç´ åˆ°å †çš„æœ«å°¾
    mh->minHeap[mh->realSize] = element;
    //è°ƒæ•´å †
    int index = mh->realSize;
    //çˆ¶èŠ‚ç‚¹çš„ä¸‹æ ‡
    int parent = index / 2;
    while (mh->minHeap[index] < mh->minHeap[parent] && index > 1) //å †ä¸‹æ ‡ä»1å¼€å§‹ï¼Œ1æ²¡æœ‰çˆ¶èŠ‚ç‚¹
    {
        //äº¤æ¢å…ƒç´ 
        int temp = mh->minHeap[index];
        mh->minHeap[index] = mh->minHeap[parent];
        mh->minHeap[parent] = temp;
        //ä¸ºäº†ä¸æ–­å‘ä¸Šè°ƒæ•´
        index = parent;
        parent = index / 2;
    }
}

//å †å…ƒç´ åˆ é™¤å‡½æ•°
int delete (MinHeap *mh)
{
    // å¦‚æœå½“å‰ã€Œå †ã€çš„å…ƒç´ ä¸ªæ•°ä¸º0ï¼Œ åˆ™è¿”å›ã€ŒDon't have any elementã€
    if (mh->realSize < 1)
    {
        printf("Don't have any element!");
        return intMax;
    }

    //ä¿ç•™åˆ é™¤çš„å…ƒç´ ï¼Œä»¥ä¾¿è¿”å›
    int removeElement = mh->minHeap[1];
    //åˆ é™¤å †é¡¶å…ƒç´ ï¼ŒæŠŠæœ€åä¸€ä¸ªå…ƒç´ ç§»è‡³å †é¡¶
    mh->minHeap[1] = mh->minHeap[mh->realSize];
    //æŠŠæœ€åä¸€ä¸ªå…ƒç´ ç½®ä¸ºæœ€å°(å·²ç»å®å®šä¹‰IntMinä¸º4å­—èŠ‚intç±»å‹æœ€å°å€¼)
    mh->minHeap[mh->realSize] = intMax;
    //å…ƒç´ é•¿åº¦å¤§å°å‡1
    mh->realSize--;
    //å‘ä¸‹è°ƒæ•´
    int index = 1;

    while (index < mh->realSize && index <= mh->realSize / 2)
    {
        //å·¦èŠ‚ç‚¹
        int left = index * 2;
        //å³èŠ‚ç‚¹
        int right = index * 2 + 1;

        if (mh->minHeap[index] > mh->minHeap[left] || mh->minHeap[index] > mh->minHeap[right])
        {
            if (mh->minHeap[left] < mh->minHeap[right])
            {
                int temp = mh->minHeap[index];
                mh->minHeap[index] = mh->minHeap[left];
                mh->minHeap[left] = temp;
                index = left;
            }
            else
            {
                int temp = mh->minHeap[index];
                mh->minHeap[index] = mh->minHeap[right];
                mh->minHeap[right] = temp;
                index = right;
            }
        }
        else
        {
            break;
        }
    }
    return removeElement;
}

//åˆå§‹åŒ–å †å‡½æ•°
void initMinHeap(MinHeap *mh, int size)
{
    mh->MinSize = size;
    mh->minHeap = (int *)malloc((mh->MinSize + 1) * sizeof(int)); //ä»1å¼€å§‹å­˜å‚¨
    mh->realSize = 0;
}

//è·å–å †çš„å¤§å°å‡½æ•°
int size(MinHeap *mh)
{
    return mh->MinSize;
}

//éå†å †å‡½æ•°
void traversal(MinHeap mh)
{
    for (int i = 1; i <= mh.realSize; i++)
    {
        printf("%d\n", mh.minHeap[i]);
    }
}

//è·å–å †é¡¶å…ƒç´ å‡½æ•°
int peek(MinHeap mh)
{
    return mh.minHeap[1];
}

int main()
{
    MinHeap mh;
    initMinHeap(&mh, 5);
    insert(&mh, 3);
    insert(&mh, 1);
    insert(&mh, 5);
    insert(&mh, 8);
    traversal(mh);
    printf("\nåˆ é™¤å †é¡¶çš„å…ƒç´ ä¸º%d\n\n", delete (&mh));
    traversal(mh);
    system("pause");
}

  ```
  {{< /code >}}
{{< /codes >}}

