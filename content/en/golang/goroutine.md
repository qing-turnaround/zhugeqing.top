---
date: 2022-04-01
description: "Goroutine"
image: "/images/Go.jpg"
title: "Goroutine"
author: 诸葛青
authorEmoji: 😃
pinned: false
tags:
- Go
series:
- 
---

## 协程 与 线程
{{< boxmd >}}
* 调度方式：协程是用户态的，由Go语言程序的调度器来进行调度，同时，多个协程从属于某一个线程，协程与线程的关系是M : N的，即多个协程对应多个线程，Go语言调度器可以将多个协程调度到一个线程上，但协程也可以切换到其他的线程
* 上下文切换：协程的上下文切换速度要快于线程，协程的上下文切换无须从用户态与内核态的切换
* 调度策略：线程的调度策略是抢占式的，即操作系统为了均衡每一个线程所运行的时间，会定时强制线程上下文切换。Go语言的协程在一般情况下都是协作式调度，即一个协程在运行完成之后，会主动将执行权限让给其他协程，这样一个协程能更好的在规定的时间完成任务，但当一个协程运行过长时间的话，也会被强制抢占
* 栈的大小：对于线程来说，一般线程的栈的大小为 2KB，而协程的栈的大小为2MB。线程的栈在运行是不能更改，但是协程可以随着运行时的需要而动态增加，32位机器最大可以是250MB，64位则是1GB
{{< /boxmd >}}


## GMP模型
{{< boxmd >}}
* `G`：Goroutinue，runtime.g结构体表示（Go语言的协程）
* `M`：Machine，runtime.m结构体表示（实际的线程）
* `P`：Processor，runtime.p结构体表示（Go语言的逻辑处理器）
* 每个`P`上都挂载了一个局部队列，局部队列保存待执行的`G`，当局部队列满了 无法将`G`放入的时候，会将`G`放入全局队列中
* 每一个`P`都绑定在一个`M`上，`M`是真正运行`P`中`G`的实体，`M`从绑定的`P`的局部队列上获取`G`来执行
* 当`M`绑定的`P`的局部队列为空时，`M`会从全局队列获取`G`到本地队列来执行，当全局队列也为空时，会从其他`P`的本地队列来获取，这种方式也就是`work stealing`
* 当`G`由于系统调用而阻塞时，会导致`M`也阻塞，这时`P`会跟`M`进行解绑（`hand off`），然后寻找空闲的`M`进行绑定，如果没有，则会创建一个`M`来进行绑定
* 当`G`由于`Channel`和`网络I/O`阻塞时，不会阻塞`M`，这时`M`会寻找可运行的`G`，当阻塞的`G`恢复时，可以重新进入`P`的队列，等待运行
{{< /boxmd >}}

