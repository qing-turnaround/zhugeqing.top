---
date: 2020-12-12T12:00:56+09:00
description: "å¦‚æœè¯´æ•°å­¦æ˜¯çš‡å† ä¸Šçš„ä¸€é¢—æ˜ç ï¼Œé‚£ä¹ˆç®—æ³•å°±æ˜¯è¿™é¢—æ˜ç ä¸Šçš„å…‰èŠ’ï¼Œç®—æ³•è®©è¿™é¢—æ˜ç æ›´åŠ ç† ç† ç”Ÿè¾‰ï¼Œä¸ºç§‘æŠ€è¿›æ­¥å’Œç¤¾ä¼šå‘å±•ç…§äº®äº†å‰è¿›çš„è·¯"
image: "images/recommend_site/xingyouji.jpg"
title: "ç¬¬å…­ç« ç¬¬äºŒèŠ‚"
author: è¯¸è‘›é’
authorEmoji: ğŸ…
pinned: false
tags:
- ç®—æ³•
series:
-   
---

## é˜Ÿåˆ—çš„åº”ç”¨
* 1. å¹¿åº¦ä¼˜å…ˆéå†
* 2. æ ‘ï¼šå±‚åºéå†
* 3. å›¾ï¼šæ— æƒå›¾çš„æœ€çŸ­è·¯å¾„

[102. äºŒå‰æ ‘çš„å±‚åºéå†](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```golang
type queue struct{
    node *TreeNode
    level int //å½“å‰èŠ‚ç‚¹çš„å±‚çº§
}

func levelOrder(root *TreeNode) [][]int {
    //ç”¨é˜Ÿåˆ—è§£å†³
    if root == nil{
        return [][]int{} 
    }

    res := make([][]int, 0) //ç»“æœæ•°ç»„
    q := make([]queue, 0)//åˆå§‹åŒ–é˜Ÿåˆ—
    q = append(q, queue{node:root,level:0}) //æ ¹èŠ‚ç‚¹å…ˆå…¥é˜Ÿ

    for len(q) != 0{
        node := q[0].node //è·å–é˜Ÿåˆ—ä¸­çš„å…ƒç´ 
        level := q[0].level //è·å–é˜Ÿåˆ—ä¸­çš„å±‚çº§
        q = q[1:] //å‡ºé˜Ÿ

        if level == len(res){//è¯´æ˜æ­¤æ—¶res[level]è¿˜ä¸å­˜åœ¨
            res =append(res, []int{})
        }
        res[level] = append(res[level] ,node.Val)

        //å¦‚æœå­˜åœ¨æ·»åŠ å·¦å³èŠ‚ç‚¹åˆ°é˜Ÿåˆ—ä¸­ï¼Œå±‚çº§+1
        if node.Left != nil{
            q = append(q, queue{node:node.Left,level:level+1})
        }

        if node.Right != nil{
            q = append(q, queue{node:node.Right,level:level+1})
        }
    }

    return res
}
```

[107. äºŒå‰æ ‘çš„å±‚åºéå† II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)
```golang
type queue struct{
    node *TreeNode
    level int 
}


func levelOrderBottom(root *TreeNode) [][]int {
    res := make([][]int, 0) //éœ€è¦å€’ç½®åˆ‡ç‰‡
    if root == nil{
        return res
    }

    q := make([]queue, 0)
    q = append(q ,queue{node:root,level:0} )

    for len(q) != 0{
        level := q[0].level
        node := q[0].node
        q = q[1:] //å‡ºé˜Ÿ

        //åˆ¤æ–­æ˜¯å¦å­˜åœ¨å­˜æ”¾è¯¥å±‚çš„åˆ‡ç‰‡
        if level == len(res){
            res = append(res,[]int{})
        }

        res[level] = append(res[level], node.Val)

        //å±‚åºéå†éœ€è¦å…ˆå¯¹å·¦å­æ ‘è¿›è¡Œåˆ¤æ–­æ˜¯å¦éœ€è¦å…¥é˜Ÿ
        if node.Left != nil{
            q = append(q, queue{node:node.Left,level:level+1})//å…¥é˜Ÿ
        }

        if node.Right != nil{
            q = append(q, queue{node:node.Right,level:level+1})//å…¥é˜Ÿ
        }
    }

    for i:=0;i<len(res)/2;i++{
        res[i],res[len(res)-i-1] = res[len(res)-i-1],res[i]
    }

    return res

}
```
[103. äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)
```golang
type queue struct{
    node *TreeNode //é˜Ÿåˆ—å…ƒç´ å­˜å‚¨çš„èŠ‚ç‚¹
    level int      //é˜Ÿåˆ—å…ƒç´ å­˜å‚¨çš„èŠ‚ç‚¹çš„å±‚çº§
}

func zigzagLevelOrder(root *TreeNode) [][]int {
    res := make([][]int,0) //æ„é€ è¿”å›æ•°ç»„ 
    if root == nil{
        return res
    }

    q := make([]queue, 0) //æ„é€ é˜Ÿåˆ—
    q = append(q, queue{node:root,level:0})//åˆå§‹åŒ–é˜Ÿåˆ—
    
    for len(q) != 0{
        node := q[0].node 
        level := q[0].level
        q = q[1:] //å‡ºé˜Ÿ
        
        if level == len(res){//æƒ³ç­‰è¯´æ˜è¿˜éœ€è¦æ·»åŠ ä¸€ä¸ªåˆ‡ç‰‡æ•°ç»„æ¥å­˜æ”¾æœ¬å±‚å› ä¸ºä¸‹æ ‡0å¼€å§‹å˜›...
            res = append(res, []int{})
        }

        res[level] = append(res[level], node.Val)

        //æ‹ä¸€ä¸‹ï¼Œå¶æ•°å±‚ä»å³åˆ°å·¦ï¼Œå¥‡æ•°å±‚ä»å·¦åˆ°å³//å¤šåŠ ä¸€ä¸ªåˆ¤æ–­
        if node.Left != nil{
            q = append(q,queue{node:node.Left,level:level+1})
        }
        
        if node.Right != nil{
            q = append(q,queue{node:node.Right,level:level+1})
        }
    }   
        //åªéœ€è¦æŠŠå¥‡æ•°å±‚çš„èŠ‚ç‚¹å€¼å€’ç½®ä¸€ä¸€ä¸‹å°±è¡Œäº†
        for i:=1;i<len(res);i+=2{
            length := len(res[i])
                for j:=0;j<length/2;j++{
                    res[i][j],res[i][length-1-j] = res[i][length-1-j],res[i][j]
                }
        }


     return res
}
```

[199. äºŒå‰æ ‘çš„å³è§†å›¾](https://leetcode-cn.com/problems/binary-tree-right-side-view/)
```golang
type queue struct{
    node *TreeNode
    level int //å±‚çº§
}

func rightSideView(root *TreeNode) []int {
    if root == nil{
        return []int{}
    }


    res := make([][]int, 0) 
    //é˜Ÿåˆ—å®ç°
    q := make([]queue, 0)
 
    q = append(q, queue{node:root,level:0}) //å°†rootèŠ‚ç‚¹å…ˆåŠ å…¥é˜Ÿåˆ—q

    for len(q) != 0{
        node := q[0].node
        level := q[0].level
        q = q[1:] //å‡ºé˜Ÿ

        if level == len(res){//è¯´æ˜æ­¤æ—¶éœ€è¦åŠ å…¥ä¸€ä¸ªç©ºåˆ‡ç‰‡æ¥å­˜å‚¨è¯¥å±‚èŠ‚ç‚¹çš„å€¼
            res = append(res ,[]int{})
        }

        res[level] = append(res[level], node.Val)
        //å’±ä»¬å…ˆå…¥é˜Ÿå³è¾¹çš„èŠ‚ç‚¹å†å…¥é˜Ÿå·¦è¾¹çš„èŠ‚ç‚¹

        if node.Right != nil{
            q = append(q, queue{node:node.Right,level:level+1})
        }

        if node.Left != nil{
            q = append(q, queue{node:node.Left,level:level+1})
        }
    }

    resEnd := make([]int, 0)
    //å†é‡æ–°æ„å»ºè¿”å›æ•°ç»„ï¼Œåªå–æ¯ä¸€å±‚ç¬¬ä¸€ä¸ª
    for _,v := range res{
        resEnd = append(resEnd, v[0])
    } 

    return resEnd
}
```

## BFSå’Œå›¾çš„æœ€çŸ­è·¯å¾„

[279. å®Œå…¨å¹³æ–¹æ•°](https://leetcode-cn.com/problems/perfect-squares/)
```golang
func numSquares(n int) int {
    //é˜Ÿåˆ—ï¼Œå›¾çš„æœ€çŸ­è·¯å¾„
    vivsted := make([]bool,n+1) //æŸ¥çœ‹èŠ‚ç‚¹æ˜¯å¦è¢«è®¿é—®è¿‡
    queue := make([][]int, 0)//æ„é€ é˜Ÿåˆ—

    queue = append(queue, []int{})
    queue[0] = append(queue[0], n)
    queue[0] = append(queue[0], 0)
    vivsted[queue[0][0]] = true
    for len(queue) != 0{
        nums := queue[0][0]
        step := queue[0][1]
        queue = queue[1:]
    
        if nums == 0{
            return step //å·²ç»åˆ°è¾¾é›¶
        } 

        for i:=1; ;i++{
            a := nums-i*i
            if a < 0{
                break
            }else if a == 0{//ç›´æ¥è¿”å›
                return step+1
            }
            if !vivsted[a]{//åˆ¤æ–­æ˜¯å¦éå†è¿‡
                queue = append(queue, []int{a,step+1})
                vivsted[a] = true
            }
        }

    }

    return 0
}
```

[127. å•è¯æ¥é¾™](https://leetcode-cn.com/problems/word-ladder/)
```golang
func ladderLength(beginWord string, endWord string, wordList []string) int {
	//BFS+é˜Ÿåˆ—
	hash := make(map[string]int) //ä¸ºwordListå»ºç«‹æ˜ å°„
	visited := make([]bool,len(wordList)) //ç”¨æ¥ä¿å­˜å›¾çš„è¯¥èŠ‚ç‚¹æ˜¯å¦å·²ç»è¢«è®¿é—®è¿‡äº†
	queue := make([]string,0) //é˜Ÿåˆ—ç”¨äºBFS

	for i:=0;i<len(wordList);i++{
		hash[wordList[i]] = i //åˆ›å»ºæ˜ å°„
		if beginWord == wordList[i]{
			visited[i] = true //å¦‚æœå›¾çš„èµ·å§‹ä½ç½®ä¹Ÿåœ¨wordListä¸­ï¼Œåˆ™æ ‡è®°ä¸ºtureï¼Œé˜²æ­¢é‡å¤éå†
		}
	}

	 _,ok:=hash[endWord]
	 if !ok{ //wordListé‡Œé¢ä¸å­˜åœ¨endWordï¼Œç›´æ¥è¿”0æ²¡æœ‰è·¯å¾„
		return 0
	 }

	queue = append(queue,beginWord) //å…¥é˜Ÿ
	wordlength := 0 //è·¯å¾„é•¿åº¦
	for len(queue) != 0{
		n := len(queue)
		wordlength++
		for n !=0{
			n--
			str := queue[0] //å–é˜Ÿé¦–å…ƒç´ 
			queue = queue[1:]//å‡ºé˜Ÿ
			for i:=0;i<len(beginWord);i++{
				word := []byte(str) //å…ˆè½¬æ¢æˆå­—èŠ‚åˆ‡ç‰‡
				//æŠŠå•è¯çš„æ¯ä¸€ä¸ªéƒ½å˜åŒ–25æ¬¡ï¼Œå³26ä¸ªè‹±æ–‡å•è¯ï¼Œæ‰¾åˆ°è·¯å¾„ï¼Œè¿˜éœ€è¿˜åŸ
				for j:=0;j<=25;j++{
					word[i] = 'a' + byte(j)
					v,ok := hash[string(word)]
					if ok && !visited[v]{ //æ‰¾åˆ°
						queue = append(queue,string(word))//å…¥é˜Ÿ
						visited[v] = true
						if string(word) == endWord{ //å¦‚æœæ˜¯æœ€ç»ˆèŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›
							return wordlength + 1
						}
					}
				}
			}
		}
	}
	return 0 //æ²¡æœ‰æ­¤è·¯å¾„
}
```