---
date: 2020-12-12T12:00:56+09:00
description: "å¦‚æœè¯´æ•°å­¦æ˜¯çš‡å† ä¸Šçš„ä¸€é¢—æ˜ç ï¼Œé‚£ä¹ˆç®—æ³•å°±æ˜¯è¿™é¢—æ˜ç ä¸Šçš„å…‰èŠ’ï¼Œç®—æ³•è®©è¿™é¢—æ˜ç æ›´åŠ ç† ç† ç”Ÿè¾‰ï¼Œä¸ºç§‘æŠ€è¿›æ­¥å’Œç¤¾ä¼šå‘å±•ç…§äº®äº†å‰è¿›çš„è·¯"
image: "images/recommend_site/xingyouji.jpg"
title: "ç¬¬å…­ç« ç¬¬ä¸€èŠ‚"
author: è¯¸è‘›é’
authorEmoji: ğŸ…
pinned: false
tags:
- ç®—æ³•
series:
-   
---

## æ ˆçš„åº”ç”¨
[20. æœ‰æ•ˆçš„æ‹¬å·](https://leetcode-cn.com/problems/valid-parentheses/)
```golang
func isValid(s string) bool {
    //ç”¨æ ˆè§£å†³çš„ç»å…¸é—®é¢˜

    stack := make([]byte,0)

    for i:=0;i<len(s);i++{
        if s[i] == '(' || s[i] == '{' || s[i] == '['{ //å·¦æ‹¬å·ï¼Œå…¥æ ˆ
            stack = append(stack, s[i]) //push
        }else{ //å³æ‹¬å·ï¼Œè¿›è¡ŒåŒ¹é…å‡ºæ ˆ
            if len(stack) == 0{ //æ ˆä¸ºç©ºï¼Œæ— æ³•åŒ¹é…ï¼Œè¿”å›false
                return false
            }
            var match byte
            if s[i] == '}'{
                match = '{'
            }else if s[i] == ')'{
                match = '('
            }else{
                match = '['
            }

            if match != stack[len(stack)-1]{ //åŒ¹é…ä¸æˆåŠŸï¼Œå‡ºæ ˆ
                return false
            } 

            stack = stack[:len(stack)-1] //pop
        }
    }

    if len(stack) != 0{ //æ ˆä¸ºç©ºï¼ŒåŒ¹é…æœªå®Œæˆï¼Œè¿”å›false
        return false
    }
    return true 
}
```

[150. é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)
```golang
func evalRPN(tokens []string) int {
	stack := make([]string,0)

	for i:=0;i<len(tokens);i++{
		ch := tokens[i]

		if ch == "+" || ch == "/" || ch == "-" || ch == "*"{ //åŒ¹é…åˆ°è¿ç®—ç¬¦ï¼Œå‡ºæ ˆä¸¤ä¸ªå…ƒç´ è¿›è¡Œè¿ç®—

			nums1,_:= strconv.Atoi(stack[len(stack)-2])
			nums2,_:= strconv.Atoi(stack[len(stack)-1])
			stack = stack[:len(stack)-2] //å‡ºæ ˆä¸¤ä¸ªå…ƒç´ 
			var res int
			switch ch {
			case "+":
				res = nums1 + nums2
			case "-":
				res = nums1 - nums2
			case "*":
				res = nums1 * nums2
			case "/":
				res = nums1 / nums2
			}
			stack = append(stack,strconv.Itoa(res)) //ç»“æœå…¥æ ˆ
		}else{ //åŒ¹é…åˆ°æ•°å­—ï¼Œç›´æ¥å…¥æ ˆ
			stack = append(stack,tokens[i])
		}
	}
		res,_:= strconv.Atoi(stack[0])
		return res
}
```
[71. ç®€åŒ–è·¯å¾„](https://leetcode-cn.com/problems/simplify-path/)
```golang
func simplifyPath(path string) string {
    parts := strings.Split(path, "/")
	var stack []string
	for _, part := range parts {
		switch part {
		case "", ".": //ç©ºå­—ç¬¦ä¸²å’Œ"."ç›´æ¥è·³è¿‡
			continue
		case "..": //é‡åˆ°..å°±å‡ºæ ˆä¸€ä¸ªç›®å½•å
			if len(stack) > 0 {
				stack = stack[:len(stack)-1]
			}
		default: //ä¸ºå­—æ¯å­—ç¬¦ä¸²ï¼Œç›´æ¥å…¥æ ˆ
			stack = append(stack, part)
		}
	}
	return "/" + strings.Join(stack, "/")
}
```

## æ ˆå’Œé€’å½’çš„å…³ç³»ç´§å¯†

### äºŒå‰æ ‘ä¸­çš„ç®—æ³•

``ä¸‰ç§äºŒå‰æ ‘éå†ç”¨æ ˆè§£å†³``

[144. äºŒå‰æ ‘çš„å‰åºéå†](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)
```golang
type Command struct{
    s string
    node *TreeNode
}

func inorderTraversal(root *TreeNode)(res []int){
    if root == nil{
        return 
    }
    stack := make([]Command, 0)
    stack = append(stack, Command{s:"go",node:root})
    for len(stack) != 0{
        command := stack[len(stack)-1] //å–æ ˆé¡¶å…ƒç´ 
        stack = stack[:len(stack)-1] //å‡ºæ ˆ    
    
        if command.s == "print" { //åˆ¤æ–­æ˜¯å¦æ˜¯éœ€è¦æ‰“å°çš„èŠ‚ç‚¹
            res = append(res, command.node.Val) 
        }else{
            if command.node.Right != nil{
                stack = append(stack, Command{s:"go",node:command.node.Right})
            }
            if command.node.Left != nil{
                stack = append(stack, Command{s:"go",node:command.node.Left})
            }
            stack = append(stack, Command{s:"print",node:command.node}) //æŠŠæ ¹èŠ‚ç‚¹è®¾ç¬¬ä¸€ä¸ªæ‰“å°çš„

        }
    }

    return res
}
```

[94.äºŒå‰æ ‘çš„ä¸­åºéå†](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)
```golang
type Command struct{
    s string
    node *TreeNode
}

func inorderTraversal(root *TreeNode)(res []int){
    if root == nil{
        return 
    }
    stack := make([]Command, 0)
    stack = append(stack, Command{s:"go",node:root})
    for len(stack) != 0{
        command := stack[len(stack)-1] //å–æ ˆé¡¶å…ƒç´ 
        stack = stack[:len(stack)-1] //å‡ºæ ˆ    
    
        if command.s == "print" { //åˆ¤æ–­æ˜¯å¦æ˜¯éœ€è¦æ‰“å°çš„èŠ‚ç‚¹
            res = append(res, command.node.Val) 
        }else{
            if command.node.Right != nil{
                stack = append(stack, Command{s:"go",node:command.node.Right})
            }
            stack = append(stack, Command{s:"print",node:command.node}) //æŠŠæ ¹èŠ‚ç‚¹è®¾ç¬¬äºŒä¸ªæ‰“å°çš„
            if command.node.Left != nil{
                stack = append(stack, Command{s:"go",node:command.node.Left})
            }
        }
    }

    return res
}
```

[145. äºŒå‰æ ‘çš„ååºéå†](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)
```golang
type Command struct{
    s string
    node *TreeNode
}

func postorderTraversal(root *TreeNode)(res []int){
    if root == nil{
        return 
    }
    stack := make([]Command, 0)
    stack = append(stack, Command{s:"go",node:root})
    for len(stack) != 0{
        command := stack[len(stack)-1] //å–æ ˆé¡¶å…ƒç´ 
        stack = stack[:len(stack)-1] //å‡ºæ ˆ    
    
        if command.s == "print" { //åˆ¤æ–­æ˜¯å¦æ˜¯éœ€è¦æ‰“å°çš„èŠ‚ç‚¹
            res = append(res, command.node.Val) 
        }else{
            stack = append(stack, Command{s:"print",node:command.node}) //æŠŠæ ¹èŠ‚ç‚¹è®¾ä¸ºæœ€åä¸€ä¸ªæ‰“å°çš„
            if command.node.Right != nil{
                stack = append(stack, Command{s:"go",node:command.node.Right})
            }
            if command.node.Left != nil{
                stack = append(stack, Command{s:"go",node:command.node.Left})
            }
        }
    }

    return res
}
```
