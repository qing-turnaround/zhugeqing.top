---
date: 2020-12-12T12:00:56+09:00
description: "å¦‚æœè¯´æ•°å­¦æ˜¯çš‡å† ä¸Šçš„ä¸€é¢—æ˜ç ï¼Œé‚£ä¹ˆç®—æ³•å°±æ˜¯è¿™é¢—æ˜ç ä¸Šçš„å…‰èŠ’ï¼Œç®—æ³•è®©è¿™é¢—æ˜ç æ›´åŠ ç† ç† ç”Ÿè¾‰ï¼Œä¸ºç§‘æŠ€è¿›æ­¥å’Œç¤¾ä¼šå‘å±•ç…§äº®äº†å‰è¿›çš„è·¯"
image: "images/recommend_site/xingyouji.jpg"
title: "ç¬¬ä¸ƒç« ç¬¬ä¸€èŠ‚"
author: è¯¸è‘›é’
authorEmoji: ğŸ…
pinned: false
tags:
- ç®—æ³•
series:
-   
---

[104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

```golang
func max(i,j int)int{
    if i >= j{
        return i
    }else{
        return j
    }
}


func maxDepth(root *TreeNode) int {
    if root == nil{
        return 0
    }

    //åŠ 1æ˜¯å½“å‰èŠ‚ç‚¹ï¼Œ
    return max(maxDepth(root.Left),maxDepth(root.Right)) + 1
}
```

[111. äºŒå‰æ ‘çš„æœ€å°æ·±åº¦](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

#### é€’å½’å†™æ³•
```golang
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func minDepth(root *TreeNode) int {
    //æ— æ³•å†™æˆäºŒå‰æ ‘æœ€å¤§æ·±åº¦çš„å†™æ³•ï¼Œå› ä¸ºéœ€è¦è€ƒè™‘è¯¥åˆ†æ”¯æ˜¯å¦æœ‰å¶å­èŠ‚ç‚¹
    if root == nil{
        return 0
    }

    //å¦‚æœå·¦å³èŠ‚ç‚¹éƒ½ä¸ºä¸ä¸ºç©ºï¼Œåˆ™è¿›è¡Œé€’å½’æ¯”è¾ƒ
    if root.Left != nil && root.Right != nil{
        return 1 + min(minDepth(root.Left),minDepth(root.Right))
    }   

    if root.Left != nil{
        return 1 + minDepth(root.Left)
    }else if root.Right != nil{
        return 1 + minDepth(root.Right)
    }else {
        return 1
    }


}
// åˆ¤æ–­å¤§å°å‡½æ•°
func min(a,b int)int{
    if a > b{
        return b
    }else {
        return a
    }
}
```


#### é˜Ÿåˆ—å†™æ³•
```golang
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func minDepth(root *TreeNode) int {

    if root == nil{
        return 0
    }
    //é‡‡ç”¨é˜Ÿåˆ—ï¼ˆå¹¿åº¦ä¼˜å…ˆç¼–åˆ—ï¼‰
    //è®°å½•æ¯ä¸€æ¡è·¯å¾„
    queue := make([]*TreeNode,0)
    //è®°å½•æ¯ä¸€æ¡è·¯å¾„çš„æ·±åº¦
    count := make([]int,0)

    //å…¥é˜Ÿåˆ—
    queue = append(queue,root)
    count = append(count,1)
    //è®°å½•çš„ç´¢å¼•
    index := 0
    //å¹¿åº¦ä¼˜å…ˆéå†ï¼Œä¸€å±‚ä¸€å±‚éå†ï¼Œé‡åˆ°æ²¡æœ‰å·¦å³å­©å­èŠ‚ç‚¹å°±é€€å‡ºå¾ªç¯

    for len(queue) > 0{
        temp := queue[index]

        if temp.Left == nil && temp.Right == nil{
            return count[index]
        }

        if temp.Left != nil{
            queue = append(queue,temp.Left)
            count = append(count,count[index]+1)
        }

        if temp.Right != nil{
            queue = append(queue,temp.Right)
            count = append(count,count[index]+1)
        }

        index++
    }

    return 0
}
```
[100. ç›¸åŒçš„æ ‘](https://leetcode-cn.com/problems/same-tree/)
#### é€’å½’å†™æ³•
```golang
func isSameTree(p *TreeNode, q *TreeNode) bool {
    if p == nil && q == nil{
        return true
    }

    if p == nil || q== nil{
        return false
    }


    if p.Val != q.Val{
        return false
    }

    return isSameTree(p.Left,q.Left) && isSameTree(p.Right,q.Right)
}
```

#### è¿­ä»£å†™æ³•
```golang
func isSameTree(p *TreeNode, q *TreeNode) bool {
    //è¿­ä»£å†™æ³•
    //æ„å»ºé˜Ÿåˆ—
    queue := make([]*TreeNode,0)
    //å°†ä¸¤ä¸ªæ ¹èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—
    queue = append(queue,p)
    queue = append(queue,q)

    for len(queue) > 0 {
        //å–é˜Ÿé¦–ä¸¤ä¸ªå…ƒç´ 
        u := queue[0]
        v := queue[1]
        //å‡ºé˜Ÿåˆ—
        queue = queue[2:]

        //è‹¥ä¸¤ä¸ªèŠ‚ç‚¹éƒ½ä¸ºç©ºï¼Œåˆ™è·³åˆ°ä¸‹ä¸€è½®æ¯”è¾ƒ
        if u == nil && v == nil{
            continue 
        }

        //è‹¥å…¶ä¸­ä¸€ä¸ªèŠ‚ç‚¹ä¸ºç©ºï¼Œè€Œå¦å¤–ä¸€ä¸ªèŠ‚ç‚¹ä¸ä¸ºç©ºï¼Œåˆ™è¿”å›false
        if u == nil || v == nil{
            return false 

        }
        //è‹¥ä¸¤ä¸ªèŠ‚ç‚¹éƒ½ä¸ä¸ºç©ºï¼Œä½†æ˜¯ä¸ç›¸ç­‰ï¼Œåˆ™è¿”å›false
        if u.Val != v.Val{
            return false 
        }

        queue = append(queue,u.Left)
        queue = append(queue,v.Left)    
        queue = append(queue,u.Right)
        queue = append(queue,v.Right)
    }

    return true
}
```

[101. å¯¹ç§°äºŒå‰æ ‘](https://leetcode-cn.com/problems/symmetric-tree/)

#### é€’å½’å†™æ³•
```golang
func compare(p,q *TreeNode)bool{
    if p == nil && q == nil{
        return true 
    }

    if p == nil || q == nil{
        return false
    }
    // //ç­‰ä»·äº
    // if p != nil && q == nil{
    //     return false
    // }else if p == nil && q != nil{
    //     return false 
    // }
    if p.Val != q.Val{
        return false
    }

    //è¿›è¡Œé€’å½’(é•œåƒå¤„ç†pçš„å·¦èŠ‚ç‚¹åº”ä¸qçš„å³èŠ‚ç‚¹è¿›è¡Œæ¯”è¾ƒï¼ŒåŒæ—¶qçš„å·¦èŠ‚ç‚¹ä¹Ÿåº”è¯¥ä¸)
    return compare(p.Left,q.Right) && compare(p.Right,q.Left)

}

func isSymmetric(root *TreeNode) bool {
    // è®¾ç«‹ä¸¤æŒ‡é’ˆæ¥é€’å½’æ¯”è¾ƒ
    //å·¦å³åˆ†å¼€
    return compare(root,root) 
}
```

#### è¿­ä»£å†™æ³•
```golang
func isSymmetric(root *TreeNode) bool {
    //æ„å»ºé˜Ÿåˆ—æ¥è¿›è¡Œå±‚åºéå†ï¼Œä¸æ–­éå†å°†å·¦å³èŠ‚ç‚¹å­˜å…¥é˜Ÿåˆ—ä¸­
    queue := make([]*TreeNode,0)
    //æ ¹èŠ‚ç‚¹å…¥é˜Ÿï¼Œæ¯”è¾ƒä¸¤è¾¹çš„é•œåƒ
    queue = append(queue,root)
    queue = append(queue,root)

    //è¿­ä»£è¿‡ç¨‹
    for len(queue) > 0{
        p := queue[0]
        q := queue[1]
        //å‡ºé˜Ÿåˆ—
        queue = queue[2:]

        //è¿›è¡Œæ¯”è¾ƒ   
        if p == nil && q == nil{
            //æ¯æ¬¡åªæ¯”è¾ƒä¸¤ä¸ª
            continue 
        }

        if p == nil || q == nil{
             return false
         }

        if p.Val != q.Val{
            return false    
        }

        queue = append(queue,p.Left)
        queue = append(queue,q.Right)
        queue = append(queue,p.Right)
        queue = append(queue,q.Left)
    }

    return true
}
```