---
date: 2020-12-12T12:00:56+09:00
description: "å¦‚æœè¯´æ•°å­¦æ˜¯çš‡å† ä¸Šçš„ä¸€é¢—æ˜ç ï¼Œé‚£ä¹ˆç®—æ³•å°±æ˜¯è¿™é¢—æ˜ç ä¸Šçš„å…‰èŠ’ï¼Œç®—æ³•è®©è¿™é¢—æ˜ç æ›´åŠ ç† ç† ç”Ÿè¾‰ï¼Œä¸ºç§‘æŠ€è¿›æ­¥å’Œç¤¾ä¼šå‘å±•ç…§äº®äº†å‰è¿›çš„è·¯"
image: "images/recommend_site/xingyouji.jpg"
title: "ç¬¬å››ç« ç¬¬ä¸€èŠ‚"
author: è¯¸è‘›é’
authorEmoji: ğŸ…
pinned: false
tags:
- ç®—æ³•
series:
-   
---
``ä¸¤ç±»æŸ¥æ‰¾é—®é¢˜``
* 1.æŸ¥æ‰¾æœ‰æ— 
-å…ƒç´ 'a'æ˜¯å¦å­˜åœ¨ï¼Ÿsetï¼ˆé›†åˆï¼‰

* 2.æŸ¥æ‰¾å¯¹åº”å…³ç³»ï¼ˆé”®å€¼å¯¹åº”ï¼‰
-å…ƒç´ 'a'å‡ºç°äº†å‡ æ¬¡ï¼Ÿmapï¼ˆå­—å…¸ï¼‰

``ç»ƒä¹ ``
[349. ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†](https://leetcode-cn.com/problems/intersection-of-two-arrays/)
```golang
func intersection(nums1 []int, nums2 []int) []int {
    hash := make(map[int]bool)
    res := make([]int, 0)

    for _, v := range nums1 {
        hash[v] = true
    }

    for _, v := range nums2 {
        if hash[v] == true {
            res = append(res, v)
            hash[v] = false
        }
    }
    return res
}

```

[242. æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯](https://leetcode-cn.com/problems/valid-anagram/)
```golang
func isAnagram(s string, t string) bool {
    if len(s) != len(t){ //é•¿åº¦ä¸ç­‰ï¼Œç›´æ¥è¿”å›false
        return false
    }

    //å»ºç«‹ä¸€ä¸ªä¸ä¸¤ä¸ªå­—ç¬¦ä¸²æœ‰å…³çš„æ˜ å°„ï¼Œåˆå§‹å€¼ä¸º0ï¼Œmap[s[i]]å°±åŠ 1ï¼Œmap[t[i]]å°±å‡1ï¼Œå¦‚æœmapé‡Œé¢å‡ºç°äº†å€¼ä¸ä¸º0çš„keyå°±è¯´æ˜
    //ä¸æ˜¯å¼‚ä½è¯
    hash := make(map[byte]int) 

    for i:=0;i<len(s);i++{
        hash[s[i]-'a']++
        hash[t[i]-'a']--
    }

    for _,v := range hash{
        if v != 0{
            return false
        }
    }

    return true
}
```

[202.å¿«ä¹æ•°](https://leetcode-cn.com/problems/happy-number/)
```golang
func isHappy(n int) bool {
    hash := make(map[int]bool)
    res := n
    for{
        if res == 1{
            return true
        }else if hash[res] == true{
            return false
        }
        hash[res] = true
        res = getSquareSUm(res)

    }

    return false
}

func getSquareSUm(n int)int{
    res := 0

    for n > 0{
        res += (n%10) * (n%10)
        n = n / 10
    }
    return res
}
```
[290. å•è¯è§„å¾‹](https://leetcode-cn.com/problems/word-pattern/)
```golang
func wordPattern(pattern string, s string) bool {
	//åŒæ˜ å°„ï¼Œå­—ç¬¦->å­—ç¬¦ä¸²ï¼Œå­—ç¬¦ä¸²->å­—ç¬¦
    word2ch := make(map[string]byte)
	ch2word := make(map[byte]string)
    stringSlice := strings.Split(s, " ")

	if len(stringSlice) != len(pattern){
		return false
	}

    //åŒæ˜ å°„ï¼Œå¯¹åº”çš„å­—ç¬¦æœ‰ç€å¯¹åº”çš„å­—ç¬¦ä¸²ï¼Œå¯¹åº”çš„å­—ç¬¦ä¸²æœ‰ç€å¯¹åº”çš„å­—ç¬¦
    for i:=0;i<len(pattern);i++{
        if word2ch[stringSlice[i]] != 0 && word2ch[stringSlice[i]] != pattern[i]{
            return false
        }
        if ch2word[pattern[i]] != "" && ch2word[pattern[i]] != stringSlice[i]{
            return false
        }
        word2ch[stringSlice[i]] = pattern[i]
        ch2word[pattern[i]] = stringSlice[i]
    }


	return true
}
```

[451. æ ¹æ®å­—ç¬¦å‡ºç°é¢‘ç‡æ’åº](https://leetcode-cn.com/problems/sort-characters-by-frequency/)
```golang
//ç¬¬ä¸€ç§å†™æ³•
func frequencySort(s string) string {
	if len(s) == 1 || s == ""{
		return s
	}
	freq := make(map[byte]int) //è®°å½•å­—ç¬¦çš„å‡ºç°é¢‘ç‡
	ret := make([]byte,0) //è®°å½•ä¸åŒçš„å­—ç¬¦
	res := make([]byte,0) //è¿”å›ç»“æœ
	for i:=0;i<len(s);i++{
		if freq[s[i]] == 0{
			ret = append(ret,s[i])
		}
		freq[s[i]]++
	}

	//sort.Slice(ret, func(i, j int) bool {
	//	return freq[ret[i]] > freq[ret[j]]
	//})
	quickSort(ret,freq)

	for i:=0;i<len(ret);i++{
		for j:=0;j<freq[ret[i]];j++{
			res = append(res,ret[i])
		}
	}

	return string(res)

}

func quickSort(ret []byte,freq map[byte]int){
	partition(ret,freq,0,len(ret)-1)
}

func partition(ret []byte,freq map[byte]int,low,high int){
	if low >= high{
		return
	}
	pivot := ret[low]
	l := low
	r := high

	for l < r{
		for l < r && freq[ret[r]] < freq[pivot]{
			r--
		}
		if l < r{
			ret[l] = ret[r]
			l++
		}
		for l < r && freq[ret[l]] >= freq[pivot]{
			l++
		}
		if l < r {
			ret[r] = ret[l]
			r--
		}
	}
	ret[l] = pivot
	partition(ret,freq,low,l-1)
	partition(ret,freq,l+1,high)

}
```

```golang
//ç¬¬äºŒç§å†™æ³•
func frequencySort(s string) string {
	if len(s) == 1 || s == ""{
		return s
	}
	freq := make(map[byte]int) //è®°å½•å­—ç¬¦çš„å‡ºç°é¢‘ç‡
	ret := make([]byte,0) //è®°å½•ä¸åŒçš„å­—ç¬¦
	res := make([]byte,0) //è¿”å›ç»“æœ
	for i:=0;i<len(s);i++{
		if freq[s[i]] == 0{
			ret = append(ret,s[i])
		}
		freq[s[i]]++
	}

	//sort.Slice(ret, func(i, j int) bool {
	//	return freq[ret[i]] > freq[ret[j]]
	//})
	sort.Slice(ret,func(i,j int)bool{
		return freq[ret[i]] > freq[ret[j]]
	})

	for i:=0;i<len(ret);i++{
		for j:=0;j<freq[ret[i]];j++{
			res = append(res,ret[i])
		}
	}

	return string(res)

}
```

[1. ä¸¤æ•°ä¹‹å’Œ](https://leetcode-cn.com/problems/two-sum/)
```golang
func twoSum(nums []int, target int) []int {
    hashMap := map[int]int{} //å®ä¾‹åŒ–ä¸€ä¸ªmap

    for i:=0;i<len(nums);i++{
        if v,ok := hashMap[target-nums[i]];ok{//å¦‚æœå­˜åœ¨å°±æ”¾å›hashMapçš„å€¼
            return []int{i,v}
        } 
        hashMap[nums[i]] = i //æ·»åŠ 
    }

    return []int{} //æ²¡æ‰¾åˆ°
}
```

[15. ä¸‰æ•°ä¹‹å’Œ](https://leetcode-cn.com/problems/3sum/submissions/)
```golang
func threeSum(nums []int) [][]int {
	res := make([][]int, 0)
	// å…ˆå¯¹åŸå§‹æ•°ç»„è¿›è¡Œæ’åºï¼Œæ’åºåä¸€æ¥å¯ä»¥è¿‡æ»¤å¾ˆå¤šé‡å¤ç»“æœï¼ŒäºŒæ¥å¯ä»¥è®©twoSumä»¥O(n)å¤„ç†
	sort.Ints(nums)
	for i := 0; i < len(nums); i++ {
		//if nums[i] == nums[i+1] && nums[i+1] == nums[i+2] {
		//	continue
		//}
		// ä»å‘ååˆ¤æ–­æ”¹ä¸ºå‘å‰åˆ¤æ–­ç›¸ç­‰ï¼Œé‚£ä¹ˆç¬¬ä¸€æ¬¡çš„ç»“æœå°±ä¸€å®šè¦åŠ å…¥ç»“æœåˆ—è¡¨é‡Œé¢ï¼Œç„¶ååé¢å¦‚æœæœ‰å’Œå‰é¢ç›¸åŒçš„æšä¸¾å°±è·³è¿‡
		if i > 0 && nums[i] == nums[i-1] {
			continue
		}
		twoSumTarget := nums[i] * -1
		l, r := i+1, len(nums)-1
		for l < r {
			// è¿™é‡Œéœ€è¦ç¡®ä¿å‰æŒ‡é’ˆåç§»ä¸èƒ½è¶Šè¿‡åæŒ‡é’ˆï¼Œç„¶åæ˜¯å‘å‰åˆ¤æ–­ç›¸ç­‰
			if l > i+1 && nums[l] == nums[l-1] {
				l++
				continue
			}
			twoSum := nums[l] + nums[r]
			if twoSum == twoSumTarget {
				// è¿™æ ·çš„æƒ…å†µå°±æ˜¯twoSumç¬¦åˆç›®æ ‡å€¼ï¼Œè®°å½•è¿™ä¸ªä¸‰å…ƒç»„
				res = append(res, []int{nums[i], nums[l], nums[r]})
				// ç„¶åæ‰¾åˆ°ä¸‰å…ƒç»„åå‰åæŒ‡é’ˆä¸€èµ·ç§»åŠ¨
				r--
				l++
			}

			// twoSumæ¯”ç›®æ ‡å€¼å¤§ï¼ŒåæŒ‡é’ˆè¦å‘å‰ç§»
			if twoSum > twoSumTarget { //å»é‡
				r--
				continue
			}
			if twoSum < twoSumTarget { //å»é‡
				// twoSumå°äºç›®æ ‡å€¼ï¼Œå‰æŒ‡é’ˆåç§»
				l++
				continue
			}

		}
	}
	return res
}
```
[16. æœ€æ¥è¿‘çš„ä¸‰æ•°ä¹‹å’Œ](https://leetcode-cn.com/problems/3sum-closest/)
```golang
func abs(a int)int{
	if a >= 0{
		return  a
	}else{
		return -a
	}
}

func threeSumClosest(nums []int, target int) int {
	sub := math.MaxInt64 //è®°å½•ä¸ç›®æ ‡å€¼çš„å·®å€¼
	res := math.MaxInt64 //è®°å½•æœ€æ¥è¿‘ç›®æ ‡çš„å’Œ
	sort.Ints(nums)
	for i:=0;i<len(nums);i++{
		//å»é‡
		if i > 0 && nums[i-1] == nums[i]{
			continue //æœ‰ç›¸åŒå…ƒç´ å¯ä»¥ç›´æ¥è·³è¿‡è€ƒè™‘ï¼Œå› ä¸ºåœ¨ç¬¬ä¸€æ¬¡å·²ç»è€ƒè™‘
		}
		l := i+1
		r := len(nums)-1
		//
		for l < r{
			//å¯»æ‰¾æœ€æ¥è¿‘çš„ä¸‰æ•°ä¹‹å’Œ
			curr := nums[i] + nums[l] + nums[r] //ä¸´æ—¶è®°å½•å’Œ
			currSub := abs(curr - target) //ä¸´æ—¶çš„å·®å€¼
			if curr < target { //å½“å‰çš„å·®å€¼å°äºæœ€å°‘çš„å·®å€¼
				l++
				if currSub < sub{
					sub = currSub //å½“å‰æœ€æ¥è¿‘çš„å·®å€¼
					res = curr  //å½“å‰æœ€æ¥è¿‘çš„ç»“æœ
				}
			}else if curr > target { //å·®å€¼å¤§äºsubï¼Œè¯´æ˜å’Œå¤ªå¤§äº†æˆ–è€…å¤ªå°äº†
				r--
				if currSub < sub{
					sub = currSub //å½“å‰æœ€æ¥è¿‘çš„å·®å€¼
					res = curr //å½“å‰æœ€æ¥è¿‘çš„ç»“æœ
				}
			}else{ //ç›®æ ‡å€¼æƒ³ç­‰ï¼Œä¸€å®šæ˜¯æœ€æ¥è¿‘çš„æ•°ï¼Œç›´æ¥è¿”å›
				return curr
			}

		}
	}
	return res
}
```
[454. å››æ•°ç›¸åŠ  II](https://leetcode-cn.com/problems/4sum-ii/)
```golang
func fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int {
    //å»ºç«‹ä¸€ä¸ªæŸ¥æ‰¾è¡¨ï¼ˆé‡‡ç”¨mapï¼Œé”®ä¸ºnums3å’Œnums4å’Œçš„å¯èƒ½æ€§ï¼Œå€¼ä¸ºå‡ºç°çš„é¢‘ç‡ï¼‰
    hash1 := make(map[int]int) //nums1 + nums2
    hash2 := make(map[int]int) //nums3 + nums4
    res := 0 //è¿”å›ç»“æœ
    
    for i:=0;i<len(nums1);i++{
        for j:=0;j<len(nums2);j++{
            hash1[nums1[i]+nums2[j]]++ //ç»Ÿè®¡é¢‘ç‡
        }
    }
    for i:=0;i<len(nums3);i++{
        for j:=0;j<len(nums4);j++{
            hash2[nums3[i]+nums4[j]]++ //ç»Ÿè®¡é¢‘ç‡
        }
    }

    for i,v := range hash1{
        if hash2[0-i] != 0{
            res += v * hash2[0-i]
        }
    }

    return res
}
```
[49. å­—æ¯å¼‚ä½è¯åˆ†ç»„](https://leetcode-cn.com/problems/group-anagrams/)
```golang
func groupAnagrams(strs []string) [][]string {
    hash := make(map[string][]string) //æ„å»ºä¸€ä¸ªå­—å…¸
    res := make([][]string, 0) //è¿”å›ç»“æœ
    for _,v := range strs{
        s := []byte(v) //å°†æ¯ä¸ªå­—ç¬¦ä¸²è½¬æ¢æˆbyteåˆ‡ç‰‡æ’åºåå†è½¬æ¢æˆstringè¿›è¡Œæ˜ å°„
        sort.Slice(s,func(i,j int)bool{
            return s[i] < s[j]  //ä»å°åˆ°å¤§æ’åˆ—
        })

        hash[string(s)] = append(hash[string(s)], v) //æ·»åŠ åˆ°valueåˆ‡ç‰‡ä¸­
    }

    for _,v := range hash{
        res = append(res, v) //æŠŠæ¯ä¸€ä¸ªvalue(ä¸€ç»´åˆ‡ç‰‡)æ·»åŠ åˆ°äºŒç»´åˆ‡ç‰‡ä¸­
    }

    return res
}
```
[447. å›æ—‹é•–çš„æ•°é‡](https://leetcode-cn.com/problems/number-of-boomerangs/)
```golang
func numberOfBoomerangs(points [][]int) int {
    res := 0 //æœ€ç»ˆè¿”å›ç»“æœ
    for i:=0;i<len(points);i++{ //iå½“åšæ¢çº½ï¼Œå¯»æ‰¾åˆ°iè·ç¦»æƒ³ç­‰çš„ç‚¹
        hash := make(map[int]int) //æœ¬è½®çš„å“ˆå¸Œè¡¨ï¼Œä¸åŒçš„iç‚¹æœ‰ä¸åŒçš„å“ˆå¸Œè¡¨
        for j := 0;j<len(points);j++{ //jä¸ºå¦å¤–ä¸€ä¸ªç‚¹
            if i != j{ //ä¸¤ç‚¹ä¸èƒ½ç›¸åŒ
                hash[distance(points[i],points[j])]++ //é¢‘ç‡åŠ ä¸€
            }
        } //äºŒå±‚å¾ªç¯for
        for _,v := range hash{
            res += v * (v-1) //ç¬¬ä¸€æ¬¡æœ‰vç§é€‰æ‹©ï¼Œç¬¬äºŒæ¬¡æœ‰v-1ç§é€‰æ‹©
        }
    }
        return res
}

func distance(a,b []int)int{ //å¦‚æœè·ç¦»å¤ªå¤§éœ€è¦æ”¹ç”¨int64
    return (a[0]-b[0]) * (a[0]-b[0]) + (a[1]-b[1]) * (a[1]-b[1]) //è®¡ç®—çš„æ˜¯a,bä¸¤ç‚¹çš„å¹³æ–¹
}
```

[149. ç›´çº¿ä¸Šæœ€å¤šçš„ç‚¹æ•°](https://leetcode-cn.com/problems/max-points-on-a-line/)
```golang
func maxPoints(points [][]int) int {
    //ä»¥iç‚¹ä¸ºæ¢çº½ï¼Œæ‰¾åˆ°ä¸iç‚¹ç»„æˆçš„ç›´çº¿çš„æ–œç‡ç›¸åŒçš„ç‚¹
    resMax := 0 //è¿”å›å€¼
    for i:=0;i<len(points);i++{
        //å»ºç«‹ä¸€ä¸ªkeyä¸ºä¸¤ç‚¹æ–œç‡ï¼Œå¯èƒ½ä¸ºæµ®ç‚¹æ•°ï¼Œæ‰€ä»¥æ‰è¦float64ï¼Œvalueä¸ºç›¸åŒæ–œç‡ç‚¹çš„ä¸ªæ•° 
        hash := make(map[float64]int)
        for j:=0;j<len(points);j++{
            if i != j{ //ä¸èƒ½æ˜¯åŒä¸€ä¸ªç‚¹ç»„æˆç›´çº¿
                hash[lineSlope(points[i],points[j])]++
            }
        }

        for _,v := range hash{
            if v > resMax{ //éå†hashè¡¨ï¼ŒåŒä¸€ç›´çº¿æœ€å¤šçš„ç‚¹æ•°
                resMax = v
            }
        }
    }
    return resMax + 1 //å› ä¸ºhashè¡¨æ²¡æœ‰ç»Ÿè®¡ç‚¹iå®ƒè‡ªèº«ï¼Œæ‰€ä»¥éœ€è¦åŠ ä¸€
}

func lineSlope(a,b []int)float64{
    return float64(a[1]-b[1]) / float64(a[0]-b[0]) //ç›¸å½“äº(ay-by) / (ax-bx)
}
```