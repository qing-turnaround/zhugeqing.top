---
date: 2020-12-12T12:00:56+09:00
description: "如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路"
image: "images/recommend_site/xingyouji.jpg"
title: "第八章第一节"
author: 诸葛青
authorEmoji: 🎅
pinned: false
tags:
- 算法
series:
-   
---

## 树型问题

[17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)
```golang
func letterCombinations(digits string) []string {
        if digits == ""{
            return []string{}
        }

    	hash := map[byte][]byte{
		'0' : []byte{' '},
		'1' : []byte{' '},
		'2' : []byte{'a','b','c'},
		'3' : []byte{'d','e','f'},
		'4' : []byte{'g','h','i'},
		'5' : []byte{'j','k','l'},
		'6' : []byte{'m','n','o'},
		'7' : []byte{'p','q','r','s'},
		'8' : []byte{'t','u','v'},
		'9' : []byte{'w','x','y','z'},
    }

    //返回数组
    res := make([]string,0)

    var findCombinations func(digits []byte,index int,s []byte)

    findCombinations = func(digits []byte,index int,s []byte){
        if index == len(digits){
            res = append(res,string(s))
            return //递归终止条件
        }

        //递归
        for i:=0;i<len(hash[digits[index]]);i++{
            findCombinations(digits,index+1,append(s,hash[digits[index]][i]))
        }
    }

    findCombinations([]byte(digits),0,[]byte{})

    return res
}
```

## 递归调用一个重要的特征：回溯

[93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)
```golang
func restoreIpAddresses(s string) []string {
    //回溯是暴力解法的一个主要手段
    //一个ip地址一共有4个段
    //返回答案
    ans := make([]string,0)
    //每一段的数字segment[i]
    segmentIp := make([]int,4)

    //dfs函数的含义：将s拆分为一个合法的ip地址
    //segment表示当前dfs函数需要确定的是第几段ip地址,startIp则表示在s字符串中的下标
    var dfs func(segment ,startIp int)

    dfs = func(segment,startIp int){
        //递归终止条件
        //已经包含4段，加入结果集
        if segment == 4{
            //只有长度符合要求才能加入结果集
            if startIp == len(s){
                subStr := ""
                for i:=0;i<segment;i++{
                    subStr += strconv.Itoa(segmentIp[i])
                    if i!= 3{
                        subStr += "."
                    }    
                }
                ans = append(ans,subStr)
            }
            return
        }


        if startIp == len(s){
            //提前回溯
            return
        }


        //不能含有前导0
        if s[startIp] == '0'{
            //直接把这一段的值置为0
            segmentIp[segment] = 0
            //段号加一，下标也加一，继续递归
            dfs(segment+1,startIp+1)
        }

        val := 0
        for endIp:=startIp;endIp<len(s);endIp++{
            //选取数字进行递归
            val = val*10 + int(s[endIp]-'0')
            if val > 0 && val <= 0xff{
                segmentIp[segment] = val
                dfs(segment+1,endIp+1)
            }else{
                break
            }
        }

        return
    }

    dfs(0,0)

    return ans
}
```

[131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)
```golang
//判断是否是回文子串
func isVaild(s []byte)bool{
	length := len(s)
	for i:=0;i<length/2;i++{
		if s[i] != s[length-i-1]{
			return false
		}
	}

	return true
}


func partition(s string) [][]string {
	//回溯解法
	//返回数组
	ans := make([][]string,0)
	res := []string{}
	var dfs func(index int)
	//dfs函数的意义是为了拆分字符串，使得是回文子串
	dfs = func(index int){
		//递归终止条件（进行回溯）
		if index == len(s){
            // append([]string(nil), res...)是为了隔离ans[i]与res的关系
			ans = append(ans,append([]string(nil), res...))
			return
		}

		//子串（0...len(s)-1）
		for i:=index;i<len(s);i++{
			//如果是回文串就向下递归
			if isVaild([]byte(s[index:i+1])) {
				res = append(res, s[index:i+1])
				//如果是回文串就向下递归
				dfs(i + 1)
				//删除一个字符串，重新递归
				res = res[:len(res)-1]
			}
		}
		return
	}

	dfs(0)

	return ans
}
```

## 排列问题

[46. 全排列](https://leetcode-cn.com/problems/permutations/)
```golang
func permuteUnique(nums []int) [][]int {
	//怎么这么多的大佬，通过率也太高了

	//元素数组为空，返回空结果
	if len(nums) == 0{
		return [][]int{}
	}
	//返回结果数组
	ans := [][]int{}
	//used用于判断递归的路径使用的哪些元素
	used := make(map[int]bool,len(nums))

	//暂存一次排列结果
	temp := []int{}

	//dfs函数进行回溯，index表示当前结果一维数组的大小，
	var dfs func(index int)

	dfs = func(index int) {
		//满足条件，组合结束，加入结果集
		if len(temp) == len(nums){
			ans = append(ans,append([]int(nil),temp...))
			return
		}

		for i:=0;i<len(nums);i++{
			_,ok:=used[nums[i]]
			//如果不在used里面就进行递归
			if !ok{
				used[nums[i]] = true
				temp = append(temp,nums[i])
				dfs(index+1)
				//回溯回来之后，重新选取，删除temp添加的元素
				temp = temp[:len(temp)-1]
				//删除used标记的元素
				delete(used,nums[i])
			}

		}
		return
	}

	dfs(0)
	return ans
}
```

[47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

```golang
func permuteUnique(nums []int) [][]int {
	if len(nums) == 0{
		return [][]int{}
	}
	//返回结果数组
	res := make([][]int,0)

	//结果暂存数组
	temp := make([]int,0)

	//标记元素是否使用
	used := make(map[int]bool)

	//先对数组进行排序，方便剪枝
	sort.Ints(nums)

	//回溯递归函数
	var dfs func(index int)

	dfs = func(index int){
		//递归终止
		if index == len(nums){
			res = append(res,append([]int(nil),temp...))
			return
		}

		//选取路径
		for i:=0;i<len(nums);i++{
			//需要剪枝的情况，
			if used[i]{
				continue
			}
			if i > 0 && !used[i-1] && nums[i-1] == nums[i]{
				continue
			}
			//标记已使用
			used[i] = true
			//加入暂存组合结果
			temp = append(temp,nums[i])
			//递归
			dfs(index+1)
			//释放标记
			used[i] = false
			temp = temp[:len(temp)-1]
		}
	}

	dfs(0)

	fmt.Println(res)
	return res
}
```

