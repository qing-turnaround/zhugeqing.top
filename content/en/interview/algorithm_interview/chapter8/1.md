---
date: 2020-12-12T12:00:56+09:00
description: "å¦‚æœè¯´æ•°å­¦æ˜¯çš‡å† ä¸Šçš„ä¸€é¢—æ˜ç ï¼Œé‚£ä¹ˆç®—æ³•å°±æ˜¯è¿™é¢—æ˜ç ä¸Šçš„å…‰èŠ’ï¼Œç®—æ³•è®©è¿™é¢—æ˜ç æ›´åŠ ç† ç† ç”Ÿè¾‰ï¼Œä¸ºç§‘æŠ€è¿›æ­¥å’Œç¤¾ä¼šå‘å±•ç…§äº®äº†å‰è¿›çš„è·¯"
image: "images/recommend_site/xingyouji.jpg"
title: "ç¬¬å…«ç« ç¬¬ä¸€èŠ‚"
author: è¯¸è‘›é’
authorEmoji: ğŸ…
pinned: false
tags:
- ç®—æ³•
series:
-   
---

## æ ‘å‹é—®é¢˜

[17. ç”µè¯å·ç çš„å­—æ¯ç»„åˆ](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)
```golang
func letterCombinations(digits string) []string {
        if digits == ""{
            return []string{}
        }

    	hash := map[byte][]byte{
		'0' : []byte{' '},
		'1' : []byte{' '},
		'2' : []byte{'a','b','c'},
		'3' : []byte{'d','e','f'},
		'4' : []byte{'g','h','i'},
		'5' : []byte{'j','k','l'},
		'6' : []byte{'m','n','o'},
		'7' : []byte{'p','q','r','s'},
		'8' : []byte{'t','u','v'},
		'9' : []byte{'w','x','y','z'},
    }

    //è¿”å›æ•°ç»„
    res := make([]string,0)

    var findCombinations func(digits []byte,index int,s []byte)

    findCombinations = func(digits []byte,index int,s []byte){
        if index == len(digits){
            res = append(res,string(s))
            return //é€’å½’ç»ˆæ­¢æ¡ä»¶
        }

        //é€’å½’
        for i:=0;i<len(hash[digits[index]]);i++{
            findCombinations(digits,index+1,append(s,hash[digits[index]][i]))
        }
    }

    findCombinations([]byte(digits),0,[]byte{})

    return res
}
```

## é€’å½’è°ƒç”¨ä¸€ä¸ªé‡è¦çš„ç‰¹å¾ï¼šå›æº¯

[93. å¤åŸ IP åœ°å€](https://leetcode-cn.com/problems/restore-ip-addresses/)
```golang
func restoreIpAddresses(s string) []string {
    //å›æº¯æ˜¯æš´åŠ›è§£æ³•çš„ä¸€ä¸ªä¸»è¦æ‰‹æ®µ
    //ä¸€ä¸ªipåœ°å€ä¸€å…±æœ‰4ä¸ªæ®µ
    //è¿”å›ç­”æ¡ˆ
    ans := make([]string,0)
    //æ¯ä¸€æ®µçš„æ•°å­—segment[i]
    segmentIp := make([]int,4)

    //dfså‡½æ•°çš„å«ä¹‰ï¼šå°†sæ‹†åˆ†ä¸ºä¸€ä¸ªåˆæ³•çš„ipåœ°å€
    //segmentè¡¨ç¤ºå½“å‰dfså‡½æ•°éœ€è¦ç¡®å®šçš„æ˜¯ç¬¬å‡ æ®µipåœ°å€,startIpåˆ™è¡¨ç¤ºåœ¨så­—ç¬¦ä¸²ä¸­çš„ä¸‹æ ‡
    var dfs func(segment ,startIp int)

    dfs = func(segment,startIp int){
        //é€’å½’ç»ˆæ­¢æ¡ä»¶
        //å·²ç»åŒ…å«4æ®µï¼ŒåŠ å…¥ç»“æœé›†
        if segment == 4{
            //åªæœ‰é•¿åº¦ç¬¦åˆè¦æ±‚æ‰èƒ½åŠ å…¥ç»“æœé›†
            if startIp == len(s){
                subStr := ""
                for i:=0;i<segment;i++{
                    subStr += strconv.Itoa(segmentIp[i])
                    if i!= 3{
                        subStr += "."
                    }    
                }
                ans = append(ans,subStr)
            }
            return
        }


        if startIp == len(s){
            //æå‰å›æº¯
            return
        }


        //ä¸èƒ½å«æœ‰å‰å¯¼0
        if s[startIp] == '0'{
            //ç›´æ¥æŠŠè¿™ä¸€æ®µçš„å€¼ç½®ä¸º0
            segmentIp[segment] = 0
            //æ®µå·åŠ ä¸€ï¼Œä¸‹æ ‡ä¹ŸåŠ ä¸€ï¼Œç»§ç»­é€’å½’
            dfs(segment+1,startIp+1)
        }

        val := 0
        for endIp:=startIp;endIp<len(s);endIp++{
            //é€‰å–æ•°å­—è¿›è¡Œé€’å½’
            val = val*10 + int(s[endIp]-'0')
            if val > 0 && val <= 0xff{
                segmentIp[segment] = val
                dfs(segment+1,endIp+1)
            }else{
                break
            }
        }

        return
    }

    dfs(0,0)

    return ans
}
```

[131. åˆ†å‰²å›æ–‡ä¸²](https://leetcode-cn.com/problems/palindrome-partitioning/)
```golang
//åˆ¤æ–­æ˜¯å¦æ˜¯å›æ–‡å­ä¸²
func isVaild(s []byte)bool{
	length := len(s)
	for i:=0;i<length/2;i++{
		if s[i] != s[length-i-1]{
			return false
		}
	}

	return true
}


func partition(s string) [][]string {
	//å›æº¯è§£æ³•
	//è¿”å›æ•°ç»„
	ans := make([][]string,0)
	res := []string{}
	var dfs func(index int)
	//dfså‡½æ•°çš„æ„ä¹‰æ˜¯ä¸ºäº†æ‹†åˆ†å­—ç¬¦ä¸²ï¼Œä½¿å¾—æ˜¯å›æ–‡å­ä¸²
	dfs = func(index int){
		//é€’å½’ç»ˆæ­¢æ¡ä»¶ï¼ˆè¿›è¡Œå›æº¯ï¼‰
		if index == len(s){
            // append([]string(nil), res...)æ˜¯ä¸ºäº†éš”ç¦»ans[i]ä¸resçš„å…³ç³»
			ans = append(ans,append([]string(nil), res...))
			return
		}

		//å­ä¸²ï¼ˆ0...len(s)-1ï¼‰
		for i:=index;i<len(s);i++{
			//å¦‚æœæ˜¯å›æ–‡ä¸²å°±å‘ä¸‹é€’å½’
			if isVaild([]byte(s[index:i+1])) {
				res = append(res, s[index:i+1])
				//å¦‚æœæ˜¯å›æ–‡ä¸²å°±å‘ä¸‹é€’å½’
				dfs(i + 1)
				//åˆ é™¤ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œé‡æ–°é€’å½’
				res = res[:len(res)-1]
			}
		}
		return
	}

	dfs(0)

	return ans
}
```

## æ’åˆ—é—®é¢˜

[46. å…¨æ’åˆ—](https://leetcode-cn.com/problems/permutations/)
```golang
func permuteUnique(nums []int) [][]int {
	//æ€ä¹ˆè¿™ä¹ˆå¤šçš„å¤§ä½¬ï¼Œé€šè¿‡ç‡ä¹Ÿå¤ªé«˜äº†

	//å…ƒç´ æ•°ç»„ä¸ºç©ºï¼Œè¿”å›ç©ºç»“æœ
	if len(nums) == 0{
		return [][]int{}
	}
	//è¿”å›ç»“æœæ•°ç»„
	ans := [][]int{}
	//usedç”¨äºåˆ¤æ–­é€’å½’çš„è·¯å¾„ä½¿ç”¨çš„å“ªäº›å…ƒç´ 
	used := make(map[int]bool,len(nums))

	//æš‚å­˜ä¸€æ¬¡æ’åˆ—ç»“æœ
	temp := []int{}

	//dfså‡½æ•°è¿›è¡Œå›æº¯ï¼Œindexè¡¨ç¤ºå½“å‰ç»“æœä¸€ç»´æ•°ç»„çš„å¤§å°ï¼Œ
	var dfs func(index int)

	dfs = func(index int) {
		//æ»¡è¶³æ¡ä»¶ï¼Œç»„åˆç»“æŸï¼ŒåŠ å…¥ç»“æœé›†
		if len(temp) == len(nums){
			ans = append(ans,append([]int(nil),temp...))
			return
		}

		for i:=0;i<len(nums);i++{
			_,ok:=used[nums[i]]
			//å¦‚æœä¸åœ¨usedé‡Œé¢å°±è¿›è¡Œé€’å½’
			if !ok{
				used[nums[i]] = true
				temp = append(temp,nums[i])
				dfs(index+1)
				//å›æº¯å›æ¥ä¹‹åï¼Œé‡æ–°é€‰å–ï¼Œåˆ é™¤tempæ·»åŠ çš„å…ƒç´ 
				temp = temp[:len(temp)-1]
				//åˆ é™¤usedæ ‡è®°çš„å…ƒç´ 
				delete(used,nums[i])
			}

		}
		return
	}

	dfs(0)
	return ans
}
```

[47. å…¨æ’åˆ— II](https://leetcode-cn.com/problems/permutations-ii/)

```golang
func permuteUnique(nums []int) [][]int {
	if len(nums) == 0{
		return [][]int{}
	}
	//è¿”å›ç»“æœæ•°ç»„
	res := make([][]int,0)

	//ç»“æœæš‚å­˜æ•°ç»„
	temp := make([]int,0)

	//æ ‡è®°å…ƒç´ æ˜¯å¦ä½¿ç”¨
	used := make(map[int]bool)

	//å…ˆå¯¹æ•°ç»„è¿›è¡Œæ’åºï¼Œæ–¹ä¾¿å‰ªæ
	sort.Ints(nums)

	//å›æº¯é€’å½’å‡½æ•°
	var dfs func(index int)

	dfs = func(index int){
		//é€’å½’ç»ˆæ­¢
		if index == len(nums){
			res = append(res,append([]int(nil),temp...))
			return
		}

		//é€‰å–è·¯å¾„
		for i:=0;i<len(nums);i++{
			//éœ€è¦å‰ªæçš„æƒ…å†µï¼Œ
			if used[i]{
				continue
			}
			if i > 0 && !used[i-1] && nums[i-1] == nums[i]{
				continue
			}
			//æ ‡è®°å·²ä½¿ç”¨
			used[i] = true
			//åŠ å…¥æš‚å­˜ç»„åˆç»“æœ
			temp = append(temp,nums[i])
			//é€’å½’
			dfs(index+1)
			//é‡Šæ”¾æ ‡è®°
			used[i] = false
			temp = temp[:len(temp)-1]
		}
	}

	dfs(0)

	fmt.Println(res)
	return res
}
```

