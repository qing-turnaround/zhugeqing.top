---
date: 2020-12-12T12:00:56+09:00
description: "å¦‚æœè¯´æ•°å­¦æ˜¯çš‡å† ä¸Šçš„ä¸€é¢—æ˜ç ï¼Œé‚£ä¹ˆç®—æ³•å°±æ˜¯è¿™é¢—æ˜ç ä¸Šçš„å…‰èŠ’ï¼Œç®—æ³•è®©è¿™é¢—æ˜ç æ›´åŠ ç† ç† ç”Ÿè¾‰ï¼Œä¸ºç§‘æŠ€è¿›æ­¥å’Œç¤¾ä¼šå‘å±•ç…§äº®äº†å‰è¿›çš„è·¯"
image: "images/recommend_site/xingyouji.jpg"
title: "ç¬¬å…«ç« ç¬¬å››èŠ‚â€”â€”floodfill"
author: è¯¸è‘›é’
authorEmoji: ğŸ…
pinned: false
tags:
- ç®—æ³•
series:
-   
---

## floodfillç®—æ³•

[79. å•è¯æœç´¢](https://leetcode-cn.com/problems/word-search/)
```golang
func exist(board [][]byte, word string) bool {
   m,n := len(board), len(board[0])
   for i := 0; i < m; i++ {//è¡ŒèŒƒå›´
       for j := 0; j < n; j++ {//åˆ—èŒƒå›´
         //å¦‚æœåœ¨æ•°ç»„ä¸­æ‰¾å¾—åˆ°ç¬¬ä¸€ä¸ªæ•°ï¼Œå°±æ‰§è¡Œä¸‹ä¸€æ­¥ï¼Œå¦åˆ™è¿”å›false
         if search(board, i, j, 0,word) {
             //dsfæ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œä»ä¸€ä¸ªèµ·ç‚¹å¼€å§‹æœç´¢ï¼Œè‹¥æœç´¢åˆ°ï¼Œåˆ™è¿”å›trueï¼Œå¦åˆ™ï¼Œä¸‹ä¸€ä¸ªçŸ©é˜µå•å…ƒ
             return true
             }
        }
    }
    return false   
}
func search(board [][]byte, i,j,k int, word string) bool {
    //å¦‚æœæ‰¾åˆ°æœ€åä¸€ä¸ªæ•°ï¼Œåˆ™è¿”å›true,æœç´¢æˆåŠŸ
    if k == len(word) { //kè¡¨ç¤ºwordå½“å‰éå†ä¸‹æ ‡
        return true
    }
    //i,jçš„çº¦æŸæ¡ä»¶
    if i < 0 || j < 0 || i == len(board) || j == len(board[0]) {
        return false
    }

    //è¿›å…¥DFSæ·±åº¦ä¼˜å…ˆæœç´¢
    //å…ˆæŠŠæ­£åœ¨éå†çš„è¯¥å€¼é‡æ–°èµ‹å€¼ï¼Œå¦‚æœåœ¨è¯¥å€¼çš„å‘¨å›´éƒ½æœç´¢ä¸åˆ°ç›®æ ‡å­—ç¬¦ï¼Œåˆ™å†æŠŠè¯¥å€¼è¿˜åŸ
        //å¦‚æœåœ¨æ•°ç»„ä¸­æ‰¾åˆ°ç¬¬ä¸€ä¸ªå­—ç¬¦ï¼Œåˆ™è¿›å…¥ä¸‹ä¸€ä¸ªå­—ç¬¦çš„æŸ¥æ‰¾
    if board[i][j] == word[k] {
        temp := board[i][j]
        board[i][j] = ' '
        //ä¸‹é¢è¿™ä¸ªifè¯­å¥ï¼Œå¦‚æœæˆåŠŸè¿›å…¥ï¼Œè¯´æ˜æ‰¾åˆ°è¯¥å­—ç¬¦ï¼Œç„¶åè¿›è¡Œä¸‹ä¸€ä¸ªå­—ç¬¦çš„æœç´¢,ç›´åˆ°æ‰€æœ‰çš„æœç´¢éƒ½æˆåŠŸï¼Œ
        //å³k == len(word) - 1 çš„å¤§å°æ—¶ï¼Œä¼šè¿”å›trueï¼Œè¿›å…¥è¯¥æ¡ä»¶è¯­å¥ï¼Œç„¶åè¿”å›å‡½æ•°trueå€¼ã€‚
        if search(board, i, j + 1, k + 1, word) || //å‘ä¸‹æœç´¢
        search(board, i, j - 1, k + 1, word) ||    //å‘ä¸Šæœç´¢
        search(board, i + 1, j, k + 1, word) ||    //å‘å³æœç´¢
        search(board, i - 1, j, k + 1, word)  {    //å‘å·¦æœç´¢
            return true
        }else {
        //æ²¡æœ‰æ‰¾åˆ°ç›®æ ‡å­—ç¬¦ï¼Œè¿˜åŸä¹‹å‰é‡æ–°èµ‹å€¼çš„board[i][j]
            board[i][j] = temp
        }
    }

  
    return false
}
```

[200. å²›å±¿æ•°é‡](https://leetcode-cn.com/problems/number-of-islands/)
```golang
func numIslands(grid [][]byte) int {
	//åˆå§‹åŒ–ä¸€ä¸ªäºŒç»´æ•°ç»„ï¼Œç”¨æ¥æ ‡è®°è¯¥åœ°åŒºæ˜¯å¦å·²ç»è¢«è®¿é—®è¿‡
	used := make([][]bool,len(grid))
	for i:=0;i<len(grid);i++{
		used[i] = make([]bool,len(grid[i]))
	}
	//äºŒç»´æ•°ç»„çš„è¡Œæ•°å’Œåˆ—æ•°
	m,n:=len(grid),len(grid[0])

    var notInArea func(x,y int)bool

    notInArea = func(x,y int)bool{
        return x < 0 || x >= m || y < 0 || y >= n
    }


	var dfs func(startx,starty int)bool

	dfs = func(startx, starty int) bool {
		//è¶Šç•Œï¼Œç›´æ¥è¿”å›false
		if notInArea(startx,starty){
			return false
		}
		//è¯´æ˜æ˜¯æµ·æ´‹ï¼Œç›´æ¥è¿”å›
		if grid[startx][starty] == '0' || used[startx][starty]{
			return false
		}



		used[startx][starty] = true
		//å‘ä¸Šå³ä¸‹å·¦å››ä¸ªæ–¹å‘æ ‡è®°é™†åœ°
		dfs(startx+1,starty)
		dfs(startx,starty+1)
		dfs(startx-1,starty)
		dfs(startx,starty-1)

		return true
	}
	//è¿”å›æ•°ï¼Œå²›å±¿çš„æ•°é‡
	ans := 0

	//ä»ä¸åŒçš„åœ°æ–¹å¼€å§‹å‡ºå‘
	for i:=0;i<m;i++{
		for j:=0;j<n;j++{
			//å¦‚æœè¯¥ä½ç½®å·²ç»è¢«ä½¿ç”¨è¿‡ï¼Œç›´æ¥è·³è¿‡æœ¬æ¬¡å¾ªç¯
			if used[i][j]{
				continue
			}

			if grid[i][j] != '0' && dfs(i,j){
				//æ‰¾åˆ°ä¸€ä¸ªæ–°å²›å±¿ï¼ŒansåŠ ä¸€
				ans++
			}

		}
	}
	//è¿”å›æ‰¾åˆ°çš„å²›å±¿æ•°é‡
	return ans
}
```

[130. è¢«å›´ç»•çš„åŒºåŸŸ](https://leetcode-cn.com/problems/surrounded-regions/)
```golang
func solve(board [][]byte)  {
    //é‡‡ç”¨floodfillç®—æ³•
    //å‡†å¤‡è¿›è¡Œæ´ªæ°´æ”»å‡»å§
    //æˆ‘ä»¬çš„ç›®çš„æ˜¯æŠŠè¢«XåŒ…å›´çš„Oå˜æˆOï¼Œä½†æ˜¯å‘¨å›´æœ‰ä¸€äº›æ£è›‹é¬¼Oæ²¡æœ‰è¢«XåŒ…å›´ï¼Œæˆ‘å°±ä»ä»–ä»¬å¼€å§‹è¿›è¡Œfloodfillï¼ŒæŠŠä»–ä»¬å…¨éƒ¨å˜æˆ'Y'å­—ç¬¦ï¼Œæœ€åå†æ‰«æåŒºåŸŸï¼ŒæŠŠè¢«XåŒ…å›´çš„å¥½å­©å­'O'åŠ å…¥Xçš„ä¸€è¾¹ï¼ŒæŠŠæ£è›‹é¬¼Yå†å˜æˆO

    //è¡¨ç¤ºçŸ©é˜µçš„è¡Œåˆ—æ•°
    m,n := len(board),len(board[0])
    var notInArea func(x,y int)bool

    notInArea = func(x,y int)bool{
        return x < 0 || x >= m || y < 0 || y >= n 
    }

    //è¿›è¡Œæ´ªæ°´æ”»å‡»çš„å‡½æ•°
    var dfs func(startx,starty int)

    dfs = func(startx,starty int){
        //å¦‚æœè¶Šç•Œæˆ–è€…è¯¥å­—ç¬¦ä¸æ˜¯'O'ï¼Œå°±ä¸ç”¨æ”»å‡»äº†ï¼Œç›´æ¥è¿”å›
        if notInArea(startx,starty) || board[startx][starty] != 'O'{
            return
        }         

        //å¦‚æœæ˜¯'O'è¿™ä¸ªæ£è›‹é¬¼å°±æŠŠä»–å˜æˆ'Y'
        board[startx][starty] = 'Y'
        //å‘å››å¤„è¿›è¡Œæ´ªæ°´æ”»å‡»
        //ä¸Šé¢
        dfs(startx-1,starty)
        //ä¸‹é¢
        dfs(startx+1,starty)
        //å·¦é¢
        dfs(startx,starty-1)
        //å³é¢
        dfs(startx,starty+1)
    }


    //å…ˆä»ä¸Šè¾¹å¼€å§‹è¿›è¡Œâ€œæ´ªæ°´æ”»å‡»â€ï¼ˆfloodfillï¼‰
    for i:=0;i<n;i++{
        dfs(0,i)
    }

    //ä»ä¸‹è¾¹å¼€å§‹è¿›è¡Œâ€œæ´ªæ°´æ”»å‡»â€ï¼ˆfloodfillï¼‰
    for i:=0;i<n;i++{
        dfs(m-1,i)
    }

    //å…ˆä»å·¦è¾¹å¼€å§‹è¿›è¡Œâ€œæ´ªæ°´æ”»å‡»â€ï¼ˆfloodfillï¼‰
    //ä¸‹é¢ä»1å¼€å§‹ï¼Œm-2ç»“å°¾åªæ˜¯å› ä¸ºè¿›è¡Œä¸Šä¸‹æ´ªæ°´æ”»å‡»çš„æ—¶å€™å·²ç»ä»åŒ…å«åœ¨å·¦è¾¹çš„ä¸¤ä¸ªåæ ‡å¼€å§‹äº†ï¼Œçœå»è¿™ä¸¤ä¸ªåæ ‡
    for i:=1;i<m-1;i++{
        dfs(i,0)
    }

    //å…ˆä»å³è¾¹å¼€å§‹è¿›è¡Œâ€œæ´ªæ°´æ”»å‡»â€ï¼ˆfloodfillï¼‰
    for i:=1;i<m-1;i++{
        dfs(i,n-1)
    }


    for i:=0;i<m;i++{
        for j:=0;j<n;j++{
            //æŠŠå¥½å­©å­'O'å˜æˆ'X'
            if board[i][j] == 'O'{
                board[i][j] = 'X'
            //æŠŠå·²ç»å˜æˆäº†'Y'çš„åå­©å­'O'å†å˜æˆ'O'
            }else if board[i][j] == 'Y'{
                board[i][j] = 'O'
            }
        }
    }

}
```

```golang
func pacificAtlantic(heights [][]int) [][]int {
	//ç»“æœè¿”å›æ•°ç»„
	res := make([][]int,0)
	//floodfill
	m,n := len(heights),len(heights[0])
	P := make([][]bool,m)
	A := make([][]bool,m)
	for i:=0;i<m;i++{
		P[i] = make([]bool,n)
		A[i] = make([]bool,n)
	}

	var notInArea func(x,y int)bool

	notInArea = func(x, y int)bool{
		return x < 0 || y < 0 || x >= m || y >= n
	}
	var dfs func(visited [][]bool,startx,starty int,numsSize int)

	dfs = func(visited [][]bool,startx, starty int,numsSize int) {
		if  notInArea(startx,starty) || visited[startx][starty] || heights[startx][starty] < numsSize{
			return
		}

		visited[startx][starty] = true

		if P[startx][starty] && A[startx][starty]{
			res = append(res,[]int{startx,starty})
		}

		dfs(visited,startx+1,starty,heights[startx][starty])
		dfs(visited,startx-1,starty,heights[startx][starty])
		dfs(visited,startx,starty+1,heights[startx][starty])
		dfs(visited,startx,starty-1,heights[startx][starty])

	}

    //ä¸Šä¸‹
	for i:=0;i<n;i++{
		dfs(P,0,i,math.MinInt64)
		dfs(A,m-1,i,math.MinInt64)
	}

    //å·¦å³
	for i:=0;i<m;i++{
		dfs(P,i,0,math.MinInt64)
		dfs(A,i,n-1,math.MinInt64)
	}

	return res
}
```