---
date: 2020-12-12T12:00:56+09:00
description: "å¦‚æœè¯´æ•°å­¦æ˜¯çš‡å† ä¸Šçš„ä¸€é¢—æ˜ç ï¼Œé‚£ä¹ˆç®—æ³•å°±æ˜¯è¿™é¢—æ˜ç ä¸Šçš„å…‰èŠ’ï¼Œç®—æ³•è®©è¿™é¢—æ˜ç æ›´åŠ ç† ç† ç”Ÿè¾‰ï¼Œä¸ºç§‘æŠ€è¿›æ­¥å’Œç¤¾ä¼šå‘å±•ç…§äº®äº†å‰è¿›çš„è·¯"
image: "images/recommend_site/xingyouji.jpg"
title: "ç¬¬äº”ç« ç¬¬äºŒèŠ‚"
author: è¯¸è‘›é’
authorEmoji: ğŸ…
pinned: false
tags:
- ç®—æ³•
series:
-   
---

[24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)
```golang
func swapPairs(head *ListNode) *ListNode {
    dummy := &ListNode{Next:head} //è™šæ‹ŸèŠ‚ç‚¹
    pre := dummy //éå†é“¾è¡¨

    for pre.Next != nil && pre.Next.Next != nil{
        node1 := pre.Next
        node2 := pre.Next.Next

        node1.Next = node2.Next
        node2.Next = node1
        pre.Next = node2

        pre = pre.Next.Next //å‰è¿›ä¸¤æ­¥ 
    }

    return dummy.Next
}
```
[25. K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)
```golang
func reverse(head *ListNode,k int){
    curr := head.Next
    for i:=0;i<k-1;i++{ //åªéœ€è¦ç§»åŠ¨k-1ä¸ªèŠ‚ç‚¹
        node := curr.Next

        curr.Next = node.Next
        node.Next = head.Next
        head.Next = node
    }
}


func reverseKGroup(head *ListNode, k int) *ListNode {
    if k == 1 || head == nil{ //k=1æ—¶ï¼Œä¸éœ€è¦äº¤æ¢
        return head
    }
	//ç©¿é’ˆå¼•çº¿
    dummy := &ListNode{Next:head} //è™šæ‹ŸèŠ‚ç‚¹
    pre := dummy //ç”¨äºéå†çš„èŠ‚ç‚¹
    for pre.Next != nil{
        i := 0
        curr := pre.Next 
        for i!=k && curr != nil{ //åˆ¤æ–­æ˜¯å¦æ»¡è¶³åè½¬æ¡ä»¶
            i++
            curr = curr.Next
        }
        if i != k{
            return dummy.Next //èŠ‚ç‚¹ä¸å¤Ÿç”¨ï¼Œç›´æ¥è¿”å›
        }else{
            reverse(pre,k) //ç¿»è½¬æ“ä½œ
            for i:=0;i<k;i++{ //preå‰è¿›kæ­¥
                pre = pre.Next
            }
        }

    }
    return dummy.Next //è¿”å›å¤´ç»“ç‚¹
}
```

[147. å¯¹é“¾è¡¨è¿›è¡Œæ’å…¥æ’åº](https://leetcode-cn.com/problems/insertion-sort-list/)

```golang
func insertionSortList(head *ListNode) *ListNode {
    if head == nil{
        return nil
    }
    dummy := &ListNode{Next:head} //è™šæ‹ŸèŠ‚ç‚¹
    
    lastSort,curr := head,head.Next//å·²æ’åºå®ŒæˆåŒºé—´çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹å’Œå½“å‰æ‰«æèŠ‚ç‚¹

    for curr != nil{
        if lastSort.Val <= curr.Val{//æ˜¯æœ‰åºçš„ï¼Œç›´æ¥å‰è¿›
            lastSort = lastSort.Next
        }else{ //ä¸æ˜¯æœ‰åºçš„ï¼Œä»åŒºé—´æœ€å¼€å§‹çš„åœ°æ–¹éå†
            pre := dummy

            for pre.Next.Val <= curr.Val{
                pre = pre.Next
            }
            //æ‰¾åˆ°æ¯”currèŠ‚ç‚¹å€¼å¤§çš„èŠ‚ç‚¹ï¼Œè¿›è¡Œäº¤æ¢
            lastSort.Next = curr.Next
            curr.Next = pre.Next
            pre.Next = curr

        }
        
        curr = lastSort.Next //currå‰è¿›
    }
    
    return dummy.Next
}
```

[148. æ’åºé“¾è¡¨](https://leetcode-cn.com/problems/sort-list/)
```golang
func merge(l1,l2 *ListNode)*ListNode{ //åˆå¹¶ä¸¤ä¸ªæœ‰åºåˆ—è¡¨
    dummy := &ListNode{}
    head := dummy

    for l1 != nil && l2 != nil{
        if l1.Val <= l2.Val{
            head.Next = l1
            l1 = l1.Next //l1æŒ‡é’ˆå¾€åç§»
        }else{
            head.Next = l2
            l2 = l2.Next //l2æŒ‡é’ˆå¾€åç§»
        }
        head = head.Next //éå†èŠ‚ç‚¹å¾€åç§»
    }

    //è¿æ¥å‰©ä½™èŠ‚ç‚¹ï¼ˆå¯èƒ½æ˜¯l1ï¼Œä¹Ÿå¯èƒ½æ˜¯l2ï¼‰
    if l1 != nil{
        head.Next = l1 
    }

    if l2 != nil{
        head.Next = l2
    }

    return dummy.Next
}

func sortList(head *ListNode) *ListNode {
    if head == nil{
        return head
    }
    //å½’å¹¶æ’åº
    //1.å…ˆå¾—å‡ºé“¾è¡¨çš„é•¿åº¦
    length := 0
    for curr := head;curr != nil;curr = curr.Next{
        length ++ //è®¡ç®—é“¾è¡¨çš„é•¿åº¦
    }

    //2.ä»¥é“¾è¡¨çš„é•¿åº¦ä¸ºæœ€å¤§å€¼ï¼Œä»é•¿åº¦ä¸º1çš„é“¾è¡¨åˆå¹¶é“¾è¡¨ï¼Œä¸æ–­è¿­ä»£
  
    dummy := &ListNode{Next:head}
    for subLength:=1;subLength<length;subLength *= 2 {
        curr := dummy.Next //æ¯ä¸€è½®åˆå¹¶çš„èµ·å§‹éå†èŠ‚ç‚¹
        pre := dummy 
        
        for curr != nil{
            head1 := curr //è®°å½•éœ€è¦åˆå¹¶çš„é“¾è¡¨çš„èµ·å§‹èŠ‚ç‚¹
            
            for i:=1;i<subLength && curr.Next!=nil;i++{
                curr = curr.Next //èŠ‚ç‚¹åç§»
            }

            head2 := curr.Next //ç¬¬äºŒä¸ªé“¾è¡¨çš„èµ·å§‹ä½ç½®
            curr.Next = nil //æ–­å¼€ç¬¬ä¸€ä¸ªé“¾è¡¨ä¸åé¢èŠ‚ç‚¹çš„è¿æ¥
            curr = head2 //æ‰¾å¯»ç¬¬äºŒä¸ªé“¾è¡¨çš„æœ«å°¾

            //å› ä¸ºè¿›è¡Œç¬¬ä¸€ä¸ªé“¾è¡¨çš„æœå¯»å¯èƒ½æœç´¢åˆ°currä¸ºnil,æ‰€ä»¥å¤šä¸€ä¸ªæ¡ä»¶åˆ¤æ–­
            for i:=1;i<subLength &&  curr != nil && curr.Next!=nil;i++{
                curr = curr.Next //èŠ‚ç‚¹åç§»
            }

            if curr != nil{
                temp := curr.Next //ä¿å­˜ä¸‹ä¸€æ¬¡åˆå¹¶çš„å¤´èŠ‚ç‚¹
                curr.Next = nil //æ–­å¼€ç¬¬äºŒé“¾è¡¨ä¸åé¢èŠ‚ç‚¹
                curr = temp //currç»§ç»­è¿›è¡Œæ‰¾å¯»åˆå¹¶çš„é“¾è¡¨
            }
            //ä¸‹é¢ä¸¤æ®µä»£ç éå¸¸é‡è¦ï¼Œä½¿ç”¨preæ¥è¿æ¥åˆå¹¶ä¹‹åçš„é“¾è¡¨
            pre.Next = merge(head1, head2)
            for pre.Next != nil{ 
                pre = pre.Next
            }
        } 

    }
    return dummy.Next
}
```

[61. æ—‹è½¬é“¾è¡¨](https://leetcode-cn.com/problems/rotate-list/)
```golang
func rotateRight(head *ListNode, k int) *ListNode {
    if k== 0 || head == nil || head.Next == nil{ 
        return head
    }
    //è§£æ³•ï¼ŒæŠŠè¿™ä¸ªé“¾è¡¨å½“æˆä¸€ä¸ªåœ†ç›˜é¤æ¡Œï¼Œä¸€ä¸ªä¸€ä¸ªä¼ é€’èœï¼Œä»é“¾è¡¨å€’æ•°ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å¼€å§‹ä¼ é€’...å€’æ•°ç¬¬äºŒä¸ª...ç¬¬ä¸€ä¸ªã€‚ä¸€å…±ä¼ é€’kæ¬¡ï¼Œåªéœ€è¦æ±‚æœ€åçš„èœä¼ åˆ°äº†å“ªé‡Œï¼Œå†æ–­å¼€é“¾è¡¨ä¸­è¿™ä¸ªäººçš„å‰ä¸€ä¸ªèŠ‚ç‚¹
    //ç”±äºæ˜¯åœ†ç›˜é¤æ¡Œï¼Œå½“k >= length(åœ†ç›˜é•¿åº¦)ï¼Œå¯ä»¥é‡‡å–å–æ¨¡å‡å°‘è¿ç®—
    //å‡å¦‚kä¸º3,lengthä¸º5,å¯ä»¥ç”¨length - kå¾—åˆ°æœ€ç»ˆé€åˆ°äº†äºŒå·èŠ‚ç‚¹
    dummy := &ListNode{Next:head} //è™šæ‹ŸèŠ‚ç‚¹
    curr := head
    length := 1 //é“¾è¡¨çš„é•¿åº¦
    //å…ˆå¼„ä¸€ä¸ªç¯å½¢é“¾è¡¨
    for curr.Next != nil{
        curr = curr.Next
        length++ //ç»Ÿè®¡é“¾è¡¨çš„é•¿åº¦
    }
    curr.Next = head //é¦–å°¾ç›¸è¿

    m := length - k%length //è™½ç„¶é“¾è¡¨æ–¹å‘å’Œé€èœæ–¹å‘æ˜¯ç›¸åçš„ï¼Œä½†å¯ä»¥é€šè¿‡length - k æ¥è®¡ç®—

    curr = dummy
    for i:=0;i<m;i++{
        curr = curr.Next 
    }

    temp := curr.Next
    curr.Next = nil //æ–­å¼€è¿æ¥


    return temp
}
```
*
[143. é‡æ’é“¾è¡¨](https://leetcode-cn.com/problems/reorder-list/)
```golang
func reverseList(head *ListNode) *ListNode {
    var prev, cur *ListNode = nil, head
    for cur != nil {
        nextTmp := cur.Next
        cur.Next = prev
        prev = cur
        cur = nextTmp
    }
    return prev
}

func mergeList(l1, l2 *ListNode) {
    var l1Tmp, l2Tmp *ListNode
    for l1 != nil && l2 != nil {
        l1Tmp = l1.Next
        l2Tmp = l2.Next

        l1.Next = l2
        l1 = l1Tmp

        l2.Next = l1
        l2 = l2Tmp
    }
}

func reorderList(head *ListNode) {
    if head == nil {
        return
    }
    slow, fast := head, head
    for fast.Next != nil && fast.Next.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }
    mid := slow
    l1 := head
    l2 := mid.Next
    mid.Next = nil
    l2 = reverseList(l2)
    mergeList(l1, l2)
}
```