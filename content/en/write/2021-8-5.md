---
date: 2021-08-04
description: "学习Golang字符串"
image: "images/recommend_site/xingyouji.jpg"
title: "Golang字符串"
author: 诸葛青
authorEmoji: 😃
pinned: false
tags:
- 
series:
-
---

## 字符集
<font color=MediumTurquoise>众所周知，变量都存在在计算机内存中，同时以二进制的形式存储， 比如int8类型的6在计算机中就应该是0000 0110，这很容易理解，因为这就是6的二进制形式，而加入是一个字符'a'呢，在没学到ASCII码集的时候，让你写出字符'a'的二进制形式你可能会相当懵。所以就诞生了字符集，通俗点讲，字符串就是用阿拉伯数字对字符进行编号，ASCII码集最初一共收录了128个字符，我们所常用的字母字符，数字字符，常用符号字符都包含于ASCII码集，直接上图吧</font>

![](/images/write/string1.png)

<font color=MediumTurquoise>而之后ASCII码字符集的扩展收录了256个字符，但是后面发现缺少汉字也不行，所以又出现了GB2312,而这也没有繁体字啊,随后又出现了BIG5，但是依然有许多字符没有被收录，比如日语，而后又有了GBK等等字符集，但最后本着全球统一化标准的的目的，Unicode字符集就诞生了，实现了跨语言，跨平台的文本转换和处理，字符集促成了字符与二进制的合作。</font>

<font color=MediumTurquoise>但是这并不代表这结束，来看另外一个问题，如何存储一个字符串，比如s := "hello世界"，那么它在如何以二进制形式存储于计算机中呢，可能你会想直接代入字符集的编号不就行了，这确实可以，但是，这一串二进制数应该如何划分呢？如果没有一个划分规则的话，可能你存储的和取出的不是一个字符串了，有一种方法叫定长编码，就是一个字符由n个字节组成，如果这个字符位数不够，那么就高位补零，这样假如这个字符串每一个字符都占2个字节，那么我们解码的时候就直接每2个字节做一个字符翻译，但是这有很大的不足，可能像汉字这样的一些字符需要2个字节，但是常用的字母只需要一个字节就能表示，所以显然定长编码造成了显著的浪费。那就换一种，使用不定长编码，小编号只占少字节，而高编号就占多字节，但这样同样需要一个划分规则，直接上图</font>

![](/images/write/string2.png)


<font color=MediumTurquoise>比如字符'e'的编码就是0110 0101（在区间[0,127]），而字符'世'的编码就是11100100        10111000  10010110  </font>

可以尝试运行下面代码
```golang
package main

import (
	"fmt"
)

func main() {
	s := "e世"

	for i := 0; i < len(s); i++ {
		fmt.Printf("%b\t", s[i])
	}

}
```
<font color=MediumTurquoise>而这个编码方式也就是go语言的默认编码方式UTF-8编码</font>

## 字符串类型的结构

<font color=MediumTurquoise>首先在内存中找到这个字符串得有一个起始地址，而对于结尾，内存非常大，无法得知这个字符串的结尾在哪里，对于C语言字符串采取的是在尾部放一个编号为0的字符'\0'，而go语言设计者并没有这样做，而是在放一个长度，这个长度指的是的字符串的字节个数，如下图</font>

![](/images/write/string3.png)

<font color=MediumTurquoise>go语言的字符串可以进行读，但是不能进行修改，所以go语言编译器会把定义的字符串分配的只读内存段。假如能够对字符串进行修改，那么如果有两个字符串变量同时指向了一个字符串，由于字符串变量是可以共用底层字符串内容的，通过其中一个变量对字符串进行修改，那么另个一个字符串变量同样被修改，这样的影响是不可预测的，所以要修改字符串变量就只能重新指向一个字符串</font>

<font color=VioletRed>记：持续行动的第三天！</font>