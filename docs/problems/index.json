[{"content":"关于Go的面试中，有一个经常被问到的问题   面试官：你知道Go语言切片是怎么样进行扩容的吗？\n  背完八股文且自信满满的小明：Go切片扩容分为两种情况\n 当新切片需要的容量cap大于两倍扩容的容量，则直接按照新切片需要的容量扩容； 当原 slice 容量 \u0026lt; 1024 的时候，新 slice 容量变成原来的 2 倍； 当原 slice 容量 \u0026gt; 1024，进入一个循环，每次容量变成原来的1.25倍,直到大于期望容量。    面试官：你确定Go语言 切片扩容都是这样的吗？\n  此时小明有点不太确定，经过思索过后，回答：我当前用的版本是Go 1.17，我看的源码的扩容策略是这样的。\n  面试官也没继续问，就此打住\n  第一个问题：Go切片扩容只跟 扩容策略有关吗？  让我们来看以下代码  1 2 3 4 5 6 7 8 9 10 11 12 13  package main import ( \u0026#34;fmt\u0026#34; ) func main() { s1 := make([]int, 2, 2) fmt.Println(len(s1), cap(s1)) // 2, 2  s1 = append(s1, 1, 2, 3) fmt.Println(len(s1), cap(s1)) // 5, ? }     在当s1进行扩容之后，它的cap为多少呢，如果是背过八股文的，肯定知道是5（当新切片需要的容量cap大于两倍扩容的容量，则直接按照新切片需要的容量扩容）\n  当我们实际运行后 会发现，答案是6，为什么？扩容源码是在逗我？\n  让我们再细看一下源码，当完成我们所说的八股文策略之后，后面还有一部分源码，\n  1 2  ...... capmem = roundupsize(uintptr(newcap))     当Go的runtime分配内存的时候，会调用roundupsize，取整内存值\n  我们需要的内存大小为 8 * 5，但是系统给我们分配了48字节，为什么？\n   int 类型占8字节，需要 5个int类型\n  看一下系统取整内存源码  1  var class_to_size = [_NumSizeClasses]uint16{0, 8, 16, 24, 32, 48, 64, 80, 96, 112, .......]     当我们需要40字节，系统从class_to_size找到 第一个大于等于40字节的数，那就是48\n  然后因为 48 / 8 = 6，所以扩容结果为6 而不是 5\n   48为系统分配的字节数，8为int类型在64位机器所占字节大小\n 第一个问题：Go语言的不同版本的 Slice扩容策略都是一样的   先给出答案，如果你使用的版本是Go 1.17以及之前版本，那么就是小明所背八股文 + 系统分配内存策略，但是如果你使用的版本是Go 1.18 以及当前最新版本（2023年3月19日的最新版本），那就有所不同\n  源码有真相，查看完整源码，点击此处\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  newcap := old.cap // 双倍容量 \tdoublecap := newcap + newcap if cap \u0026gt; doublecap { // 策略1：当需要的容量 大于 双倍原容量，直接使用 需要的容量 \tnewcap = cap } else { const threshold = 256 if old.cap \u0026lt; threshold { // 策略2：不符合策略1 并且当 原容量 小于 256时，直接使用双倍原容量 \tnewcap = doublecap } else { for 0 \u0026lt; newcap \u0026amp;\u0026amp; newcap \u0026lt; cap { // 策略3：当不符合策略1 且 原容量 大于等于 256时，每次原容量扩大1.25倍并加上 256 * (3/4)，直到大于等于 需要的容量  newcap += (newcap + 3*threshold) / 4 } // Set newcap to the requested cap when \t// the newcap calculation overflowed. \tif newcap \u0026lt;= 0 { newcap = cap } } }   总结：  不同的切片类型，扩容值可能是不同的，Go的runtime分配内存的时候，会调用roundupsize，取整内存值（第一个问题） 随着Go版本的迭代，扩容策略可能会有所改动的（第二个问题）  源码补充 Go 1.17扩容源码  此链接 的 162行的growslice函数  Go 1.18扩容源码  此链接的 166行的growslice函数  能分配多少内存大小源码  此链接的93行  ","description":"Go 切片扩容，你还在背八股文吗？","id":0,"section":"golang","tags":["Go"],"title":"Go 切片扩容","uri":"https://www.zhugeqing.top/golang/append/"},{"content":"对一个为nil的channel进行操作 1 2 3 4 5 6 7 8 9 10 11 12 13  package main import \u0026#34;fmt\u0026#34; func main() { var a chan int fmt.Println(a == nil) // true  // 进行一些读，写，关闭操作 \t// fmt.Println(\u0026lt;-a) // panic \t// a \u0026lt;- 1 // panic \t// close(a) // panic }   对一个关闭的channel进行操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14  package main import \u0026#34;fmt\u0026#34; func main() { a := make(chan int, 1) a \u0026lt;- 100 close(a) // 进行一些读，写，关闭操作 \tfmt.Println(\u0026lt;-a) // 100 \t// a \u0026lt;- 200 // panic \t// close(a) // panic }   对一个无缓冲的channel进行操作 1 2 3 4 5 6 7 8 9  package main func main() { a := make(chan int) // a \u0026lt;- 100 // 堵塞直到死锁，需要有其他goroutine来读 \t// fmt.Println(\u0026lt;-a) // 堵塞直到死锁，需要有其他goroutine来写 \tclose(a) }   ","description":"对nil、关闭的 channel、有数据的 channel，再进行读、写、关闭","id":1,"section":"golang","tags":["Go"],"title":"Go Channel question","uri":"https://www.zhugeqing.top/golang/chan-q3/"},{"content":"使用场景  就比如Windows的任务管理器，无法我们按下多少次快捷键，也只会有一个任务管理器窗口 也就是一个类，有且只能 创建出一个对象  分类  单例模式根据实例对象创建的时间 可以分为 饿汉模式 和 懒汉模式 饿汉模式重点在于饿，也就是它在程序运行的时候就会创建好对象，但可能很长时间也不会去使用这个对象，陷入一种饥饿的状态 懒汉模式重点在于懒，也就是只有当有人调用创建实例的方法的时候，才会创建对象，给人一种很懒的感觉，我不会主动去创建，得等人叫我去干才干。  C++实现 懒汉模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026#34;singleton.h\u0026#34;mutex Singleton::_mtx; Singleton* Singleton::This = nullptr; // 懒汉式 const Singleton* Singleton::getInstance() { // 双重检查  if(This == nullptr) { _mtx.lock(); // 此时还需要再次检测This是否为nullptr，否则会重复new对象  if(This == nullptr) { This = new Singleton; } _mtx.unlock(); } cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; This-\u0026gt;Print(); return This; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #pragma once #include \u0026lt;iostream\u0026gt;#include \u0026lt;mutex\u0026gt;using namespace std; class Singleton { public: static const Singleton* getInstance(); static void Print() { cout \u0026lt;\u0026lt; \u0026#34;This is Print()\u0026#34; \u0026lt;\u0026lt; endl; } static const int a = 100; private: Singleton(); virtual ~Singleton(); static Singleton* This; // 互斥锁（防止并发访问懒汉模式返回多个不同对象）  static mutex _mtx; };   1 2 3 4 5 6 7 8 9  // 测试单例函数 void SingletonTest() { const Singleton* s1 = Singleton::getInstance(); const Singleton* s2 = Singleton::getInstance(); s1-\u0026gt;Print(); s2-\u0026gt;Print(); cout \u0026lt;\u0026lt; (s1 == s2) \u0026lt;\u0026lt; endl; }   饿汉模式 1 2 3 4 5  Singleton* Singleton::This = new Singleton; // 饿汉式 const Singleton* Singleton::getInstance() { This-\u0026gt;Print(); return This; }   Go实现 懒汉模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) //Singleton 是单例模式类 type Singleton struct{ name string } var once sync.Once var singleton *Singleton // 懒汉模式 func (s Singleton)GetInstance() *Singleton { once.Do(func() { singleton = \u0026amp;Singleton{name: \u0026#34;singleton\u0026#34;} }) return singleton } func (s Singleton)Print() { fmt.Println(\u0026#34;I am \u0026#34;, s.name) } func main() { s1 := Singleton{}.GetInstance() s1.GetInstance() s2 := Singleton{}.GetInstance() s2.GetInstance() fmt.Println(s1 == s2) }   饿汉模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  package main import ( \u0026#34;fmt\u0026#34; ) //Singleton 是单例模式类 type Singleton struct{ name string } var singleton *Singleton = new(Singleton) // 饿汉模式 func (s Singleton)GetInstance() *Singleton { return singleton } func (s Singleton)Print() { fmt.Println(\u0026#34;I am \u0026#34;, s.name) } func main() { s1 := Singleton{}.GetInstance() s1.GetInstance() s2 := Singleton{}.GetInstance() s2.GetInstance() fmt.Println(s1 == s2) }   ","description":"设计模式之单例模式","id":2,"section":"designpattern","tags":["设计模式"],"title":"单例模式","uri":"https://www.zhugeqing.top/designpattern/singleton/"},{"content":"使用场景  观察者模式也可以被叫做发布——订阅模式，只要是场景的发布订阅场景就可以使用 举例：一个公司里有几个程序员喜欢在老板离开公司的摸鱼，但是如果被老板回来发现的话，那就完蛋了，所以这几个程序员决定跟前台的姐姐 打好关系，在老板回到公司之后，立马发送消息通知他们，这样这几个程序员就能在摸鱼 与 工作之间反复横跳。而这里的程序员就可以当做订阅者，前台当做发布者，当前台发布老板回来的消息的时候，程序员们就必须立即作出反应 简单的说，当一个对象的改变需要同时改变其他对象的时候，就可以使用观察者模式   来自《大话设计模式》中的观察者模式 故事，订阅者也是观察者；发布者也是通知者，或是主题\n 优缺点  优点：  观察者模式满足“开-闭原则”。主题接口仅仅依赖于观察者接口，而观察者具体是什么，可以自行实现 耦合的双方都依赖与抽象，而不是依赖具体的实现   缺点：  如果通知的观察者较多，将会耗费不少时间 如果观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩    C++实现 抽象发布者接口 1 2 3 4 5 6 7 8 9 10 11 12  #pragma once #include \u0026lt;string\u0026gt;#include \u0026#34;Observer.h\u0026#34; // 抽象发布者——通知者（抽象主题） class Subject { public: virtual void Attach(Observer * observer) = 0; // 注册订阅者  virtual void Detach(Observer * observer) = 0; // 注销订阅者  virtual void Notify(string) = 0; // 通知订阅者 private: };   具体发布者——前台 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  #pragma once #include \u0026lt;list\u0026gt;#include \u0026#34;Observer.h\u0026#34;#include \u0026#34;IObject.h\u0026#34;using namespace std; // 具体发布者——比如前台 class ConcreteSubject: public IObject{ public: // 注册订阅者  void Attach(Observer* observer) { observers.push_back(observer); } // 注销订阅者  void Detach(Observer* observer) { observers.remove(observer); } // 通知订阅者(一次性通知所有)  void Notify(string event) { for(auto it : observers) { it-\u0026gt;Update(event); } } private: list\u0026lt;Observer *\u0026gt; observers; };   抽象订阅者(抽象观察者) 1 2 3 4 5 6 7 8 9  #pragma once #include \u0026lt;string\u0026gt;using namespace std; // 抽象类观察者 class Observer { public: virtual void Update(string) = 0; // 收到通知，做出行动  };   具体订阅者——程序员 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  #pragma once #include \u0026lt;string\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026#34;Observer.h\u0026#34;#include \u0026#34;ConcreteSubject.h\u0026#34;using namespace std; // 具体观察者——可以根据不同的岗位处理，比如这里是程序员，还可以是产品经理 class Programmer: public Observer { public: Programmer(string \u0026amp;name, Subject * mySubject) : my_name(name), my_subject(mySubject) {} void Update(string event) override { my_event = event; cout \u0026lt;\u0026lt; my_name \u0026lt;\u0026lt; \u0026#34;收到前台通知：\u0026#34; \u0026lt;\u0026lt; my_event \u0026lt;\u0026lt; endl; } private: string my_name; // 观察者名字  string my_event; // 观察者当前收到通知  Subject* my_subject; // 订阅的主题，或者是 关联的 发布者 };   具体订阅者——产品经理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #pragma once #include \u0026lt;string\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026#34;Observer.h\u0026#34;#include \u0026#34;Subject.h\u0026#34; using namespace std; // 具体观察者——可以根据不同的岗位处理，比如这里是程序员，还可以是产品经理 class ProductManager: public Observer { // 产品经理 public: ProductManager(string \u0026amp;name, Subject* mySubject) : my_name(name), my_subject(mySubject) {} void Update(string event) override { my_event = event; cout \u0026lt;\u0026lt; my_name \u0026lt;\u0026lt; \u0026#34;收到前台通知：\u0026#34; \u0026lt;\u0026lt; my_event \u0026lt;\u0026lt; endl; } private: string my_name; // 观察者名字  string my_event; // 观察者当前收到通知  Subject* my_subject; // 订阅的主题，或者是 关联的 发布者 };   客户端执行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  #include \u0026#34;ConcreteSubject.h\u0026#34;#include \u0026#34;Programmer.h\u0026#34;#include \u0026#34;ProductManager.h\u0026#34;int main() { // 创建一个主题（通知者），前台  auto subject = new ConcreteSubject(); string name1 = \u0026#34;麦当\u0026#34;; string name2 = \u0026#34;咕咚\u0026#34;; string name3 = \u0026#34;笛亚\u0026#34;; // 程序员  auto* ob1 = new Programmer(name1, subject); // 程序员——观察者  auto* ob2 = new Programmer(name2, subject); // 产品经理  auto* ob3 = new ProductManager(name3, subject); // 观察者1 订阅 主题  subject-\u0026gt;Attach(ob1); // 观察者2 订阅 主题  subject-\u0026gt;Attach(ob2); // 观察者3 订阅 主题  subject-\u0026gt;Attach(ob3); // 通知程序员  subject-\u0026gt;Notify(\u0026#34;老板走了，开始追求自由吧！\u0026#34;); // 通知者程序员  subject-\u0026gt;Notify(\u0026#34;老板回来了，赶紧开始工作\u0026#34;); // 注销：下班了，不需要前台来通知了  subject-\u0026gt;Detach(ob1); subject-\u0026gt;Detach(ob2); subject-\u0026gt;Detach(ob3); return 0; }   ","description":"设计模式之观察者模式","id":3,"section":"designpattern","tags":["设计模式"],"title":"观察者模式","uri":"https://www.zhugeqing.top/designpattern/observer/"},{"content":"为什么需要Helm  当我需要在kubernetes中部署一个应用时，往往需要多种对象，包括但不仅限于 ConfigMap，Secret，Pod，PriorityClass等。这样我们就需要编写多个yaml文件（或者是写入同一个yaml，但需要分隔），这会比较麻烦，而Heml将一个应用程序在kubernetes所需要的对象 都打包成一个 chart，我如果需要部署一个应用在kubernetes，就可以直接安装一个chart包，或者自己来进行编写。   https://helm.sh/docs/\n 概念  Chart：Chart 代表着 Helm 包。相当于 Yum RPM 在Kubernetes 中的等价物。 Repository： 是用来存放和共享 charts 的地方 release：运行在 Kubernetes 集群中的 chart 的实例（同一个chart可以安装多次）  编写一个简单的Chart  https://helm.sh/docs/chart_template_guide/getting_started/\n   我们可以直接使用heml create mychart来创建一个默认的chart（创建了一个目录），里面包含了一些初始化的默认文件\n  在 ./mychart/templates 目录下创建一个 configmap.yaml\n  1 2 3 4 5 6  apiVersion:v1kind:ConfigMapmetadata:name:mychart-configmapdata:today:\u0026#34;2022-09-20\u0026#34;  执行helm install mychart ./mychart 安装这个chart   使用kubectl get cm，查看这个configmap是否创建成功\n ","description":"实战 Helm的使用","id":4,"section":"after","tags":["k8s"],"title":"Helm的使用","uri":"https://www.zhugeqing.top/after/helm/"},{"content":"URL Search（通过URL query进行搜索） 基本了解 1 2 3 4  GET /movies/_search?q=2012\u0026amp;df=title\u0026amp;sort=year:desc\u0026amp;from=0\u0026amp;size=10 { \u0026#34;profile\u0026#34;: \u0026#34;true\u0026#34; }    q 指定查询语句，后面接Query String Syntax df指定查询的字段，不指定时，会对所有字段进行查询 Sort 排序，form 和 size用于分页 profile 查看查询是如何被执行的  指定字段和泛查询   指定字段：q=title:2012\n  泛查询：q=2012\n  Trem查询：q=(Happy Mind) （等效于Happy or Mind）\n  Phrase查询：q=\u0026ldquo;Happy Mind\u0026rdquo;（等效于Happy and Mind，并且要求顺序保持一致）\n  布尔操作\n AND (\u0026amp;\u0026amp;) OR (||) NOT (!)    分组\n   代表Must     代表Must_not   例子：q=title:(-Beautiful +Mind)    区间查询\n []是闭区间，{}是开区间 year:{2022 TO 2024} year:[* TO 2023]    通配符查询（占用内存大，不建议使用）\n ?代表一个字符，*代表0或多个字符 title:beautifu? title:be*    模糊匹配\n q=title:balck~2（解释：允许balck增删改2个字符得到最终匹配的单词）    近似度匹配\n q=title:\u0026ldquo;Happy Mind\u0026rdquo;~2 （解释：允许Happy 和 Mind中间相隔N个单词）    RequestBody  将查询语句 通过 HTTP Request Body发送给 Elasticsearch  Term Query 1 2 3 4 5 6 7 8  POST usres/_search { \u0026#34;query\u0026#34;: { \u0026#34;term\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;诸葛青\u0026#34; } } }   match Query 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  POST movies/_search { \u0026#34;sort\u0026#34;: [ { \u0026#34;year\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;desc\u0026#34; } } ], \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;title\u0026#34;: { \u0026#34;query\u0026#34;: \u0026#34;Beautiful Mind\u0026#34;, \u0026#34;operator\u0026#34;: \u0026#34;AND\u0026#34; } } } }   match_pharse Query 1 2 3 4 5 6 7 8 9 10 11  POST movies/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_phrase\u0026#34;: { \u0026#34;title\u0026#34;: { \u0026#34;query\u0026#34;: \u0026#34;Beautiful A\u0026#34;, \u0026#34;slop\u0026#34;: \u0026#34;3\u0026#34; } } } }   query_string 1 2 3 4 5 6 7 8 9  POST users/_search { \u0026#34;query\u0026#34;: { \u0026#34;query_string\u0026#34;: { \u0026#34;default_field\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;query\u0026#34;: \u0026#34;Ruan AND Yiming\u0026#34; } } }    类似URL query\n 学习感受  进一步学习   https://www.elastic.co/guide/en/elasticsearch/reference/current/full-text-queries.html\n  Elasticsearch提供了相当多查询，无法全部记住，只能学习常用的部分  ","description":"elasticsearch search api使用","id":5,"section":"es","tags":["elasticsearch"],"title":"elasticsearch search api使用","uri":"https://www.zhugeqing.top/es/search-api/"},{"content":" 参考：https://olivere.github.io/elastic/\n 初始化客户端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/olivere/elastic/v7\u0026#34; \u0026#34;log\u0026#34; ) var esUrl = \u0026#34;http://127.0.0.1:9200/\u0026#34; // es 地址  func main() { client, err := elastic.NewClient(elastic.SetSniff(false), elastic.SetURL(esUrl)) if err != nil { log.Fatalln(err) } ctx := context.Background() result, code, err := client.Ping(esUrl).Do(ctx) fmt.Println(result, code, err) }   document_api Post一个文档 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  func Post(client *elastic.Client) { user := User{Age: 20, Name: \u0026#34;zhugeqing\u0026#34;} // 不指定ID \t//res, err := client.Index().Index(user.GetIndexName()).BodyJson(user).Do(context.Background())  // 指定ID \tres, err := client.Index().Index(user.GetIndexName()).Id(\u0026#34;100\u0026#34;).BodyJson(user).Do(context.Background()) if err != nil { panic(err) } // 输出文档ID \tfmt.Println(res.Id) } type User struct { Age int `json:\u0026#34;age\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` } // GetIndexName: 获取索引名 func (u User) GetIndexName() string { return \u0026#34;users\u0026#34; }   Get一个文档 1 2 3 4 5 6 7 8  func Get(client *elastic.Client) { res, err := client.Get().Index(\u0026#34;users\u0026#34;).Id(\u0026#34;100\u0026#34;).Do(context.Background()) if err != nil { panic(err) } source, _ := res.Source.MarshalJSON() fmt.Println(string(source)) }   Delete一个文档 1 2 3 4 5 6 7  func Delete(client *elastic.Client) { deleteRes, err := client.Delete().Index(User{}.GetIndexName()).Id(\u0026#34;100\u0026#34;).Do(context.Background()) if err != nil { panic(err) } fmt.Println(deleteRes.Result) }   match查询  https://github.com/olivere/elastic/blob/release-branch.v7/search_queries_match_test.go\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  func Match(client *elastic.Client) { // 去 索引 users 中查询 name是zhugeqing的  indexName := \u0026#34;users\u0026#34; query := elastic.NewMatchQuery(\u0026#34;name\u0026#34;, \u0026#34;zhugeqing\u0026#34;) res, err := client.Search().Index(indexName).Query(query).Do(context.Background()) if err != nil { panic(err) } fmt.Println(res.Hits.TotalHits.Value) // 查看搜索数量 \tfor _, v := range res.Hits.Hits { // 查看搜索结果的hit \tfmt.Println(v.Id) // 查看文档Id  // 查看文档Source \tif json, err := v.Source.MarshalJSON(); err == nil { fmt.Println(string(json)) } else { panic(err) } } }   将Elasticsearch 文档数据转换为 go 结构体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  package main import ( \u0026#34;context\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/olivere/elastic/v7\u0026#34; ) type User struct { Age int `json:\u0026#34;age\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` } func ConvertToStruct(client *elastic.Client) { // 去 索引 users 中查询 name是zhugeqing的  indexName := \u0026#34;users\u0026#34; query := elastic.NewMatchQuery(\u0026#34;name\u0026#34;, \u0026#34;zhugeqing\u0026#34;) res, err := client.Search().Index(indexName).Query(query).Do(context.Background()) if err != nil { panic(err) } fmt.Println(res.Hits.TotalHits.Value) // 查看搜索数量 \tfor _, v := range res.Hits.Hits { // 查看搜索结果的hit \tuser := \u0026amp;User{} // 解析到结构体中 \tif err := json.Unmarshal(v.Source, user); err != nil { panic(err) } fmt.Println(\u0026#34;the user is\u0026#34;, user) } }   追踪es请求的发送 1 2 3 4 5 6 7 8 9 10 11  func TraceElastic() { logger := log.New(os.Stdout, \u0026#34;es-trace:\u0026#34;, log.LstdFlags) client, err := elastic.NewClient(elastic.SetURL(esUrl), elastic.SetSniff(false), elastic.SetTraceLog(logger)) if err != nil { panic(err) } // 保存数据到es中 \tUpdate(client) }   使用go语言 向es创建Mapping 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  // 商品索引 type Goods struct { Id int `json:\u0026#34;id\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` } func (Goods)getIndexName() string { return \u0026#34;goods\u0026#34; } const mapping = ` { \u0026#34;settings\u0026#34;:{ \u0026#34;number_of_shards\u0026#34;: 1, \u0026#34;number_of_replicas\u0026#34;: 0 }, \u0026#34;mappings\u0026#34;:{ \u0026#34;properties\u0026#34;:{ \u0026#34;name\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;:\u0026#34;ik_max_word\u0026#34; }, \u0026#34;id\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;integer\u0026#34; } } } } ` func CreateMapping(client *elastic.Client) { createIndexResult, err := client.CreateIndex(\u0026#34;goods\u0026#34;).BodyString(mapping).Do(context.Background()) if err != nil { panic(err) } fmt.Println(createIndexResult.Acknowledged) }   遇到的坑 无法连通docker中部署的elasticsearch  使用olivere/elastic时，连接es会将输入的网址转换成内网地址或者是docker中的IP地址，导致无法连接 可以设置elastic.SetSniff(false)  ","description":"go 语言操作Elasticsearch","id":6,"section":"es","tags":["elasticsearch"],"title":"go 语言操作Elasticsearch","uri":"https://www.zhugeqing.top/es/go-es/"},{"content":"Mapping是什么  Mapping 类似数据库的 schema的定义，可以用于  定义索引中的字段名称 定义字段的数据类型 字段，倒排索引的相关配置（比如分词）   Mapping 可以分为Dynamic Mapping（动态Mapping） 和 Explicit Mapping（显式Mapping）  Dynamic Mapping  在写入文档时候，如果索引不存在，会自动创建索引 Dynamic Mapping可以让我们不需要手动定义Mapping，Elasticsearch会自动推断出字段的类型 但是有时候类型的推断并不符号我们的预期，从而导致一些查询无法正常进行  类型的自动识别  字符串(JSON)  匹配日期格式，设置成Date 匹配数字，设置为float或者long 匹配字符串，设置为Text，并且增加keywork子字段   布尔值  匹配 boolean   浮点数  匹配 float   整数  匹配 long   对象  匹配 Object   数组  由数组中第一个非空数值的类型决定   空值  忽略    设置Mapping 的dynamic    设置的值 true false strict     文档是否能索引 Yes Yes No   字段是否能索引 Yes No No   mapping是否更新 YES No NO     当dynamic设置成 true 时，有新增字段的写入，Mapping也同时被更新（默认为true） 当dynamic设置成 false时，mapping不会被更新，新增字段的数据无法被索引，但是信息可以存在_source中（也就是可以被其他的字段查询到） 当dynamic设置为 strict时，文档写入失败 对于索引已经存在的字段，无法修改字段的定义，除非使用Reindex API 重建索引  显式Mapping 控制字段是否被索引 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  #设置 index 为 false PUT users { \u0026#34;mappings\u0026#34; : { \u0026#34;properties\u0026#34; : { \u0026#34;firstName\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;text\u0026#34; }, \u0026#34;lastName\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;text\u0026#34; }, \u0026#34;mobile\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;text\u0026#34;, \u0026#34;index\u0026#34;: false } } } } PUT users/_doc/1 { \u0026#34;firstName\u0026#34;: \u0026#34;qing\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;zhuge\u0026#34;, \u0026#34;mobile\u0026#34; : \u0026#34;123\u0026#34; } # 下面无法的mobile字段无法被search GET users/_search?q=mobile:123   copy_to 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  #设置 Copy to DELETE users PUT users { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;firstName\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;copy_to\u0026#34;: \u0026#34;fullName\u0026#34; }, \u0026#34;lastName\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;copy_to\u0026#34;: \u0026#34;fullName\u0026#34; } } } } # 增加一个文档 PUT users/_doc/1 { \u0026#34;firstName\u0026#34;:\u0026#34;qing\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;zhuge\u0026#34; } # 尝试使用copy_to fullName进行search GET users/_search?q=fullName:(zhuge qing)   设置默认的空值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  DELETE users PUT users { \u0026#34;mappings\u0026#34; : { \u0026#34;properties\u0026#34; : { \u0026#34;firstName\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;text\u0026#34; }, \u0026#34;lastName\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;text\u0026#34; }, \u0026#34;mobile\u0026#34; : { \u0026#34;type\u0026#34; : \u0026#34;keyword\u0026#34;, \u0026#34;null_value\u0026#34;: \u0026#34;1111\u0026#34; } } } } PUT users/_doc/1 { \u0026#34;firstName\u0026#34;: \u0026#34;qing\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;zhuge\u0026#34;, \u0026#34;mobile\u0026#34; : null } GET users/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;mobile\u0026#34;: \u0026#34;1111\u0026#34; } } }   数组类型  Elasticsearch不提供数组类型，任意字段，都可以包含多个相同类型的数值  实战 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  # 增加文档 PUT mapping_test/_doc/1 { \u0026#34;firstName\u0026#34;:\u0026#34;qing\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;zhuge\u0026#34;, \u0026#34;loginDate\u0026#34;:\u0026#34;2018-07-24\u0026#34; } # 查看索引的Mapping GET mapping_test/_mapping ## 修改索引 mapping 的 dynamic PUT dynamic_mapping_test/_mapping { \u0026#34;dynamic\u0026#34;: \u0026#34;false\u0026#34; }   ","description":"Elasticsearch Mapping 学习","id":7,"section":"es","tags":["elasticsearch"],"title":"Mapping 学习","uri":"https://www.zhugeqing.top/es/mapping/"},{"content":"简单了解  Analysis（文本分析）是将 全文本 转换程一系列单词的过程，也叫做分词 Analysis（分词）需要通过 Analyzer（分词器）来实现  可以使用Elasticsearch内置的分词器，也可以定制分词器   分词器主要由三部分组成  Character Filters 针对原始文本进行处理，比如去除HTML Tokenize 按照一定规则 切分为单词 Token Filter 将切分的单词进行加工，小写，删除 stopwords，增加同义词等等   ES内置的分词器  Standard Analyzer：默认的分词器，按词切分，小写处理 Simple Analyzer：按照非字母切分，非字母都会被去除，小写处理 WhiteSpace Analyzer：按照空格切分 Keyword Analyzer：不进行分词 pattern Analyzer：按照正则表达式进行分词    中文分词  选型，使用Ik分词器，地址：https://github.com/medcl/elasticsearch-analysis-ik\n IK 中 analyzer ik_max_word 和 ik_smart 什么区别   ik_max_word: 会将文本做最细粒度的拆分，比如会将“中华人民共和国国歌”拆分为“中华人民共和国,中华人民,中华,华人,人民共和国,人民,人,民,共和国,共和,和,国国,国歌”，会穷尽各种可能的组合，适合 Term Query\n  ik_smart: 会做最粗粒度的拆分，比如会将“中华人民共和国国歌”拆分为“中华人民共和国,国歌”，适合 Phrase Query\n  创建自己的IK词库   进入到/usr/share/elasticsearch/plugins/ik/config目录下（安装的IK目录下的config）\n  创建一个放自定义字典的目录mkdir my_dict\n  创建一个文件存放自定义的word，vi word.dic，写入一些word，比如：商品的全名，动漫名，总之是一些你能识别，但分词器难以识别的词\n  创建一个文件存放自定义的stop_word，vi stop_word.dic，写入一些stop_word，比如：的，地，是，呦\n  vi /usr/share/elasticsearch/plugins/ik/config/IKAnalyzer.cfg.xml 将自定义词典路径添加进去\n  重启容器，测试，分词是否包含词库定义的词\n  tips docker环境下的elasticsearch容器中文出现乱码  添加中文环境  1 2 3 4 5  yum install kde-l10n-Chinese -y yum install glibc-common -y localedef -c -f UTF-8 -i zh_CN zh_CN.utf8 echo \u0026#34;export LC_ALL=zh_CN.utf8\u0026#34; \u0026gt;\u0026gt; /etc/profile source /etc/profile   ","description":"Elasticsearch 分词 学习","id":8,"section":"es","tags":["elasticsearch"],"title":"分词 学习","uri":"https://www.zhugeqing.top/es/analyzer/"},{"content":"为什么学习Elasticsearch  Elasticsearchg高性能，容易使用，容易扩展 Elasticsearch可以作为分布式搜索引擎，还可以用于大数据近实时分析。  基本概念 文档  Elasticsearch 是面向文档的，文档是所有可搜索数据的最小单位  比如日志文件中的日志项 一个电影的具体信息 MP3的一首歌   文档被序列化程 JSON格式，保存到 Elasticsearch中 每个文档都有自己的 Unique ID  可以自己指定ID，也可以由Elasticsearch自动生成   文档中可以有一些元数据  _index：文档所属索引名 _type：文档所属类型名 _id：文档ID _source：文档的原始Json数据 _version：文档的版本 _score：文档的相应评分    索引  索引是文档的容器，是一类文档的结合  每一个索引多有自己的Mapping 和 Setting Mapping定义文档字段的类型 Setting定义不同数据的分布    倒排索引  正排索引是 从一个文档ID 找到 文档内存或单词 倒排索引是 从一个单词 找到文档的ID 倒排索引包含两个部分  单词词典：记录所有文档的单词，记录单词到倒排列表的关联关系 倒排列表：记录单词对应的文档集合，由倒排索引项组成  倒排索引项包括 文档ID，单词出现次数，单词在语句中的位置，单词的开始结束位置      常用API  put 用于指定ID的情况\n 增加一个文档  自动生成ID  1 2 3 4  post users/_doc { \u0026#34;user\u0026#34;: \u0026#34;zhugeqing\u0026#34; }    指定ID，如果ID存在就报错  1 2 3 4  put users/_doc/1?op_type=create { \u0026#34;user\u0026#34;: \u0026#34;elk\u0026#34; }   更新一个文档  直接更新（版本加1）  1 2 3 4  PUT users/_doc/1 { \u0026#34;user\u0026#34; : \u0026#34;elk\u0026#34; }   查看一个文档 1  GET users/_doc/1   删除一个文档 1  DELETE users/_doc/1   Bulk API 1 2 3 4 5 6 7 8  POST _bulk { \u0026#34;index\u0026#34; : { \u0026#34;_index\u0026#34; : \u0026#34;test\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34; } } { \u0026#34;field1\u0026#34; : \u0026#34;value1\u0026#34; } { \u0026#34;delete\u0026#34; : { \u0026#34;_index\u0026#34; : \u0026#34;test\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;2\u0026#34; } } { \u0026#34;create\u0026#34; : { \u0026#34;_index\u0026#34; : \u0026#34;test\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;3\u0026#34; } } { \u0026#34;field1\u0026#34; : \u0026#34;value3\u0026#34; } { \u0026#34;update\u0026#34; : {\u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;_index\u0026#34; : \u0026#34;test\u0026#34;} } { \u0026#34;doc\u0026#34; : {\u0026#34;field2\u0026#34; : \u0026#34;value2\u0026#34;} }    bulk API 支持在一次API调用中，对不同的索引进行不同的操作，支持（Index，Create，Update，Delete）\n单条操作失败，不会影响其他操作结果\n上例 第一个操作为 向 test索引 ID为1的文档 进行index，source为{ \u0026ldquo;field1\u0026rdquo; : \u0026ldquo;value1\u0026rdquo; }\n第二个操作为删除 test索引中ID为2的文档\n 批量读取(mget)  批量读取可以减少网络连接所产生的开销，提高性能\n 1 2 3 4 5 6 7 8 9 10 11 12 13  GET /_mget { \u0026#34;docs\u0026#34;: [ { \u0026#34;_index\u0026#34;: \u0026#34;users\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;1\u0026#34; }, { \u0026#34;_index\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;2\u0026#34; } ] }   批量查询(msearch) 1 2 3  POST /_msearch {\u0026#34;index\u0026#34;: \u0026#34;kibana_sample_data_ecommerce\u0026#34;} {\u0026#34;query\u0026#34;: {\u0026#34;match_all\u0026#34;: {}}, \u0026#34;size\u0026#34;: 1}   分词 ","description":"elasticsearch 初步使用","id":9,"section":"es","tags":["elasticsearch"],"title":"elasticsearch 初步使用","uri":"https://www.zhugeqing.top/es/quick-start/"},{"content":"为什么需要CRD  https://kubernetes.io/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/\n  虽然kubernetes为我们提供了非常多的Api对象，但是我们生产环境中总有一些特殊情况，而CRD就可以用于自定义api对象来应对这些“特殊情况”  声明CRD对象  实战的第一步：定义好需要的CRD对象\n  创建CRD对象的yaml文件  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  apiVersion:apiextensions.k8s.io/v1kind:CustomResourceDefinitionmetadata:# 名字必需与下面的 spec 字段匹配，并且格式为 \u0026#39;\u0026lt;名称的复数形式\u0026gt;.\u0026lt;组名\u0026gt;\u0026#39;name:networks.testcrd.k8s.iospec:# 组名称，用于 REST API: /apis/\u0026lt;组\u0026gt;/\u0026lt;版本\u0026gt;group:testcrd.k8s.io# 列举此 CustomResourceDefinition 所支持的版本versions:- name:v1# 每个版本都可以通过 served 标志来独立启用或禁止served:true# 其中一个且只有一个版本必需被标记为存储版本storage:trueschema:openAPIV3Schema:type:objectproperties:spec:type:objectproperties:cronSpec:type:stringimage:type:stringreplicas:type:integer# 可以是 Namespaced 或 Clusterscope:Namespacednames:# 名称的复数形式，用于 URL：/apis/\u0026lt;组\u0026gt;/\u0026lt;版本\u0026gt;/\u0026lt;名称的复数形式\u0026gt;plural:network# 名称的单数形式，作为命令行使用时和显示时的别名singular:network# kind 通常是单数形式的驼峰命名（CamelCased）形式。你的资源清单会使用这一形式。kind:Network# shortNames 允许你在命令行使用较短的字符串来匹配资源shortNames:- ct  编写CRD 控制器 实现main函数逻辑 ","description":"实战 k8s CRD开发","id":10,"section":"after","tags":["k8s"],"title":"k8s CRD","uri":"https://www.zhugeqing.top/after/crd/"},{"content":"RBAC是什么   RBAC(Role-Based Access control，基于角色的访问控制) 是一种基于角色（用户）来调节控制对资源的访问的方法。\n  RBAC中一种拥有四种顶级资源对象：Role，ClusterRole，RoleBinding，ClusterRoleBinding，与其他的APi资源一样，我们可以使用kubectl 或者 API调用来操作这些资源对象\n  role代表了一组权限的集合，这些定义的权限，都是许可的形式，并且范围是在一个命名空间中。如果想要定义一个集群级别的权限集合 就需要使用ClusterRole\n  roleBinding 表示 将 role 绑定到一个目标上，这个目标可以是User、Group、ServiceAccount。这样就可以给这些目标进行授权，roleBinding代表命名空间范围内的授权，ClusterRoleBinding为集群范围内授权\n  实战RBAC Role 1 2 3 4 5 6 7 8 9  apiVersion:rbac.authorization.k8s.io/v1kind:Rolemetadata:namespace:defaultname:role-testrules:- apiGroups:[\u0026#34;\u0026#34;]# API 组resources:[\u0026#34;pods\u0026#34;]# 资源类型verbs:[\u0026#34;get\u0026#34;,\u0026#34;watch\u0026#34;,\u0026#34;list\u0026#34;]# 能够对资源进行的操作  CLusterRole 1 2 3 4 5 6 7 8 9 10  apiVersion:rbac.authorization.k8s.io/v1kind:ClusterRolemetadata:# \u0026#34;namespace\u0026#34; 被忽略，因为 ClusterRoles 不受名字空间限制name:clusterrole-testrules:- apiGroups:[\u0026#34;\u0026#34;]# 在 HTTP 层面，用来访问 Secret 资源的名称为 \u0026#34;secrets\u0026#34;resources:[\u0026#34;secrets\u0026#34;]verbs:[\u0026#34;get\u0026#34;,\u0026#34;watch\u0026#34;,\u0026#34;list\u0026#34;]  RoleBinding 1    ","description":"实战 k8s RBAC鉴权和StorageClass","id":11,"section":"kubernetes","tags":["k8s"],"title":"k8s RBAC鉴权和StorageClass","uri":"https://www.zhugeqing.top/kubernetes/rbac/"},{"content":"kube-scheduler 调度流程  过滤：根据规则，将生成一个可以让Pod 调度的节点列表 打分：根据评分规则，将Pod调度到得分最高的节点   https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/kube-scheduler/#scheduling\n 调度器的高级特性  NodeName 和 NodeSelector，可以让Pod直接调度到设置的节点上 NodeAffinity：决定Pod部署在哪些主机上 PodAffinity：决定Pod和哪些已经在运行中的Pod部署在同一拓扑域 PodAntiAffinity：决定Pod‘不和’哪些已经在运行中的Pod部署在同一拓扑域  实战Nodename  编写yaml文件  1 2 3 4 5 6 7 8 9 10  apiVersion:v1kind:Podmetadata:name:nodename-testspec:containers:- name:nginximage:nginximagePullPolicy:IfNotPresentnodeName:node1   执行kubectl apply，然后可以修改nodeName，查看Pod是否每一次都调度到指定的节点\n  Nodename注意点：Nodename调度的优先级高于NodeSelector以及节点亲和性 和 非亲和性的规则\n   https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/#nodename\n 实战NodeSelector  https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/assign-pods-nodes/\n  给想要调度的节点打上label   kubectl label node node1 nodeselect=node1   key为nodeselect，value为node1\nkubectl get nodes node1 \u0026ndash;show-labels 用于查看节点对应的label\n 编写yaml文件  1 2 3 4 5 6 7 8 9 10 11  apiVersion:v1kind:Podmetadata:name:nodeselector-testspec:containers:- name:nginximage:nginximagePullPolicy:IfNotPresentnodeSelector:nodeselect:node1  执行kubectl apply，然后可以给其他node打上label，修改nodeSelector，查看Pod是否每一次都调度到对应label的节点  实战NodeAffinity  https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity\n   在有了nodeName和nodeSelector之后，我们可以将Pod调度到指定的节点或包含某种标签的节点上。而NodeAffinity的功能更加强大，它不仅能 按照‘硬性要求’只将Pod调度到含有特殊标签的节点上，它还能按照‘软性规则’将尝试将Pod调度到某中标签的节点上，如果没有这样的节点，调度器仍然可以调度该Pod\n  nodeAffinity可以这种两种规则，requiredDuringSchedulingIgnoredDuringExecution： 调度器只有在规则被满足的时候才能执行调度。此功能类似于 nodeSelector， 但其语法表达能力更强。\npreferredDuringSchedulingIgnoredDuringExecution： 调度器会尝试寻找满足对应规则的节点。如果找不到匹配的节点，调度器仍然会调度该 Pod。\n   IgnoredDuringExecution 意味着如果节点标签在 Kubernetes 调度 Pod 时发生了变更，Pod 仍将继续运行。\n  编写yaml文件并提前创建好标签   在node1上有标签zone=zoneA, node2上有标签zone=zoneB\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  apiVersion:v1kind:Podmetadata:name:nodeaffinityspec:containers:- name:nginximage:nginximagePullPolicy:IfNotPresentaffinity:nodeAffinity:requiredDuringSchedulingIgnoredDuringExecution:nodeSelectorTerms:- matchExpressions:- key:kubernetes.io/hostnameoperator:In# 匹配规则为 key必须要在node1或node2中values:- \u0026#34;node1\u0026#34;- \u0026#34;node2\u0026#34;preferredDuringSchedulingIgnoredDuringExecution:- weight:1# 权重为1preference:matchExpressions:# 匹配规则为zone 为zoneA- key:zoneoperator:Invalues:- \u0026#34;zoneA\u0026#34;- weight:2# 权重为2preference:matchExpressions:# 匹配规则为zone 为zoneA- key:zoneoperator:Invalues:- \u0026#34;zoneB\u0026#34;  执行kubectl apply，查看Pod 被调度到的节点为node2  注意事项   requiredDuringSchedulingIgnoredDuringExecution 是硬性要求，是必须要满足的条件，如果指定了多个与 nodeAffinity 类型关联的 nodeSelectorTerms， 只要其中一个 nodeSelectorTerms 满足的话，Pod 就可以被调度到节点上。\n  如果指定了多个与同一 nodeSelectorTerms 关联的 matchExpressions， 就必须要当 matchExpressions 都满足时 Pod 才可以被调度到节点上。\n  同时指定了 nodeSelector 和 nodeAffinity，两者 必须都要满足， 才能将 Pod 调度到候选节点上。\n  如果在NodeAffinity中同时设置了硬性要求 和 软性要求，就必须当硬性要求满足之一才能进行软性要求的策略\n  preferredDuringSchedulingIgnoredDuringExecution 亲和性类型可以设置weight，将所有满足匹配的weight值相加，总分越高，优先级也越高\n  实战Pod 间亲和性和反亲和性   对于Nodeaffinity是基于节点的label来实现亲和性，而这里使用到的PodAffinity和PodAntiAffinity是基于Pod的label来实现亲和性和反亲和性\n  PodAffinity 和 PodAntiAffinity 同样拥有requiredDuringSchedulingIgnoredDuringExecution\npreferredDuringSchedulingIgnoredDuringExecution两个类型\n  实战  创建对应的环境   在node1节点上拥有一个name为Pod1，lable含有name=pod1的Pod，且node1设置一个label：topologyX=node1（表示它属于topologyX这个拓扑域） 在node2节点上拥有一个name为Pod2，lable含有name=pod2的Pod，且node1设置一个label：topologyX=node2，topologyY=node2（表示它属于topologyX和topologyY这两个拓扑域）   设置label  1 2 3  kubectl label nodes node1 topologyX=node1 kubectl label nodes node2 topologyX=node2 kubectl label nodes node2 topologyY=node2   编写Pod1和Pod2 yaml文件  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  apiVersion:v1kind:Podmetadata:name:pod1labels:name:pod1spec:containers:- name:nginximage:nginximagePullPolicy:IfNotPresentnodeName:node1---apiVersion:v1kind:Podmetadata:name:pod2labels:name:pod2spec:containers:- name:nginximage:nginximagePullPolicy:IfNotPresentnodeName:node2  编写测试podAffinity的Pod文件  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  apiVersion:v1kind:Podmetadata:name:podaffinityspec:containers:- name:nginximage:nginximagePullPolicy:IfNotPresentaffinity:podAffinity:requiredDuringSchedulingIgnoredDuringExecution:- labelSelector:matchExpressions:- key:nameoperator:In# 匹配规则为 key必须要在pod1或pod2中values:- \u0026#34;pod1\u0026#34;- \u0026#34;pod2\u0026#34;topologyKey:\u0026#34;topologyX\u0026#34;podAntiAffinity:preferredDuringSchedulingIgnoredDuringExecution:- weight:100podAffinityTerm:labelSelector:matchExpressions:- key:nameoperator:Invalues:- \u0026#34;pod1\u0026#34;- \u0026#34;pod2\u0026#34;topologyKey:\u0026#34;topologyY\u0026#34;   依次执行，查看 podaffinity这个pod的调度结果，\n  分析结果，最终 podaffinity被调度到node1上，首先是先匹配podAffinity的\u0026rsquo;硬性要求'，他们都能匹配matchExpressions，而且都属于topologyX。\n然后就是匹配 podAntiAffinity的软性要求，由于Pod2不仅匹配了matchExpressions，而且也属于topologyY这一个拓扑域，所以Pod不能调度到node2上，最终选择node1\n  注意点  podAffinity 规范当前Pod应该调度到 ‘已经运行了某些规定Pod’上的node上，而podAntiAffinity就是规范当前Pod不应该调度到 ‘已经运行了某些规定Pod’上的node上  实战污点和容忍度  https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/taint-and-toleration/\n   对于Pod的亲和性和反亲和性，可以分别使用PodAffinity 和 PodAntiAffinity，而对于Node的亲和性，也可以使用nodeSelector或者NodeAffinity，那么Node的反亲和性是怎么来做呢？答案是：污点（taint）\n  当一个Node上有污点（taint），就表示它需要排斥某一类Pod，而如果Pod想调度到这个Node，就必须要设置一个容忍度，如果容忍度的规则 与 污点匹配的话，就可以调度到这Node。（就好比我们生活中，总有一些讨厌去的地方，但是我们都在尽量地容忍，比如有的不想去教室上课，但为了某种目的，我们最终还是要容忍着去上课）\n  简单实战  给Node加上污点  1 2 3 4  # 给node1打上一个 key1：value1键值对 且效果为NodeSchedule的污点 kubectl taint nodes node1 key1=value1:NoSchedule # 上同 kubectl taint nodes node2 key2=value2:NoSchedule   编写yaml文件  1 2 3 4 5 6 7 8 9 10 11 12 13 14  apiVersion:v1kind:Podmetadata:name:taint-podspec:containers:- name:nginximage:nginximagePullPolicy:IfNotPresenttolerations:- key:key1operator:Equalvalue:value1effect:NoSchedule  最终结果：Pod运行在了Pod1上，因为Pod无法容忍node2节点（没有针对node2设置tolerations）  注意事项   对于tolerations的operator可以使用两种，如果 operator 是 Exists （此时容忍度不能指定 value），key就需要存在；如果operator 是 Equal ，则它们的 value 应该相等\n  对于污点effect可以这种三种，NoSchedule：如果不能容忍污点，就不能调度到该node；perferNoSchedule：如果不能容忍污点，“尽量”不要调度到这个node，NoExcute：如果不能容忍污点，就无法在该node上运行，即使污点是在运行之后加的，也会将之前的pod进行驱逐。\n  operator 是 Exists，并且没有设置Key，就代表这个容忍度能容忍任何污点\n  如果effect为空，则代表可以匹配任何的effect\n  ","description":"实战 k8s Pod调度的高级特性","id":12,"section":"kubernetes","tags":["k8s"],"title":"k8s 调度器","uri":"https://www.zhugeqing.top/kubernetes/scheduler/"},{"content":"使用docker-compose安装ELK  编写docker-compose.yaml  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  # 声明版本version:\u0026#34;3\u0026#34;services:elasticsearch:image:zhugeqing/elasticsearch:7.9.3# 可以自行修改版本，不过ELK组件的版本都要一致ports:- \u0026#34;9200:9200\u0026#34;- \u0026#34;9300:9300\u0026#34;volumes:- ./elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearchs/config/elasticsearch.ymlenvironment:ES_JAVA_OPTS:\u0026#34;-Xmx256m -Xms256m\u0026#34;ELASTIC_PASSWORD:zhugeqingdiscovery.type:single-nodenetwork.publish_host:_eth0_logstash:image:zhugeqing/logstash:7.9.3ports:- \u0026#34;5044:5044\u0026#34;- \u0026#34;5000:5000\u0026#34;- \u0026#34;9600:9600\u0026#34;volumes:- ./logstash/config/logstash.yml:/usr/share/logstash/config/logstash.yml- ./logstash/pipeline/logstash.conf:/usr/share/logstash/pipeline/logstash.conf- ./logstash/movies.csv:/usr/share/logstash/movies.csvenvironment:LS_JAVA_OPTS:\u0026#34;-Xmx256m -Xms256m\u0026#34;kibana:image:zhugeqing/kibana:7.9.3ports:- \u0026#34;5601:5601\u0026#34;volumes:- ./kibana/config/kibana.yml:/usr/share/kibana/config/kibana.yml   在创建docker-compose.yaml所在的目录下，创建三个子目录：elasticsearch，kibana，logstash。\n  在elasticsearch目录下创建elasticsearch.yaml\n  1 2 3 4 5 6  cluster.name:\u0026#34;elasticsearch\u0026#34;network.host:0.0.0.0xpack.license.self_generated.type:trailxpack.security.enabled:truexpack.monitoring.collector.enabled:true  在kibana目录下创建kibana.yaml  1 2 3 4 5 6 7 8 9  ---server.name:kibanaserver.host:0.0.0.0elasticsearch.hosts:[\u0026#34;http://elasticsearch:9200\u0026#34;]monitoring.ui.container.elasticsearch.enabled:trueelasticsearch.username:elasticelasticsearch.password:zhugeqingi18n.locale:zh-CN# 设置中文插件  在logstash目录下创建config、pipeline目录；并在config下创建logstash.yaml，在pipeline下创建logstash.config  1 2 3 4 5 6 7  ---http.host:\u0026#34;0.0.0.0\u0026#34;xpack.monitoring.elasticsearch.hosts:[\u0026#34;http://elasticsearch:9200\u0026#34;]xpack.monitoring.enabled:truexpack.monitoring.elasticsearch.username:elasticxpack.monitoring.elasticsearch.password:zhugeqing  先下载需要导入到logstash中的测试数据   https://grouplens.org/datasets/movielens\n   wget https://files.grouplens.org/datasets/movielens/ml-10m.zip\n  进行解压，修改解压目录明为movietest(放在./logstash下)，然后编写logstash.conf文件。\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  input { beats { port =\u0026gt; 5044 } tcp { port =\u0026gt; 5000 } file { path =\u0026gt; \u0026#34;/usr/share/logstash/movies.csv\u0026#34; start_position =\u0026gt; \u0026#34;beginning\u0026#34; sincedb_path =\u0026gt; \u0026#34;/dev/null\u0026#34; } } output { elasticsearch { hosts =\u0026gt; \u0026#34;elasticsearch:9200\u0026#34; user =\u0026gt; \u0026#34;elastic\u0026#34; password =\u0026gt; \u0026#34;zhugeqing\u0026#34; index =\u0026gt; \u0026#34;%{[@metadata][-zhugeqing]}-%{[@metadata][version]}-%{+YYYY.MM.dd}\u0026#34; } }   7.在docker-compose.yaml下，执行docker-compose up -d。\ntips  最终宿主机的目录树形结构如下  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  . |-- docker-compose.yml |-- elasticsearch | `-- config | `-- elasticsearch.yml |-- kibana | `-- config | `-- kibana.yml `-- logstash |-- config | `-- logstash.yml |-- movietest | |-- allbut.pl | |-- movies.dat | |-- ratings.dat | |-- README.html | |-- split_ratings.sh | `-- tags.dat `-- pipeline `-- logstash.conf   安装分词器   进入es容器的/usr/share/elasticsearch目录，比如安装analysis-icu\n  命令行安装：可以执行bin/elasticsearch-plugin install analysis-icu\n  url安装：可以执行bin/elasticsearch-plugin install [url]\n   url填所需要哦分词器的地址，需要匹配版本\n  离线安装，将下载的分词器解压缩 到/usr/share/elasticsearch/plugins下  ","description":"安装ELK","id":13,"section":"es","tags":["elasticsearch"],"title":"安装ELK","uri":"https://www.zhugeqing.top/es/install/"},{"content":"应对问题  Kubernetes集群资源十分紧张，而此时又需要部署一些比较重要的业务，如何去进行“抢占”集群资源，让关键业务在集群跑起来？   https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/pod-priority-preemption/#how-to-use-priority-and-preemption\n PriorityClass  PriorityClass 是一个无命名空间对象，主要有三个字段   value：可以设置为任何小于或等于 10 亿的 32 位整数值，value越大，代表使用这个PriorityClass的Pod优先级越高，越不容易被抢占资源；\nglobalDefault：globalDefault 字段表示这个 PriorityClass 的值应该用于没有 priorityClassName 的 Pod，\n系统中只能存在一个 globalDefault 设置为 true 的 PriorityClass，如果不存在设置了 globalDefault 的 PriorityClass， 则没有 priorityClassName 的 Pod 的优先级为零。\ndescription： 是一个任意字符串。 它用来告诉集群用户何时应该使用此 PriorityClass。\n 抢占测试说明 集群环境  k8s v1.24 两台Work Node，每台CPU数都为两核，Memory 不限(足够测试)。  测试流程   创建两个PriorityClass，一个为High，一个为low，然后创建两个PriorityClass为low的Pod，且CPU均需要占用1.3核CPU。然后再创建一个需要占用1.3核心的CPU的Pod,且PriorityClass为high\n  当PriorityClass被创建后，会分别占用两台Node的资源，且无法均再创建一个1.3核心CPU的Pod（1.3 + 1.3 \u0026gt; 2），当创建PriorityClass为High的Pod后，就会强制抢占PriorityClass其中的一个\n  实战 创建PriorityClass  high PriorityClass的 value 高于 low PriorityClass的 value\n  创建high PriorityClass  1 2 3 4 5 6 7  apiVersion:scheduling.k8s.io/v1kind:PriorityClassmetadata:name:high-priorityvalue:1001globalDefault:falsedescription:\u0026#34;此优先级类应仅用于 XYZ 服务 Pod。\u0026#34;  创建low PriorityClass  1 2 3 4 5 6 7  apiVersion:scheduling.k8s.io/v1kind:PriorityClassmetadata:name:low-priorityvalue:1000globalDefault:falsedescription:\u0026#34;此优先级类应仅用于 ABC 服务 Pod。\u0026#34;  创建low-nginx Pod  创建nginx-low-1 Pod  1 2 3 4 5 6 7 8 9 10 11 12 13 14  apiVersion:v1kind:Podmetadata:name:nginx-low-1spec:containers:- name:nginximage:nginximagePullPolicy:IfNotPresentresources:limits:memory:\u0026#34;300Mi\u0026#34;cpu:\u0026#34;1300m\u0026#34;priorityClassName:low-priority  创建nginx-low-2 Pod  1 2 3 4 5 6 7 8 9 10 11 12 13 14  apiVersion:v1kind:Podmetadata:name:nginx-low-2spec:containers:- name:nginximage:nginximagePullPolicy:IfNotPresentresources:limits:memory:\u0026#34;300Mi\u0026#34;cpu:\u0026#34;1300m\u0026#34;priorityClassName:low-priority  kubectl apply -f nginx-low-1.yaml nginx-low-2.yaml  创建high-ngin Pod  创建nginx-high Pod  1 2 3 4 5 6 7 8 9 10 11 12 13 14  apiVersion:v1kind:Podmetadata:name:nginx-highspec:containers:- name:nginximage:nginximagePullPolicy:IfNotPresentresources:limits:memory:\u0026#34;100Mi\u0026#34;cpu:\u0026#34;1300m\u0026#34;priorityClassName:high-priority   可以另开一个终端，执行kubectl get pod -w来观察Pod的变化\n  执行kubectl apply -f nginx-high.yaml\n  可以观察有一个low-nginx Pod被抢占\n  End（实战非抢占Priority Class）  想要设置优先级高的Pod，并且不想让它去抢占别的Pod，可以在它使用的PriorityClass的preemptionPolicy字段设置为Never   创建非抢占优先级的PriorityClass  1 2 3 4 5 6 7 8  apiVersion:scheduling.k8s.io/v1kind:PriorityClassmetadata:name:high-priority-nonpreemptingvalue:1002preemptionPolicy:NeverglobalDefault:falsedescription:\u0026#34;This priority class will not cause other pods to be preempted.\u0026#34;  创建使用它的Pod  1 2 3 4 5 6 7 8 9 10 11 12 13 14  apiVersion:v1kind:Podmetadata:name:nginx-nopreemptionspec:containers:- name:nginximage:nginximagePullPolicy:IfNotPresentresources:limits:memory:\u0026#34;100Mi\u0026#34;cpu:\u0026#34;1300m\u0026#34;priorityClassName:high-priority-nonpreempting  依次使用命令创建对象（在之前抢占示例的基础上），发现就算这个PriorityClass的value比较大（优先级大），也无法抢占别的Pod  ","description":"实战 k8s Pod的PriorityClass 和抢占","id":14,"section":"kubernetes","tags":["k8s"],"title":"k8s PriorityClass","uri":"https://www.zhugeqing.top/kubernetes/pod-priority/"},{"content":"应对问题  Volume 和 Pod的生命周期是绑定的，当Pod删除后，Volume里面的数据也有可能被一同删除。kubernetes 提供了PV（Persistent Volume）用于持久化存储数据。但是光有PV还不能直接使用，PV需要与PVC绑定起来，PVC就像我们面向对象中的接口，它声明的一些方法（也就是关于PV的规范），而PV则是具体实现的对象。   https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/\nhttps://kubernetes.io/zh-cn/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-v1/\n 实战  创建PVC  1 2 3 4 5 6 7 8 9 10  apiVersion:v1kind:PersistentVolumeClaimmetadata:name:pvc-testspec:accessModes:- \u0026#34;ReadWriteOnce\u0026#34;resources:requests:storage:400M  创建pv  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  apiVersion:v1kind:PersistentVolumemetadata:name:pv-testspec:capacity:storage:500M# 容量volumeMode:FilesystemaccessModes:- ReadWriteOnce# 访问权限persistentVolumeReclaimPolicy:Retain# 回收策略nodeAffinity:# 节点调度required:nodeSelectorTerms:- matchExpressions:- key:kubernetes.io/hostnameoperator:Invalues:- \u0026#34;node1\u0026#34;local:path:/k8s/pvtest/# 绑定目录（存储插件选择local）  创建Pod  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  apiVersion:v1kind:Podmetadata:name:test-podspec:containers:- name:test-podimage:nginxcommand:- \u0026#34;/bin/sh\u0026#34;args:- \u0026#34;-c\u0026#34;- \u0026#34;touch /mnt/SUCCESS \u0026amp;\u0026amp; exit 0 || exit 1\u0026#34;#创建一个SUCCESS文件后退出volumeMounts:- name:pv-pvc-testmountPath:\u0026#34;/mnt\u0026#34;restartPolicy:\u0026#34;Never\u0026#34;volumes:- name:pv-pvc-testpersistentVolumeClaim:claimName:pvc-test#与PVC名称保持一致  依次使用kubelet apply yaml文件。  ","description":"实战 k8s PV 和 PVC","id":15,"section":"kubernetes","tags":["k8s"],"title":"实战k8s PV 和 PVC","uri":"https://www.zhugeqing.top/kubernetes/persistent/"},{"content":"Namespace   对于docker而言，本身只是通过Linux的Namespace技术来将容器作为一个进程 与其他进程进行隔离。\n  Namespace 技术实际上修改了应用进程看待整个计算机“视图”，即它的“视线”被操作系统做了限制，只能“看到”某些指定的内容。\n  使用UTS Namespace就可以隔离nodename和domainname；使用IPC Namespace就可以隔离进程间通信，使用USer Namespace就可以隔离用于和用户组的ID，使用Network Namespace就可以隔离网络资源，使用PID Namespace可以隔离进程ID，使用Mount Namespace可以隔离挂载点\n  下面使用go语言来使用这个隔离的系统调用（切换成Linux模式进行开发，不然有些变量没有提示）\n  UTS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; \u0026#34;syscall\u0026#34; ) // UTS Namespace主要用于隔离nodeName 和 domainName func uts_proc() { cmd := exec.Command(\u0026#34;sh\u0026#34;) cmd.SysProcAttr = \u0026amp;syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS, } cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr if err := cmd.Run(); err != nil { log.Fatal(err) } }   IPC 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; \u0026#34;syscall\u0026#34; ) // IPC Namespace 用于隔离进程间通信 func ipc_proc() { cmd := exec.Command(\u0026#34;sh\u0026#34;) cmd.SysProcAttr = \u0026amp;syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC, } cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr if err := cmd.Run(); err != nil { log.Fatal(err) } }   PID 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; \u0026#34;syscall\u0026#34; ) // PID Namespace 用于隔离 进程ID func pid_proc() { cmd := exec.Command(\u0026#34;sh\u0026#34;) cmd.SysProcAttr = \u0026amp;syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID, } cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr if err := cmd.Run(); err != nil { log.Fatal(err) } }   Mount 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; \u0026#34;syscall\u0026#34; ) // Mount Namespace 用于隔离 挂载点 func mount_proc() { cmd := exec.Command(\u0026#34;sh\u0026#34;) cmd.SysProcAttr = \u0026amp;syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS, } cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr if err := cmd.Run(); err != nil { log.Fatal(err) } }   User 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; \u0026#34;syscall\u0026#34; ) // user Namespace 用于隔离 用户 和 用户组（运行之后使用id查看） func user_proc() { cmd := exec.Command(\u0026#34;sh\u0026#34;) cmd.SysProcAttr = \u0026amp;syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS, } cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr cmd.SysProcAttr.Credential = \u0026amp;syscall.Credential{ Uid: uint32(1), Gid: uint32(1), } if err := cmd.Run(); err != nil { log.Fatal(err) } }   Network 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; \u0026#34;syscall\u0026#34; ) // Network Namespace 用于隔离 网络资源 func network_proc() { cmd := exec.Command(\u0026#34;sh\u0026#34;) cmd.SysProcAttr = \u0026amp;syscall.SysProcAttr{ Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS | syscall.CLONE_NEWNET, } cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr cmd.SysProcAttr.Credential = \u0026amp;syscall.Credential{ Uid: uint32(1), Gid: uint32(1), } if err := cmd.Run(); err != nil { log.Fatal(err) } }   ","description":"docker Namespace","id":16,"section":"golang","tags":["Go"],"title":"docker Namespace","uri":"https://www.zhugeqing.top/golang/docker-namespace/"},{"content":"普通消息 生产者  https://github.com/apache/rocketmq-client-go/blob/master/examples/producer/async/main.go\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2/primitive\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2/producer\u0026#34; \u0026#34;time\u0026#34; ) func main() { p, err := rocketmq.NewProducer( producer.WithNameServer([]string{\u0026#34;192.168.200.120:9876\u0026#34;}), producer.WithGroupName(\u0026#34;producer_group1\u0026#34;), producer.WithRetry(3), // 失败重试次数 \t) if err != nil { panic(err) } p.Start() // 启动producer  for i := 0; i \u0026lt; 10; i++ { // 发送消息 \terr = p.SendAsync(context.Background(), // 异步发送 \tfunc(ctx context.Context, result *primitive.SendResult, err error) { if err != nil { fmt.Println(\u0026#34;rocketmq send error:\u0026#34;, err) } else { fmt.Println(\u0026#34;rocketmq send success, result:\u0026#34;, result) } }, \u0026amp;primitive.Message{ Topic: \u0026#34;topic1\u0026#34;, Body: []byte(\u0026#34;I am producer\u0026#34;), }) if err != nil { panic(err) } } time.Sleep(time.Second * 40) p.Shutdown() // 关闭producer }   消费者  https://github.com/apache/rocketmq-client-go/blob/master/examples/consumer/acl/main.go\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2/consumer\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2/primitive\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var ( a int mu sync.Mutex ) func main() { c, err := rocketmq.NewPushConsumer( consumer.WithNameServer([]string{\u0026#34;192.168.200.120:9876\u0026#34;}), consumer.WithGroupName(\u0026#34;consumer_group1\u0026#34;), ) if err != nil { panic(err) } err = c.Subscribe(\u0026#34;topic1\u0026#34;, consumer.MessageSelector{}, func(ctx context.Context, msgs ...*primitive.MessageExt) (consumer.ConsumeResult, error) { for i := range msgs { fmt.Println(\u0026#34;消费内容：\u0026#34;, msgs[i].Body) } add() return consumer.ConsumeSuccess, nil // 返回消费结果 \t}) if err != nil { panic(err) } c.Start() // 启动消费者  time.Sleep(time.Second * 20) if err := c.Shutdown(); err != nil { panic(err) } fmt.Println(a) // 查看是否 消费了10次 } func add() { mu.Lock() a++ mu.Unlock() }   顺序消息 生产者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2/primitive\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2/producer\u0026#34; \u0026#34;time\u0026#34; ) type QueueSelector struct { } func (QueueSelector) Select(msg *primitive.Message, queue []*primitive.MessageQueue) *primitive.MessageQueue { return queue[0] // 固定选择 } // 顺序发送 func main() { p, err := rocketmq.NewProducer( producer.WithNameServer([]string{\u0026#34;42.192.19.149:9876\u0026#34;}), producer.WithGroupName(\u0026#34;producer_group2\u0026#34;), producer.WithRetry(3), // 失败重试次数 \tproducer.WithQueueSelector(QueueSelector{}), // 只发送到一个queue中 \t) if err != nil { panic(err) } p.Start() // 启动producer  for i := 0; i \u0026lt; 10; i++ { // 发送消息 \tresult, err := p.SendSync(context.Background(), // 使用同步发送 \t\u0026amp;primitive.Message{ Topic: \u0026#34;topic2\u0026#34;, Body: []byte(fmt.Sprintf(\u0026#34;I am producer, send %d times, test\u0026#34;, i+1)), }) if err != nil { panic(err) } else { fmt.Println(\u0026#34;producer send result is \u0026#34;, result) } } time.Sleep(time.Second * 10) p.Shutdown() // 关闭producer }   消费者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2/consumer\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2/primitive\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var ( mu sync.Mutex ) // FIFO 消费 func main() { c, err := rocketmq.NewPushConsumer( consumer.WithNameServer([]string{\u0026#34;42.192.19.149:9876\u0026#34;}), consumer.WithGroupName(\u0026#34;consumer_group2\u0026#34;), consumer.WithConsumerModel(consumer.Clustering), consumer.WithConsumeFromWhere(consumer.ConsumeFromFirstOffset), consumer.WithConsumerOrder(true), ) if err != nil { panic(err) } err = c.Subscribe(\u0026#34;topic2\u0026#34;, consumer.MessageSelector{}, func(ctx context.Context, msgs ...*primitive.MessageExt) (consumer.ConsumeResult, error) { // 调用函数进行消费 \tConsumer(msgs) return consumer.ConsumeSuccess, nil // 返回消费结果 \t}) if err != nil { panic(err) } c.Start() // 启动消费者  time.Sleep(time.Second * 50) if err := c.Shutdown(); err != nil { panic(err) } } func Consumer(msgs []*primitive.MessageExt) { mu.Lock() for i := range msgs { fmt.Println(\u0026#34;消费内容：\u0026#34;, string(msgs[i].Body)) } mu.Unlock() }   延时消息 生产者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2/primitive\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2/producer\u0026#34; \u0026#34;time\u0026#34; ) type QueueSelector struct { } // 延时发送 func main() { p, err := rocketmq.NewProducer( producer.WithNameServer([]string{\u0026#34;42.192.19.149:9876\u0026#34;}), producer.WithGroupName(\u0026#34;producer_group3\u0026#34;), producer.WithRetry(3), // 失败重试次数 \t) if err != nil { panic(err) } p.Start() // 启动producer  for i := 0; i \u0026lt; 10; i++ { // 发送消息 \tmsg := \u0026amp;primitive.Message{ Topic: \u0026#34;topic3\u0026#34;, Body: []byte(fmt.Sprintf(\u0026#34;I am producer, send %d times, test\u0026#34;, i+1)), } msg.WithDelayTimeLevel(4) // 设置延时发送级别 第4个级别是30s \tresult, err := p.SendSync(context.Background(), msg) if err != nil { panic(err) } else { fmt.Println(\u0026#34;producer send result is \u0026#34;, result) } } time.Sleep(time.Second * 50) p.Shutdown() // 关闭producer }   消费者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2/consumer\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2/primitive\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var ( mu sync.Mutex ) // FIFO 消费 func main() { c, err := rocketmq.NewPushConsumer( consumer.WithNameServer([]string{\u0026#34;42.192.19.149:9876\u0026#34;}), consumer.WithGroupName(\u0026#34;consumer_group2\u0026#34;), ) if err != nil { panic(err) } err = c.Subscribe(\u0026#34;topic3\u0026#34;, consumer.MessageSelector{}, func(ctx context.Context, msgs ...*primitive.MessageExt) (consumer.ConsumeResult, error) { // 调用函数进行消费 \tConsumer(msgs) return consumer.ConsumeSuccess, nil // 返回消费结果 \t}) if err != nil { panic(err) } c.Start() // 启动消费者  time.Sleep(time.Second * 50) if err := c.Shutdown(); err != nil { panic(err) } } func Consumer(msgs []*primitive.MessageExt) { mu.Lock() for i := range msgs { fmt.Println(\u0026#34;消费内容：\u0026#34;, string(msgs[i].Body)) } mu.Unlock() }   事务消息 生产者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  package main import ( \u0026#34;context\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2/primitive\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2/producer\u0026#34; uuid \u0026#34;github.com/satori/go.uuid\u0026#34; \u0026#34;time\u0026#34; ) // 实现事务消息 进行回调的接口 type Listener struct { } func (*Listener)ExecuteLocalTransaction(*primitive.Message) primitive.LocalTransactionState { // 执行本地事务逻辑 \t// 进行库存扣减 \tvar err = errors.New(\u0026#34;本地事务执行失败\u0026#34;) if err != nil { return primitive.CommitMessageState // 执行失败，需要通知库存服务归还库存，将半消息发送给 库存服务 \t} return primitive.RollbackMessageState // 执行成功，无须再归还库存了，丢弃半消息 } func (*Listener)CheckLocalTransaction(*primitive.MessageExt) primitive.LocalTransactionState { // 回查就会调用这个函数，这个函数执行检查 \tvar err = errors.New(\u0026#34;本地事务执行失败\u0026#34;) if err != nil { // 回查 发现本地事务依旧失败 \treturn primitive.CommitMessageState } return primitive.RollbackMessageState } // 事务消息 func main() { p, err := rocketmq.NewTransactionProducer(\u0026amp;Listener{}, producer.WithNameServer([]string{\u0026#34;42.192.19.149:9876\u0026#34;}), producer.WithGroupName(\u0026#34;producer_group4\u0026#34;), producer.WithRetry(3), // 失败重试次数 \t) if err != nil { panic(err) } p.Start() // 启动producer  // 发送半消息 \tp.SendMessageInTransaction(context.Background(), \u0026amp;primitive.Message{ Topic: \u0026#34;reback\u0026#34;, // 归还商品库存 \tBody: []byte(\u0026#34;please reback\u0026#34;), TransactionId: uuid.NewV4().String(), }) time.Sleep(time.Second * 200) p.Shutdown() // 关闭producer }   消费者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2/consumer\u0026#34; \u0026#34;github.com/apache/rocketmq-client-go/v2/primitive\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var ( mu sync.Mutex ) func main() { c, err := rocketmq.NewPushConsumer( consumer.WithNameServer([]string{\u0026#34;42.192.19.149:9876\u0026#34;}), consumer.WithGroupName(\u0026#34;consumer_group4\u0026#34;), consumer.WithConsumerModel(consumer.Clustering), consumer.WithConsumeFromWhere(consumer.ConsumeFromFirstOffset), consumer.WithConsumerOrder(true), ) if err != nil { panic(err) } err = c.Subscribe(\u0026#34;reback\u0026#34;, consumer.MessageSelector{}, func(ctx context.Context, msgs ...*primitive.MessageExt) (consumer.ConsumeResult, error) { // 调用函数进行消费 \tConsumer(msgs) return consumer.ConsumeSuccess, nil // 返回消费结果 \t}) if err != nil { panic(err) } c.Start() // 启动消费者  time.Sleep(time.Second * 50) if err := c.Shutdown(); err != nil { panic(err) } } func Consumer(msgs []*primitive.MessageExt) { mu.Lock() for i := range msgs { fmt.Println(\u0026#34;消费内容：\u0026#34;, string(msgs[i].Body)) } mu.Unlock() }   ","description":"Go 语言操作rocketmq","id":17,"section":"golang","tags":["Go"],"title":"Go 语言操作rocketmq","uri":"https://www.zhugeqing.top/golang/rocketmq/"},{"content":"部署Mysql 编写Mysql StatefulSet文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  apiVersion:v1kind:Servicemetadata:name:onlineshopping-mysqllabels:app:mysqlspec:ports:- port:3306name:mysqlnodePort:30306type:NodePortselector:app:mysql---apiVersion:apps/v1kind:StatefulSetmetadata:name:mysqlspec:selector:matchLabels:app:mysql# has to match .spec.template.metadata.labelsserviceName:\u0026#34;mysql\u0026#34;replicas:1# by default is 1template:metadata:labels:app:mysql# has to match .spec.selector.matchLabelsspec:terminationGracePeriodSeconds:10containers:- name:mysqlimage:mysql:5.7ports:- containerPort:3306name:mysqlvolumeMounts:- name:host-pathmountPath:/var/lib/mysqlenv:- name:MYSQL_ROOT_PASSWORDvalue:\u0026#34;root\u0026#34;# 密码volumes:- name:host-pathhostPath:path:/k8s/mysql/# 本地 目录type:DirectoryOrCreate  创建对应资源  kubectl apply -f mysql.yaml  部署redis 编写configmap.yaml，存放一些redis相关配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  apiVersion:v1kind:ConfigMapmetadata:name:redislabels:app:redisdata:redis-user.conf:|# 容器内部端口 port 6379 # daemonize yes logfile \u0026#34;$port.log\u0026#34; dbfilename \u0026#34;dump-redis-$port.rdb\u0026#34; # 访问redis-server密码 requirepass 123456 # 设置redis最大内存 maxmemory 100MB # 设置redis内存淘汰策略 maxmemory-policy volatile-lru # 开启AOF appendonly yes # 总是追加到AOF文件 appendfsync always # 超过100MB就进行重写 auto-aof-rewrite-min-size 100mb # 超过增长率就进行重写 auto-aof-rewrite-percentage 40 # 开启AOF-RDB 混合持久化 aof-use-rdb-preamble yes # 配置慢查询日志（不超过100微秒就不会被记录） slowlog-log-slower-than 100 # 最多记录100条，先进先出 slowlog-max-len 100--  便携部署redis 的StatefulSet 文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  apiVersion:v1kind:Servicemetadata:name:onlineshopping-redislabels:app:redisspec:ports:- port:6379name:redis-usernodePort:6379type:NodePortselector:app:redis---apiVersion:apps/v1kind:StatefulSetmetadata:name:redis-userspec:selector:matchLabels:app:redis# has to match .spec.template.metadata.labelsserviceName:\u0026#34;redis\u0026#34;replicas:1# by default is 1template:metadata:labels:app:redis# has to match .spec.selector.matchLabelsspec:terminationGracePeriodSeconds:10containers:- name:redisimage:zhugeqing/rediscommand:[\u0026#34;sh\u0026#34;,\u0026#34;-c\u0026#34;,\u0026#34;redis-server\u0026#34;,\u0026#34;/etc/redis/redis.conf\u0026#34;]ports:- containerPort:6379name:redisresources:limits:memory:300MivolumeMounts:- name:confmountPath:/etc/redis/- name:datamountPath:/data- name:time# 同步时间mountPath:/etc/localtimevolumes:- name:confconfigMap:name:redisitems:- key:redis-user.confpath:redis.conf- name:datahostPath:path:/k8s/redis-user/type:DirectoryOrCreate- name:timehostPath:path:/etc/localtime  ","description":"k8s 部署应用","id":18,"section":"kubernetes","tags":["k8s"],"title":"使用k8s部署应用","uri":"https://www.zhugeqing.top/kubernetes/deploy/"},{"content":"linux   read\n  |\n   ,\u0026raquo;,\u0026lt;\n   操作系统  进程和线程之间的区别  ","description":"you can","id":19,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2022-05-01/"},{"content":"git   git HEAD分离\n  .git文件夹探秘\n  git的commit，tree，blob\n  linux  linux shel脚本执行方式以及不同  算法  爬楼梯  ","description":"you can","id":20,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2022-04-30/"},{"content":"mysql   mysql事务ACID\n  mysql事务并发带来的后果\n  mysql事务隔离级别\n  mysql 悲观锁与乐观锁\n  常见的封锁类型\n  InnoDB是表级锁还是行级锁\n  mvcc\n  linux   vim正常模式\n  vim命令模式\n  ifconfig,ping,traceroute,route,telnet,nslookup,tcpdump,netstat,ss,\n  操作系统   什么是死锁\n  死锁发生的必要条件\n  如何预防死锁\n  git   git log, \u0026ndash;graph,-all,-n2,master\n  git commit -am \u0026ldquo;哈哈\u0026rdquo;\n  ","description":"you can","id":21,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2022-04-29/"},{"content":"linux   read\n  |\n   ,\u0026raquo;,\u0026lt;\n   操作系统  进程和线程之间的区别  ","description":"you can","id":22,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2022-04-07/"},{"content":"git   git HEAD分离\n  .git文件夹探秘\n  git的commit，tree，blob\n  linux  linux shel脚本执行方式以及不同  算法  爬楼梯  ","description":"you can","id":23,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2022-04-06/"},{"content":"mysql   mysql事务ACID\n  mysql事务并发带来的后果\n  mysql事务隔离级别\n  mysql 悲观锁与乐观锁\n  常见的封锁类型\n  InnoDB是表级锁还是行级锁\n  mvcc\n  linux   vim正常模式\n  vim命令模式\n  ifconfig,ping,traceroute,route,telnet,nslookup,tcpdump,netstat,ss,\n  操作系统   什么是死锁\n  死锁发生的必要条件\n  如何预防死锁\n  git   git log, \u0026ndash;graph,-all,-n2,master\n  git commit -am \u0026ldquo;哈哈\u0026rdquo;\n  ","description":"you can","id":24,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2022-04-05/"},{"content":"容器 分类  容器可以按照存放的数据方式，可以分为序列式容器 和 关联式容器 序列式容器包括 vector, list, deque, 还有是适配器的stack, queue, priority_queue 关联式容器包括 set, multiset, map, multimap  map 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  #pragma once #include \u0026lt;map\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; struct MapDisplay { void operator()(pair\u0026lt;string, double\u0026gt; Pair) { // 重载括号运算符  cout \u0026lt;\u0026lt; Pair.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; Pair.second \u0026lt;\u0026lt; endl; } }; void MapTest() { // 初始化一个Map  map\u0026lt;string, double\u0026gt; i_d_map; // 添加数据  i_d_map[\u0026#34;zhugeqing1\u0026#34;] = 100; // 1  i_d_map[\u0026#34;zhugeqing4\u0026#34;] = 400; i_d_map.insert(pair\u0026lt;string, double\u0026gt;(\u0026#34;zhugeqing2\u0026#34;, 200)); // 2  i_d_map.insert(map\u0026lt;string, double\u0026gt;::value_type (\u0026#34;zhugeqing3\u0026#34;, 300)); // 3  // 遍历数据  for_each(i_d_map.begin(), i_d_map.end(), MapDisplay()); // 查找数据  auto iter = i_d_map.find(\u0026#34;zhugeqing2\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;find zhugeqin2 Pair is \u0026#34;\u0026lt;\u0026lt; iter-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; iter-\u0026gt;second \u0026lt;\u0026lt; endl; // 移除数据  i_d_map.erase(iter); for_each(i_d_map.begin(), i_d_map.end(), MapDisplay()); cout \u0026lt;\u0026lt; \u0026#34;使用迭代器遍历map\u0026#34; \u0026lt;\u0026lt; endl; // 使用迭代器遍历，并移除小于300的 pair  for(iter = i_d_map.begin(); iter != i_d_map.end();) { if(iter-\u0026gt;second \u0026lt; 300) { i_d_map.erase(iter++); // 删除这个pair之后，迭代器失效  } else { iter++; } } for(iter = i_d_map.begin(); iter != i_d_map.end(); iter++) { cout \u0026lt;\u0026lt; \u0026#34;Pair is \u0026#34;\u0026lt;\u0026lt; iter-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; iter-\u0026gt;second \u0026lt;\u0026lt; endl; } }   ","description":"C++ STL","id":25,"section":"c++","tags":["c++"],"title":"C++ STL","uri":"https://www.zhugeqing.top/c++/stl/"},{"content":"创建一个线程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #include \u0026lt;iostream\u0026gt;#include \u0026lt;thread\u0026gt;using namespace std; void Test1(const char* i) { cout \u0026lt;\u0026lt; \u0026#34;I am thread \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } int main() { // 创建线程t1  thread t1(Test1, \u0026#34;t1\u0026#34;); // 创建线程t2  thread t2(Test1, \u0026#34;t2\u0026#34;); // 等待线程执行完成  t1.join(); // 等待线程执行完成  t2.join(); return 0; }   使用互斥锁控制并发 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #include \u0026lt;iostream\u0026gt;#include \u0026lt;thread\u0026gt;using namespace std; void Test1(const char* num, mutex\u0026amp; mu) { for(int i = 0; i \u0026lt; 10; i++) { mu.lock(); cout \u0026lt;\u0026lt; \u0026#34;I am thread \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; and count \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; mu.unlock(); } } int main() { mutex mu; // 创建线程t1  auto num1 = \u0026#34;number 1\u0026#34;, num2 = \u0026#34;number 2\u0026#34;; thread t1(Test1, num1, ref(mu)); // 创建线程t2  thread t2(Test1, num2, ref(mu)); // 等待线程执行完成  t1.join(); // 等待线程执行完成  t2.join(); return 0; }   docker run -e SESSION_TOKEN=\u0026quot;$(echo $SESSION_TOKEN)\u0026quot; \u0026ndash;rm -it registry.cn-hangzhou.aliyuncs.com/sunshanpeng/wechaty-chatgpt:0.0.8\n","description":"C++ 多线程","id":26,"section":"c++","tags":["c++"],"title":"C++ 多线程","uri":"https://www.zhugeqing.top/c++/multithread/"},{"content":"linux   read\n  |\n   ,\u0026raquo;,\u0026lt;\n   操作系统  进程和线程之间的区别  ","description":"you can","id":27,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2022-04-03/"},{"content":"构建最小的go程序镜像  我一般通常会在云服务器上安装Go，然后build源程序，最后通过在busybo中进行运行 来构建go程序镜像\n  现在删除Go，用Go image来构建吧！  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  FROMzhugeqing/golang:1.17 AS builderWORKDIR/appMAINTAINER诸葛青COPY . .ARG TARGETPLATFORM=\u0026#34;linux/amd64\u0026#34;# 设置代理环境变量ARG GOPROXY=\u0026#34;https://goproxy.cn,direct\u0026#34;# 编译，在image内运行RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o main main.goFROMzhugeqing/alpine # 拷贝缓存区构建完成的文件（这样镜像还是非常小的）COPY --from=builder /app/main ./main # 暴露端口，只是显示而已EXPOSE6666 # 运行 可执行文件CMD [ \u0026#34;/main\u0026#34; ]   缺点就是会产生缓存image，需要执行docker system prune进行清理  ","description":"使用docker正确的构建go程序镜像","id":28,"section":"docker","tags":["docker"],"title":"docker 构建go镜像","uri":"https://www.zhugeqing.top/docker/docker-go-build/"},{"content":"volume  https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/\n 实战挂载NFS（Network File System）卷   在 master 和 worker node 上安装 nfs服务\nyum install -y nfs-utils\n  修改 master 配置\necho \u0026quot;/nfsdata *(rw,sync,no_root_squash)\u0026quot; \u0026gt; /etc/exports\n  配置 master nfs 自启动\nsystemctl enable --now rpcbind\nsystemctl enable --now nfs\n  创建nfs.yaml 测试nfs挂载\n   需要先在 master上创建对应的 /nfsdata\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  apiVersion:v1kind:Podmetadata:name:myapplabels:name:myappspec:containers:- name:myappimage:nginxvolumeMounts:- mountPath:/usr/share/nginx/htmlname:nfsresources:limits:memory:\u0026#34;128Mi\u0026#34;cpu:\u0026#34;500m\u0026#34;ports:- containerPort:80volumes:- name:nfsnfs:server:masterpath:/nfsdata   kubectl apply -f nfs.yaml 创建pod\n  kubectl exec -it myapp sh 进入容器内部\n  echo \u0026quot;zhugeqing\u0026quot; /usr/share/nginx/html/a.txt 创建文件\n  回到master，进入/nfsdata目录查看文件是否存在\n  实战pv（Persistent Volume） 和 pvc（PersistentVolumeClaims）  https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/\n  创建 pv.yaml  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  apiVersion:v1kind:PersistentVolumemetadata:name:pv-demolabels:name:pv-demospec:capacity:storage:5GiaccessModes:- ReadWriteOncepersistentVolumeReclaimPolicy:Recyclenfs:path:/nfsdataserver:master   kubectl apply -f pv.yaml 创建pv\n  创建 pvc.yaml\n  1 2 3 4 5 6 7 8 9 10 11 12  apiVersion:v1kind:PersistentVolumeClaimmetadata:name:pvc-demolabels:name:pvc-demospec:accessModes:- \u0026#34;ReadWriteOnce\u0026#34;resources:requests:storage:2Gi   kubectl apply -f pvc.yaml 创建pvc\n  kubectl get pv，kubectl get pvc查看\n  实战storage Class  https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/\n 创建 Persistent Volume Provisioner 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  apiVersion:apps/v1kind:Deploymentmetadata:name:nfs-client-provisionerlabels:app:nfs-client-provisioner# replace with namespace where provisioner is deployednamespace:default #与RBAC文件中的namespace保持一致spec:replicas:1selector:matchLabels:app:nfs-client-provisionerstrategy:type:Recreateselector:matchLabels:app:nfs-client-provisionertemplate:metadata:labels:app:nfs-client-provisionerspec:serviceAccountName:nfs-client-provisionercontainers:- name:nfs-client-provisionerimage:registry.cn-beijing.aliyuncs.com/qingfeng666/nfs-client-provisioner:v3.1.0volumeMounts:- name:nfs-client-rootmountPath:/persistentvolumesenv:- name:PROVISIONER_NAMEvalue:qgg-nfs-storage #provisioner名称,请确保该名称与 nfs-StorageClass.yaml文件中的provisioner名称保持一致- name:NFS_SERVERvalue:master #NFS Server IP地址- name:NFS_PATHvalue:/nfsdata #NFS挂载卷volumes:- name:nfs-client-rootnfs:server:master #NFS Server IP地址path:/nfsdata #NFS 挂载卷  创建用户和角色 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  apiVersion:v1kind:ServiceAccountmetadata:name:nfs-client-provisioner# replace with namespace where provisioner is deployednamespace:default #根据实际环境设定namespace,下面类同---kind:ClusterRoleapiVersion:rbac.authorization.k8s.io/v1metadata:name:nfs-client-provisioner-runnerrules:- apiGroups:[\u0026#34;\u0026#34;]resources:[\u0026#34;persistentvolumes\u0026#34;]verbs:[\u0026#34;get\u0026#34;,\u0026#34;list\u0026#34;,\u0026#34;watch\u0026#34;,\u0026#34;create\u0026#34;,\u0026#34;delete\u0026#34;]- apiGroups:[\u0026#34;\u0026#34;]resources:[\u0026#34;persistentvolumeclaims\u0026#34;]verbs:[\u0026#34;get\u0026#34;,\u0026#34;list\u0026#34;,\u0026#34;watch\u0026#34;,\u0026#34;update\u0026#34;]- apiGroups:[\u0026#34;storage.k8s.io\u0026#34;]resources:[\u0026#34;storageclasses\u0026#34;]verbs:[\u0026#34;get\u0026#34;,\u0026#34;list\u0026#34;,\u0026#34;watch\u0026#34;]- apiGroups:[\u0026#34;\u0026#34;]resources:[\u0026#34;events\u0026#34;]verbs:[\u0026#34;create\u0026#34;,\u0026#34;update\u0026#34;,\u0026#34;patch\u0026#34;]---kind:ClusterRoleBindingapiVersion:rbac.authorization.k8s.io/v1metadata:name:run-nfs-client-provisionersubjects:- kind:ServiceAccountname:nfs-client-provisioner# replace with namespace where provisioner is deployednamespace:defaultroleRef:kind:ClusterRolename:nfs-client-provisioner-runnerapiGroup:rbac.authorization.k8s.io---kind:RoleapiVersion:rbac.authorization.k8s.io/v1metadata:name:leader-locking-nfs-client-provisioner# replace with namespace where provisioner is deployednamespace:defaultrules:- apiGroups:[\u0026#34;\u0026#34;]resources:[\u0026#34;endpoints\u0026#34;]verbs:[\u0026#34;get\u0026#34;,\u0026#34;list\u0026#34;,\u0026#34;watch\u0026#34;,\u0026#34;create\u0026#34;,\u0026#34;update\u0026#34;,\u0026#34;patch\u0026#34;]---kind:RoleBindingapiVersion:rbac.authorization.k8s.io/v1metadata:name:leader-locking-nfs-client-provisionersubjects:- kind:ServiceAccountname:nfs-client-provisioner# replace with namespace where provisioner is deployednamespace:defaultroleRef:kind:Rolename:leader-locking-nfs-client-provisionerapiGroup:rbac.authorization.k8s.io  创建 storage class 1 2 3 4 5 6 7  apiVersion:storage.k8s.io/v1kind:StorageClassmetadata:name:managed-nfs-storageprovisioner:qgg-nfs-storage#这里的名称要和provisioner配置文件中的环境变量PROVISIONER_NAME保持一致parameters:archiveOnDelete:\u0026#34;false\u0026#34;  创建 pvc 1 2 3 4 5 6 7 8 9 10 11 12  kind:PersistentVolumeClaimapiVersion:v1metadata:name:test-claimannotations:volume.beta.kubernetes.io/storage-class:\u0026#34;managed-nfs-storage\u0026#34;#与nfs-StorageClass.yaml metadata.name保持一致spec:accessModes:- ReadWriteManyresources:requests:storage:1Mi  创建 一个 Pod测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  kind:PodapiVersion:v1metadata:name:test-podspec:containers:- name:test-podimage:nginxcommand:- \u0026#34;/bin/sh\u0026#34;args:- \u0026#34;-c\u0026#34;- \u0026#34;touch /mnt/SUCCESS \u0026amp;\u0026amp; exit 0 || exit 1\u0026#34;#创建一个SUCCESS文件后退出volumeMounts:- name:nfs-pvcmountPath:\u0026#34;/mnt\u0026#34;restartPolicy:\u0026#34;Never\u0026#34;volumes:- name:nfs-pvcpersistentVolumeClaim:claimName:test-claim #与PVC名称保持一致  ","description":"k8 持久化存储 学习","id":29,"section":"kubernetes","tags":["k8s"],"title":"k8 持久化存储 学习","uri":"https://www.zhugeqing.top/kubernetes/storage/"},{"content":"git   git HEAD分离\n  .git文件夹探秘\n  git的commit，tree，blob\n  linux  linux shel脚本执行方式以及不同  算法  爬楼梯  ","description":"you can","id":30,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2022-04-02/"},{"content":"Channel 的结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  type hchan struct { qcount uint // chan 当前里面的数据个数 \tdataqsiz uint // chan 的容量 \tbuf unsafe.Pointer // 数据缓冲区 \telemsize uint16 // chan 元素 类型 的大小 \tclosed uint32 // 是否已经关闭 \telemtype *_type // chan 元素 的类型 \tsendx uint // 记录发送者在buf中的序号 \trecvx uint // 记录接受者在buf中的序号 \trecvq waitq // 读取的阻塞协程队列 \tsendq waitq // 写入的阻塞协程队列 \tlock mutex // 锁，并发保护 } type waitq struct { first *sudog // sudog 为对 goroutine数据结构的封装 \tlast *sudog }   Channel的初始化  判断要初始化的 Channel 需分配大小是否为 0，如果为0，则只在内存中分配hchan结构体大小 当通道元素中不包含指针时，连续分配 hchan结构体大小和size * 元素大小（size为channel元素容量） 当通道元素包含指针时，需要单独分配内存空间，这样才能正常的进行垃圾回收   Channel的写入  先判断当前 通道是否为 nil，如果是nil，则阻塞当前协程 然后进行加锁，判断 通道 是否已经关闭，如果是已经关闭，则抛出 panic 然后判断是否有正在等待的读取协程，如果有，则从读取协程链表中获取第一个协程，并将数据复制给它，解锁，重新唤醒 goroutine 判断 环形buf是否有空余，如果有空余，则将数据写入环形buf，解锁，重新唤醒 goroutine 如果没有空余，则将 该 goroutine 放入 写入协程链表的尾部，阻塞协程，等待被再次唤醒，解锁   Channel的读取  先判断当前 通道是否为nil，如果为nil，则阻塞当前协程 然后进行加锁，判断当前通道是否已经关闭且buf为空，如果是，则 解锁，返回 通道数据类型对应的 零值，唤醒协程 然后先判断是否有正在等待的写入协程，有如果有，则从写入协程链表中获取第一个协程，并将它写入的数据复制到当前协程里面，解锁，等待调度 判断 环形buf是否有空余，如果有，则读取buf的数据，并写入当前读取的协程当中，解锁，唤醒 goroutine 如果没有空余，则将当前 goroutine 加入到等待读取协程链表的尾部，阻塞协程，等待被再次唤醒，解锁   Channel的关闭  首先判断Channel是否为nil，如果是，则抛出异常 上锁，判断通过是否已经 close过，如果是，则解锁，抛出异常 如果没有关闭过，则将 hchan的closed字段改成1，然后遍历 等待读取协程链表和等待写入协程链表，将它们的 goroutine 收集到一个队列当中， 解锁，然后遍历这个队列，挨个唤醒协程   ","description":"Channel","id":31,"section":"golang","tags":["Go"],"title":"Go Channel","uri":"https://www.zhugeqing.top/golang/channel/"},{"content":"context 是什么   context中文翻译为\u0026rsquo;上下文'， 其本质是用于 在goroutine之间 传递上下文消息，比如：取消信号，k-v键值对，超时时间，截止时间等。\n  context可以协调多个goroutine 执行取消操作，并且还可以存储键值对，当然，它是并发安全的\n  context的使用场景 传递共享数据  比如web 开发中，往往一个请求对应了一个goroutine，而一个请求需要执行多项流程，又会创建子goroutine来处理，但是这些流程所需要的 验证参数不能丢，比如一个用户请求的token，可以让我们在请求处理的流程中 来区分用户。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { // 创建一个根对象， \tctx := context.Background() // 尝试调用help \thelp(ctx) // 使用 WithValue创建一个 包含键值对的 子context \tchildCtx := context.WithValue(ctx, \u0026#34;token\u0026#34;, \u0026#34;user1-xx-xx-xx\u0026#34;) help(childCtx) } func help(ctx context.Context) { token, ok := ctx.Value(\u0026#34;token\u0026#34;).(string) if ok { fmt.Println(\u0026#34;token is \u0026#34;, token) } else { fmt.Println(\u0026#34;no token\u0026#34;) } }   定时取消  当我们需要限制一个请求超时时间，就需要用到定时取消，因为请求已经到达了超时时间，不管程序再怎么处理，我也不需要这些处理的结果了。这时候应该要关闭 进行处理的goroutine  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { // 创建一个根对象， \tctx := context.Background() // 使用 WithTimeout 创建一个能够定时5秒 自动取消的 子context \tchildCtx, cancel := context.WithTimeout(ctx, time.Second*5) defer cancel() go help(childCtx) time.Sleep(time.Second * 20) } func help(ctx context.Context) { for { select { case \u0026lt;-ctx.Done(): fmt.Println(\u0026#34;5 seconds\u0026#34;) return case \u0026lt;-time.After(time.Second * 12): // 定时12秒 \tfmt.Println(\u0026#34;12 seconds\u0026#34;) return } } }   防止goroutine泄露  有的时候goroutine不能如期 停止，这个时候就可以使用context 配置for-select，监听goroutinue停止信号的到达。  contex底层原理   context本质上是一个接口，定义了4个方法，它们都是幂等的（多次调用同一个方法，得到的结果相同）\n  Deadline() 返回context的截止时间\n  Done() 返回一个 只读channel，当这个channel被关闭时，说明这个contex被取消了\n  Err() 返回一个错误，表示channel被关闭的原因，例如是被取消，还是超时关闭\n  Value() 可以传入对应的key来获取value\n  context 很大程度上是利用 通道在被关闭后 会通知所有监听它的协程这一特性来实现。在需要控制退出的子协程 使用for-select 监听context.Done()返回的通道即可，如果当前context还有子context，就会递归调用并关闭子context的通道。\n  对于使用WithCancel函数返回的子context，会有两种情况退出，一种是主动调用cancel，另一种情况是当父context退出，与其关联的所有子context都需要退出\n  对于使用WithTimeout函数返回的子context，有三种情况会退出，一种是主动调用cancel，另一种情况是当父context退出，还有一种是超时退出。\n  ","description":"Go Context","id":32,"section":"golang","tags":["Go"],"title":"Go Context","uri":"https://www.zhugeqing.top/golang/context/"},{"content":"分配内存  Go 语言有两个分配原语，一个是new，一个是make，它们做不同的事情并适用于不同的类型，   new  new它是一个分配内存的内置函数，但与其他一些语言中的同名函数不同，它不会初始化内存，它只会将其归零。也就是说， new(T)为 分配零存储 T并返回其地址，即：*T。用术语来讲的话就是：它返回一个指向新分配的类型零值的指针T。   make  有了分配内存的new，为什么还需要有make呢？，答案显而易见，make只适用于三种类型：slice, map, chan；这三种类型与其他类型的区别就是：它们引用的数据结构在使用之前必须被初始化！，比如slice：其中就包含cap，len，内置数组。 术语化来说：内置函数make(T, args)的用途不同于new(T)， 它只创建切片、映射和通道，并返回已初始化的（非归零值）T   ","description":"Go new与make的区别","id":33,"section":"golang","tags":["Go"],"title":"Go new与make的区别","uri":"https://www.zhugeqing.top/golang/allocation_new/"},{"content":"协程 与 线程  调度方式：协程是用户态的，由Go语言程序的调度器来进行调度，同时，多个协程从属于某一个线程，协程与线程的关系是M : N的，即多个协程对应多个线程，Go语言调度器可以将多个协程调度到一个线程上，但协程也可以切换到其他的线程 上下文切换：协程的上下文切换速度要快于线程，协程的上下文切换无须从用户态与内核态的切换 调度策略：线程的调度策略是抢占式的，即操作系统为了均衡每一个线程所运行的时间，会定时强制线程上下文切换。Go语言的协程在一般情况下都是协作式调度，即一个协程在运行完成之后，会主动将执行权限让给其他协程，这样一个协程能更好的在规定的时间完成任务，但当一个协程运行过长时间的话，也会被强制抢占 栈的大小：对于线程来说，一般线程的栈的大小为 2KB，而协程的栈的大小为2MB。线程的栈在运行是不能更改，但是协程可以随着运行时的需要而动态增加，32位机器最大可以是250MB，64位则是1GB   GMP模型  G：Goroutinue，runtime.g结构体表示（Go语言的协程） M：Machine，runtime.m结构体表示（实际的线程） P：Processor，runtime.p结构体表示（Go语言的逻辑处理器） 每个P上都挂载了一个局部队列，局部队列保存待执行的G，当局部队列满了 无法将G放入的时候，会将G放入全局队列中 每一个P都绑定在一个M上，M是真正运行P中G的实体，M从绑定的P的局部队列上获取G来执行 当M绑定的P的局部队列为空时，M会从全局队列获取G到本地队列来执行，当全局队列也为空时，会从其他P的本地队列来获取，这种方式也就是work stealing 当G由于系统调用而阻塞时，会导致M也阻塞，这时P会跟M进行解绑（hand off），然后寻找空闲的M进行绑定，如果没有，则会创建一个M来进行绑定 当G由于Channel和网络I/O阻塞时，不会阻塞M，这时M会寻找可运行的G，当阻塞的G恢复时，可以重新进入P的队列，等待运行   ","description":"Goroutine","id":34,"section":"golang","tags":["Go"],"title":"Goroutine","uri":"https://www.zhugeqing.top/golang/goroutine/"},{"content":"Go语言包的初始化顺序  从main包开始，先初始化导入的包，导入的包会按照导入的顺序进行初始化。 一个包被多个包导入，也只会初始化一次   一个包中的初始化顺序  同一个包下的 go 文件，会按照文件名的顺序进行初始化 而对于同一个包，会先初始化 const，再初始化 var，最后再是init() (也就是会按照文件的顺序，先初始化各个文件的const，再初始化各个文件的var，最后再初始化init()) main包 总是最后进行初始化   ","description":"Go语言初始化顺序","id":35,"section":"golang","tags":["Go"],"title":"Go语言初始化顺序","uri":"https://www.zhugeqing.top/golang/%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/"},{"content":"使用示例  开启10个goroutine，每一个goroutine进行计数1000000次   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  package main import ( \u0026#34;sync\u0026#34; ) type Counter struct { count int mu sync.Mutex } func main() { var wg sync.WaitGroup counter := \u0026amp;Counter{} wg.Add(10) for i := 0; i \u0026lt; 10; i++ { go func() { for j := 0; j \u0026lt; 1000000; j++ { counter.mu.Lock() counter.count++ counter.mu.Unlock() } wg.Done() }() } wg.Wait() println(\u0026#34;计数得到的结果为：\u0026#34;, counter.count) }   Mutex底层实现  Mutex一共有两个字段，一个为state，为int32类型，其中有三个比特为mutexLocked（记录这个锁是否被持有），mutexWoken（是否有唤醒的 goroutine），mutexStarving（记录是否处于饥饿模式），其余比特用于记录等待此锁的 goroutine 数（最大为1\u0026lt;\u0026lt;(32-3)-1个） 在正常模式下，当一个 goroutine 未获得锁时会先进行自旋几次，如果还是没有获得到锁，就加入等待队列的尾部，等待队列会按照FIFO的顺序排队。当锁处于未被持有的状态时，等待队列的第一个 goroutine会被唤醒，然后需要与后来的处于自旋状态的 goroutine 进行竞争，这时，后来的 goroutine 会更有优势获得锁，一方面是它们仍在cpu上运行，另一方面是处于自旋状态的 goroutine 可以有多个，而被唤醒的 goroutine 只有一个，所以被唤醒的goroutine 大概率会失败。然后这个 goroutine 会被重新插入到队列的首部。但是当一个 goroutine 加锁等待时间超过了 1ms 以后，Mutex会进入饥饿模式。 在饥饿模式下，Mutex的所有权会从执行Unlock的 goroutine 直接传递给等待队列的头部的 goroutine，后来的goroutine也不会再进行自旋操作，而是直接加入等待队列的尾部，当等待队列的头部goroutine 加锁等待时间小于 1ms 或者是等待队列为空时，Mutex会重新切换为正常模式  ","description":"Go Mutex","id":36,"section":"golang","tags":["Go"],"title":"并发原语之Mutex","uri":"https://www.zhugeqing.top/golang/mutex/"},{"content":"mysql   mysql事务ACID\n  mysql事务并发带来的后果\n  mysql事务隔离级别\n  mysql 悲观锁与乐观锁\n  常见的封锁类型\n  InnoDB是表级锁还是行级锁\n  mvcc\n  linux   vim正常模式\n  vim命令模式\n  ifconfig,ping,traceroute,route,telnet,nslookup,tcpdump,netstat,ss,\n  read\n  |\n   ,\u0026raquo;,\u0026lt;\n   操作系统   什么是死锁\n  死锁发生的必要条件\n  如何预防死锁\n  进程和线程之间的区别\n  git   git log, \u0026ndash;graph,-all,-n2,master\n  git commit -am \u0026ldquo;哈哈\u0026rdquo;\n  ","description":"you can","id":37,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2022-04-01/"},{"content":"git   git HEAD分离\n  .git文件夹探秘\n  git的commit，tree，blob\n  linux   linux shel脚本执行方式以及不同\n  read\n  |\n   ,\u0026raquo;,\u0026lt;\n   算法  爬楼梯  操作系统  进程和线程之间的区别  ","description":"you can","id":38,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2022-03-31/"},{"content":"基本操作   一般在shell脚本的第一行写上#!/bin/bash，如果运行命令是bash a.sh，则这一行会被当成注释，而如果就是./a.sh来执行，则会解释为使用bash来执行。（以#!开头）\n  shell脚本使用#开头来进行注释\n  shell脚本的执行方式  bash 1.sh ./1.sh source 1.sh . 1.sh 区别1：使用./1.sh这种方式执行，需要对文件赋予执行权限，其他不用。 区别2：使用bash 1.sh，./1.sh方式执行，会产生一个子进程来执行，比如sh脚本中是cd /temp，而在当前目录执行，执行完成之后，也不会进入/temp。而其他两种可以     |\n 管道是进程通信的方式之一，能将前一个命令的执行结果传递给后面的命令 例：ls | grep 1*  \n  \u0026lt;\n 输入重定向 例： read zhugeqing \u0026lt; zhugeqing.txt（将zhugeqing.txt的内容作为$zhugeqing的内容）  \n  \u0026gt;, \u0026gt;\u0026gt; , \u0026amp;\u0026gt;\n 输出重定向 例：echo \u0026quot;zhugeqing\u0026quot; \u0026gt; zhugeqing.txt（将内容zhugeqing写入并覆盖zhugeqing.txt里面的内容） 例：echo \u0026quot;zhugeqing\u0026quot; \u0026gt;\u0026gt; zhugeqing.txt（将内容zhugeqing追加到zhugeqing.txt里面） 例：ld \u0026amp;\u0026gt; error.log （将执行产生的错误写入到文件中;错误重定向）  \n  输入和输出重定向组合使用 cat \u0026gt; /root/a.txt \u0026laquo;EOF\nzhugeqing\nEOF\n\u0026gt; 用于覆盖，\u0026gt;\u0026gt;用于追加 变量赋值  变量名只能包含字母，数字，下划线；变量名不能以数字开头 变量名=变量值；例：a=12345 使用let为变量赋值；例：let a=12345 将命令赋给变量；例：l=ls（可以临时将一些比较长的命令赋给一个变量再用于使用） 将命令结果赋给变量；例：ls_res=$(ls)（或者使用` `来代替$()） 变量值有空格等特殊符号需要包含在\u0026quot; \u0026quot;活' '中；例：string=\u0026quot;123 33\u0026quot;   变量的引用  $zhugeqing （zhugeqing为 shell变量） ${zhugeqing} 在shell脚本中，使用shell变量，由于bash 1.sh和./1.sh这两种方式会生成子进程，会导致变量无法到子进程使用，所有需要通过export zhugeqing来导出变量，使得子进程也可以访问 使用unset zhugeqing来删除变量   环境变量  $PATH也就是执行命令的搜索路径，当有命令想在任意路径都能对其进行访问，可以在/etc/profile文件中加入PATH=$PATH:/root（比如这个命令就在/root/目录下），需要再source一下profile文件 通过修改变量$PS1可以改变shell提示终端符，通过修改/root/.bashrc来到达永久生效的效果，比如设置PS1=\u0026quot;[\\e[32;40m\\u @\\h \\t \\w$]\u0026quot;（具体搜索——修改linux shell 变量PS1），也可以将变量加入到/etc/profile，然后再source   预定义变量  $?:展示上一条命令的执行结果是否正常，0为正常，1为错误 $$:展示当前进程的进程ID $0:展示当前的进程名字   位置变量  $0 $1\u0026hellip; ${11}可以用于读取执行shell脚本所带的值  1 2 3 4  #!/bin/bash  echo $1 echo $2   source 1.sh 诸葛青 shell\n1 2 3 4  #!/bin/bash  echo $1 echo ${2-我就是shell}   source 1.sh 诸葛青（可以解决传入参数不足，默认使用我就是shell）\n 进阶姿势 read  -p：输出提示信息 -t：等待用户输入时间， 如果到了时间就不让用户继续输入了（单位为秒）   1 2 3 4 5  #!/bin/bash  read -t 5 -p \u0026#34;请输入您的名字：\u0026#34; name # 等待5s用户输入 name=${name:-诸葛青} # 如果没有输入任何值则赋予变量默认值 echo \u0026#34;您的名字是$name\u0026#34;   基本语法  “$((运算式))”或“$[运算式]”或者 expr m + n //expression 表达式 注意 expr 运算符间要有空格, 如果希望将 expr 的结果赋给某个变量，使用 temp = `expr 1 + 2` expr m - n expr *, /, % 乘，除，取余   判断 判断语法\n  单分支\nif [ 判断条件 ]\nthen\n代码\nfi\n  多分支\nif [ 判断条件 ]\nthen\n代码\nelif [ 判断条件 ]\nthen\n代码\nfi\n  case\ncase $1 in\n\u0026ldquo;1\u0026rdquo;)\necho \u0026ldquo;周一\u0026rdquo;\n;;\n\u0026ldquo;2\u0026rdquo;)\necho \u0026ldquo;周二\u0026rdquo;\n;;\n\u0026ldquo;3\u0026rdquo;)\necho \u0026ldquo;周三\u0026rdquo;\n;;\n*)\necho \u0026ldquo;other\u0026rdquo;\nesac\n   判断条件：\n 字符串比较：= 数字比较：\n小于：-lt（Less than）\n小于等于：-le（Less than equal）\n大于：-gt（Greater than）\n大于等于：-ge（Greater than equal）\n不等于：-ne（not equal） 按照文件权限进行判断\n有读的权限：-r\n有写的权限：-w\n有执行的权限：-x 按照文件类型进行判断\n文件存在且是一个常规的文件：-f\n文件存在：-e\n是一个目录：-d   循环  for循环  1 2 3 4 5 6 7  #!/bin/bash #从命令行输入一个数 n，统计从 1+..+ n 的值是多少？  SUM=0 for i in `seq 1 $1`; do SUM=`expr $SUM + $i` done echo $SUM   1 2 3 4 5 6 7 8  #!/bin/bash #从命令行输入一个数 n，统计从 1+..+ n 的值是多少？  SUM=0 for ((i = 1; i \u0026lt;= $1; i++)) do SUM=`expr $SUM + $i` done echo $SUM   while循环  1 2 3 4 5 6 7 8 9 10 11  #!/bin/bash #从命令行输入一个数 n，统计从 1+..+ n 的值是多少？  SUM=0 i=0 while [ $i -le $1 ] do SUM=`expr $SUM + $i` i=`expr $i + 1` done echo $SUM   函数 1 2 3 4 5 6 7 8 9 10 11  #!/bin/bash function HelloWorld() { local a=\u0026#34;Hello World\u0026#34; echo $a echo $1 } HelloWorld $1 a=$\u0026#39;111\u0026#39; echo $a   ","description":"Linux Shell脚本","id":39,"section":"linux","tags":["Linux"],"title":"Linux Shell脚本","uri":"https://www.zhugeqing.top/linux/shell%E8%84%9A%E6%9C%AC/"},{"content":"mysql   mysql事务ACID\n  mysql事务并发带来的后果\n  mysql事务隔离级别\n  mysql 悲观锁与乐观锁\n  常见的封锁类型\n  InnoDB是表级锁还是行级锁\n  mvcc\n  linux   vim正常模式\n  vim命令模式\n  ifconfig,ping,traceroute,route,telnet,nslookup,tcpdump,netstat,ss,\n  linux shel脚本执行方式以及不同\n  操作系统   什么是死锁\n  死锁发生的必要条件\n  如何预防死锁\n  git   git log, \u0026ndash;graph,-all,-n2,master\n  git commit -am \u0026ldquo;哈哈\u0026rdquo;\n  git HEAD分离\n  .git文件夹探秘\n  git的commit，tree，blob\n  算法  爬楼梯  ","description":"you can","id":40,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2022-03-30/"},{"content":"headless Service  k8s可以为服务提供负载均衡，但是有时候开发人员希望 能够自己 来控制 负载均衡的策略，Kubernetes提供了Headless Service来实现这种功能，即不为Service设置ClusterIP（入口IP地址），也就是将Service文件中clusterIP设置为 None  pv 和 pvc  pv 就像是 管理员创建了一些硬盘，而 pvc 就是员工排队过来领硬盘的规范  ","description":"k8s 常用知识","id":41,"section":"kubernetes","tags":["k8s"],"title":"k8s 常用知识","uri":"https://www.zhugeqing.top/kubernetes/tip/"},{"content":"mysql   mysql事务ACID\n  mysql事务并发带来的后果\n  mysql事务隔离级别\n  mysql 悲观锁与乐观锁\n  常见的封锁类型\n  InnoDB是表级锁还是行级锁\n  mvcc\n  linux   vim正常模式\n  vim命令模式\n  ifconfig,ping,traceroute,route,telnet,nslookup,tcpdump,netstat,ss,\n  操作系统   什么是死锁\n  死锁发生的必要条件\n  如何预防死锁\n  git   git log, \u0026ndash;graph,-all,-n2,master\n  git commit -am \u0026ldquo;哈哈\u0026rdquo;\n  ","description":"you can","id":42,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2022-03-29/"},{"content":"初步了解  在Kubernetes平台上，很少会直接创建一个Pod，在大多数情况下会通过RC（Replication Controller）、Deployment、DaemonSet、Job等控制器完成对一组Pod副本的创建、调度及全生命周期的自动控制任务。  ReplicaSet  https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/\n  ReplicaSet 的目的是维护一组在任何时候都处于运行状态的 Pod 副本的稳定集合。 因此，它通常用来保证给定数量的、完全相同的 Pod 的可用性。（我们不应该直接使用底层的ReplicaSet来控制Pod副本，而应该使用管理ReplicaSet的Deployment对象来控制副本，这是来自官方的建议。）  快速使用  创建 replicaSet.yaml  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  apiVersion:apps/v1kind:ReplicaSetmetadata:name:nginxspec:replicas:3selector:matchLabels:app:nginxtemplate:metadata:name:nginxlabels:app:nginxspec:containers:- name:nginximage:nginxports:- containerPort:80  执行kubectl apply -f replicaSet.yaml  Deployment  https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/\n  创建 deployment.yaml  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  apiVersion:apps/v1kind:Deploymentmetadata:name:nginxspec:replicas:2selector:matchLabels:app:nginxtemplate:metadata:labels:app:nginxspec:containers:- name:nginximage:nginxresources:limits:memory:\u0026#34;128Mi\u0026#34;cpu:\u0026#34;500m\u0026#34;ports:- containerPort:80   执行kubectl apply -f deployment.yaml\n  可以修改deployment.yaml，再重新执行apply命令，达到扩展副本的效果\n  StatefulSet  https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/\n  删除或者收缩 StatefulSet 并不会删除它关联的存储卷。 这样做是为了保证数据安全，它通常比自动清除 StatefulSet 所有相关的资源更有价值。 当删除 StatefulSets 时，StatefulSet 不提供任何终止 Pod 的保证。 为了实现 StatefulSet 中的 Pod 可以有序地且体面地终止，可以在删除之前将 StatefulSet 缩放为 0。  DaemonSet  https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/\n Job  https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/\n ","description":"k8s 控制器 学习","id":43,"section":"kubernetes","tags":["k8s"],"title":"k8s controller","uri":"https://www.zhugeqing.top/kubernetes/controller/"},{"content":"网络管理   ifconfig\n  查看网络接口命令\n  网络接口名字包含（eno1 板载网卡，ens33 PCI-E网卡，enp0s33无法获取物理信息的PCI-E网卡，如果都不匹配就是eth0）\n  通过在/etc/default/grub的 GRUB_CMDLINE_LINUX行修改biosdevname=0 net.ifnames=0（没有对应参数就加上），然后执行rub2-mkconfig -o /boot/grub2/grub.cfg，重启，即可将网卡名字修改为eth0\n  enss33：biosdevname=0 net.ifnames=1\n  em1：biosdevname=1 net.ifnames=0\n  eth0：biosdevname=0 net.ifnames=0\n  ifconfig docker0 172.17.0.3 netmask 255.255.0.0 修改docker0网络接口和子网掩码\n  ifconfig docker0 up 关闭docker0网络接口\n  ifconfig docker0 down 开启docker0网络接口\n  \n  route\n 查看网关 route -n 加上-n参数，不解析主机名 route add -host 10.0.0.1 gw 10.244.0.0 添加访问10.0.0.1的网关为10.244.0.0的路由规则 route del 10.0.0.1 gw 10.244.0.0删除该条路由规则 route add -net 192.168.0.0 netmask 255.255.255.0 gw 10.244.0.1 添加网段192.168.0.0的路由规则  \n  ping\n 检测与目标主机是否畅通 参数-w，设置等待时间 例：ping -w 2 zhugeqing.top（等待2s，如果没有响应就超时退出）  \n  traceroute\n 跟踪路由 例：traceroute -w 1 www.zhugeqing.top  \n  nslookup\n 查看域名解析  \n  telnet\n 测试目标主机的某个端口是否可达 例:telnet www.zhugeqing.top 80  \n  tcpdump\n 捕获数据包 参数-i 指定对应的网络接口 参数-n 不要将IP地址解析成域名形式显示 参数port 指定端口 参数host 指定主机 例:tcpdump -i any -n port 80 and host 192.0.0.1  \n  netstat\n 查看端口网络连接状态 参数-n 不要将IP地址解析成域名形式显示 参数-u 显示udp协议相关 参数-t 显示tcp协议相关 参数-p 显示对应的进程 参数-l 显示LISTEN状态 参数-e 显示ESTABLISHED状态 例子：netstat -ntpl  \n  ss\n 操作和效果类似netstat，但是更加详细  \n  网络配置文件\n 进入/etc/sysconfig/network-scripts/，修改ifcfg-eth0可以对网络配置进行修改 BOOTPROTO修改为none将会使用手动配置的ip，而不是使用dhcp IPADDR设置IP地址 NETMASK设置子网掩码 gateway设置网关 DNS1 设置域名服务器（也可以DNS2，DNS3） 使用systemctl restart network重启网络  \n  hostnamectl\n 修改主机名 hostnamectl set-hostname zhugeqing.top（需要再将127.0.0.1 zhugeqing.top写入/etc/hosts）  \n  进程管理  进程查看\n ps   单独执行ps只会查看当前终端可以查询到的\nps -ef：以全形式查看当前所有的进程\n-a：当前终端所有进程\n-u：以用户格式显示\n-x：后台进程也显示\n  pstree   以树形结构显示\n  top   动态查看\n   ","description":"Linux服务管理","id":44,"section":"linux","tags":["Linux"],"title":"Linux服务管理","uri":"https://www.zhugeqing.top/linux/%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/"},{"content":"Linux常见目录  / 系统根目录 /root root用户家目录 /bin 命令目录 /sbin 管理命令目录 /etc 配置文件目录 /home/username 普通用户目录 /usr/bin /usr/sbin 系统预装的其他命令  Linux基本命令 帮助命令  man   man 是 manual(手册)的缩写\nman 命令分为9章，同时执行man man来查看，比如man 7 man（主要是为了区分一些重名，比如命令与配置文件重名）\n通过执行LANG=zh_CN.UTF8，可以切换为中文（locale查看当前使用语言）\n  help   shell（命令解释器）自带的命令为内部命令，其他是外部命令\n内部命令： help cd\n外部命令：ls --help\n  info   info 帮助比help更详细，作为help的补充\n比如info ls\n 文件相关命令（一切皆文件）  pwd   显示当前目录名称\n  cd   意为change directory，更改当前的操作目录\ncd -回到上一次的目录\ncd .. 回到上一级目录（通过ls -al可以查看到..和.这两个隐藏目录）\ncd ./root 去当前目录下的root目录\n  ls   查看当前目录的文件\n-l 长格式显示文件（等价于ll）\n-a 显示隐藏文件\n-r 逆序显示\n-t 按照时间顺序显示\n-R 递归显示当前目录下所有文件\n可以使用ls -lartR 和ls -l -a -r -R -t两种组合方式\n  mkdir   创建目录\nmkdir a b c创建 a, b, c多个目录\nmkdir -p /a/b/c创建多级目录\n  rmdir   删除目录（要求目录为空才能删除，除非加上忽略为空的参数）\n  rm   删除目录或文件\n-r 递归删除\n-f 强制删除，不做任何提示\n  cp   复制目录或文件\ncp ./a /root/a，前者为原有文件，后者为目标文件\n-p 保持原始文件的所有者，组，许可，和时间表属性\n-r 递归复制目录\n  mv   移动目录或文件\nmv ./a /root/b，移动并改名为b，前者为原文件，后者为目标文件\nmv ./a* /root/ 使用通配符，将能匹配a的文件进行移动\n  cat   查看文件文本内容显示到终端\ncat a.txt\n  head   查看文件开头\n-size size表示一个数字\nhead -100 hello.txt查看开头100行的内容\n  tail   查看文件结尾\n-size size表示一个数字\ntail -100 hello.txt查看末尾100行的内容\n-f 实时查看\n  wc   统计文件文本信息\nwc a.txt，如果显示内容为10 5 453 a.txt，第一个数表示文件的总行数，第二个数表示文件不为空的行数，第三个数表示文件中字符的数量\nwc -l a.txt 显示文件总行数\n  tar   打包命令\n-c 打包\n-x 解包\n-f 指定文件名\n-v 显示详细信息\n-z 以zip形式压缩（压缩速度比gzip快）\n-j 比bz2形式压缩（压缩比例更高）\ntar -zcvf hello.tar.gz hello将hello文件或者目录进行打包压缩，并显示详细信息\ntar -zxvf hello.tar.gz -C /root/ 进行解包，并放入/root/目录下\n  vim   编辑文本文件\n  最开始进入的就是正常模式\n正常模式下使用k，j，h，l来进行上下左右移动光标（字符终端需要使用这种，不然使用键盘自带的键会有乱码）\n在光标所在行按下yy能复制整行，再按下p就能再下一行进行粘贴\n按下需要复制行的行数，并按下yy，能够复制多行，比如3yy，复制当前行以及之后的两行\n按下y$可以复制光标之后的字符（只是当前行）\n按下dd可以剪切一整行\n按下d$剪切光标这一行之后的字符（包含光标字符）\n按下u可以撤销一次操作\n按下ctrl+r可以重做撤销的操作\n按下x可以删除光标字符\n按下r 再输入一个字符可以替换光标字符\n按下指定行的行数，再按下shift+g可以移动到自定行\n按下^前往光标当前行的行首\n按下$前往光标当前行的行尾\n  按下i, I, a, A, o, O均可进入插入模式\ni在光标当前位置进入插入模式；I在光标的这一行的行首进入插入模式\na在光标的下一个位置进入插入模式；A在光标的这一行的行尾进入插入模式\no在光标当前行后面插入一行并移到这一行的行首，O在光标当前行前面插入一行并移到这一行的行首\n  按下esc再写入:，进入命令模式\nw /root/a.txt将当前编辑的内容保存到/root/a.txt\n按下q表示直接退出，（q!为强制退出）\n按下w表示保存\n按下!在后面接linux中的命令也是回车执行（比如!ls -lh）\n按下esc再写入/，后面接需要查找的文本内容，可以进行查找操作；执行之后按n来查找下一个匹配的文本内容，shift+n匹配上一个；\n在正常模式按下:s/old/new可以将old替换为new（只针对光标当前行，且只替换一个），按下:s/old/new/g可以在光标当前行进行全部替换；按下:%s/old/new可以进行全文件每一行单次的替换，:%s/old/new/g进行全文件全部替换\n输入:set nu可以显示行号，:set nonu显示行号\n编辑文件/etc/vimrc，并在末尾添加set nu可以使得每次使用vim编辑文件都能显示行号。\n ","description":"Linux基本系统操作","id":45,"section":"linux","tags":["Linux"],"title":"Linux系统操作","uri":"https://www.zhugeqing.top/linux/%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C/"},{"content":"快速使用  Pod 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。 Pod 是一组（一个或多个） 容器； 这些容器共享存储、网络、以及怎样运行这些容器的声明。 如果一个Pod 由多个容器构成，那么这些容器将绑定在同一个环境中，可以理解为这些应用在同一个主机中运行。   创建一个 nginx Pod\n step 1: 便携nginx.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  apiVersion:v1kind:Podmetadata:name:my-nginxlabels:name:my-nginxspec:containers:- name:my-nginximage:nginxresources:limits:memory:\u0026#34;128Mi\u0026#34;cpu:\u0026#34;500m\u0026#34;ports:- containerPort:80  step 2: 通过yaml文件创建 Pod  kubectl create -f nginx.yaml （创建pod） kubectl get pod （查看pod运行情况）   -w 持续查看\n  kubectl describe pod my-nginx （查看pod信息） kubectl exec -it my-nginx sh （进入容器内部） kubectl delete pod my-nginx （删除Pod） kubectl delete -f nginx.yaml（删除Pod）  Pod 生命周期   Pod Phase  Pending（挂起）：Pod 已被 Kubernetes 系统接受，但有一个或者多个容器尚未创建亦未运行。此阶段包括等待 Pod 被调度的时间和通过网络下载镜像的时间。 Running（运行中）：Pod 已经绑定到了某个节点，Pod 中所有的容器都已被创建。至少有一个容器仍在运行，或者正处于启动或重启状态。 Succeeded（成功）：Pod 中的所有容器都已成功终止，并且不会再重启。   也就是调度任务成功执行完成\n  Failed（失败）\tPod 中的所有容器都已终止，并且至少有一个容器是因为失败终止。也就是说，容器以非 0 状态退出或者被系统终止。 Unknown（未知）\t因为某些原因无法取得 Pod 的状态。这种情况通常是因为与 Pod 所在主机通信失败。  为容器的生命周期事件设置处理函数  https://kubernetes.io/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/\n 定义 postStart 和 preStop 处理函数  Kubernetes 在容器创建后立即发送 postStart 事件 Kubernetes 在容器结束前立即发送 preStop 事件  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  apiVersion:v1kind:Podmetadata:name:lifecycle-demospec:containers:- name:lifecycle-demo-containerimage:nginxlifecycle:postStart:exec:command:[\u0026#34;/bin/sh\u0026#34;,\u0026#34;-c\u0026#34;,\u0026#34;echo Hello from the postStart handler \u0026gt; /usr/share/message\u0026#34;]preStop:exec:command:[\u0026#34;/bin/sh\u0026#34;,\u0026#34;-c\u0026#34;,\u0026#34;nginx -s quit; while killall -0 nginx; do sleep 1; done\u0026#34;]  创建包含Init容器的Pod  https://kubernetes.io/docs/concepts/workloads/pods/init-containers/\n  每个 Pod 中可以包含多个容器， 应用运行在这些容器里面，同时 Pod 也可以有一个或多个先于应用容器启动的 Init 容器。 总是运行到完成 如果Pod 的Init容器运行失败，k8s 会不断重启 该Pod（除非设置restartPolicy 为 Never） Init 容器支持应用容器的全部字段和特性，包括资源限制、数据卷和安全设置，不支持 lifecycle、livenessProbe、readinessProbe 和 startupProbe， 因为它们必须在 Pod 就绪之前运行完成。  创建 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  apiVersion:v1kind:Podmetadata:name:init-myapplabels:app:init-myappspec:containers:- name:myapp-containerimage:busybox:1.28command:[\u0026#34;sh\u0026#34;,\u0026#34;-c\u0026#34;,\u0026#34;echo The app is running! \u0026amp;\u0026amp; sleep 3600\u0026#34;]resources:limits:memory:\u0026#34;128Mi\u0026#34;cpu:\u0026#34;500m\u0026#34;initContainers:- name:init-containerimage:busybox:1.28command:[\u0026#34;sh\u0026#34;,\u0026#34;-c\u0026#34;,\u0026#34;echo The app is Inited! \u0026amp;\u0026amp; sleep 10\u0026#34;]   kubectl create -f InitPod.yaml （创建Pod） kubectl logs init-myapp-c myapp-container（查看 init-myapp Pod 中Init容器之后的第一个容器） kubectl logs init-myapp -c init-container （查看init-myapp Pod 中 Init容器日志） kubectl get -f initpod.yaml -w  用探针检查 Pod的健康性  https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#container-probes\nhttps://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/\n  probe(探针) 是由 kubelet 对容器执行的定期诊断。 要执行诊断，kubelet 既可以在容器内执行代码，也可以发出一个网络请求  探针机制  exec：在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。 grpc：使用 gRPC 执行一个远程过程调用。 目标应该实现 gRPC健康检查。 如果响应的状态是 \u0026ldquo;SERVING\u0026rdquo;，则认为诊断成功。\nhttpGet：对容器的 IP 地址上指定端口和路径执行 HTTP GET 请求。如果响应的状态码大于等于 200 且小于 400，则诊断被认为是成功的。\ntcpSocket：对容器的 IP 地址上的指定端口执行 TCP 检查。如果端口打开，则诊断被认为是成功的。  探测结果  Success（成功）：容器通过了诊断。 Failure（失败）：容器未通过诊断。 Unknown（未知）：诊断失败，因此不  尝试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  apiVersion:v1kind:Podmetadata:labels:test:livenessname:liveness-httpspec:containers:- name:livenessimage:mirrorgooglecontainers/livenessargs:- /serverlivenessProbe:httpGet:path:/healthzport:8080httpHeaders:- name:Custom-Headervalue:AwesomeinitialDelaySeconds:3periodSeconds:3   在这个配置文件中，periodSeconds 字段指定了 kubelet 每隔 3 秒执行一次存活探测。 initialDelaySeconds 字段告诉 kubelet 在执行第一次探测前应该等待 3 秒。 kubelet 会向容器内运行的服务（服务在监听 8080 端口）发送一个 HTTP GET 请求来执行探测。 如果服务器上 /healthz 路径下的处理程序返回成功代码，则 kubelet 认为容器是健康存活的。 如果处理程序返回失败代码，则 kubelet 会杀死这个容器并将其重启。  为容器设置启动时要执行的命令和参数  https://kubernetes.io/zh-cn/docs/tasks/inject-data-application/define-command-argument-container/\n 为容器定义相互依赖的环境变量  https://kubernetes.io/zh-cn/docs/tasks/inject-data-application/define-interdependent-environment-variables/\n  使用的变量需要提前定义，不然无法使用  为容器和 Pods 分配 CPU 资源  https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/assign-cpu-resource/\n  启动容器时一定要主要对cpu资源进行限制 Pod 调度是基于资源请求值来进行的。 仅在某节点具有足够的 CPU 资源来满足 Pod CPU 请求时，Pod 将会在对应节点上运行，比如当resource-request-cpu超过所有节点时，尽管args-cpus设置的比较低也是无法调度Pod的  用节点亲和性把 Pods 分配到对应节点上  https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/assign-pods-nodes-using-node-affinity/\n  kubectl get nodes --show-labels，列出集群中的节点及其标签 kubectl label node node2 disktype=ssd选择一个节点（比如这里选择node2节点），给它添加一个标签 创建yaml文件  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  apiVersion:v1kind:Podmetadata:name:nginxspec:affinity:nodeAffinity:requiredDuringSchedulingIgnoredDuringExecution:nodeSelectorTerms:- matchExpressions:- key:disktypeoperator:Invalues:- ssd containers:- name:nginximage:nginximagePullPolicy:IfNotPresent  4.创建Pod，发现运行在node2上（可以再修改lable 和 yaml文件尝试）\n将configmap数据注入容器  编写configmap.yaml（定义configmap 和 Pod）  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  apiVersion:v1kind:ConfigMapmetadata:name:my-db-configdata:db-url:localhost---apiVersion:v1kind:Podmetadata:name:myapplabels:name:myappspec:containers:- name:myappimage:busyboxcommand:[\u0026#34;sh\u0026#34;,\u0026#34;-c\u0026#34;,\u0026#34;env\u0026#34;]envFrom:- configMapRef:name:my-db-configresources:limits:memory:\u0026#34;128Mi\u0026#34;cpu:\u0026#34;500m\u0026#34;  kubectl create -f configmap.yaml （创建资源）  使用非 root 用户 运行 Pod docker 用户权限  对于docker 来说，启动容器，默认是赋予 root 权限，但是这个root用户 权限比较少，比如无法修改hostname，需要赋予更高特权模式权限， 在运行时加入参数 --privileged  为 Pod 或容器配置安全上下文  https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/security-context/\n ","description":"k8s Pod学习","id":46,"section":"kubernetes","tags":["k8s"],"title":"k8s Pod","uri":"https://www.zhugeqing.top/kubernetes/pod/"},{"content":"Service 快速使用  通过创建Service，可以为一组具有相同功能的Pod提供一个统一的入口地址，并且将请求负载分发到后端的各个Pod应用上\nhttps://kubernetes.io/zh-cn/docs/concepts/services-networking/service/\n  创建service.yaml  1 2 3 4 5 6 7 8 9 10  apiVersion:v1kind:Servicemetadata:name:my-nginxspec:selector:run:my-nginxports:- port:80targetPort:80  创建pod.yaml  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  apiVersion:apps/v1kind:Deploymentmetadata:name:my-nginxspec:selector:matchLabels:run:my-nginxreplicas:2template:metadata:labels:run:my-nginxspec:containers:- name:my-nginximage:nginxresources:limits:memory:\u0026#34;128Mi\u0026#34;cpu:\u0026#34;500m\u0026#34;ports:- containerPort:80   执行命令 kubectl create -f nginx-service.yaml，kubectl create -f nginx-deployment.yaml\n  执行 kubectl describe svc my-nginx，ubectl get pods -l run=my-nginx -o yaml | grep podIP 查看相关信息\n  Service 服务发现  https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#discovering-services\nhttps://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/#pod-sethostnameasfqdn-field\n  Service 服务发现一共有环境变量 和 DNS 两种方式 环境变量：需要注意 相关联的 Service 需要在 Pod之前创建，不然环境变量无法自动注入 DNS：可以为Service 和 POd 定义 DNS记录  快速创建Pod的 DNS记录  编写dns.yaml文件（注意hostname 和 subdomain字段）  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  apiVersion:v1kind:Servicemetadata:name:busyboxspec:selector:app:busyboxports:- port:80targetPort:80---apiVersion:v1kind:Podmetadata:name:busybox-1labels:app:busyboxspec:hostname:busybox-1subdomain:default-subdomaincontainers:- name:busyboximage:busybox:1.28command:[\u0026#34;sh\u0026#34;,\u0026#34;-c\u0026#34;,\u0026#34;sleep 1h\u0026#34;]resources:limits:memory:\u0026#34;128Mi\u0026#34;cpu:\u0026#34;500m\u0026#34;ports:- containerPort:80---apiVersion:v1kind:Podmetadata:name:busybox-2labels:app:busyboxspec:hostname:busybox-2subdomain:default-subdomaincontainers:- name:myappimage:busybox:1.28command:[\u0026#34;sh\u0026#34;,\u0026#34;-c\u0026#34;,\u0026#34;sleep 1h\u0026#34;]resources:limits:memory:\u0026#34;128Mi\u0026#34;cpu:\u0026#34;500m\u0026#34;ports:- containerPort:80   执行kubectl create -f dns.yaml\n  执行kubectl exec -it busybox-1 sh 或者 kubectl exec -it busybox-2 sh 进入Pod 容器内部\n  执行hostname -f 查看容器当前完整DNS记录\n  从集群外部访问 Service  https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#type-nodeport\n ","description":"k8s Service学习","id":47,"section":"kubernetes","tags":["k8s"],"title":"k8s Service","uri":"https://www.zhugeqing.top/kubernetes/service/"},{"content":"安装 Dashboard  均操作在 master上\n  wget https://zhugeqing.top/kubernetes/kubernetes-dashboard.yaml kubectl create -f kubernetes-dashboard.yaml 访问https://ip:port ，默认yaml文件里面的端口为31111 输入kubectl -n kube-system describe $(kubectl -n kube-system get secret -n kube-system -o name | grep namespace) | grep token ，得到token后输入在登陆界面  k8s 命令补全（centos） 1 2 3 4 5 6 7 8  #!/bin/bash yum -y install bash-completion source /usr/share/bash-completion/bash_completion source \u0026lt;(kubectl completion bash) # 添加别名 echo \u0026#34;alias kc=\u0026#39;kubectl\u0026#39;\u0026#34; \u0026gt;\u0026gt; ~/.bashrc echo \u0026#34;source \u0026lt;(kubectl completion bash | sed \u0026#39;s/kubectl/kc/g\u0026#39; )\u0026#34; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc   ","description":"安装一些k8s的插件","id":48,"section":"kubernetes","tags":["k8s"],"title":"安装k8s 插件","uri":"https://www.zhugeqing.top/kubernetes/plugins-install/"},{"content":"忘记master节点init后的join命令怎么办  在master节点上 执行 kubeadm token create --print-join-command，然后将打印出来的对应 命令在 work节点上运行  升级k8s   用最新的补丁版本号替换 1.24.x-0 中的 x\nyum install -y kubeadm-1.24.x-0 --disableexcludes=kubernetes\n  用最新的补丁版本号替换 1.24.x-00 中的 x\nyum install -y kubelet-1.24.x-0 kubectl-1.24.x-0 --disableexcludes=kubernetes\n  查看可以安装的版本\nyum list --showduplicates kubeadm --disableexcludes=kubernetes\nyum list --showduplicates kubelet --disableexcludes=kubernetes\nyum list --showduplicates kubectl --disableexcludes=kubernetes\n  k8s 被限制映射的端口   vim /etc/kubernetes/manifests/kube-apiserver.yaml\n  在 spec.containers.command下添加\n- --service-node-port-range=1-65535\n  ","description":"解决一些在k8s中遇到的问题","id":49,"section":"kubernetes","tags":["k8s"],"title":"k8s的一些问题","uri":"https://www.zhugeqing.top/kubernetes/problems/"},{"content":"Linux版本为centos 7.x，建议全部看完再进行操作  准备工作  有两种安装需求，第一种就是主机都是内网IP能ping通的（比如自己电脑的两个虚拟机）。第二种用公网才能Ping通的（比如两台云服务器），下面会对两者进行区别。\n  先开启云服务器控制台的的端口TCP入规则   端口：6443,2379,2380,80,2381\n 在同一个网络的机器  把脚本放入对应机器执行即可（记得修改基本里面的一些参数，比如IP地址）\n这里用虚拟机 中ip地址做示例，master IP为 192.168.200.128，node1为 192.168.200.129\nkubernete版本选择 v1.23.4-0\n Master节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164  #!/bin/bash set -e # 安装日志 install_log=/var/log/install_k8s.log tm=$(date +\u0026#39;%Y%m%d %T\u0026#39;) # 日志颜色 COLOR_G=\u0026#34;\\x1b[0;32m\u0026#34; # green RESET=\u0026#34;\\x1b[0m\u0026#34; function info(){ echo -e \u0026#34;${COLOR_G}[$tm] [Info] ${1}${RESET}\u0026#34; } function run_cmd(){ sh -c \u0026#34;$1| $(tee -a \u0026#34;$install_log\u0026#34;)\u0026#34; } function run_function(){ $1 | tee -a \u0026#34;$install_log\u0026#34; } function install_docker(){ info \u0026#34;1.使用脚本自动安装docker...\u0026#34; curl -sSL https://get.daocloud.io/docker | sh info \u0026#34;2.启动 Docker CE...\u0026#34; systemctl enable docker systemctl start docker info \u0026#34;3.添加镜像加速器...\u0026#34; if [ ! -f \u0026#34;/etc/docker/daemon.json\u0026#34; ];then touch /etc/docker/daemon.json fi cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/docker/daemon.json { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://registry.cn-hangzhou.aliyuncs.com\u0026#34;], \u0026#34;exec-opts\u0026#34;: [\u0026#34;native.cgroupdriver=systemd\u0026#34;] } EOF info \u0026#34;4.重新启动服务...\u0026#34; systemctl daemon-reload systemctl restart docker info \u0026#34;5.测试 Docker 是否安装正确...\u0026#34; docker run hello-world info \u0026#34;6.检测...\u0026#34; docker info } function install_k8s() { info \u0026#34;初始化k8s部署环境...\u0026#34; init_env info \u0026#34;添加k8s安装源...\u0026#34; add_aliyun_repo info \u0026#34;安装kubelet kubeadmin kubectl...\u0026#34; install_kubelet_kubeadmin_kubectl info \u0026#34;安装kubernetes master...\u0026#34; yum -y install net-tools if [[ ! \u0026#34;$(ps aux | grep \u0026#39;kubernetes\u0026#39; | grep -v \u0026#39;grep\u0026#39;)\u0026#34; ]];then kubeadmin_init else info \u0026#34;kubernetes master已经安装...\u0026#34; fi info \u0026#34;安装网络插件flannel...\u0026#34; install_flannel info \u0026#34;去污点...\u0026#34; kubectl taint nodes --all node-role.kubernetes.io/master- } # 初始化部署环境 function init_env() { info \u0026#34;关闭防火墙\u0026#34; systemctl stop firewalld systemctl disable firewalld info \u0026#34;关闭selinux\u0026#34; sed -i \u0026#39;s/^SELINUX=enforcing$/SELINUX=disabled/g\u0026#39; /etc/selinux/config source /etc/selinux/config info \u0026#34;关闭swap（k8s禁止虚拟内存以提高性能）\u0026#34; swapoff -a sed -i \u0026#39;/swap/s/^\\(.*\\)$/#\\1/g\u0026#39; /etc/fstab info \u0026#34;设置网桥参数\u0026#34; cat \u0026lt;\u0026lt;-EOF \u0026gt; /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sysctl --system #生效 sysctl -w net.ipv4.ip_forward=1 } # 添加aliyun安装源 function add_aliyun_repo() { cat \u0026gt; /etc/yum.repos.d/kubernetes.repo \u0026lt;\u0026lt;- EOF [kubernetes] name=Kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgcheck=0 repo_gpgcheck=0 gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg EOF } function install_kubelet_kubeadmin_kubectl() { yum install kubelet-1.23.4 kubeadm-1.23.4 kubectl-1.23.4 -y systemctl enable kubelet.service info \u0026#34;确认kubelet kubeadmin kubectl是否安装成功\u0026#34; yum list installed | grep kubelet yum list installed | grep kubeadm yum list installed | grep kubectl kubelet --version } function kubeadmin_init() { sleep 1 # 修改 ip=192.168.200.128 hostnamectl set-hostname master cat \u0026gt;\u0026gt; /etc/hosts \u0026lt;\u0026lt; EOF ${ip} master 192.168.200.129 node1 192.168.200.130 node2 EOF kubeadm init --apiserver-advertise-address=\u0026#34;${ip}\u0026#34; --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.23.4 --service-cidr=10.96.0.0/12 --pod-network-cidr=10.244.0.0/16 mkdir -p \u0026#34;$HOME\u0026#34;/.kube cp -i /etc/kubernetes/admin.conf \u0026#34;$HOME\u0026#34;/.kube/config chown \u0026#34;$(id -u)\u0026#34;:\u0026#34;$(id -g)\u0026#34; \u0026#34;$HOME\u0026#34;/.kube/config } function install_flannel() { yum -y install wget wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml kubectl apply -f kube-flannel.yml } # 安装docker read -p \u0026#34;是否安装docker？默认为：no. Enter [yes/no]：\u0026#34; is_docker if [[ \u0026#34;$is_docker\u0026#34; == \u0026#39;yes\u0026#39; ]];then run_function \u0026#34;install_docker\u0026#34; fi # 安装k8s read -p \u0026#34;是否安装k8s？默认为：no. Enter [yes/no]：\u0026#34; is_k8s if [[ \u0026#34;$is_k8s\u0026#34; == \u0026#39;yes\u0026#39; ]];then run_function \u0026#34;install_k8s\u0026#34; fi   Work Node  下面为node1\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151  #!/bin/bash set -e # 安装日志 install_log=/var/log/install_k8s.log tm=$(date +\u0026#39;%Y%m%d %T\u0026#39;) # 日志颜色 COLOR_G=\u0026#34;\\x1b[0;32m\u0026#34; # green RESET=\u0026#34;\\x1b[0m\u0026#34; function info(){ echo -e \u0026#34;${COLOR_G}[$tm] [Info] ${1}${RESET}\u0026#34; } function run_cmd(){ sh -c \u0026#34;$1| $(tee -a \u0026#34;$install_log\u0026#34;)\u0026#34; } function run_function(){ $1 | tee -a \u0026#34;$install_log\u0026#34; } function install_docker(){ info \u0026#34;1.使用脚本自动安装docker...\u0026#34; curl -sSL https://get.daocloud.io/docker | sh info \u0026#34;2.启动 Docker CE...\u0026#34; systemctl enable docker systemctl start docker info \u0026#34;3.添加镜像加速器...\u0026#34; if [ ! -f \u0026#34;/etc/docker/daemon.json\u0026#34; ];then touch /etc/docker/daemon.json fi cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/docker/daemon.json { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://registry.cn-hangzhou.aliyuncs.com\u0026#34;], \u0026#34;exec-opts\u0026#34;: [\u0026#34;native.cgroupdriver=systemd\u0026#34;] } EOF info \u0026#34;4.重新启动服务...\u0026#34; systemctl daemon-reload systemctl restart docker info \u0026#34;5.测试 Docker 是否安装正确...\u0026#34; docker run hello-world info \u0026#34;6.检测...\u0026#34; docker info } function install_k8s() { info \u0026#34;初始化k8s部署环境...\u0026#34; init_env info \u0026#34;添加k8s安装源...\u0026#34; add_aliyun_repo info \u0026#34;安装kubelet kubeadmin kubectl...\u0026#34; install_kubelet_kubeadmin_kubectl info \u0026#34;安装kubernetes master...\u0026#34; yum -y install net-tools if [[ ! \u0026#34;$(ps aux | grep \u0026#39;kubernetes\u0026#39; | grep -v \u0026#39;grep\u0026#39;)\u0026#34; ]];then kubeadmin_init else info \u0026#34;kubernetes master已经安装...\u0026#34; fi } # 初始化部署环境 function init_env() { info \u0026#34;关闭防火墙\u0026#34; systemctl stop firewalld systemctl disable firewalld info \u0026#34;关闭selinux\u0026#34; sed -i \u0026#39;s/^SELINUX=enforcing$/SELINUX=disabled/g\u0026#39; /etc/selinux/config source /etc/selinux/config info \u0026#34;关闭swap（k8s禁止虚拟内存以提高性能）\u0026#34; swapoff -a sed -i \u0026#39;/swap/s/^\\(.*\\)$/#\\1/g\u0026#39; /etc/fstab info \u0026#34;设置网桥参数\u0026#34; cat \u0026lt;\u0026lt;-EOF \u0026gt; /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sysctl --system #生效 sysctl -w net.ipv4.ip_forward=1 } # 添加aliyun安装源 function add_aliyun_repo() { cat \u0026gt; /etc/yum.repos.d/kubernetes.repo \u0026lt;\u0026lt;- EOF [kubernetes] name=Kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgcheck=0 repo_gpgcheck=0 gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg EOF } function install_kubelet_kubeadmin_kubectl() { yum install kubelet-1.23.4 kubeadm-1.23.4 kubectl-1.23.4 -y systemctl enable kubelet.service info \u0026#34;确认kubelet kubeadmin kubectl是否安装成功\u0026#34; yum list installed | grep kubelet yum list installed | grep kubeadm yum list installed | grep kubectl kubelet --version } function kubeadmin_init() { sleep 1 # 修改 hostnamectl set-hostname node1 cat \u0026gt;\u0026gt; /etc/hosts \u0026lt;\u0026lt; EOF 192.168.200.128 master 192.168.200.129 node1 192.168.200.130 node2 EOF ## 修改 mkdir -p /etc/cni/net.d/ read -p \u0026#34;请将 master 节点的 admin.conf 拷贝到 node1（20秒后自动跳过，在master上执行 scp /etc/kubernetes/admin.conf root@node1:/etc/kubernetes/）:\u0026#34; -t 20 a read -p \u0026#34;请将master节点下面 /etc/cni/net.d/下面的所有文件拷贝到node节点上（20秒后自动跳过，在master上执行scp /etc/cni/net.d/* root@node1:/etc/cni/net.d/）\u0026#34; -t 20 a mkdir -p \u0026#34;$HOME\u0026#34;/.kube cp -i /etc/kubernetes/admin.conf \u0026#34;$HOME\u0026#34;/.kube/config chown \u0026#34;$(id -u)\u0026#34;:\u0026#34;$(id -g)\u0026#34; \u0026#34;$HOME\u0026#34;/.kube/config } # 安装docker read -p \u0026#34;是否安装docker？默认为：no. Enter [yes/no]：\u0026#34; is_docker if [[ \u0026#34;$is_docker\u0026#34; == \u0026#39;yes\u0026#39; ]];then run_function \u0026#34;install_docker\u0026#34; fi # 安装k8s read -p \u0026#34;是否安装k8s？默认为：no. Enter [yes/no]：\u0026#34; is_k8s if [[ \u0026#34;$is_k8s\u0026#34; == \u0026#39;yes\u0026#39; ]];then run_function \u0026#34;install_k8s\u0026#34; fi    下面为node2\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151  #!/bin/bash set -e # 安装日志 install_log=/var/log/install_k8s.log tm=$(date +\u0026#39;%Y%m%d %T\u0026#39;) # 日志颜色 COLOR_G=\u0026#34;\\x1b[0;32m\u0026#34; # green RESET=\u0026#34;\\x1b[0m\u0026#34; function info(){ echo -e \u0026#34;${COLOR_G}[$tm] [Info] ${1}${RESET}\u0026#34; } function run_cmd(){ sh -c \u0026#34;$1| $(tee -a \u0026#34;$install_log\u0026#34;)\u0026#34; } function run_function(){ $1 | tee -a \u0026#34;$install_log\u0026#34; } function install_docker(){ info \u0026#34;1.使用脚本自动安装docker...\u0026#34; curl -sSL https://get.daocloud.io/docker | sh info \u0026#34;2.启动 Docker CE...\u0026#34; systemctl enable docker systemctl start docker info \u0026#34;3.添加镜像加速器...\u0026#34; if [ ! -f \u0026#34;/etc/docker/daemon.json\u0026#34; ];then touch /etc/docker/daemon.json fi cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/docker/daemon.json { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://registry.cn-hangzhou.aliyuncs.com\u0026#34;], \u0026#34;exec-opts\u0026#34;: [\u0026#34;native.cgroupdriver=systemd\u0026#34;] } EOF info \u0026#34;4.重新启动服务...\u0026#34; systemctl daemon-reload systemctl restart docker info \u0026#34;5.测试 Docker 是否安装正确...\u0026#34; docker run hello-world info \u0026#34;6.检测...\u0026#34; docker info } function install_k8s() { info \u0026#34;初始化k8s部署环境...\u0026#34; init_env info \u0026#34;添加k8s安装源...\u0026#34; add_aliyun_repo info \u0026#34;安装kubelet kubeadmin kubectl...\u0026#34; install_kubelet_kubeadmin_kubectl info \u0026#34;安装kubernetes master...\u0026#34; yum -y install net-tools if [[ ! \u0026#34;$(ps aux | grep \u0026#39;kubernetes\u0026#39; | grep -v \u0026#39;grep\u0026#39;)\u0026#34; ]];then kubeadmin_init else info \u0026#34;kubernetes master已经安装...\u0026#34; fi } # 初始化部署环境 function init_env() { info \u0026#34;关闭防火墙\u0026#34; systemctl stop firewalld systemctl disable firewalld info \u0026#34;关闭selinux\u0026#34; sed -i \u0026#39;s/^SELINUX=enforcing$/SELINUX=disabled/g\u0026#39; /etc/selinux/config source /etc/selinux/config info \u0026#34;关闭swap（k8s禁止虚拟内存以提高性能）\u0026#34; swapoff -a sed -i \u0026#39;/swap/s/^\\(.*\\)$/#\\1/g\u0026#39; /etc/fstab info \u0026#34;设置网桥参数\u0026#34; cat \u0026lt;\u0026lt;-EOF \u0026gt; /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sysctl --system #生效 sysctl -w net.ipv4.ip_forward=1 } # 添加aliyun安装源 function add_aliyun_repo() { cat \u0026gt; /etc/yum.repos.d/kubernetes.repo \u0026lt;\u0026lt;- EOF [kubernetes] name=Kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgcheck=0 repo_gpgcheck=0 gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg EOF } function install_kubelet_kubeadmin_kubectl() { yum install kubelet-1.23.4 kubeadm-1.23.4 kubectl-1.23.4 -y systemctl enable kubelet.service info \u0026#34;确认kubelet kubeadmin kubectl是否安装成功\u0026#34; yum list installed | grep kubelet yum list installed | grep kubeadm yum list installed | grep kubectl kubelet --version } function kubeadmin_init() { sleep 1 # 修改 hostnamectl set-hostname node2 cat \u0026gt;\u0026gt; /etc/hosts \u0026lt;\u0026lt; EOF 192.168.200.128 master 192.168.200.129 node1 192.168.200.130 node2 EOF ## 修改 mkdir -p /etc/cni/net.d/ read -p \u0026#34;请将 master 节点的 admin.conf 拷贝到 node2（20秒后自动跳过，在master上执行 scp /etc/kubernetes/admin.conf root@node2:/etc/kubernetes/）:\u0026#34; -t 20 a read -p \u0026#34;请将master节点下面 /etc/cni/net.d/下面的所有文件拷贝到node节点上（20秒后自动跳过，在master上执行scp /etc/cni/net.d/* root@node2:/etc/cni/net.d/）\u0026#34; -t 20 a mkdir -p \u0026#34;$HOME\u0026#34;/.kube cp -i /etc/kubernetes/admin.conf \u0026#34;$HOME\u0026#34;/.kube/config chown \u0026#34;$(id -u)\u0026#34;:\u0026#34;$(id -g)\u0026#34; \u0026#34;$HOME\u0026#34;/.kube/config } # 安装docker read -p \u0026#34;是否安装docker？默认为：no. Enter [yes/no]：\u0026#34; is_docker if [[ \u0026#34;$is_docker\u0026#34; == \u0026#39;yes\u0026#39; ]];then run_function \u0026#34;install_docker\u0026#34; fi # 安装k8s read -p \u0026#34;是否安装k8s？默认为：no. Enter [yes/no]：\u0026#34; is_k8s if [[ \u0026#34;$is_k8s\u0026#34; == \u0026#39;yes\u0026#39; ]];then run_function \u0026#34;install_k8s\u0026#34; fi   不同网络的机器  把上面脚本放入对应机器，先不要执行！\n 先写好配置文件  先编辑好一个要用的etcd需要配置的文件 vim ectd.yaml（只有第二种需要操作）   将下面的公网IP替换成自己云服务器的公网IP（需要四处）\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  apiVersion:v1kind:Podmetadata:annotations:kubeadm.kubernetes.io/etcd.advertise-client-urls:https://公网IP:2379creationTimestamp:nulllabels:component:etcdtier:control-planename:etcdnamespace:kube-systemspec:containers:- command:- etcd- --advertise-client-urls=https://公网IP:2379- --cert-file=/etc/kubernetes/pki/etcd/server.crt- --client-cert-auth=true- --data-dir=/var/lib/etcd- --initial-advertise-peer-urls=https://公网IP:2380- --initial-cluster=master-k8s=https://公网IP:2380- --key-file=/etc/kubernetes/pki/etcd/server.key- --listen-metrics-urls=http://127.0.0.1:2381- --listen-client-urls=https://0.0.0.0:2379- --listen-peer-urls=https://0.0.0.0:2380- --name=master-k8s- --peer-cert-file=/etc/kubernetes/pki/etcd/peer.crt- --peer-client-cert-auth=true- --peer-key-file=/etc/kubernetes/pki/etcd/peer.key- --peer-trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt- --snapshot-count=10000- --trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crtimage:registry.aliyuncs.com/google_containers/etcd:3.4.3-0imagePullPolicy:IfNotPresentlivenessProbe:failureThreshold:8httpGet:host:127.0.0.1path:/healthport:2381scheme:HTTPinitialDelaySeconds:15timeoutSeconds:15name:etcdresources:{}volumeMounts:- mountPath:/var/lib/etcdname:etcd-data- mountPath:/etc/kubernetes/pki/etcdname:etcd-certshostNetwork:truepriorityClassName:system-cluster-criticalvolumes:- hostPath:path:/etc/kubernetes/pki/etcdtype:DirectoryOrCreatename:etcd-certs- hostPath:path:/var/lib/etcdtype:DirectoryOrCreatename:etcd-datastatus:{}  master开始执行  chmod 777 master.sh 赋予执行权限 sh k8s.sh 执行脚本 当再开一个ssh终端连接master云服务器，当执行shell脚本出现[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory \u0026quot;/etc/kubernetes/manifests\u0026quot;. This can take up to 4m0s时候，在新开的终终端执行cat etcd.yaml \u0026gt; /etc/kubernetes/manifests/etcd.yaml  报错处理 worknode 无法执行kubectl  work node节点上执行kubectl出现The connection to the server localhost:8080 was refused - did you specify the right host or port?   解决：没有将admin.conf拷贝成功\n  需要执行  1 2 3  mkdir -p \u0026#34;$HOME\u0026#34;/.kube cp -i /etc/kubernetes/admin.conf \u0026#34;$HOME\u0026#34;/.kube/config chown \u0026#34;$(id -u)\u0026#34;:\u0026#34;$(id -g)\u0026#34; \u0026#34;$HOME\u0026#34;/.kube/config    如果本机没有admin.conf，需要将master上的文件拷贝过来，例如：scp /etc/kubernetes/admin.conf root@node1:/etc/kubernetes/  安装之后Pod无法访问外部域名，或者外部无法ping Pod  参考文章：https://blog.csdn.net/qq_47855463/article/details/119682175\n   安装的cni报错 vxlan_network.go:198] failed to add vxlanRoute (10.244.1.0/24 -\u0026gt; 10.244.1.0): network is down\n  查看node1 和 node2，发现flannel网卡没有IP地址，删除网卡ip link delete flannel.1，重启network systemctl restart network，在控制平面节点上删除CNIkubectl delete -f kube-flannel.yml，重新安装\nkubectl apply -f kube-flannel.yml\n  出现问题需要根据报错来处理，情况多样。\n  ","description":"安装中...","id":50,"section":"kubernetes","tags":["k8s"],"title":"k8s的安装","uri":"https://www.zhugeqing.top/kubernetes/k8s-install/"},{"content":"释放Linux cache 先查询一下空闲内存  手动清理——echo 3 \u0026gt; /proc/sys/vm/drop_caches cat /proc/meminfo | grep \u0026quot;MemFree\u0026quot; | awk '{print $2}'  编写脚本  并赋予权限\n 1 2 3 4 5 6 7 8 9  #! /bin/bash #Memory小于 一般情况下的内存 时 释放Cached的内存 least=1156184 freemem=$(cat /proc/meminfo | grep \u0026#34;MemFree\u0026#34; | awk \u0026#39;{print $2}\u0026#39;) if [ $freemem -le $least ];then sync # 同步一下 sync echo 3 \u0026gt; /proc/sys/vm/drop_caches # 释放 fi   设置定时任务  输入crontab –e编辑定时任务 输入*/3 * * * * /root/linux_study/release_memory.sh按照vim操作保存   每隔三分钟执行一次\n  通过crontab -l查看定时任务  给命令设置别名  示例 设置 kubectl 别名 为 kc\n  echo \u0026quot;alias kc='kubectl'\u0026quot; \u0026gt;\u0026gt; /etc/bashrc source /etc/bashrc  ","description":"linux 小技巧","id":51,"section":"linux","tags":["Linux"],"title":"linux 小技巧","uri":"https://www.zhugeqing.top/linux/tips/"},{"content":"内存限制   使用docker stats 可以查看容器的内存使用状态。\n  以docker 限制 redis使用内存为例：\n docker run -d -m 500M --memory-swap -1 -name redis zhugeqing/redis redis-server 上面容器启动命令的 -m参数指定容器的最大使用内存为500M -- memory-swap -1表示容器程序使用内存的受限，而可以使用的 swap 空间使用不受限制(宿主机有多少 swap 容器就可以使用多少)。  \n  docker update --memory 1200M --memory-swap 1400M redis\n   更新容器 redis的内存限制\n-memory 1200M --memory-swap 1400M表示容器能使用的内存为1200M，但swap能使用1400M-1200M，也就是200M，如果不对--memory-swap设置或者是设置为0，则表示能使用的swap是内存的两倍。\n 磁盘清理  docker system df 查看docker磁盘占用，加入-v，显示更详细 docker container prune 仅删除停止运行的容器。 docker rm -f $(docker ps -aq) : 删除所有容器（包括停止的、正在运行的）。 docker image rm $(docker image ls -q) ：删除所有镜像 docker volume prune  删除不再使用的数据卷 docker builder prune 删除 build cache docker system prune 可以用于清理磁盘，删除关闭的容器、无用的数据卷和网络，以及 dangling 镜像（也就是无 tag 的镜像）。 docker system prune -a : 清理得更加彻底，可以将没有容器使用 Docker镜像都删掉。  ","description":"部署docker容器时，限制容器的内存","id":52,"section":"docker","tags":["docker"],"title":"限制容器内存和管理docker占用磁盘","uri":"https://www.zhugeqing.top/docker/docker-memory/"},{"content":"基本使用  docker-compose up 创建并启动docker-compose.yml的容器和其他的资源   加入 -d 可以后台运行，加入\u0026ndash;build 可以运行之前构建镜像\n docker-compose stop 停止docker-compose.yml 定义的容器 docker-compose start 启动 docker-compose.yml 定义的容器   docker-compose restart 就是重新启动\n docker-compose rm 删除docker-compose.yml 定义的容器 docker-compose down 停止并删除 docker-compose.yml 定义的容器 docker-compose ps 查看 docker-compose.yml 定义的容器的运行情况 docker-compose build 对 docker-compose.yml 指定的 dockerfile 构建镜像   在build 后面可以指定 镜像名字\n docker-compose的安装  curl -L \u0026quot;https://github.com/docker/compose/releases/download/v2.3.3/docker-compose-$(uname -s)-$(uname -m)\u0026quot; -o /usr/local/bin/docker-compose chmod 744 /usr/local/bin/docker-compose   赋予命令执行权限\n  docker-compose --version   测试是否安装成功\n compose 文件的结构  docker compose文件的语法说明 https://docs.docker.com/compose/compose-file/\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  version:\u0026#34;3.8\u0026#34;# version是必须指定的，而且总是位于文件的第一行。 # 它定义了Compose文件格式（主要是API）的版本。建议使用最新版本。services:# 容器servicename:# 服务名字，这个名字也是内部 bridge网络可以使用的 DNS namebuild:# 可选，相当于执行docker build，这个选项填 dockerfile的路径image:# 镜像的名字command:# 可选，如果设置，则会覆盖默认镜像里的 CMD命令environment:# 可选，相当于 docker run里的 --envvolumes:# 可选，相当于docker run里的 -vnetworks:# 可选，相当于 docker run里的 --networkports:# 可选，相当于 docker run里的 -pservicename2:volumes:# 可选，相当于 docker volume createnetworks:# 可选，相当于 docker network create  例如 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  version:\u0026#34;3.8\u0026#34;services:flask-demo:image:flask-demo:latestenvironment:- REDIS_HOST=redis-servernetworks:- demo-networkports:- 8080:5000redis-server:image:redis:latestnetworks:- demo-networknetworks:demo-network:ipam:driver:defaultconfig:-subnet:\u0026#34;172.16.200.0/24\u0026#34;  docker-compose 水平扩展  docker-compose up -d --scale flask=3 扩展 servicename为 flask的容器为3  docker-compose 环境变量设置   可以在docker-compose.yml里面直接定义，也可以将值改成某一个变量，比如：REDIS_HOST=${host}，在到docker-compose.yml 同路径中创建一个 .env文件，写入host=redis-server\n  可以使用 docker-compose config 来查看配置\n  docker-compose 健康检查  在docker-compose.yml中 每一个servicename中与 image 同级别 添加 healthcheck\n  不错的例子https://gist.github.com/phuysmans/4f67a7fa1b0c6809a86f014694ac6c3a  ","description":"Docker compose","id":53,"section":"docker","tags":["docker"],"title":"Docker compose","uri":"https://www.zhugeqing.top/docker/docker-compose/"},{"content":"docker network基础  docker 网络分为bridge，host，none三种  [root@zhugeqing ~]# docker network ls NETWORK ID NAME DRIVER SCOPE 23bfb9b413e1 bridge bridge local da3b8a887179 host host local 8124818e6997 none null local 默认情况下，创建的container会连接到bridge上  [root@zhugeqing ~]# docker container run -d --rm --name linux1 ubuntu:21.04 /bin/sh -c \u0026quot;while true; do sleep 3600; done\u0026quot; fb99caa72e20a4d0a86aa83840fe328e5dca179fc9dd0d59b9ecc4d2a9255e47 [root@zhugeqing ~]# docker container run -d --rm --name linux2 ubuntu:21.04 /bin/sh -c \u0026quot;while true; do sleep 3600; done\u0026quot; 07eab1fef9bb88386ffacd7a0a040c40a2d854daec50e5c818115d3a51bfaf3e [root@zhugeqing ~]# docker network inspect bridge \u0026quot;Containers\u0026quot;: { \u0026quot;fb99caa72e20a4d0a86aa83840fe328e5dca179fc9dd0d59b9ecc4d2a9255e47\u0026quot;: { \u0026quot;Name\u0026quot;: \u0026quot;linux1\u0026quot;, \u0026quot;EndpointID\u0026quot;: \u0026quot;4ab7071e9308743a20f22ed450dde0b1acc84803019e0963149b2a1b852efb60\u0026quot;, \u0026quot;MacAddress\u0026quot;: \u0026quot;02:42:ac:11:00:06\u0026quot;, \u0026quot;IPv4Address\u0026quot;: \u0026quot;172.17.0.6/16\u0026quot;, \u0026quot;IPv6Address\u0026quot;: \u0026quot;\u0026quot; } \u0026quot;07eab1fef9bb88386ffacd7a0a040c40a2d854daec50e5c818115d3a51bfaf3e\u0026quot;: { \u0026quot;Name\u0026quot;: \u0026quot;linux2\u0026quot;, \u0026quot;EndpointID\u0026quot;: \u0026quot;e86202bc76dd0d226f8f188434b6289c96b2dd648d950b0fcc7ecb2e73c78a3d\u0026quot;, \u0026quot;MacAddress\u0026quot;: \u0026quot;02:42:ac:11:00:07\u0026quot;, \u0026quot;IPv4Address\u0026quot;: \u0026quot;172.17.0.7/16\u0026quot;, \u0026quot;IPv6Address\u0026quot;: \u0026quot;\u0026quot; }, 使用docker network create来创建自定义bridge docker network driver类型为host和null的网络有且只有一个（无法再进行创建） 当一个容器连接到host网络上的时候，可以与本机共享网络配置，且只能在创建容器的时候通过--network参数来指定；之后无法通过docker network disconnet和docker network connect来控制这个容器的网络配置 当一个容器连接到none网络上的时候，将会只拥有一个本地环回地址，且只能在创建容器的时候通过--network参数来指定；之后无法通过docker network disconnet和docker network connect来控制这个容器的网络配置   可以之后在容器内部配置网络\n docker network create常用参数   -d 指定创建docker网络的 driver（实际上，只能指定bridge，而默认也是bridge）\n\u0026ndash;gateway 指定网络的网关地址\n\u0026ndash;subnet 指定网络的网络地址\n使用docker network create \u0026ndash;help 查看更多参数\n docker network相关命令  docker network create -d bridge micro   -d指定网络driver，这里是bridge，micro，创建的bridge的名字\n docker network ls   列出所有的docker网络\n docker network inspect micro   查看docker 网络 micro的详情\n docker network connect micro linux1   使容器linux1连接到micro这个docker网络上\n可以使得同一个容器连接到多个docker 网络\n docker network disconnect micro linux1   使容器linux1取消连接到micro这个docker网络上\n docker container run -d --rm --name linux1 --network micro ubuntu:21.04 /bin/sh -c \u0026quot;while true; do sleep 3600; done\u0026quot;   在docker创建容器时通过使用参数--network指定容器所连接的docker网络\n docker network rm micro   删除micro这一个docker network\n swarm overlay 网络  如果是使用分布式的docker环境，也就是docker swarm，那么swarm将用专门的overlay网络 在已经存在一个swarm集群的前提下，通过docker network create -d overlay --attachable mysql 可以创建一个mysql集群所需要的分布式系统网络  ","description":"Docker network","id":54,"section":"docker","tags":["docker"],"title":"Docker network","uri":"https://www.zhugeqing.top/docker/docker-network/"},{"content":"无缓冲的生产者消费者模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  package main import \u0026#34;fmt\u0026#34; func producer(out chan\u0026lt;- int) { for i := 0; i \u0026lt; 10; i++ { data := i * i fmt.Println(\u0026#34;生产者生产数据:\u0026#34;, data) out \u0026lt;- data // 缓冲区写入数据 \t} close(out) //写完关闭管道 } func consumer(in \u0026lt;-chan int) { // 没有数据就阻塞 \tfor data := range in { fmt.Println(\u0026#34;消费者得到数据：\u0026#34;, data) } } func main() { ch := make(chan int) //无缓冲channel \tgo producer(ch) // 子go程作为生产者 \tconsumer(ch) // 主go程作为消费者 }   有缓冲的生产者消费者模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  package main import \u0026#34;fmt\u0026#34; func producer(out chan\u0026lt;- int) { for i := 0; i \u0026lt; 10; i++ { data := i * i fmt.Println(\u0026#34;生产者生产数据:\u0026#34;, data) out \u0026lt;- data // 缓冲区写入数据 \t} close(out) //写完关闭管道 } func consumer(in \u0026lt;-chan int) { // 没有数据就阻塞 \tfor data := range in { fmt.Println(\u0026#34;消费者得到数据：\u0026#34;, data) } } func main() { ch := make(chan int, 5) //有缓冲channel \tgo producer(ch) // 子go程作为生产者 \tconsumer(ch) // 主go程作为消费者 }   多消费者多生产者模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) var cond sync.Cond // 条件变量来协同生产者消费者  func producer(id int, out chan\u0026lt;- int) { for { cond.L.Lock() for len(out) == 5 { cond.Wait() // 产品区满等待消费者消费 \t} product := rand.Intn(1000) fmt.Printf(\u0026#34;编号为%d的生产者生成的产品为%d\\n\u0026#34;, id, product) out \u0026lt;- product cond.L.Unlock() cond.Signal() // 生产完成，唤醒消费者协程 \ttime.Sleep(100 * time.Millisecond) //等待10毫秒，给其他生产者协程机会 \t} } func consumer(id int, in \u0026lt;-chan int) { for { cond.L.Lock() for len(in) == 0 { cond.Wait() // 产品区为空等待生产者生产 \t} fmt.Printf(\u0026#34;编号为%d的消费者消费的产品为%d\\n\u0026#34;, id, \u0026lt;-in) cond.L.Unlock() cond.Signal() // 消费完成，唤醒生成者协程 \ttime.Sleep(100 * time.Millisecond) //等待10毫秒，给其他消费者协程机会 \t} } func main() { quit := make(chan bool) // 阻塞主协程 \tproduct := make(chan int, 5) // 产品区 \t// 初始化cond结构体的互斥锁（分配内存空间，不然会报错） \tcond.L = new(sync.Mutex) for i := 0; i \u0026lt; 5; i++ { go producer(i, product) // 开启5个生产者 \t} for i := 0; i \u0026lt; 5; i++ { go consumer(i, product) // 开启5个消费者 \t} \u0026lt;-quit }   ","description":"三种Go实现方式","id":55,"section":"golang","tags":["Go"],"title":"Go语言实现生产者消费者模型","uri":"https://www.zhugeqing.top/golang/producer_consumer/"},{"content":"Data volume  当容器被删除了，则数据也没有了\n Docker主要提供了两种方式做数据的持久化\n Data Volume, 由Docker管理，(/var/lib/docker/volumes), 持久化数据的最好方式 Bind Mount，由用户指定存储的数据具体mount在系统什么位置  volume  通过在DockerFile中加入VOLUME [ \u0026quot;/app\u0026quot; ]，可以使得容器中的/app目录中的数据被记录到docker volume中 也可以在执行docker run时加上-v zhugeqing:/app来创建docker volume（其中zhugeqing为volume名字，/app为映射到docker volume的容器内目录名） docker volume ls可以来查看所有的volume docker volume inspect VOLUMENAME可以查看该volume的详细信息 docker volume prune可以清理不使用volume  volume练习MySql 准备镜像 docker pull mysql:5.7\n创建容器 mysql镜像的详细信息\n  执行 docker container run --name mysql5.7 -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 -d -v mysql-data:/var/lib/mysql mysql:5.7来创建容器\n  执行docker volume ls可以来查看所有的volume\n  执行docker volume inspect mysql-data来查看该容器所生成的volume\n  验证  执行docker container exec -it mysql5.7 mysql -u root -p并输入密码。在数据库中创建一个名字为zhugeqing的数据库 执行ls /var/lib/docker/volumes/mysql-data/_data来查看生成volume对应的目录，发现确实也生成了一个zhugeqing的目录  Bind Mount  提出一个问题：如果本地机器没有安装go环境，该如何使用docker来生成可执行文件到本机上？\n  选择一个目录（比如/root），编写需要编译的go文件 /root/main.go  1 2 3 4 5 6 7 8  package main import \u0026#34;fmt\u0026#34; func main(){ fmt.Println(\u0026#34;吃掉那只青蛙！\u0026#34;) }    拉取go镜像——docker pull golang\n  使用go镜像运行一个容器——docker run -it -v $(pwd):/root golang\n  切换到容器内的/root/目录——cd /root\n  执行go build main.go\n  退出容器，发现本机的当前目录已经生成了一个可执行文件\n  总结：使用这种方式可以让本机的当前目前与容器中的指定目录进行共享操作\n  ","description":"Docker volume","id":56,"section":"docker","tags":["docker"],"title":"Docker的存储","uri":"https://www.zhugeqing.top/docker/docker-volume/"},{"content":"题目 给你一个字符串 s，找到 s 中最长的回文子串。 力扣地址\n\n解法 中心枚举     ","description":"生命没有极限，除非你自己定义","id":57,"section":"interview","tags":[""],"title":"最长回文子串","uri":"https://www.zhugeqing.top/interview/quality_questions/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"content":"网络代理   网络代理：用户通过代理发送请求消息；请求通过网络代理转发到目标服务器；目标服务器的响应通过网络代理回传给用户\n  网络代理与网络转发的区别：\n 网络代理：用户不直接连接服务器，由网络代理去连接，获取数据后返回给用户。 网络转发：是路由器对报文的转发操作，中间可能对数据包修改    正向代理  一种客户端的代理技术，帮助客户端访问无法访问的服务资源，可以隐藏用户真实IP。比如：浏览器web代理，VPN等\n 正向代理示例：（直接运行，同时需要打开电脑的代理设置，并设置与程序同步的Host:Port）\n 代理接受客户端请求，复制原请求对象，并根据数据配置新请求各种参数 把新请求发送到真实服务端，并接受到服务端的返回 代理服务器对响应做一些处理，然后返回给客户端  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;net\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;strings\u0026#34; ) type Pxy struct{} func (p *Pxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) { // 打印请求的对应字段 \tfmt.Printf(\u0026#34;Received request %v %v %v\\n\u0026#34;, req.Method, req.Host, req.RemoteAddr) transport := http.DefaultTransport // 定义一个数据连接池 \t// step 1，浅拷贝 \toutReq := new(http.Request) *outReq = *req if clientIP, _, err := net.SplitHostPort(outReq.RemoteAddr); err != nil { fmt.Println(\u0026#34;clientIP is\u0026#34;, clientIP) if v, ok := outReq.Header[\u0026#34;X-Forwarded-For\u0026#34;]; ok { clientIP = strings.Join(v, \u0026#34;,\u0026#34;) + \u0026#34;, \u0026#34; + clientIP } outReq.Header.Set(\u0026#34;X-Forwarded-For\u0026#34;, clientIP) } // step 2, 请求下游 \tresponse, err := transport.RoundTrip(outReq) if err != nil { rw.WriteHeader(http.StatusBadGateway) return } // step3, 将下游的请求内容返回给上游 \tfor key, value := range response.Header { for _, v := range value { rw.Header().Add(key, v) } } rw.WriteHeader(response.StatusCode) // 正常响应 \tio.Copy(rw, response.Body) response.Body.Close() } func main() { fmt.Println(\u0026#34;Listening on :8080\u0026#34;) http.Handle(\u0026#34;/\u0026#34;, \u0026amp;Pxy{}) http.ListenAndServe(\u0026#34;0.0.0.0:8080\u0026#34;, nil) }   反向代理  一种服务端的代理技术，帮助服务器做负载均衡、缓存、安全校验等，可以隐藏服务器真实IP，比如：Nginx Proxy_pass等\n 反向代理示例：（运行两个程序，一个服务端程序，一个反向代理程序）\n 代理接受客户端请求，更改请求结构体信息 通过一定的负载均衡算法获取下游服务地址 把请求发送到下游服务器，并返回响应\n服务器代码  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/signal\u0026#34; \u0026#34;syscall\u0026#34; \u0026#34;time\u0026#34; ) type RealServer struct { Addr string } func (r *RealServer) HelloHandler(w http.ResponseWriter, req *http.Request) { uPath := fmt.Sprintf(\u0026#34;http://%s%s\\n\u0026#34;, r.Addr, req.URL.Path) io.WriteString(w, uPath) } func (r *RealServer) ErrorHandler(w http.ResponseWriter, req *http.Request) { uPath := \u0026#34;error handler\u0026#34; w.WriteHeader(http.StatusInternalServerError) io.WriteString(w, uPath) } func (r *RealServer) Run() { log.Println(\u0026#34;Starting http server at\u0026#34; + r.Addr) mux := http.NewServeMux() mux.HandleFunc(\u0026#34;/\u0026#34;, r.HelloHandler) mux.HandleFunc(\u0026#34;/base/error\u0026#34;, r.ErrorHandler) server := \u0026amp;http.Server{ Addr: r.Addr, WriteTimeout: time.Second * 3, Handler: mux, } go func() { log.Fatal(server.ListenAndServe()) }() } func main() { rs1 := \u0026amp;RealServer{\u0026#34;127.0.0.1:8081\u0026#34;} rs2 := \u0026amp;RealServer{\u0026#34;127.0.0.1:8082\u0026#34;} rs1.Run() rs2.Run() // 监听关闭信号 \tquit := make(chan os.Signal) signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM) \u0026lt;-quit }   反向代理代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  package main import ( \u0026#34;bufio\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/url\u0026#34; ) var ( proxy_addr = \u0026#34;http://127.0.0.1:8081\u0026#34; port = \u0026#34;8083\u0026#34; ) func handler(w http.ResponseWriter, req *http.Request) { // step 1：解析代理地址，并更改请求体的协议和主机 \tproxy, _ := url.Parse(proxy_addr) req.URL.Scheme = proxy.Scheme // 更改请求协议 \treq.URL.Host = proxy.Host // 更改请求地址  // step 2：请求下游 \ttransport := http.DefaultTransport resp, err := transport.RoundTrip(req) if err != nil { log.Println(err) return } // step 3：把响应返回给上游 \tfor k, vv := range resp.Header { for _, v := range vv { w.Header().Add(k, v) } } defer resp.Body.Close() // 让Body不再占用内存资源 \tbufio.NewReader(resp.Body).WriteTo(w) } func main() { http.HandleFunc(\u0026#34;/\u0026#34;, handler) log.Println(\u0026#34;server starting on port\u0026#34;, port) if err := http.ListenAndServe(\u0026#34;:\u0026#34;+port, nil); err != nil { log.Fatal(err) } }    测试 命令行输入curl http://127.0.0.1:8083   请求反向代理（127.0.0.1:8083），通过反向代理将请求发送给真正的服务器（127.0.0.1:8081）\n ReverseProxy  支持更改内容 错误信息回调 支持自定义负载均衡 url重写功能 连接池功能 支持webSocker服务 支持https代理   用ReverseProxy简单实现一个http代理  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/http/httputil\u0026#34; \u0026#34;net/url\u0026#34; ) var addr = \u0026#34;127.0.0.1:8083\u0026#34; // 代理地址  // 用ReverseProxy来简单实现一个代理  func main() { rs1 := \u0026#34;http://127.0.0.1:8081/base/\u0026#34; // 真实服务器地址 \turl1, err1 := url.Parse(rs1) if err1 != nil { log.Println(err1) } proxy := httputil.NewSingleHostReverseProxy(url1) log.Println(\u0026#34;proxyServer Listening on \u0026#34;, addr) // 开启代理监听 \tif err := http.ListenAndServe(addr, proxy); err != nil { log.Fatal(err) } }   修改ReverseProxy来实现可以修改返回内容的代理  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79  package main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/http/httputil\u0026#34; \u0026#34;net/url\u0026#34; \u0026#34;strings\u0026#34; ) var addr = \u0026#34;127.0.0.1:8083\u0026#34; // 代理地址  func NewSingleHostReverseProxy(target *url.URL) *httputil.ReverseProxy { targetQuery := target.RawQuery director := func(req *http.Request) { req.URL.Scheme = target.Scheme req.URL.Host = target.Host // 将请求路径附加到目标路径下 \treq.URL.Path = singleJoiningSlash(target.Path, req.URL.Path) if targetQuery == \u0026#34;\u0026#34; || req.URL.RawQuery == \u0026#34;\u0026#34; { req.URL.RawQuery = targetQuery + req.URL.RawQuery } else { req.URL.RawQuery = targetQuery + \u0026#34;\u0026amp;\u0026#34; + req.URL.RawQuery } if _, ok := req.Header[\u0026#34;User-Agent\u0026#34;]; !ok { // explicitly disable User-Agent so it\u0026#39;s not set to default value \treq.Header.Set(\u0026#34;User-Agent\u0026#34;, \u0026#34;\u0026#34;) } } modifyFunc := func(res *http.Response) error { if res.StatusCode == http.StatusOK { // 读取body \toldPayload, err := ioutil.ReadAll(res.Body) if err != nil { return err } newPayload := []byte(\u0026#34;你好\u0026#34; + string(oldPayload)) // 产生新body，修改body，并改变contentLength \tres.Body = ioutil.NopCloser(bytes.NewBuffer(newPayload)) res.ContentLength = int64(len(newPayload)) res.Header.Set(\u0026#34;Content-Length\u0026#34;, fmt.Sprintf(\u0026#34;%d\u0026#34;, res.ContentLength)) } return nil } return \u0026amp;httputil.ReverseProxy{ Director: director, ModifyResponse: modifyFunc, } } func singleJoiningSlash(a, b string) string { aslash := strings.HasSuffix(a, \u0026#34;/\u0026#34;) bslash := strings.HasPrefix(b, \u0026#34;/\u0026#34;) switch { case aslash \u0026amp;\u0026amp; bslash: return a + b[1:] case !aslash \u0026amp;\u0026amp; !bslash: return a + \u0026#34;/\u0026#34; + b } return a + b } // 用ReverseProxy来简单实现一个代理 func main() { rs1 := \u0026#34;http://127.0.0.1:8081/base/\u0026#34; // 真实服务器地址 \turl1, err1 := url.Parse(rs1) if err1 != nil { log.Println(err1) } proxy := NewSingleHostReverseProxy(url1) log.Println(\u0026#34;proxyServer Listening on \u0026#34;, addr) // 开启代理监听 \tif err := http.ListenAndServe(addr, proxy); err != nil { log.Fatal(err) } }   实现X-Forwarded-For，X-Real-IP   X-Forwarded-For：记录最后直连实际服务器之前，整个代理过程；可能会被伪造\nX-Real-IP：请求实际服务器的IP（Client_IP）；不会被伪造\n ","description":"Go实战微服务网关","id":58,"section":"golang","tags":["Go"],"title":"Go 微服务网关","uri":"https://www.zhugeqing.top/golang/go-micro-gateway/"},{"content":"Go map基础  Go map 又称为 hash表，Go语言 map采用的是开放寻址法里面的线性探测，线性探测策略是顺序（每次探测间隔为1）的\n map 的声明与初始化 1 2 3 4 5 6 7 8 9  func defineMap() { // 第一种声明方式 \tvar hash map[int]int hash[111] = 222 // panic，hash没有被初始化，map值为nil，  // 第二种声明方式（make的第二个参数代表初建map的长度，如果不填的话，默认长度为 0） \thash = make(map[int]int, 1) hash[111] = 222 // success }   map 的访问  当一个键不存在于map中时，访问的结果将会得到value类型的 零值\n 1 2 3 4 5 6 7 8 9  func accessMap() { hash := make(map[int]int) // 第一种访问方式 \tv := hash[0] fmt.Println(v) // 第二种访问方式 \tv, ok := hash[0] fmt.Println(v, ok) }   map的赋值 1 2 3 4 5 6 7 8 9 10  func assignMap() { hash := make(map[int]int) // map赋值 将 key 和 value绑定在一起 \thash[2002] = 04 // 可以 使用delete对 map相同的键 进行多次删除操作（不会出现报错的情况） \tfor i := 0; i \u0026lt; 100; i++ { delete(hash, 2002) // 前一个参数为需要进行删除操作的map，第二个参数为指定需要删除的key \t} fmt.Println(hash[2002]) }   map key的比较  对于key，切片、函数、map是不可以比较的，也就是说这三种类型都不能当做map的key类型\n 1 2 3 4 5  func compareMapKey() { // hash := make(map[[]int]int) // error \t// hash := make(map[map[int]int]int) // error \t//hash := make(map[func()int]int) error }   map 的并发冲突  Go语言的官方文档中写道：要求所有map操作都互斥将减慢大多数程序的速度，而只会增加少数程序的安全性“即Go语言只支持并发读取的原因是保证大多数场景下的查找效率\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  func concurrentMap() { hash := make(map[int]int) // 1. map并不支持并发读写（fatal error: concurrent map read and map write） \t/* // 写操作 go func() { for { hash[1] = 2 } }() // 读操作 go func() { for { _ = hash[1] } }() for i:=0; i\u0026lt;100;i++{} } */ // 2. map支持并发读取（success） \t// 写操作 \tgo func() { for { _, _ = hash[1] } }() // 写操作 \tgo func() { for { _ = hash[1] } }() for i := 0; i \u0026lt; 100; i++ {} }   Go map底层 Go map底层结构  源码位置：go SDK\\src\\runtime\\map.go\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  type hmap struct { // count 表示map中元素的个数 \tcount int // flags 表示当前map的状态（是否处于读写状态等） \tflags uint8 // 2的B次幂表示当前map中桶的数量，2^B=Buckets size \tB uint8 // noverflow为map中溢出桶的数量。当溢出的桶太多时，map会进行same-size map growth，其实质是避免溢出桶过大导致内存泄露。 \tnoverflow uint16 // hash的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入 \thash0 uint32 // buckets是指向当前map对应的桶的指针 \tbuckets unsafe.Pointer // oldbuckets是在map扩容时存储旧桶的，当所有旧桶中的数据都已经转移到了新桶中时，则清空 \toldbuckets unsafe.Pointer // nevacuate在扩容时使用，用于标记当前旧桶中小于nevacuate的数据都已经转移到了新桶中 \tnevacuate uintptr // extra存储map中的溢出桶 \textra *mapextra } // 桶结构 type bmap struct { tophash [bucketCnt]uint8 key [bucketCnt]T // key 数组 \tvalue [bucketCnt]T // value 数组 }   问答  Golang Map 底层实现  Go 语言map底层实现是一个hash表，其解决hash碰撞使用的是开放寻址法中的线性探测策略(探测间隔为1)。主要由两个结构体实现，一个是hmap（a header for a go map），一个是bmap（a bucket for a go map）也就是bucket。其中hmap的主要字段有count（int，map中的元素个数），B（uint8，2的B次幂就是map中桶的数量），flags（uint8,表明map的一些状态，表示是否在进行扩容，是否在进行读写操作），buckets（unsafe.Pointer，当前map对应的桶的指针），oldbuckets（unsafe.Pointer，在map进行扩容时，指向旧桶），extra（map中的溢出桶的指针）。对于bmap主要字段有tophash（一个固定长度为8的uint8数组，存储key对应的hash值得高8位），key（数组），value（数组），overflow（指向溢出桶的指针）；其中除了tophash，其他字段都由程序在编译时重建bmap结构体产生，并确定key，value，桶的大小。\nGolang Map如何扩容  关于map 扩容的源码函数为runtime.mapassign函数\n有两种情况发生时触发哈希的扩容：\n 装载因子已经超过 6.5（负载因子=哈希表中的元素数量/桶的数量）   双倍扩容（也就是渐进式扩容），原有的桶不会进行一次性搬迁，每次最多搬迁两个，一个旧桶的数据会分流到两个新桶上，如果数据的hash\u0026amp;bucketMask小于或等于旧桶的大小，则此数据必须转移到和旧桶位置完全对应的新桶中去，理由是当前key所在新桶的序号与旧桶是完全相同的。\n  溢出桶数量过多；（由于 Go 语言哈希的扩容不是一个原子的过程，所以 runtime.mapassign 函数还需要判断当前哈希是否已经处于扩容状态，避免二次扩容造成混乱）   等量扩容，重新排列，进行简单的直接转移即可。\n ","description":"Go map底层刨析","id":59,"section":"golang","tags":["Go"],"title":"Go map","uri":"https://www.zhugeqing.top/golang/map/"},{"content":"部署Jaeger  docker部署shell脚本  1 2 3 4 5 6 7 8 9 10  docker run -d --name jaeger \\ -e COLLECTOR_ZIPKIN_HTTP_PORT=9441 \\ -p 5775:5775/udp \\ -p 6831:6831/udp \\ -p 6832:6832/udp \\ -p 5778:5778 \\ -p 16686:16686 \\ -p 14268:14268 \\ -p 9441:9441 \\ jaegertracing/all-in-one   实现中间件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  package middlewares import ( \u0026#34;context\u0026#34; \u0026#34;web_app/pkg/tracer\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/opentracing/opentracing-go\u0026#34; \u0026#34;github.com/opentracing/opentracing-go/ext\u0026#34; \u0026#34;github.com/uber/jaeger-client-go\u0026#34; ) func Tracing() func(c *gin.Context) { return func(c *gin.Context) { var newCtx context.Context var span opentracing.Span spanCtx, err := opentracing.GlobalTracer().Extract( opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(c.Request.Header), ) if err != nil { span, newCtx = opentracing.StartSpanFromContextWithTracer( c.Request.Context(), tracer.Tracer, c.Request.URL.Path, ) } else { span, newCtx = opentracing.StartSpanFromContextWithTracer( c.Request.Context(), tracer.Tracer, c.Request.URL.Path, opentracing.ChildOf(spanCtx), opentracing.Tag{ Key: string(ext.Component), Value: \u0026#34;HTTP\u0026#34;, }, ) } defer span.Finish() var traceID string var spanID string var spanContext = span.Context() switch spanContext.(type) { case jaeger.SpanContext: jaegerContext := spanContext.(jaeger.SpanContext) traceID = jaegerContext.TraceID().String() spanID = jaegerContext.SpanID().String() } c.Set(\u0026#34;X-Trace-ID\u0026#34;, traceID) // 后续取出 \tc.Set(\u0026#34;X-Span-ID\u0026#34;, spanID) c.Request = c.Request.WithContext(newCtx) c.Next() } }   日志追踪（zap日志库）  打印日志时添加span_id和trace_id\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // GinLogger 接收gin框架默认的日志 func GinLogger() gin.HandlerFunc { return func(c *gin.Context) { start := time.Now() path := c.Request.URL.Path query := c.Request.URL.RawQuery c.Next() cost := time.Since(start) zap.L().Info(path, zap.Int(\u0026#34;status\u0026#34;, c.Writer.Status()), zap.String(\u0026#34;method\u0026#34;, c.Request.Method), zap.String(\u0026#34;path\u0026#34;, path), zap.String(\u0026#34;query\u0026#34;, query), zap.String(\u0026#34;ip\u0026#34;, c.ClientIP()), zap.String(\u0026#34;user-agent\u0026#34;, c.Request.UserAgent()), zap.String(\u0026#34;errors\u0026#34;, c.Errors.ByType(gin.ErrorTypePrivate).String()), zap.Duration(\u0026#34;cost\u0026#34;, cost), zap.String(\u0026#34;trace_id\u0026#34;, c.GetString(\u0026#34;X-Trace-ID\u0026#34;)), zap.String(\u0026#34;span_id\u0026#34;, c.GetString(\u0026#34;X-Span-ID\u0026#34;)), ) } }   ","description":"给项目添加链路追踪吧！","id":60,"section":"golang","tags":["Go"],"title":"Gin + Jaeger，实现链路追踪","uri":"https://www.zhugeqing.top/golang/use-jaeger/"},{"content":"持续行动 English  单词  算法  739. 每日温度  ","description":"寒冷降服脆弱的身体，但无法动摇我的意志","id":61,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2022-2-2/"},{"content":"持续行动 English  单词  算法  340. 至多包含 K 个不同字符的最长子串  ","description":"寒冷降服脆弱的身体，但无法动摇我的意志","id":62,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2022-2-3/"},{"content":"protobuf  protobuf（Google Protocol Buffer）是Google旗下的一种平台无关、语言无关、可扩展的序列化结构数据格式，很适合作为数据存储和不同语言之间相互通信的数据交换格式\n  优点：  序列化以后体积比JSON和XML格式小，便于网络传输。 支持跨平台、跨语言。 序列化和反序列化速度快，高于JSON的处理速度    protobuf生成Go代码   安装protoc 并加入环境变量\n  安装protobuf文件库\n   go get -u github.com/golang/protobuf/proto\ngo get -u github.com/golang/protobuf/protoc-gen-go\ngo get github.com/micro/micro/v2/cmd/protoc-gen-micro\n 安装micro工具   go get -v github.com/micro/micro/v2\n 编写好.proto文件  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  syntax = \u0026#34;proto3\u0026#34;; // 指定版本（proto2, proto3） package main; // proto 包名 option go_package=\u0026#34;./test;test\u0026#34;; // ./test表示go文件存放地址， test表示生成go文件所属包名 service Product { // 定义的服务  rpc AddProduct(ProductInfo) returns (ResponseProduct) {}}message ProductInfo { // 消息格式  // 定义类似c语言  int64 id = 1; // 此处的1，2代表的是字段的标识符  string product_name = 2;}message ResponseProduct { int64 product_id = 1;}  执行 protoc -I. --go_out=./ --micro_out=./ *.proto来生成.pb.go和.pb.micro.go   protoc的具体使用  使用docker container  拉取docker 镜像docker pull zhugeqing/protoc 运行一个containerdocker run --rm -v $(pwd):$(pwd) -w $(pwd) zhugeqing/protoc --go_out=./ --micro_out=./ -I ./ *.proto   \u0026ndash;rm表示当容器退出时自动删除容器；-v来指定bind mount；-w来指定工作目录，\u0026ndash;go_out和\u0026ndash;micro_out来指定生成go文件的路径；-I指定寻找proto文件的路径。\n 避雷！ 无法安装micro v2 在安装micro工具包时(go get -v github.com/micro/micro/v2) 尽量选择使用go 1.14版本，在使用go 1.17版本时，会有报错信息\nPS D:gozhugeqing\u0026gt; micro help panic: qtls.ConnectionState not compatible with tls.ConnectionState goroutine 1 [running]: github.com/lucas-clemente/quic-go/internal/handshake.init.1() D:/Code/CodeTools/GoPath/pkg/mod/github.com/lucas-clemente/quic-go@v0.14.1/internal/handshake/unsafe.go:17 +0x139  解决：   替换Go sdk版本，切换为1.14，将GoPath目录下的bin/go.exe替换成go 1.14 sdk/bin/go.exe。 删除GoPath/pkg/github.com/micro/ 相关文件（此步骤只是为了以防万一，不执行应该也行） 重新执行go get -v github.com/micro/micro/v2 命令行下执行micro help来测试可用性  micro:v2 api 无法使用consul  解决方法就是重新编译micro\n  打开micro源码目录创建plugins.go  1 2 3 4 5  package main import ( _\u0026#34;github.com/micro/go-plugins/registry/consul/v2\u0026#34; )    重新编译：go build -o micro main.go plugins.go（如果是windows，记得改后缀为.exe） 用新构建micro来执行命令  修改micro源码，构建我们想要的程序  下载micro源码包（这里使用micro v2）   https://github.com/micro/micro/releases/tag/v2.9.3\n  修改源码包/internal/template/ 下面的模版文件，编写自己需要实代码   注释：alias代表生成目录的尾名（例如github.com/xing-you-ji/user中的user）\n{{.Dir}}表示github.com/xing-you-ji/user\n{{title .Alias}} 表示大写 User\n{dehyphen .Alias}} 表示小写 user\n{{.Alias}}也表示user，不过在import时使用\n  go build -o micro main.go   通过修改go env的GOOS，CGO_ENABLED构建不同平台的micro源程序（编译平台为windows）\nmac：CGO_ENABLED=0 GOOS=darwin3\nlinux：CGO_ENABLED=0 SET GOOS=linux\n ","description":"初探Go微服务","id":63,"section":"golang","tags":["Go"],"title":"go-micro基础","uri":"https://www.zhugeqing.top/golang/grpc/"},{"content":"使用crontab指令在centos8中设置定时执行脚本  引出问题：当我每次完成代码或笔记编写之后，不仅需要在本地推送代码到github，还需要在云服务器上将更新的内容拉取下来。\n  先写git pull脚本（并给予执行权限）  1 2  #!/bin/bash cd /www/zhugeqing.top/ \u0026amp;\u0026amp; git pull origin master   设置定时执行脚本任务   输入crontab –e编辑定时任务 输入50 23 * * * /root/linux_study/sh_vim/website_pull.sh按vim操作保存 通过crontab -l查看定时任务   crontab语法：第一个*表示一小时中的第几分钟（0-59），第二个*表示一天的第几小时（0-23），第三个*表示一个月的第几天（1-31），第四个*表示一年的第几个月（1-12），第五个*表示一周当中的星期几（0-7 0,7都表示星期天）\n上例表示每天的23:50分都会执行一次shell脚本\n ","description":"我们总会忘记一些繁琐的事情","id":64,"section":"linux","tags":["Linux"],"title":"Linux设置定时任务","uri":"https://www.zhugeqing.top/linux/croud/"},{"content":"持续行动 English  单词 听力新闻头尾最重要，注意听引用词和转折词  面试知识 算法  43. 字符串相乘  ","description":"新的一年，至少做出一些改变","id":65,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2022-2-1/"},{"content":"持续行动 病终于好了\n","description":"小病初愈","id":66,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2022-1-7/"},{"content":"实现 当项目读取文件时，帮助准确找到文件所在路径，迅速推断出项目根目录 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  package infer import ( \u0026#34;os\u0026#34; \u0026#34;path/filepath\u0026#34; ) var ( // 项目主目录 \tRootDir string ) // 推断 Root目录 func InferRootDir() { pwd, err := os.Getwd() if err != nil { panic(err) } var infer func(string) string infer = func(dir string) string { if exists(dir + \u0026#34;/template\u0026#34;) { return dir } // 查看dir的父目录 \tparent := filepath.Dir(dir) return infer(parent) } RootDir = infer(pwd) } func exists(dir string) bool { // 查找主机是不是存在 dir \t_, err := os.Stat(dir) return err == nil || os.IsExist(err) }   ","description":"推断一个项目的工作目录","id":67,"section":"golang","tags":["Go"],"title":"推断一个项目的工作目录","uri":"https://www.zhugeqing.top/golang/inferdir/"},{"content":" ","description":"","id":68,"section":"problems","tags":["网络题目"],"title":"TCP、UDP协议分别属于什么层","uri":"https://www.zhugeqing.top/problems/network/1/"},{"content":"算法  无须强调的习惯\n  113. 路径总和 II——题库冲刺第一遍 958. 二叉树的完全性检验——题库冲刺第二遍 101. 对称二叉树——题库冲刺第二遍  修改潜意识  开始阶段\n 记：  骂自己的第1天   看书不能停！\n 改变坏习惯的第1天   继续坚持，转移注意力\n 思念祖母的第131天   泪流思念\n 持续正念第27天   一定坚持\n 持续行动的140天！   为了自我\n ","description":"有时候，行动应该先于选择","id":69,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-12-25/"},{"content":"算法  无须强调的习惯\n  124. 二叉树中的最大路径和——第二遍  修改潜意识  开始阶段\n 记：  骂自己的第21天   看书不能停！\n 改变坏习惯的第5天   继续坚持，转移注意力\n 思念祖母的第127天   泪流思念\n 持续正念第23天   一定坚持\n 持续行动的136天！   为了自我\n ","description":"有时候，行动应该先于选择","id":70,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-12-21/"},{"content":"算法  无须强调的习惯\n  101. 对称二叉树——迭代第一遍 958. 二叉树的完全性检验——第一遍  修改潜意识  开始阶段\n 记：  骂自己的第20天   看书不能停！\n 改变坏习惯的第4天   继续坚持，转移注意力\n 思念祖母的第126天   泪流思念\n 持续正念第22天   一定坚持\n 持续行动的135天！   为了自我\n ","description":"有时候，行动应该先于选择","id":71,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-12-20/"},{"content":"算法  无须强调的习惯\n  105. 从前序与中序遍历序列构造二叉树——第1.5遍 106. 从中序与后序遍历序列构造二叉树——第1.5遍  修改潜意识  开始阶段\n 记：  骂自己的第19天   看书不能停！\n 改变坏习惯的第3天   再继续坚持\n 思念祖母的第125天   泪流思念\n 持续正念第21天   一定坚持\n 持续行动的134天！    ","description":"有时候，行动应该先于选择","id":72,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-12-19/"},{"content":"安装与示例   go get -u github.com/gin-gonic/gin来安装gin框架\n  示例代码\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  package main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { // 创建一个默认的路由引 \tr := gin.Default() // GET：请求方式；/zhugeqing：请求的路径 \t// 当客户端以GET方法请求/zhugeqing路径时，会执行后面的匿名函数 \tr.GET(\u0026#34;/zhugeqing\u0026#34;, func(c *gin.Context) { // c.JSON：返回JSON格式的数据 \tc.JSON(200, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;Hello world!\u0026#34;, }) }) // 启动HTTP服务，默认在8080端口进行监听 \tr.Run() }   RESTful API  Gin框架支持开发RESTful API的开发。\n  代码示例  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  package main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { r := gin.Default() //返回默认的路由 \tr.GET(\u0026#34;/zhugeqing\u0026#34;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;GET\u0026#34;, }) }) r.POST(\u0026#34;/zhugeqing\u0026#34;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;POST\u0026#34;, }) }) r.PUT(\u0026#34;/zhugeqing\u0026#34;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;PUT\u0026#34;, }) }) r.DELETE(\u0026#34;/zhugeqing\u0026#34;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;DELETE\u0026#34;, }) }) //启动服务 \tr.Run() }   Gin渲染 HTML渲染 存放模板文件文件夹：templates，再在其内部分别定义一个posts文件夹和一个users文件夹。\n 模版文件posts/index.tmpl  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  {{define \u0026#34;posts/index.tmpl\u0026#34;}} \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;posts/index\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; {{.title}} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; {{end}}    模版文件users/index.tmpl  1 2 3 4 5 6 7 8 9 10 11 12 13 14  {{define \u0026#34;users/index.tmpl\u0026#34;}} \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;users/index\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; {{.title}} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; {{end}}   Gin框架中使用LoadHTMLGlob()或者LoadHTMLFiles()方法进行HTML模板解析\n 代码文件main.go  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  package main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { r := gin.Default() //获取一个gin引擎 \tr.LoadHTMLGlob(\u0026#34;templates/**/*\u0026#34;) //解析模版：正则匹配传入模版文件位置  r.GET(\u0026#34;/posts/index\u0026#34;, func(c *gin.Context) { //渲染模版 \tc.HTML(http.StatusOK, \u0026#34;posts/index.tmpl\u0026#34;, gin.H{ //name就是模版文件定义的名字 \t\u0026#34;title\u0026#34;: \u0026#34;posts/index\u0026#34;, }) }) r.GET(\u0026#34;users/index\u0026#34;, func(c *gin.Context) { c.HTML(http.StatusOK, \u0026#34;users/index.tmpl\u0026#34;, gin.H{ \u0026#34;title\u0026#34;: \u0026#34;users/index\u0026#34;, }) }) r.Run(\u0026#34;:8080\u0026#34;) }   自定义模板函数  自定义函数需要在解析模版文件之前设置好\n  代码文件main.go  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  package main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;html/template\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { r := gin.Default() //获取一个gin引擎 \t//gin框架 自定义模版函数 \tr.SetFuncMap(template.FuncMap{ \u0026#34;safe\u0026#34;: func(s string) template.HTML { return template.HTML(s) }, }) r.LoadHTMLFiles(\u0026#34;go.tmpl\u0026#34;) //解析模版：正则匹配传入模版文件位置 \tr.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { //渲染模版 \tc.HTML(http.StatusOK, \u0026#34;go.tmpl\u0026#34;, \u0026#34;\u0026lt;a href=\\\u0026#34;https://zhugeqing.top\\\u0026#34;\u0026gt;诸葛青的编程之旅\u0026lt;/a\u0026gt;\u0026#34;) }) r.Run(\u0026#34;:8080\u0026#34;) }    模版文件go.tmpl  1 2 3 4 5 6 7 8 9  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;gin 自定义模版引擎\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;{{ . | safe }}\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   静态文件处理  当渲染的HTML文件中引用了静态文件时，在渲染页面前调用gin.Static方法\n 1 2 3 4 5 6 7 8  func main() { r := gin.Default() //第一个参数的名字需要和在HTML文件中引用的css文件的路径一样 \tr.Static(\u0026#34;/static\u0026#34;, \u0026#34;./static\u0026#34;) s\tr.LoadHTMLGlob(\u0026#34;templates/**/*\u0026#34;) // ... \tr.Run(\u0026#34;:8080\u0026#34;) }   JSON渲染 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  package main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { r := gin.Default() r.GET(\u0026#34;/jsonMap\u0026#34;, func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{ \u0026#34;name\u0026#34;: \u0026#34;诸葛青\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;你好！\u0026#34;, \u0026#34;age\u0026#34;: 19}) }) r.GET(\u0026#34;/jsonStruct\u0026#34;, func(c *gin.Context) { c.JSON(http.StatusOK, struct { Name string `json:\u0026#34;名字\u0026#34;` Message string `json:\u0026#34;信息\u0026#34;` Age int `json:\u0026#34;年龄\u0026#34;` }{\u0026#34;诸葛青\u0026#34;, \u0026#34;你好！\u0026#34;, 19}) }) r.Run(\u0026#34;:8080\u0026#34;) }   参数获取 获取queryString参数  querystring指的是URL中?后面携带的参数，例如：/web?country=China\u0026amp;city=北京\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { r := gin.Default() r.GET(\u0026#34;/web\u0026#34;, func(c *gin.Context) { //查询参数为country和city，若在网址中有指定值，则返回对应结果 \tcountry := c.DefaultQuery(\u0026#34;country\u0026#34;, \u0026#34;China\u0026#34;) city := c.Query(\u0026#34;city\u0026#34;) if city == \u0026#34;\u0026#34; { city = \u0026#34;广州\u0026#34; } if country == \u0026#34;China\u0026#34; { c.JSON(http.StatusOK, gin.H{ \u0026#34;城市\u0026#34;: city + \u0026#34;是一个美丽的城市\u0026#34;, \u0026#34;国家\u0026#34;: fmt.Sprintf(\u0026#34;%v是一个强大的国家\u0026#34;, country), }) } else { c.JSON(http.StatusOK, gin.H{ \u0026#34;城市\u0026#34;: city + \u0026#34;是一个美丽的城市\u0026#34;, \u0026#34;国家\u0026#34;: fmt.Sprintf(\u0026#34;%v是一个还行的国家\u0026#34;, country), }) } }) r.Run(\u0026#34;:8080\u0026#34;) }   获取form参数  当请求的数据通过form表单提交时，例如向/login发送一个POST请求，获取请求数据的方式如下：\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  func main() { //Default返回一个默认的路由引擎 \tr := gin.Default() //POST请求来提交表单 \tr.POST(\u0026#34;/login\u0026#34;, func(c *gin.Context) { // DefaultPostForm取不到值时会返回指定的默认值 \t//username := c.DefaultPostForm(\u0026#34;username\u0026#34;, \u0026#34;********\u0026#34;) \tusername := c.PostForm(\u0026#34;username\u0026#34;) password := c.PostForm(\u0026#34;password\u0026#34;) //输出json结果给调用方 \tc.JSON(http.StatusOK, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;ok\u0026#34;, \u0026#34;username\u0026#34;: username, \u0026#34;address\u0026#34;: password, }) }) r.Run(\u0026#34;:8080\u0026#34;) }   获取path参数  请求的参数通过URL路径传递，例如：/user/search/诸葛青/星游记。 获取请求URL路径中的参数的方式如下。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func main() { //Default返回一个默认的路由引擎 \tr := gin.Default() r.GET(\u0026#34;/user/search/:username/:favorite\u0026#34;, func(c *gin.Context) { //获取路径参数 \tusername := c.Param(\u0026#34;username\u0026#34;) favorite := c.Param(\u0026#34;favorite\u0026#34;) //输出json结果给调用方 \tc.JSON(http.StatusOK, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;ok\u0026#34;, \u0026#34;username\u0026#34;: username, \u0026#34;address\u0026#34;: favorite, }) }) r.Run(\u0026#34;:8080\u0026#34;) }   参数绑定  基于请求的Content-Type识别请求数据类型并利用反射机制自动提取请求中QueryString、form表单、JSON、XML等参数到结构体中。 ShouldBind()示例：\n  如果是 GET 请求，只使用 Form 绑定引擎（query）。 如果是 POST 请求，首先检查 content-type 是否为 JSON 或 XML，然后再使用 Form（form-data）。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  // Binding from JSON type Login struct { User string `form:\u0026#34;user\u0026#34; json:\u0026#34;user\u0026#34; binding:\u0026#34;required\u0026#34;` Password string `form:\u0026#34;password\u0026#34; json:\u0026#34;password\u0026#34; binding:\u0026#34;required\u0026#34;` } func main() { router := gin.Default() // 绑定JSON的示例 ({\u0026#34;user\u0026#34;: \u0026#34;root\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;123456\u0026#34;}) \trouter.POST(\u0026#34;/loginJSON\u0026#34;, func(c *gin.Context) { var login Login if err := c.ShouldBind(\u0026amp;login); err == nil { fmt.Printf(\u0026#34;login info:%#v\\n\u0026#34;, login) c.JSON(http.StatusOK, gin.H{ \u0026#34;user\u0026#34;: login.User, \u0026#34;password\u0026#34;: login.Password, }) } else { c.JSON(http.StatusBadRequest, gin.H{\u0026#34;error\u0026#34;: err.Error()}) } }) // 绑定form表单示例 (user=root\u0026amp;password=123456) \trouter.POST(\u0026#34;/loginForm\u0026#34;, func(c *gin.Context) { var login Login // ShouldBind()会根据请求的Content-Type自行选择绑定器 \tif err := c.ShouldBind(\u0026amp;login); err == nil { c.JSON(http.StatusOK, gin.H{ \u0026#34;user\u0026#34;: login.User, \u0026#34;password\u0026#34;: login.Password, }) } else { c.JSON(http.StatusBadRequest, gin.H{\u0026#34;error\u0026#34;: err.Error()}) } }) // 绑定QueryString示例 (/loginQuery?user=root\u0026amp;password=123456) \trouter.GET(\u0026#34;/loginQuery\u0026#34;, func(c *gin.Context) { var login Login // ShouldBind()会根据请求的Content-Type自行选择绑定器 \tif err := c.ShouldBind(\u0026amp;login); err == nil { c.JSON(http.StatusOK, gin.H{ \u0026#34;user\u0026#34;: login.User, \u0026#34;password\u0026#34;: login.Password, }) } else { c.JSON(http.StatusBadRequest, gin.H{\u0026#34;error\u0026#34;: err.Error()}) } }) router.Run(\u0026#34;:8080\u0026#34;) }   ","description":"对于Gin框架的初步使用","id":73,"section":"golang","tags":["Go"],"title":"Go语言Gin框架基础","uri":"https://www.zhugeqing.top/golang/gin/"},{"content":"算法  无须强调的习惯\n  102 二叉树的层序遍历——3个月后 124. 二叉树中的最大路径和——第一遍  修改潜意识  开始阶段\n 记：  骂自己的第18天   看书不能停！\n 改变坏习惯的第2天   再继续坚持\n 思念祖母的第124天   泪流思念\n 持续正念第20天   一定坚持\n 持续行动的133天！   无法退后\n ","description":"有时候，行动应该先于选择","id":74,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-12-18/"},{"content":"算法  无须强调的习惯\n  98. 验证二叉搜索树——第一遍迭代  修改潜意识  开始阶段\n 记：  骂自己的第17天   你的目标呢？你的所谓自律呢？你还要等何时，你初中失败，高中失败，还想要大学失败吗。我不求你能取得多大的成就，但你至少能够比昨天更好，比当年更强大，这样晚年回忆起来也不是一腔热血而无处挥洒的后悔和痛哭！\n 十五分钟日记的第17天   破了，就不要抱怨，而是再下更坚定的决心！\n 思念祖母的第123天   泪流思念\n 持续正念第19天   一定坚持\n 持续行动的132天！   无法退后\n ","description":"有时候，行动应该先于选择","id":75,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-12-17/"},{"content":"算法  无须强调的习惯\n  105. 从前序与中序遍历序列构造二叉树——第一遍  修改潜意识  开始阶段\n 记：  骂自己的第16天   你的目标呢？你的所谓自律呢？你还要等何时，你初中失败，高中失败，还想要大学失败吗。我不求你能取得多大的成就，但你至少能够比昨天更好，比当年更强大，这样晚年回忆起来也不是一腔热血而无处挥洒的后悔和痛哭！\n 十五分钟日记的第16天   破了，就不要抱怨，而是再下更坚定的决心！\n 思念祖母的第122天   泪流思念\n 持续正念第18天   一定坚持\n 持续行动的131天！   无法退后\n ","description":"有时候，行动应该先于选择","id":76,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-12-16/"},{"content":"算法  无须强调的习惯\n  918. 环形子数组的最大和——第二遍  修改潜意识  开始阶段\n 记：  骂自己的第16天 十五分钟日记的第16天 思念祖母的第122天 持续正念第18天 持续行动的131天！  ","description":"有时候，行动应该先于选择","id":77,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-12-15/"},{"content":"算法  无须强调的习惯\n  236. 二叉树的最近公共祖先——两个月后 199. 二叉树的右视图——半年后  修改潜意识  开始阶段\n 记：  骂自己的第15天 十五分钟日记的第15天 思念祖母的第121天 持续正念第17天 持续行动的130天！  ","description":"有时候，行动应该先于选择","id":78,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-12-14/"},{"content":"Dockerfile镜像的选择原则（from）   官方镜像优于非官方的镜像，如果没有官方镜像，则尽量选择Dockerfile开源的\n  固定版本tag而不是每次都使用latest\n  尽量选择体积小的镜像\n  Dockerfile Run命令  RUN 主要用于在Image里执行指令，比如安装软件，下载文件等。\n Run普通写法 1 2 3 4 5 6 7  FROMubuntu:21.04RUN apt-get updateRUN apt-get install -y wgetRUN wget https://github.com/ipinfo/cli/releases/download/ipinfo-2.0.1/ipinfo_2.0.1_linux_amd64.tar.gzRUN tar zxf ipinfo_2.0.1_linux_amd64.tar.gzRUN mv ipinfo_2.0.1_linux_amd64 /usr/bin/ipinfoRUN rm -rf ipinfo_2.0.1_linux_amd64.tar.gz  通过docker image build -f dockerfile-run-1 -t ubuntu_run:1.0 .来构建镜像\n -f指定Dockerfile文件名，-t指定image tag，.表示Dockerfile文件在当前目录\n 通过docker image history ubuntu_run:1.0来查看分层情况\nIMAGE CREATED CREATED BY SIZE COMMENT 52b1dbec7f17 42 minutes ago /bin/sh -c rm -rf ipinfo_2.0.1_linux_amd64.t… 0B 70577d1a6d9f 42 minutes ago /bin/sh -c mv ipinfo_2.0.1_linux_amd64 /usr/… 9.36MB 5755b7f81c88 42 minutes ago /bin/sh -c tar zxf ipinfo_2.0.1_linux_amd64.… 9.36MB 3d1a66450a25 42 minutes ago /bin/sh -c wget https://github.com/ipinfo/cl… 4.85MB 241a8d847076 45 minutes ago /bin/sh -c apt-get install -y wget 3.73MB 95ae86536030 45 minutes ago /bin/sh -c apt-get update 35.1MB d662230a2592 13 days ago /bin/sh -c #(nop) CMD [\u0026quot;bash\u0026quot;] 0B \u0026lt;missing\u0026gt; 13 days ago /bin/sh -c #(nop) ADD file:b94883edb5db8add8… 80MB 每一行的RUN命令都会产生一层image layer, 导致镜像的臃肿。\nRun改进写法 1 2 3 4 5 6 7  FROMubuntu:21.04RUN apt-get update \u0026amp;\u0026amp; \\  apt-get install -y wget \u0026amp;\u0026amp; \\  wget https://github.com/ipinfo/cli/releases/download/ipinfo-2.0.1/ipinfo_2.0.1_linux_amd64.tar.gz \u0026amp;\u0026amp; \\  tar zxf ipinfo_2.0.1_linux_amd64.tar.gz \u0026amp;\u0026amp; \\  mv ipinfo_2.0.1_linux_amd64 /usr/bin/ipinfo \u0026amp;\u0026amp; \\  rm -rf ipinfo_2.0.1_linux_amd64.tar.gz  通过docker image build -f dockerfile-run-2 -t ubuntu_run:1.1 .来构建镜像\n -f指定Dockerfile文件名，-t指定image tag，.表示Dockerfile文件在当前目录\n通过docker image history ubuntu_run:1.1来查看分层情况\n 204507675bd9 37 seconds ago /bin/sh -c apt-get update \u0026amp;\u0026amp; apt-get ins… 48.2MB d662230a2592 13 days ago /bin/sh -c #(nop) CMD [\u0026quot;bash\u0026quot;] 0B \u0026lt;missing\u0026gt; 13 days ago /bin/sh -c #(nop) ADD file:b94883edb5db8add8… 80MB 文件复制和目录操作 (ADD,COPY,WORKDIR)  使用copy和add都可以往镜像里面复制镜像，而add相比于copy，使用add往镜像里面复制压缩文件时，add会自动解压缩文件\nworkdir 相当于是cd(change directory)\n COPY 1 2  FROMpython:3.9.5-alpine3.13COPY hello.py /app/hello.py  ADD 1 2  FROMpython:3.9.5-alpine3.13ADD hello.tar.gz /app/   WORKDIR 1 2 3  FROMpython:3.9.5-alpine3.13workdir/zhugeqingADD hello.tar.gz .  构建参数和环境变量 (ARG 和 ENV)  ARG（argument）和ENV （environment）`都可以用来设置一个“变量”。 设置好变量VERSION之后可以用语法${VERSION}来使用。\n ENV 1 2 3 4 5 6 7 8  FROMubuntu:21.04ENV VERSION=2.0.1RUN apt-get update \u0026amp;\u0026amp; \\  apt-get install -y wget \u0026amp;\u0026amp; \\  wget https://github.com/ipinfo/cli/releases/download/ipinfo-${VERSION}/ipinfo_${VERSION}_linux_amd64.tar.gz \u0026amp;\u0026amp; \\  tar zxf ipinfo_${VERSION}_linux_amd64.tar.gz \u0026amp;\u0026amp; \\  mv ipinfo_${VERSION}_linux_amd64 /usr/bin/ipinfo \u0026amp;\u0026amp; \\  rm -rf ipinfo_${VERSION}_linux_amd64.tar.gz  ARG 1 2 3 4 5 6 7 8  FROMubuntu:21.04ARG VERSION=2.0.1RUN apt-get update \u0026amp;\u0026amp; \\  apt-get install -y wget \u0026amp;\u0026amp; \\  wget https://github.com/ipinfo/cli/releases/download/ipinfo-${VERSION}/ipinfo_${VERSION}_linux_amd64.tar.gz \u0026amp;\u0026amp; \\  tar zxf ipinfo_${VERSION}_linux_amd64.tar.gz \u0026amp;\u0026amp; \\  mv ipinfo_${VERSION}_linux_amd64 /usr/bin/ipinfo \u0026amp;\u0026amp; \\  rm -rf ipinfo_${VERSION}_linux_amd64.tar.gz  不同处   作用范围不同，env设置的变量会在image中保持，而arg设置的变量只能在构建的时候用到。 arg设置的变量 可以在镜像build的时候动态修改, 通过 --build-arg进行修改（例：docker image build -f Dockerfile-arg -t ipinfo-arg-2.0.0 --build-arg VERSION=2.0.0 .） 使用场景区分：如果在容器运行的时候也需要使用到设置的变量，那么倾向于使用env，如果只会在build镜像的时候使用到设置的变量，那么倾向于使用arg   容器启动命令 CMD  CMD可以用来设置容器启动时默认会执行的命令。\n用法：CMD \u0026lt;shell 命令\u0026gt; ,CMD [\u0026quot;\u0026lt;可执行文件或命令\u0026gt;\u0026quot;,\u0026quot;\u0026lt;param1\u0026gt;\u0026quot;,\u0026quot;\u0026lt;param2\u0026gt;\u0026quot;,...]。\n  容器启动时默认执行的命令 如果docker container run启动容器时指定了其它命令，则CMD命令会被忽略 如果定义了多个CMD，只有最后一个会被执行  ENTRYPOINT   CMD 设置的命令，可以在docker container run 时传入其它命令，覆盖掉 CMD 的命令，但是 ENTRYPOINT 所设置的命令是一定会被执行的。 ENTRYPOINT 和 CMD 可以联合使用，ENTRYPOINT 设置执行的命令，CMD传递参数   Shell 格式和 Exec 格式  如果是执行shell脚本，Exec的写法应该是CMD [\u0026quot;sh\u0026quot;, \u0026quot;-c\u0026quot;, \u0026quot;echo hello $NAME\u0026quot;]\n shell CMD echo \u0026quot;hello docker\u0026quot;\nENTRYPOINT echo \u0026quot;hello docker\u0026quot;\nExec ENTRYPOINT [\u0026quot;echo\u0026quot;, \u0026quot;hello docker\u0026quot;]\nCMD [\u0026quot;echo\u0026quot;, \u0026quot;hello docker\u0026quot;]\nDockerfile技巧 合理使用缓存  docker构建镜像的时候会使用到缓存，但当dockerfile有一层没有使用缓存的时候，之后的命令即使没有改变也不会再使用缓存。\n将无需不会进行改变的命令放在最前面，有可能会改动的命令放在最后面\n 合理使用.dockerignore文件  在.dockerignore文件加入不用发送到Server的目录名或者时文件名，可以在发送build context时，将这些目录或者文件进行忽略\n Docker build context  在构建docker镜像的时候，需要把所需要的文件由Client发给Server，这些文件实际上就是build context\n 一般构建 [root@zhugeqing ~]# docker image build -f dockerfile -t cache ./docker Sending build context to Docker daemon 41.6kB Step 1/6 : FROM ubuntu:21.04 ---\u0026gt; d662230a2592 Step 2/6 : FROM python:3.9.5-alpine3.13 ---\u0026gt; 46a196bf50ae Step 3/6 : workdir /root ---\u0026gt; Using cache ---\u0026gt; 6f9c40c0c5be Step 4/6 : RUN pip install flask ---\u0026gt; Using cache ---\u0026gt; 73e539437d7e Step 5/6 : ADD hello.py /root ---\u0026gt; Using cache ---\u0026gt; 1950e2f31676 Step 6/6 : CMD [\u0026quot;python3\u0026quot;,\u0026quot;hello.py\u0026quot;] ---\u0026gt; Using cache ---\u0026gt; 3906ec34f79f Successfully built 3906ec34f79f Successfully tagged cache:latest 使用\u0026amp;\u0026amp;  尽量使用 \u0026amp;\u0026amp;来连接命令，这样不用产生新的分层\n .dockerignore文件  .dockerignore文件需放在build context指定目录下\n image-golang out project1 project2 project4 dockerfile-run-1 dockerfile-run-2 hello.tar.gz 进行构建\n[root@zhugeqing ~]# docker image build -f dockerfile -t cache ./docker Sending build context to Docker daemon 7.808kB Step 1/6 : FROM ubuntu:21.04 ---\u0026gt; d662230a2592 Step 2/6 : FROM python:3.9.5-alpine3.13 ---\u0026gt; 46a196bf50ae Step 3/6 : workdir /root ---\u0026gt; Using cache ---\u0026gt; 6f9c40c0c5be Step 4/6 : RUN pip install flask ---\u0026gt; Using cache ---\u0026gt; 73e539437d7e Step 5/6 : ADD hello.py /root ---\u0026gt; Using cache ---\u0026gt; 1950e2f31676 Step 6/6 : CMD [\u0026quot;python3\u0026quot;,\u0026quot;hello.py\u0026quot;] ---\u0026gt; Using cache ---\u0026gt; 3906ec34f79f Successfully built 3906ec34f79f Successfully tagged cache:latest 尽量使用非root用户  假如我们当前登录服务器的用户是一个普通用户，，它本身不具有sudo的权限，所以就有很多文件无法进行读写操作，比如/root目录它是无法查看的。 但是如果这个用户可以使用docker，那么就可以将/root目录映射到docker container中查看，从而越权。 所以在构建镜像时，尽量指定非root用户执行。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  FROMpython:3.9.5-slimRUN pip install flask \u0026amp;\u0026amp; \\  groupadd -r flask \u0026amp;\u0026amp; useradd -r -g flask flask \u0026amp;\u0026amp; \\  mkdir /src \u0026amp;\u0026amp; \\  chown -R flask:flask /srcUSERflaskCOPY app.py /src/app.pyWORKDIR/srcENV FLASK_APP=app.pyEXPOSE5000CMD [\u0026#34;flask\u0026#34;, \u0026#34;run\u0026#34;, \u0026#34;-h\u0026#34;, \u0026#34;0.0.0.0\u0026#34;]   通过groupadd和useradd创建一个flask的组和用户\n通过USER指定后面的命令要以flask这个用户的身份运行\n 学习更多DockerFile知识  Docker-library   可以进入官方的github仓库，然后进入library，找到某些image，然后找到文本文件中的git地址，点开地址，可以查看官方是如何编写DockerFile镜像的\n DockerFile   官方DokcerFile文档\n ","description":"Dockerfile的使用","id":79,"section":"docker","tags":["docker"],"title":"Dockerfile","uri":"https://www.zhugeqing.top/docker/dockerfile-use/"},{"content":"算法  无须强调的习惯\n  22. 括号生成——第二遍  修改潜意识  开始阶段\n 记：  骂自己的第14天 十五分钟日记的第14天 思念祖母的第120天 持续正念第16天 持续行动的129天！  ","description":"现在的我不过是无数个“可能的我”中的一个样本","id":80,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-12-13/"},{"content":"算法  无须强调的习惯\n  103. 二叉树的锯齿形层序遍历——半年后  修改潜意识  开始阶段\n 记：  骂自己的第13天 十五分钟日记的第13天 思念祖母的第119天 持续正念第15天 持续行动的128天！  ","description":"现在的我不过是无数个“可能的我”中的一个样本","id":81,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-12-12/"},{"content":"选择框架 选择使用go-sql-driver和sqlx（可以理解为database/sql是sqlx的子集）\n快速使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  package main import ( \u0026#34;fmt\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; \u0026#34;github.com/jmoiron/sqlx\u0026#34; ) // 定义一个全局对象db var db *sqlx.DB // 定义一个初始化数据库的函数 func initDB() (err error) { // DSN:Data Source Name \t//DSN格式为：[username[:password]@][protocol[(address)]]/dbname[?param1=value1\u0026amp;...\u0026amp;paramN=valueN] \tdsn := \u0026#34;root:root@tcp(127.0.0.1:3306)/test\u0026#34; //\u0026#34;也可以使用mustConnect，如果连接不成功，直接panic\u0026#34; \tdb, err = sqlx.Connect(\u0026#34;mysql\u0026#34;, dsn) //封装了open和ping，不需要再执行ping来进行真正的连接 \tif err != nil { return err } fmt.Println(\u0026#34;连接mysql成功\u0026#34;) db.SetMaxOpenConns(200) //最大连接数（默认） \tdb.SetConnMaxIdleTime(20) //最大空闲连接数（20个数据库连接随时待命） \treturn nil } func main() { err := initDB() // 调用输出化数据库的函数 \tif err != nil { panic(err) } defer db.Close() }   准备工作  在Mysql中建立名字为test的数据库   create database test;\nuse test;\n 建立表  1 2 3 4 5 6 7 8 9 10 11 12 13  CREATETABLE`person`(`user_id`int(11)NOTNULLAUTO_INCREMENT,`username`varchar(260)DEFAULTNULL,`sex`varchar(260)DEFAULTNULL,`email`varchar(260)DEFAULTNULL,PRIMARYKEY(`user_id`))ENGINE=InnoDBAUTO_INCREMENT=2DEFAULTCHARSET=utf8;CREATETABLEplace(countryvarchar(200),cityvarchar(200),telcodeint)ENGINE=InnoDBAUTO_INCREMENT=2DEFAULTCHARSET=utf8;  SetMaxOpenConns  Insert操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  //插入数据 func insertDemo() { //sql执行语句 \tsqlStr := \u0026#34;insert into person(username, sex, email)values(?, ?, ?)\u0026#34; //插入数据 \tr, err := db.Exec(sqlStr, \u0026#34;诸葛青\u0026#34;, \u0026#34;男\u0026#34;, \u0026#34;12345@qq.com\u0026#34;) if err != nil { fmt.Printf(\u0026#34;insert failed, err:%v\\n\u0026#34;, err) return } id, err := r.LastInsertId() // 新插入数据的id \tif err != nil { fmt.Println(\u0026#34;exec failed, \u0026#34;, err) return } fmt.Println(\u0026#34;insert succ:\u0026#34;, id) }   Select操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  //查询数据 func selectDemo() { //存储查询结果的结构体 \tvar person []Person //sql执行语句 \tsqlStr := \u0026#34;select user_id, username, sex, email from person where user_id =?\u0026#34; user_id := 3 //查询数据 \terr := db.Select(\u0026amp;person, sqlStr, user_id) if err != nil { fmt.Println(\u0026#34;exec failed, \u0026#34;, err) return } fmt.Println(\u0026#34;select succ:\u0026#34;, person) }   Update操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // 更新数据 func updateDemo() { sqlStr := \u0026#34;update person set username=? where user_id=?\u0026#34; username := \u0026#34;进击的诸葛青\u0026#34; user_id := 2 res, err := db.Exec(sqlStr, username, user_id) if err != nil { fmt.Printf(\u0026#34;exec failed, err:%v\\n\u0026#34;, err) return } row, err := res.RowsAffected() //影响的行数 \tif err != nil { fmt.Println(\u0026#34;rows failed, \u0026#34;, err) } fmt.Println(\u0026#34;update succ:\u0026#34;, row) }   Delete操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 删除数据 func deleteDemo() { sqlStr := \u0026#34;delete from person where user_id=?\u0026#34; user_id := 2 res, err := db.Exec(sqlStr, user_id) if err != nil { fmt.Println(\u0026#34;exec failed, \u0026#34;, err) return } row, err := res.RowsAffected() //影响行数 \tif err != nil { fmt.Println(\u0026#34;rows failed, \u0026#34;, err) } fmt.Println(\u0026#34;delete succ: \u0026#34;, row) }   NamedExec  db.NamedExec方法用来绑定SQL语句与结构体或map中的同名字段，执行增删改操作\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14  func nameExecDemo() { _,err := db.NamedExec(\u0026#34;insert into person(username, sex, email)values(:username, :sex, :email)\u0026#34;, Person{ Username:\u0026#34;HTTP权威指南\u0026#34;, Sex: \u0026#34;\u0026#34;, Email: \u0026#34;\u0026#34;, }) if err != nil { fmt.Println(err) return } fmt.Println(\u0026#34;执行成功\u0026#34;) }   NamedQuery  db.NamedQuery方法用来绑定SQL语句与结构体或map中的同名字段，进行查询操作\n  预处理   1.优化MySQL服务器重复执行SQL的方法，可以提升服务器性能，提前让服务器编译，一次编译多次执行，节省后续编译的成本。 2.避免SQL注入问题   1 2 3 4 5 6 7 8 9 10 11 12 13  func prepareDemo() { sqlStr := \u0026#34;insert into person(username, sex, email)values(?, ?, ?)\u0026#34; stmt, err := db.Prepare(sqlStr) if err != nil { fmt.Println(\u0026#34;error: prepared statement failed: \u0026#34;, err) return } fmt.Println(\u0026#34;prepare succeeded\u0026#34;) stmt.Exec(\u0026#34;记忆\u0026#34;,nil, nil) stmt.Exec(\u0026#34;redis设计与实现\u0026#34;, nil, nil) stmt.Exec(\u0026#34;mysql；innodb存储引擎\u0026#34;, nil, nil) return }   事务 mysql事务特性\n  原子性（Atomicity）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性（Consistency）：事务按照预期生效，数据的状态是预期的状态。 隔离性（Isolation）：多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。 持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。   Db.Begin() 开始事务\nDb.Commit() 提交事务\nDb.Rollback() 回滚事务\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  // 事务操作示例 func transactionDemo() { tx, err := db.Begin() // 开启事务 \tif err != nil { if tx != nil { tx.Rollback() // 回滚 \t} fmt.Printf(\u0026#34;begin trans failed, err:%v\\n\u0026#34;, err) return } sqlStr1 := \u0026#34;insert into person(username, sex, email) values(?,?,?)\u0026#34; res1, err := tx.Exec(sqlStr1, \u0026#34;无限可能\u0026#34;, \u0026#34;无\u0026#34;, nil) if err != nil { tx.Rollback() // 回滚 \tfmt.Printf(\u0026#34;exec sql1 failed, err:%v\\n\u0026#34;, err) return } affRow1, err := res1.RowsAffected() if err != nil { tx.Rollback() // 回滚 \tfmt.Printf(\u0026#34;exec res1.RowsAffected() failed, err:%v\\n\u0026#34;, err) return } //更新数据 \tsqlStr2 := \u0026#34;Update person set sex=? where user_id=?\u0026#34; res2, err := tx.Exec(sqlStr2, \u0026#34;女\u0026#34;, 3) if err != nil { tx.Rollback() // 回滚 \tfmt.Printf(\u0026#34;exec sql2 failed, err:%v\\n\u0026#34;, err) return } affRow2, err := res2.RowsAffected() if err != nil { tx.Rollback() // 回滚 \tfmt.Printf(\u0026#34;exec res1.RowsAffected() failed, err:%v\\n\u0026#34;, err) return } fmt.Println(affRow1, affRow2) if affRow1 == 1 \u0026amp;\u0026amp; affRow2 == 1 { fmt.Println(\u0026#34;事务提交啦...\u0026#34;) tx.Commit() // 提交事务 \t} else { tx.Rollback() fmt.Println(\u0026#34;事务回滚啦...\u0026#34;) } fmt.Println(\u0026#34;exec trans success!\u0026#34;) }   ","description":"mysql-go的学习","id":82,"section":"golang","tags":["Go"],"title":"Go语言对Mysql进行操作","uri":"https://www.zhugeqing.top/golang/mysql-go/"},{"content":"算法  无须强调的习惯\n  53. 最大子数组和——题库冲刺第一遍 918. 环形子数组的最大和——题库冲刺第一遍  修改潜意识  开始阶段\n 记：  骂自己的第12天 十五分钟日记的第12天 思念祖母的第118天 持续正念第14天 持续行动的127天！\n  ","description":"现在的我不过是无数个“可能的我”中的一个样本","id":83,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-12-11/"},{"content":"获取image  获取image的主要方式\n  从registry上拉取(pull) 使用DockerFile构建(build) 从离线文件中导入(load) 从进行修改后容器中提交到一个新的镜像(commit)  第一种方式（pull）  比较常用的registry有Dock hub 和 Quay\n  拉取nginx镜像——docker pull nginx（docker hub）   默认是拉取最新版本，若要拉取其他版本，则用命令docker pull nginx:1.21.4（1.21.4为版本号，前面加:）\n若是其他registry，比如Quay ，可以进入官网查看相关拉取路径和版本号\n 可以使用docker image inspect nginx查看image的详细信息（如完整ID号，tag，适用架构、系统等）  第二种方式（build）  Dockerfile是用于构建docker镜像的文件\nDockerfile里包含了构建镜像所需的“指令”\nDockerfile有其特定的语法规则\n  编写DockerFile  1 2 3 4 5  FROMubuntu:21.04RUN apt-get update \u0026amp;\u0026amp; \\  DEBIAN_FRONTEND=noninteractive apt-get install --no-install-recommends -y python3.9 python3-pip python3.9-devADD hello.py /CMD [\u0026#34;python3\u0026#34;, \u0026#34;/hello.py\u0026#34;]  编写任意Python文件  1  print(\u0026#34;你好,诸葛青！\u0026#34;)   通过build构建镜像\ndocker image build -t hello:1.0 .（-t表示tag，hello:1.0为镜像名加版本号，.表示build context（构建镜像需要发送到镜像里面的目录，这里的.表示dockerfile所在目录）,若加-f参数，则可以dockerfile可以单独指定路径）  或者使用docker build -t hell:1.0 .\n第三种方式（load） 将镜像文件导出：docker image save -o nginx_1.12.4_image.tar.gz nginx:1.21.4 （选项-o表示输出）\n将镜像文件导入：docker image load -i nginx_1.12.4_image（选项-i表示输入）\n第四种方式（commit）   使用docker container run --publish 214:80 -it nginx:1.21.4 sh\n--publish 214:80表示将docker内的80端口映射为主机的214端口，-it表示以交互式的方式运行，sh表示打开shell \n  cd /usr/share/nginx/html ，echo \u0026quot;\u0026lt;h\u0026gt; 你好 诸葛青！\u0026lt;/h\u0026gt;\u0026quot; \u0026gt; index.html，exit\n第一条命令是转到nginx的index.html的存储路径下，第二条命令是修改默认的index.html，第三条命令是退出容器的shell \n  使用docker container commit f12 zhugeqing/nginx\nf12为开启容器的ID，zhugeqing/nginx为打包之后的镜像名 \n  docker container commit c5 zhugeqing/nginx将正在ID前缀为c5的容器打包成名字为\u0026quot;zhugeqing/nginx\u0026quot;的镜像\n删除image 删除image使用docker image rm 2f1。（2f1为镜像的ID号前缀，或者是image名字:tag的形式）\n删除的前提是该镜像没有被使用，如果用该镜像运行了一个container，就算是停止了运行，也一样不能删除，因为停止的container可能会在之后运行，所以不能直接删除image，需要先使用imgae container stop d61停止容器运行再用imgae container rm d61删除容器再来删除镜像（d61为容器的ID号前缀），如果有多个容器关联了该镜像，那么需要把这些容器都删除才能删除被使用的镜像。\n分享image   通过docker login来登录Docker hub账号。\n  通过docker image tag hello zhugeqing/hello:1.0来将需要分享的镜像修改成账户名/image名:tag的形式\n  通过docker image push zhugeqing/hello:1.0将镜像push到个人Repositories。\n  Scratch镜像  Scratch是一个空的Docker镜像\n ","description":"image的创建管理和发布","id":84,"section":"docker","tags":["docker"],"title":"Docker镜像","uri":"https://www.zhugeqing.top/docker/docker-image/"},{"content":"安装Consul 1  docker run --name consul -d -p 8500:8500 -p 8300:8300 -p 8301:8301 -p 8302:8302 -p 8600:8600/udp consul consul agent -dev -client=0.0.0.0   安装Elasticsearch  创建相关映射目录   mkdir -p /docker/elasticsearch/data\nchmod 777 -R /docker/elasticsearch\n 安装es  1 2 3 4 5 6 7 8  #!/bin/bash docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \\ -e \u0026#34;discovery.type=single-node\u0026#34; \\ -e ES_JAVA_OPTS=\u0026#34;-Xms128m -Xmx256m\u0026#34; \\ -v es-conf:/usr/share/elasticsearch/config \\ -v es-data:/usr/share/elasticsearch/data \\ -v es-plugins:/usr/share/elasticsearch/plugins \\ -d elasticsearch:7.10.1   安装Kibana docker run -d --name kibana -p 5601:5601 -e \u0026quot;ELASTICSEARCH_HOSTS=http://192.168.200.129:9200\u0026quot; kibana:7.10.1\n安装Rocketmq 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97  #!/bin/bash function rocketmq_mkdir() { mkdir -p /docker/rocketmq/logs /docker/rocketmq/stores /docker/rocketmq/conf/brokerconf } function rocketmq_vim() { cat \u0026gt; /docker/rocketmq/conf/brokerconf/broker.conf \u0026lt;\u0026lt; EOF brokerClusterName=DefaultCluster brokerName=broker-a brokerId=0 # 修改为你宿主机的 IP brokerIP1=192.168.1.102 defaultTopicQueueNums=4 autoCreateTopicEnable=true autoCreateSubscriptionGroup=true listenPort=10911 deleteWhen=04 fileReservedTime=120 mapedFileSizeCommitLog=1073741824 mapedFileSizeConsumeQueue=300000 diskMaxUsedSpaceRatio=88 maxMessageSize=65536 brokerRole=ASYNC_MASTER flushDiskType=ASYNC_FLUSH EOF cat \u0026gt; /docker/rocketmq/docker-compose.yml \u0026lt;\u0026lt; EOF version: \u0026#39;3.5\u0026#39; services: rmqnamesrv: image: foxiswho/rocketmq:server container_name: rmqnamesrv ports: - 9876:9876 volumes: - /docker/rocketmq/data/logs:/opt/logs - /docker/rocketmq/store:/opt/store networks: rmq: aliases: - rmqnamesrv rmqbroker: image: foxiswho/rocketmq:broker container_name: rmqbroker ports: - 10909:10909 - 10911:10911 volumes: - /docker/rocketmq/data/logs:/opt/logs - /docker/rocketmq/store:/opt/store - /docker/rocketmq/conf/brokerconf/broker.conf:/etc/rocketmq/broker.conf environment: NAMESRV_ADDR: \u0026#34;rmqnamesrv:9876\u0026#34; JAVA_OPTS: \u0026#34; -Duser.home=/opt\u0026#34; JAVA_OPT_EXT: \u0026#34;-server -Xms128m -Xmx128m -Xmn128m\u0026#34; command: mqbroker -c /etc/rocketmq/broker.conf depends_on: - rmqnamesrv networks: rmq: aliases: - rmqbroker rmqconsole: image: styletang/rocketmq-console-ng container_name: rmqconsole ports: - 8080:8080 environment: JAVA_OPTS: \u0026#34;-Drocketmq.namesrv.addr=rmqnamesrv:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false\u0026#34; depends_on: - rmqnamesrv networks: rmq: aliases: - rmqconsole networks: rmq: name: rmq driver: bridge EOF } function rocketmq_start() { rocketmq_mkdir rocketmq_vim cd /docker/rocketmq docker-compose up } rocketmq_start   安装Jaeger 1  docker run -d --name jaeger -p 6831:6831/udp -p 16686:16686 jaegertracing/all-in-one   安装Etcd 1 2 3 4 5 6  docker run -d --name etcd \\  -p 2379:2379 \\  -p 2380:2380 \\  --env ALLOW_NONE_AUTHENTICATION=yes \\  --env ETCD_ADVERTISE_CLIENT_URLS=http://0.0.0.0:2379 \\  bitnami/etcd:latest   ","description":"docker 安装常见应用","id":85,"section":"docker","tags":["docker"],"title":"使用Docker 安装应用","uri":"https://www.zhugeqing.top/docker/docker-install/"},{"content":"算法  无须强调的习惯\n  22. 括号生成——第一遍  修改潜意识  开始阶段\n 记：  骂自己的第11天 十五分钟日记的第11天 思念祖母的第117天 持续正念第13天 持续行动的126天！\n  ","description":"现在的我不过是无数个“可能的我”中的一个样本","id":86,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-12-10/"},{"content":"在Linux中安装Docker 以root用户权限键入以下命令即可完成安装（适用于任何版本的Linux系统）\n curl -fsSL get.docker.com -o get-docker.sh 来获取安装的脚本文件 sh get-docker.sh 执行已经下载好的脚本文件 systemctl start docker centos启动docker systemctl enable docker centos设置docker自启动  基本使用  docker version来查看docker版本，判断是否安装成功 docker info 来查看更加详细的docker环境信息 docker 来查看docker命令的用法 docker container ls 列出当前正在运行的容器   docker ps 和 docker container ps也有一样的效果\n docker container ps -a 列出所有状态的容器（不只是正在运行的容器） docker container run -d nginx 运行nginx这个镜像并且以后台方式运行（不加-d就是以前台方式运行）   如果没有这个镜像会自动拉取\n docker container stop 214 停止container id为214或者是id前缀为214的container   docker stop 214也有一样的效果（涉及到以前版本的docker保留的命令格式）\n docker container ls -q 列出当前正在运行的容器的ID docker container stop $(docker container ls -q) 批处理，停止所有当前正在运行的容器   docker container rm $(docker container ls -aq) 删除所有容器(如果要删除运行状态的还需要加上-f强制删除的参数，如\ndocker container rm $(docker container ls -aq) -f\n docker image ls 列出本机已安装的docker镜像 docker image rm nginx 删除nginx这个镜像 docker conainer --help 查看更多与容器有关的命令 docker image --help 查看更多与镜像有关的命令 docker system prune -f 清理磁盘 docker image prune -a 删除所有没有被使用的镜像 docker container run --rm nginx 当容器退出时，会自动删除容器 docker update mysql --restart=always 设置容器mysql自启动 docker cp nginx:/etc/nginx /docker/nginx/conf 拷贝容器中的文件 到 宿主机  容器的attached 和 detached模式 在启动一个容器加上-d参数就可以以daemon守护进程的方式运行也就是detached模式，\n  从detached模式切换到attached模式\ndocker attach zhugeqing 切换到容器ID或者ID前缀为zhugeqing的容器的attached模式，当按下ctrl+c时会退出，当然，同样会停止容器\n  在detached模式查看attached模式的信息\ndocker container logs zhugeqing 查看容器ID或者ID前缀为zhugeqing的容器的日志（加入-f可以动态跟踪log）\n  连接容器的shell  docker container run -it ubuntu sh 创建一个ubuntu容器并进入交互式模式   键入exit退出shell并停止容器\n docker container exec -it c_ID sh在一个已经运行的容器（ID为c_ID）里执行一个额外的command，此时输入exit退出命令行并不会停止容器  容器即是进程  ps -ef | grep nginx 查看与nginx有关的进程  root 807 1 0 Dec03 ? 00:00:00 nginx: master process /www/server/nginx/sbin/nginx -c /www/server/nginx/conf/nginx.conf www 355327 807 0 Dec07 ? 00:00:12 nginx: worker process www 355328 807 0 Dec07 ? 00:00:01 nginx: cache manager process root 867209 867191 0 22:58 ? 00:00:00 nginx: master process nginx -g daemon off; 101 867260 867209 0 22:58 ? 00:00:00 nginx: worker process root 868528 859209 0 23:15 pts/0 00:00:00 grep --color=auto nginx \npstree -halps 867260 查看这个nginx进程的进程树  systemd,1 --switched-root --system --deserialize 18 └─containerd-shim,867191 -namespace moby -id 9c0ce97e9ca1f99ed4bd6b2c11f6ca472786c69fba512bacf7097fce18e75fb8 -address /run/containerd/containerd.sock └─nginx,867209 └─nginx,867260 \n 再使用docker ps来查看nginx所对应的container ID，就会发现与上面进程树的那个最长的进程名里面的字段一样，所以运行了一个容器就是运行了一个进程，或者是使用 docker top ID来查看容器的进程，一样是存在于Linux系统中的。\n docker run背后的故事 docker container run -d -p 80:80 --name webServer nginx\n -d表示daemon守护进程，-p 80:80表示将容器内的端口80暴露给容器外的端口80端口，前面的是容器外端口（也就是主机端口），后面的是容器内端口， \u0026ndash;name webServer表示为nginx这个容器起一个别名（不加这个参数，docker会自动起一个其他的名字）\n  在本地查找是否有nginx这个image镜像，如果没有发现 去远程的image registry查找nginx镜像（默认的registry是Docker Hub) 下载最新版本的nginx镜像 （nginx:latest 默认) 基于nginx镜像来创建一个新的容器，并且准备运行 docker engine分配给这个容器一个虚拟IP地址 在宿主机上打开80端口并把容器的80端口转发到宿主机上 启动容器，运行指定的命令（一个默认shell脚本去启动nginx）  参考  https://dockertips.readthedocs.io/en/latest/docker-install/docker-intro.html  小知识  docker run 的-it参数，-i 即 stdin，-t 即 tty， tty 就是 Linux 给用户提供的一个常驻小程序，用于接收用户的标准输入，返回操作系统的标准输出。为了能够在 tty 中输入信息，还需要同时开启 stdin（标准输入流）。  ","description":"安装和基本使用","id":87,"section":"docker","tags":["docker"],"title":"Docker快速上手","uri":"https://www.zhugeqing.top/docker/1/"},{"content":"算法  无须强调的习惯\n  76. 最小覆盖子串——第1.5遍 176. 第二高的薪水——第一遍  修改潜意识  开始阶段\n 记：  骂自己的第10天 十五分钟日记的第10天 思念祖母的第116天 持续正念第12天 持续行动的125天！\n  ","description":"现在的我不过是无数个“可能的我”中的一个样本","id":88,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-12-9/"},{"content":"算法  无须强调的习惯\n  5. 最长回文子串——第三遍 3. 无重复字符的最长子串——第二遍 32. 最长有效括号——两个月后  修改潜意识  开始阶段\n 记：  骂自己的第9天 十五分钟日记的第9天 思念祖母的第115天 持续正念第11天 持续行动的124天！\n  ","description":"现在的我不过是无数个“可能的我”中的一个样本","id":89,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-12-8/"},{"content":"介绍  弥补docker-compose无法部署在 多台机器的缺点 横向扩展 容器失败退出时如何新建容器确保服务正常运行 尽量确保零宕机时间 管理密码，Key等敏感数据  初步使用  docker info 查看docker engine有没有激活swarm模式，默认是Swarm: inactive（也就是未激活） 激活swam的两种方法：初始化一个swarm集群，自己成为manager 和 加入一个已经存在的swarm集群 docker swarm init 初始化一个swarm集群，自己成为manager   创建swarm集群的根证书，manager节点的证书，其它节点加入集群需要的token，创建Raft数据库用于存储证书，配置，密码等数据\n docker swarm join  加入一个swarm集群 docker node ls manager 查看当前集群节点 docker service create nginx:latest 创建一个由nginx:latest镜像构成的 service   \u0026ndash;name web 指定名字为web\n docker service ls 查看service docker service ps serviceID 查看service的大致信息 docker service update serviceID --replicas 3 修改service 的replicas   docker service scale serviceID=4 也可以修改replicas\n docker service rm serviceID 删除service（同时容器也会被删除） docker swarm join-token worker 重新查看加入swarm 集群的token docker service logs serviceID 查看service日志  tips  基本上各大云服务器厂商都不支持搭建 docker swarm， 我尝试搭建，使用一台阿里云和两台腾讯云搭建docker swarm 集群，后面发现创建的分布式容器 之间无法通过创建的 overlay网络进行连接（ping通），但如果是虚拟机就没有任何问题。  ","description":"docker swam使用","id":90,"section":"docker","tags":["docker"],"title":"docker swam使用","uri":"https://www.zhugeqing.top/docker/docker-swam/"},{"content":"算法  无须强调的习惯\n  239. 滑动窗口最大值——第二遍 214. 最短回文串——第二遍  修改潜意识  开始阶段\n 记：  骂自己的第8天 十五分钟日记的第8天 思念祖母的第114天 持续正念第10天 持续行动的123天！\n  ","description":"现在的我不过是无数个“可能的我”中的一个样本","id":91,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-12-7/"},{"content":"主节点配置  运行下面shell脚本  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  #!/bin/bash docker pull zhugeqing/mysql:5.6 read -t 20 -p \u0026#34;请输入mysql的端口号（默认3306）：\u0026#34; port # 等待20s用户输入 port=${port:-3306} # 如果没有输入任何值则赋予变量默认值 echo \u0026#34;mysql端口号为：$port\u0026#34; read -t 20 -p \u0026#34;请输入mysql的root账号密码（默认123456）：\u0026#34; password # 等待20s用户输入 password=${password:-123456} # 如果没有输入任何值则赋予变量默认值 echo \u0026#34;mysql root用户密码为：$password\u0026#34; read -t 20 -p \u0026#34;请输入mysql容器运行的名字（默认为mysql）：\u0026#34; name name=${name:-mysql} echo \u0026#34;mysql 容器运行的名字为：$name\u0026#34; # 创建进行映射的文件夹 mkdir -p /docker/mysql/$name/data mkdir -p /docker/mysql/$name/conf # 启动容器 docker container run --name ${name} -p $port:3306 -e MYSQL_ROOT_PASSWORD=$password -d -v ${name}-conf:/etc/mysql -v ${name}-data:/var/lib/mysql zhugeqing/mysql:5.6 # 建立软链接 ln -s /var/lib/docker/volumes/${name}-data/_data /docker/mysql/${name}/data ln -s /var/lib/docker/volumes/${name}-conf/_data /docker/mysql/${name}/conf read -t 20 -p \u0026#34;请输入主节点的id号（需要与从节点的id号不同，默认为1）：\u0026#34; id id=${id:-1} echo \u0026#34;主节点的id号为：$id\u0026#34; cat \u0026gt; /docker/mysql/$name/conf/_data/mysql.cnf \u0026lt;\u0026lt; EOF !includedir /etc/mysql/conf.d/ !includedir /etc/mysql/mysql.conf.d/ # 主节点配置文件 [mysqld] server-id = $id # id号 # 二进制日志 log-bin=/var/lib/mysql/mysql-bin # 错误日志 log-error = /var/lib/mysql/error.log pid-file = /var/run/mysqld/mysqld.pid socket = /var/run/mysqld/mysqld.sock datadir = /var/lib/mysql symbolic-links=0 character_set_server=utf8 init_connect=\u0026#39;SET NAMES utf8\u0026#39; max_allowed_packet = 20M [mysql] default-character-set = utf8 [mysql.server] default-character-set = utf8 [mysqld_safe] default-character-set = utf8 [client] default-character-set = utf8 EOF docker restart ${name}   从节点配置  运行下面shell脚本  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  #!/bin/bash  docker pull zhugeqing/mysql:5.6 read -t 20 -p \u0026#34;请输入mysql的端口号（默认3306）：\u0026#34; port # 等待20s用户输入 port=${port:-3306} # 如果没有输入任何值则赋予变量默认值 echo \u0026#34;mysql端口号为：$port\u0026#34; read -t 20 -p \u0026#34;请输入mysql的root账号密码（默认123456）：\u0026#34; password # 等待20s用户输入 password=${password:-123456} # 如果没有输入任何值则赋予变量默认值 echo \u0026#34;mysql root用户密码为：$password\u0026#34; read -t 20 -p \u0026#34;请输入mysql容器运行的名字（默认为mysql）：\u0026#34; name name=${name:-mysql} echo \u0026#34;mysql 容器运行的名字为：$name\u0026#34; # 创建进行映射的文件夹 mkdir -p /docker/mysql/$name/data mkdir -p /docker/mysql/$name/conf docker container run --name ${name} -p $port:3306 -e MYSQL_ROOT_PASSWORD=$password -d -v $name-conf:/etc/mysql -v ${name}-data:/var/lib/mysql zhugeqing/mysql:5.6 # 建立软链接 ln -s /var/lib/docker/volumes/${name}-data/_data /docker/mysql/${name}/data ln -s /var/lib/docker/volumes/${name}-conf/_data /docker/mysql/${name}/conf read -t 20 -p \u0026#34;请输入从节点的id号（需要与从节点的id号不同）（默认为2）：\u0026#34; id id=${id:-2} echo \u0026#34;从节点的id号为：$id\u0026#34; cat \u0026gt; /docker/mysql/$name/conf/_data/mysql.cnf \u0026lt;\u0026lt; EOF !includedir /etc/mysql/conf.d/ !includedir /etc/mysql/mysql.conf.d/ # 主节点配置文件 [mysqld] # id号 server-id = $id # relay日志 relay-log=/var/lib/mysql/relay-bin # 错误日志 log-error = /var/lib/mysql/error.log log-slow-admin-statements = on log-queries-not-using-indexes=on # 开启慢查询日志 slow-query-log = 1 # 超时时间为0.03 秒 long-query-time = 0.03 # 慢查询日志路径 slow-query-log-file = /var/lib/mysql/slow.log pid-file = /var/run/mysqld/mysqld.pid socket = /var/run/mysqld/mysqld.sock datadir = /var/lib/mysql symbolic-links=0 character_set_server=utf8 init_connect=\u0026#39;SET NAMES utf8\u0026#39; max_allowed_packet = 20M [mysql] default-character-set = utf8 [mysql.server] default-character-set = utf8 [mysqld_safe] default-character-set = utf8 [client] default-character-set = utf8 EOF docker restart ${name}     使用MySQL客户端工具连接MySQL，下面命令均在mysql命令行使用\n  清空以前从节点配置信息：reset slave;\n  配置好关于主节点的信息，输入如下命令（对应配置进行修改）\n   change master to master_host='主节点ip地址',master_port=主节点端口,master_user='主节点用户',master_password='主节点用户密码',master_log_file='mysql-bin.000001',master_log_pos=0;\n例如：change master to master_host='127.0.0.1',master_port=3306,master_user='root',master_password='123456',master_log_file='mysql-bin.000001',master_log_pos=0;\n   启动从节点：start slave;\n  查看从节点状态：show slave status \\G;\n  ","description":"使用docker部署简单mysql集群主从复制","id":92,"section":"docker","tags":["docker"],"title":"docker 部署mysql集群","uri":"https://www.zhugeqing.top/docker/docker-mysql/"},{"content":"部署redis  docker image pull zhugeqing/redis   拉取镜像\n  编写配置文件 /docker/redis/conf/redis.conf\n# 端口 port 6379 # 日志文件 logfile \u0026quot;redis.log\u0026quot; # rdb文件 dbfilename \u0026quot;dump-redis.rdb\u0026quot; # 密码 requirepass 123456 # 设置redis最大内存 maxmemory 500MB # 设置redis内存淘汰策略 maxmemory-policy volatile-lru \n  docker run -d -p 6379:6379 --restart unless-stopped --name redis -v /docker/redis/conf/:/etc/redis/ -v /docker/redis/data:/data zhugeqing/redis redis-server /etc/redis/redis.conf\n   启动容器\n docker container exec -it redis bash   进入到容器内部\n  redis-cli 和 auth 123456来验证是否运行正确\n  之后只需在本机修改映射的/docker/redis/conf/redis.conf，再进行docker restart redis即可更新redis配置\n  部署redis主从 主节点脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  #!/bin/bash  # 入口函数 function Init() { GetVar WriteToConf docker run -d --network host --restart unless-stopped --name $name -v /docker/redis/$name/conf:/etc/redis/ -v $name-data:/data zhugeqing/redis redis-server /etc/redis/redis.conf # 软链接 ln -s /var/lib/docker/volumes/$name-data/_data /docker/redis/$name/data } # 获取变量 function GetVar() { echo \u0026#34;正在使用redis master节点脚本！\u0026#34; read -t 20 -p \u0026#34;请输入容器映射到主机的端口（容器内默认为6379，主机默认为6379）：\u0026#34; port port=${port:-6379} echo \u0026#34;主机端口为${port}\u0026#34; read -t 20 -p \u0026#34;请输入容器运行时的容器名字（默认为redis）：\u0026#34; name name=${name:-redis} echo \u0026#34;容器名字为${name}\u0026#34; read -t 20 -p \u0026#34;请输入主节点密码（默认为123456）：\u0026#34; password password=${password:-123456} echo \u0026#34;主节点密码为${password}\u0026#34; # 创建需要映射的目录 mkdir -p /docker/redis/$name/conf /docker/redis/$name/data } # 编写配置文件 function WriteToConf() { cat \u0026gt; /docker/redis/$name/conf/redis.conf \u0026lt;\u0026lt; EOF # 容器内部端口 port $port # daemonize yes logfile \u0026#34;redis-$port.log\u0026#34; dbfilename \u0026#34;dump-redis-$port.rdb\u0026#34; # 访问redis-server密码 requirepass $password # 主节点密码（也需要配置，不然当master无法成为新的master节点的slave节点） masterauth $password # 设置redis最大内存 maxmemory 500MB # 设置redis内存淘汰策略 maxmemory-policy volatile-lru # 开启AOF appendonly yes # 总是追加到AOF文件 appendfsync always # 超过100MB就进行重写 auto-aof-rewrite-min-size 100mb # 超过增长率就进行重写 auto-aof-rewrite-percentage 40 # 开启AOF-RDB 混合持久化 aof-use-rdb-preamble yes # 配置慢查询日志（不超过100微秒就不会被记录） slowlog-log-slower-than 100 # 最多记录100条，先进先出 slowlog-max-len 100 EOF } Init   从节点脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84  #!/bin/bash  # 入口函数 function Init() { GetVar WriteToConf docker run -d --network host --restart unless-stopped --name $name -v /docker/redis/$name/conf:/etc/redis/ -v $name-data:/data zhugeqing/redis redis-server /etc/redis/redis.conf # 软链接 ln -s /var/lib/docker/volumes/$name-data/_data /docker/redis/$name/data } # 获取变量 function GetVar() { echo \u0026#34;正在使用redis slave节点脚本！\u0026#34; read -t 20 -p \u0026#34;请输入容器映射到主机的端口（容器内默认为6379，主机默认为6379）：\u0026#34; port port=${port:-6379} echo \u0026#34;主机端口为${port}\u0026#34; read -t 20 -p \u0026#34;请输入容器运行时的容器名字（默认为redis）：\u0026#34; name name=${name:-redis} echo \u0026#34;容器名字为${name}\u0026#34; read -t 20 -p \u0026#34;请输入主节点的ip地址（默认为127.0.0.1）：\u0026#34; masterip masterip=${masterip:-127.0.0.1} echo \u0026#34;主节点的ip为${masterip}\u0026#34; read -t 20 -p \u0026#34;请输入主节点的端口（默认为6379）：\u0026#34; masterport masterport=${masterport:-6379} echo \u0026#34;主节点的端口为${masterport}\u0026#34; read -t 20 -p \u0026#34;请输入主节点密码（默认为123456）：\u0026#34; password password=${password:-123456} echo \u0026#34;主节点密码为${password}\u0026#34; # 创建需要映射的目录 mkdir -p /docker/redis/$name/conf /docker/redis/$name/data } # 编写配置文件 function WriteToConf() { cat \u0026gt; /docker/redis/$name/conf/redis.conf \u0026lt;\u0026lt; EOF # 容器内部端口 port $port # daemonize yes logfile \u0026#34;redis-$port.log\u0026#34; dbfilename \u0026#34;dump-redis-$port.rdb\u0026#34; # 访问redis-server密码 requirepass $password # 主节点密码 masterauth $password # 配置主节点 host slaveof $masterip $masterport # 设置redis最大内存 maxmemory 500MB # 设置redis内存淘汰策略 maxmemory-policy volatile-lru # 开启AOF appendonly yes # 总是追加到AOF文件 appendfsync always # 超过100MB就进行重写 auto-aof-rewrite-min-size 100mb # 超过增长率就进行重写 auto-aof-rewrite-percentage 40 # 开启AOF-RDB 混合持久化 aof-use-rdb-preamble yes # 配置慢查询日志（不超过100微秒就不会被记录） slowlog-log-slower-than 100 # 最多记录100条，先进先出 slowlog-max-len 100 EOF } Init   部署redis-sentinel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93  #!/bin/bash  add=\u0026#34;\u0026#34; # 入口函数 function Init() { InitSentinel # 添加主节点 AddMaster while [ $add = \u0026#34;yes\u0026#34; ] do AddMaster done docker run -d --network host --restart unless-stopped --name $name -v /docker/redis/$name/conf:/etc/redis/ -v $name-data:/data zhugeqing/redis redis-sentinel /etc/redis/sentinel.conf # 软链接 ln -s /var/lib/docker/volumes/$name-data/_data /docker/redis/$name/data } function InitSentinel() { echo \u0026#34;当前正在使用部署redis-sentinel的脚本!\u0026#34; read -t 20 -p \u0026#34;请输入容器映射到主机的端口（容器内默认为26379，主机默认为26379）：\u0026#34; port port=${port:-26379} echo \u0026#34;主机端口为${port}\u0026#34; read -t 20 -p \u0026#34;请输入容器运行时的容器名字（默认为redis-sentinel）：\u0026#34; name name=${name:-redis-sentinel} echo \u0026#34;容器名字为${name}\u0026#34; read -t 20 -p \u0026#34;请输入sentinel密码（默认为123456）：\u0026#34; password password=${password:-123456} echo \u0026#34;sentinel密码为为${password}\u0026#34; # 创建需要映射的目录 mkdir -p /docker/redis/$name/conf /docker/redis/$name/data cat \u0026gt; /docker/redis/$name/conf/sentinel.conf \u0026lt;\u0026lt; EOF # 端口 port $port # 密码 requirepass $password logfile \u0026#34;redis-sentinel-$port.log\u0026#34; EOF } # 添加主节点 function AddMaster() { read -t 20 -p \u0026#34;请输入sentinel监控主节点的名字（默认为redis-master）：\u0026#34; mastername mastername=${mastername:-redis-master} echo \u0026#34;主节点的名字为${mastername}\u0026#34; read -t 20 -p \u0026#34;请输入主节点的ip地址（默认为127.0.0.1）：\u0026#34; masterip masterip=${masterip:-127.0.0.1} echo \u0026#34;主节点的ip为${masterip}\u0026#34; read -t 20 -p \u0026#34;请输入主节点的端口（默认为6379）：\u0026#34; masterport masterport=${masterport:-6379} echo \u0026#34;主节点的端口为${masterport}\u0026#34; read -t 20 -p \u0026#34;请输入主从的密码（默认为123456）：\u0026#34; masterpasswd masterpasswd=${masterpasswd:-123456} echo \u0026#34;主从节点的密码为${masterpasswd}\u0026#34; read -t 20 -p \u0026#34;请输入sentinel选举最小投票数（默认为1）：\u0026#34; vote vote=${vote:-1} echo \u0026#34;最小投票数为${vote}\u0026#34; cat \u0026gt;\u0026gt; /docker/redis/$name/conf/sentinel.conf \u0026lt;\u0026lt; EOF sentinel monitor $mastername $masterip $masterport $vote # 这个配置项指定了需要多少失效时间，一个master才会被这个sentinel主观地认为是不可用的。 单位是毫秒，默认为30秒 sentinel down-after-milliseconds $mastername 30000 sentinel auth-pass $mastername $masterpasswd # 指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行同步（默认为1） sentinel parallel-syncs $mastername 1 # 故障转移时间 sentinel failover-timeout $mastername 180000 EOF read -t 20 -p \u0026#34;是否继续添加主节点：（输入yes或者no）：\u0026#34; add } Init   删除上述操作脚本 1 2 3 4 5  #!/bin/bash read -t 20 -p \u0026#34;请输入docker容器的名字：\u0026#34; name docker rm -f $name docker volume rm $name-data rm -rf /docker/redis/$name   ","description":"使用docker简单部署redis","id":93,"section":"docker","tags":["docker"],"title":"docker 部署redis","uri":"https://www.zhugeqing.top/docker/docker-redis/"},{"content":"使用docker搭建 mysql PXC集群  使用云服务器搭建，会大致swarm集群 中容器之间无法连通，可以自建集群，或者是买 docker swarm专门的云服务，亦或者是使用虚拟机\n 先创建主节点容器   保证已经存在docker swarm 集群，并且使用docker network create -d overlay --attachable mysql-pxc创建swarm网络\n  在master上先创建主节点容器\n  1 2 3 4 5 6 7 8 9  docker run -d -p 13306:3306 \\ -e MYSQL_ROOT_PASSWORD=root \\ -e CLUSTER_NAME=pxc \\ -e XTRABACKUP_PASSWORD=root \\ -v pxc1:/var/lib/mysql \\ --privileged \\ --name=pxc1 \\ --net=mysql-pxc \\ zhugeqing/pxc   在node1上创建从节点容器  1 2 3 4 5 6 7 8 9 10  docker run -d -p 13306:3306 \\ -e MYSQL_ROOT_PASSWORD=root \\ -e CLUSTER_NAME=pxc \\ -e XTRABACKUP_PASSWORD=root \\ -e CLUSTER_JOIN=pxc1 \\ -v pxc2:/var/lib/mysql \\ --privileged \\ --name=pxc2 \\ --net=mysql-pxc \\ zhugeqing/pxc   在node2上创建从节点容器  1 2 3 4 5 6 7 8 9 10  docker run -d -p 13306:3306 \\ -e MYSQL_ROOT_PASSWORD=root \\ -e CLUSTER_NAME=pxc \\ -e XTRABACKUP_PASSWORD=root \\ -e CLUSTER_JOIN=pxc1 \\ -v pxc3:/var/lib/mysql \\ --privileged \\ --name=pxc3 \\ --net=mysql-pxc \\ zhugeqing/pxc   进行分片  部署两个pxc集群\n 使用docker搭建 Replication集群 ","description":"docker swarm 部署mysql集群\"","id":94,"section":"docker","tags":["docker"],"title":"docker部署 pxc集群 和 Replication集群","uri":"https://www.zhugeqing.top/docker/docker-mysql-pxc/"},{"content":"算法  无须强调的习惯\n  76. 最小覆盖子串——第一遍  修改潜意识  开始阶段\n 记：  骂自己的第7天 十五分钟日记的第7天 思念祖母的第113天 持续正念第9天 持续行动的122天！\n  ","description":"完成一个属于自己的最小可行化产品","id":95,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-12-6/"},{"content":"使用mysql image的一些问题 无法远程访问到mysql容器 保证运行映射的mysql容器内端口为3306，主机端口可以任意选择，并保证该端口防火墙是关闭的\n删除容器恢复数据库内容 当使用了docker volume时，删除mysql容器，再次运行时无须加入 密码参数，只要volum还是同一个，数据就依然存在\n操作mysql添加一些中文值会显示问号  配置mysql容器中的配置文件，像配置主机mysql一样，但前提是安装一些可编辑mysql容器文件的程序，比如vim 可以得知mysql内部容器包含apt命令，配置国内镜像源并安装一些自己需要的命令 配置国内镜像源并更新镜像源（cat /etc/issue 查看当前系统版本，再从 阿里云 选取对应版本的源）  cat \u0026gt; /etc/apt/sources.list \u0026lt;\u0026lt; EOF deb http://mirrors.aliyun.com/debian/ bullseye main non-free contrib deb-src http://mirrors.aliyun.com/debian/ bullseye main non-free contrib deb http://mirrors.aliyun.com/debian-security/ bullseye-security main deb-src http://mirrors.aliyun.com/debian-security/ bullseye-security main deb http://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib deb-src http://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib deb http://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib deb-src http://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib EOF  apt-get update   安装vim   apt-get install -y vim  编辑配置文件   cd /etc/mysql/mysql.conf.d \u0026amp;\u0026amp; vim mysqld.cnf  # 粘贴下列文件 [mysqld] pid-file = /var/run/mysqld/mysqld.pid socket = /var/run/mysqld/mysqld.sock datadir = /var/lib/mysql log-error = /var/log/mysql/error.log # By default we only accept connections from localhost #bind-address = 127.0.0.1 # Disabling symbolic-links is recommended to prevent assorted security risks symbolic-links=0 character_set_server=utf8 init_connect='SET NAMES utf8' max_allowed_packet = 20M [mysql] default-character-set = utf8 [mysql.server] default-character-set = utf8 [mysqld_safe] default-character-set = utf8 [client] default-character-set = utf8 # 节点id server-id=1 # 开启bin log log-bin=/var/lib/mysql/mysql-bin 使用redis 镜像遇到的问题  docker无法启动redis镜像\n  如果使用配置文件来启动redis，那么配置文件中的daemonize为yes，意思是redis服务在后台运行，与docker中的-d参数冲突了，需要把daemonize的参数值改为no或者是不进行设置。  deb http://deb.debian.org/debian stretch main\ndeb http://security.debian.org/debian-security stretch/updates main\ndeb http://deb.debian.org/debian stretch-updates main\ndeb http://mirrors.cloud.aliyuncs.com/debian/ jessie main non-free contrib\ndeb http://mirrors.cloud.aliyuncs.com/debian/ jessie-proposed-updates main non-free contrib\ndeb-src http://mirrors.cloud.aliyuncs.com/debian/ jessie main non-free contrib\ndeb-src http://mirrors.cloud.aliyuncs.com/debian/ jessie-proposed-updates main non-free contrib\ndocker启动的centos容器有些命令执行不了  赋予容器更多权限\n  启动docker时将/usr/sbin/init启动：docker run --name centos --privileged -d centos /usr/sbin/init 启动参数添加\u0026ndash;privileged参数，用于给予此container更多特权  导入 和 导出 容器  docker export consul \u0026gt; consul.tar （导出consul） docker import consul.tar consul （导入consul） docker run --restart always --name consul -d -p 8500:8500 -p 8300:8300 -p 8301:8301 -p 8302:8302 -p 8600:8600/udp consul consul agent -dev -client=0.0.0.0 （运行consul，需要带上原来的参数）  ","description":"使用Docker的一些问题","id":96,"section":"docker","tags":["docker"],"title":"解决使用docker出现的问题！","uri":"https://www.zhugeqing.top/docker/tips/"},{"content":"算法  无须强调的习惯\n  5. 最长回文子串——第二遍 1739. 放置盒子——第三遍 3. 无重复字符的最长子串——第一遍  修改潜意识  开始阶段\n 记：  骂自己的第6天 十五分钟日记的第6天 思念祖母的第112天 持续正念第8天 持续行动的121天！\n  ","description":"完成一个属于自己的最小可行化产品","id":97,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-12-5/"},{"content":"算法  无须强调的习惯\n 修改潜意识  开始阶段\n  214. 最短回文串——第一遍  记：  骂自己的第5天 十五分钟日记的第5天 思念祖母的第111天 持续正念第7天 持续行动的120天！\n  ","description":"纵使一件事情真的很难，你就迈出第一步试试，有何不可？","id":98,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-12-4/"},{"content":"算法  无须强调的习惯\n  25. K 个一组翻转链表——题库冲刺第二遍 239. 滑动窗口最大值——题库冲刺第一遍  修改潜意识  开始阶段\n 记：  骂自己的第4天 十五分钟日记的第4天 思念祖母的第110天 持续正念第6天 持续行动的119天！\n  ","description":"纵使一件事情真的很难，你就迈出第一步试试，有何不可？","id":99,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-12-3/"},{"content":"算法  无须强调的习惯\n 最长回文子串 阶乘后的零 放置盒子  修改潜意识  开始阶段\n 记：  骂自己的第3天 十五分钟日记的第3天 思念祖母的第109天 持续正念第5天 持续行动的118天！\n  ","description":"纵使一件事情真的很难，你就迈出第一步试试，有何不可？","id":100,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-12-2/"},{"content":"模板引擎的使用步骤  定义模板文件 解析模板文件  1 2 3 4  //常用方法 func (t *Template) Parse(src string) (*Template, error) func ParseFiles(filenames ...string) (*Template, error) func ParseGlob(pattern string) (*Template, error)   模板渲染  1 2 3  //常用方法 func (t *Template) Execute(wr io.Writer, data interface{}) error func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error   示例 模板文件go.tmpl\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;template示例\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;你好呀！{{.}}\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   代码文件main.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;html/template\u0026#34; \u0026#34;net/http\u0026#34; ) func example(w http.ResponseWriter, r *http.Request) { // 解析指定文件生成模板对象 \ttmpl, err := template.ParseFiles(\u0026#34;./go.tmpl\u0026#34;) if err != nil { fmt.Println(\u0026#34;create template failed, err:\u0026#34;, err) return } // 通过执行Execute将data渲染到模板，并写入到ResponseWriter \ttmpl.Execute(w, \u0026#34;诸葛青\u0026#34;) } func main() { http.HandleFunc(\u0026#34;/\u0026#34;, example) err := http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) if err != nil { fmt.Println(\u0026#34;HTTP server failed,err:\u0026#34;, err) return } }   模板语法 {{.}} 模板语法都包含在{{和}}中间，其中{{.}}中的点表示当前对象。\n当传入一个结构体对象时，可以根据.来访问结构体的对应字段：\n代码文件main.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;html/template\u0026#34; \u0026#34;net/http\u0026#34; ) func example(w http.ResponseWriter, r *http.Request) { // 解析指定文件生成模板对象 \ttmpl, err := template.ParseFiles(\u0026#34;./go.tmpl\u0026#34;) if err != nil { fmt.Println(\u0026#34;create template failed, err:\u0026#34;, err) return } // 通过执行Execute将data渲染到模板，并写入到ResponseWriter \ttmpl.Execute(w, map[string]interface{}{ \u0026#34;Name\u0026#34;: \u0026#34;诸葛青\u0026#34;, \u0026#34;Age\u0026#34;: 19, \u0026#34;favorite\u0026#34;: \u0026#34;nothing\u0026#34;, }) } func main() { http.HandleFunc(\u0026#34;/\u0026#34;, example) err := http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) if err != nil { fmt.Println(\u0026#34;HTTP server failed,err:\u0026#34;, err) return } }   模板文件go.tmpl\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;template示例\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;姓名：{{.Name}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;年龄：{{.Age}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;最喜爱的：{{.favorite}}\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   注释 {{/* a comment */}}\n注释，执行时会忽略。可以多行。注释不能嵌套，并且必须紧贴分界符始止。\npipeline pipeline是指产生数据的操作。比如{{.}}、{{.Name}}等。Go的模板语法中支持使用管道符号|链接多个命令，用法和unix下的管道类似：|前面的命令会将运算结果(或返回值)传递给后一个命令的最后一个位置。\n 注意 : 并不是只有使用了|才是pipeline。Go的模板语法中，pipeline的概念是传递数据，只要能产生数据的，都是pipeline。  变量 在模版里可以初始化一个变量来捕获传入模板的数据或其他语句生成的结果。初始化语法如下：\n$variable := pipeline\n移除空格 使用{{-语法去除模板内容左侧的所有空白符号， 使用-}}去除模板内容右侧的所有空白符号。\n{{- .Name -}}\n 注意：-要紧挨{{和}}，同时与模板值之间需要使用空格分隔。  条件判断 Go模板语法中的条件判断有以下几种:\n{{if pipeline}} T1 {{end}}\n{{if pipeline}} T1 {{else}} T0 {{end}}\n{{if pipeline}} T1 {{else if pipeline}} T0 {{end}}\n\nrange Go的模板语法中使用range关键字进行遍历，有以下两种写法，其中pipeline的值必须是数组、切片、字典或者通道。\n1 2 3  {{range $key, $val := .}} \u0026lt;p\u0026gt;{{$key}} - {{$val}}\u0026lt;/p\u0026gt; {{end}}    果pipeline的值其长度为0，不会有任何输出\n 1 2 3 4 5  {{range $key, $val := .}} \u0026lt;p\u0026gt;{{$key}} - {{$val}}\u0026lt;/p\u0026gt; {{else }}} \u0026lt;p\u0026gt;长度为0\u0026lt;/p\u0026gt; {{end}}    如果pipeline的值其长度为0，则会执行else\n with  相当于构建一个作用域\n {{with pipeline}} T1 {{end}} 如果pipeline为empty不产生输出，否则将dot设为pipeline的值并执行T1。不修改外面的dot。 {{with pipeline}} T1 {{else}} T0 {{end}} 如果pipeline为empty，不改变dot并执行T0，否则dot设为pipeline的值并执行T1。 预定义函数 执行模板时，函数从两个函数字典中查找：首先是模板函数字典，然后是全局函数字典。一般不在模板内定义函数，而是使用Funcs方法添加函数到模板里。\n预定义的全局函数如下：\nand 函数返回它的第一个empty参数或者最后一个参数； 就是说\u0026quot;and x y\u0026quot;等价于\u0026quot;if x then y else x\u0026quot;；所有参数都会执行； or 返回第一个非empty参数或者最后一个参数； 亦即\u0026quot;or x y\u0026quot;等价于\u0026quot;if x then x else y\u0026quot;；所有参数都会执行； not 返回它的单个参数的布尔值的否定 len 返回它的参数的整数类型长度 index 执行结果为第一个参数以剩下的参数为索引/键指向的值； 如\u0026quot;index x 1 2 3\u0026quot;返回x[1][2][3]的值；每个被索引的主体必须是数组、切片或者字典。 print 即fmt.Sprint printf 即fmt.Sprintf println 即fmt.Sprintln html 返回其参数文本表示的HTML逸码等价表示。 urlquery 返回其参数文本表示的可嵌入URL查询的逸码等价表示。 js 返回其参数文本表示的JavaScript逸码等价表示。 call 执行结果是调用第一个参数的返回值，该参数必须是函数类型，其余参数作为调用该函数的参数； 如\u0026quot;call .X.Y 1 2\u0026quot;等价于go语言里的dot.X.Y(1, 2)； 其中Y是函数类型的字段或者字典的值，或者其他类似情况； call的第一个参数的执行结果必须是函数类型的值（和预定义函数如print明显不同）； 该函数类型值必须有1到2个返回值，如果有2个则后一个必须是error接口类型； 如果有2个返回值的方法返回的error非nil，模板执行会中断并返回给调用模板执行者该错误； 比较函数 布尔函数会将任何类型的零值视为假，其余视为真。\n下面是定义为函数的二元比较运算的集合：\neq 如果arg1 == arg2则返回真 ne 如果arg1 != arg2则返回真 lt 如果arg1 \u0026lt; arg2则返回真 le 如果arg1 \u0026lt;= arg2则返回真 gt 如果arg1 \u0026gt; arg2则返回真 ge 如果arg1 \u0026gt;= arg2则返回真 为了简化多参数相等检测，eq（只有eq）可以接受2个或更多个参数，它会将第一个参数和其余参数依次比较，返回下式的结果：\n{{eq arg1 arg2 arg3}}\n比较函数只适用于基本类型（或重定义的基本类型，如”type Celsius float32”）。但是，整数和浮点数不能互相比较。\n自定义函数 Go的模板支持自定义函数。 代码文件main.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;html/template\u0026#34; \u0026#34;net/http\u0026#34; ) func example(w http.ResponseWriter, r *http.Request) { //定义一个模版引擎 \tt := template.New(\u0026#34;go.tmpl\u0026#34;) //在模版中自定义函数（如下函数名为\u0026#34;夸奖\u0026#34;） \tt.Funcs(template.FuncMap{\u0026#34;夸奖\u0026#34;: func(name string) (string, error) { return name + \u0026#34;持续且努力\u0026#34;, nil }}) // 解析指定文件生成模板对象 \t_, err := t.ParseFiles(\u0026#34;./go.tmpl\u0026#34;) if err != nil { fmt.Println(\u0026#34;create template failed, err:\u0026#34;, err) return } //渲染模版 \tt.Execute(w, \u0026#34;诸葛青\u0026#34;) } func main() { http.HandleFunc(\u0026#34;/\u0026#34;, example) err := http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) if err != nil { fmt.Println(\u0026#34;HTTP server failed,err:\u0026#34;, err) return } }   模版文件go.tmpl\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;template示例\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; {{夸奖 .}} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   嵌套template 可以在template中嵌套其他的template。这个template可以是单独的文件，也可以是通过define定义的template。\n模版文件1go1.tmpl\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;tmpl test\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;测试嵌套template语法\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; {{template \u0026#34;go2.tmpl\u0026#34;}} \u0026lt;hr\u0026gt; \u0026lt;p\u0026gt;我是 {{- . -}}}\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; {{ define \u0026#34;go3.tmpl\u0026#34;}} \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;吃饭\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;睡觉\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;打豆豆\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; {{end}}   模版文件2go2.tmpl\n1 2 3 4 5  \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;注释\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;日志\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;测试\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;   代码文件main.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;html/template\u0026#34; \u0026#34;net/http\u0026#34; ) func tmplDemo(w http.ResponseWriter, r *http.Request) { //解析模版  tmpl, err := template.ParseFiles(\u0026#34;./go.tmpl\u0026#34;, \u0026#34;./go2.tmpl\u0026#34;) if err != nil { fmt.Println(\u0026#34;create template failed, err:\u0026#34;, err) return } user := struct { name string sex string Age int }{\u0026#34;诸葛青\u0026#34;, \u0026#34;男\u0026#34;, 19} //渲染模版 \ttmpl.Execute(w, user) } func main() { http.HandleFunc(\u0026#34;/template\u0026#34;, tmplDemo) err := http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) if err != nil { fmt.Println(\u0026#34;HTTP server failed,err:\u0026#34;, err) return } }   block {{block \u0026quot;name\u0026quot; pipeline}} T1 {{end}}\n block是定义模板{{define \u0026quot;name\u0026quot;}} T1 {{end}}和执行{{template \u0026quot;name\u0026quot; pipeline}}缩写，典型的用法是定义一组根模板，然后通过在其中重新定义块模板进行自定义。\n 定义一个根模板base.tmpl，内容如下：\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Go Templates\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container-fluid\u0026#34;\u0026gt; {{block \u0026#34;content\u0026#34; . }}{{end}} \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   然后定义一个index.tmpl，”继承”base.tmpl：\n1 2 3 4 5 6 7  {{/*加 . 会继承根模版的数据，反之，则不会*/}} {{template \u0026#34;base.tmpl\u0026#34; .}} {{define \u0026#34;content\u0026#34;}} \u0026lt;div\u0026gt;我是content模版，我被另外一个模版找到了\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;你好!{{.}}\u0026lt;/p\u0026gt; {{end}}   代码文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;html/template\u0026#34; \u0026#34;net/http\u0026#34; ) func index(w http.ResponseWriter, r *http.Request) { tmpl, err := template.ParseGlob(\u0026#34;*.tmpl\u0026#34;) if err != nil { fmt.Println(\u0026#34;create template failed, err:\u0026#34;, err) return } //选择模版文件进行渲染 \terr = tmpl.ExecuteTemplate(w, \u0026#34;base.tmpl\u0026#34;, \u0026#34;诸葛青\u0026#34;) if err != nil { fmt.Println(\u0026#34;render template failed, err:\u0026#34;, err) return } } func main() { http.HandleFunc(\u0026#34;/index\u0026#34;, index) err := http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) if err != nil { fmt.Println(\u0026#34;HTTP server failed,err:\u0026#34;, err) return } }   修改默认的标识符 template.New(\u0026quot;go.tmpl\u0026quot;).Delims(\u0026quot;{[\u0026quot;, \u0026quot;]}\u0026quot;).ParseFiles(\u0026quot;./go.tmpl\u0026quot;)\n代码文件main.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;html/template\u0026#34; \u0026#34;net/http\u0026#34; ) func test1(w http.ResponseWriter, r *http.Request) { t, err := template.New(\u0026#34;go.tmpl\u0026#34;). Delims(\u0026#34;{[\u0026#34;, \u0026#34;]}\u0026#34;). ParseFiles(\u0026#34;./go.tmpl\u0026#34;) if err != nil { fmt.Println(err) return } err = t.Execute(w, \u0026#34;诸葛青\u0026#34;) if err != nil { fmt.Println(err) } } func main() { http.HandleFunc(\u0026#34;/test1\u0026#34;, test1) err := http.ListenAndServe(\u0026#34;:9090\u0026#34;, nil) if err != nil { fmt.Println(err) } }   模版文件go.tmpl\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;tmpl test\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;测试修改默认的标示符\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;我是{[ . ]}\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   ","description":"Go语言html/template的学习","id":101,"section":"golang","tags":["Go"],"title":"Go语言template库","uri":"https://www.zhugeqing.top/golang/template/"},{"content":"算法  无须强调的习惯\n  146. LRU 缓存机制  修改潜意识  开始阶段\n 记：  骂自己的第2天 十五分钟日记的第2天 思念祖母的第108天 持续正念第4天 持续行动的117天！\n  ","description":"纵使一件事情真的很难，你就迈出第一步试试，有何不可？","id":102,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-12-1/"},{"content":"算法  无须强调的习惯\n  25. K 个一组翻转链表——第二遍  修改潜意识  开始阶段\n 记：  骂自己的第1天 十五分钟日记的第1天 思念祖母的第107天 持续正念第3天 持续行动的一百一十六天！  ","description":"纵使一件事情真的很难，你就迈出第一步试试，有何不可？","id":103,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-30/"},{"content":"算法  1739. 放置盒子——第一遍 172. 阶乘后的零——第二遍  锻炼身心 思念 思念祖母的第106天\n记：持续行动的一百一十六天！\n","description":"纵使一件事情真的很难，你就迈出第一步试试，有何不可？","id":104,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-29/"},{"content":"算法  CD43 最小编辑代价——第一遍 85. 最大矩形——第三遍 19. 删除链表的倒数第 N 个结点——第三遍 28. 实现 strStr()——第三遍（还要再来）  锻炼身心 思念 思念祖母的第105天\n记：持续行动的一百一十五天！\n","description":"纵使一件事情真的很难，你就迈出第一步试试，有何不可？","id":105,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-28/"},{"content":"算法  72. 编辑距离——第三遍  锻炼身心 思念 思念祖母的第104天\n记：持续行动的一百一十四天！\n","description":"纵使一件事情真的很难，你就迈出第一步试试，有何不可？","id":106,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-27/"},{"content":"算法  面试题 03.02. 栈的最小值——第三遍 172. 阶乘后的零——第一遍 105. 从前序与中序遍历序列构造二叉树——N个月后  锻炼身心 思念 思念祖母的第103天\n记：持续行动的一百一十三天！\n","description":"纸上得来终觉浅，绝知此事要躬行","id":107,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-26/"},{"content":"算法  28. 实现 strStr()——第二遍  锻炼身心 思念 思念祖母的第102天\n记：持续行动的一百一十二天！\n","description":"纸上得来终觉浅，绝知此事要躬行","id":108,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-25/"},{"content":" 第二高的薪水  第二高的薪水 题目地址:入口\n 题目：编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。  1 2 3 4 5 6 7  +----+--------+|Id|Salary|+----+--------+|1|100||2|200||3|300|+----+--------+  例如上述 Employee 表，SQL查询应该返回 200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。\n1 2 3 4 5  +---------------------+|SecondHighestSalary|+---------------------+|200|+---------------------+   解法：  使用distinct来过滤相同的salary，使用order by进行排序，再加上DESC使其递减，用limit n表示返回前n条数据，offset n表示跳过n条语句，（limit 1 offset 1表示跳过前一条数据，再返回前一条数据），由于还需要返回null的情况，所以将其作为临时表\n1 2 3 4 5 6 7 8  SELECT(SELECTDISTINCTSalaryFROMEmployeeORDERBYSalaryDESCLIMIT1OFFSET1)ASSecondHighestSalary;  ifnull函数来判断表达式返回值是否为null，若为null，则返回括号后面的值，否则返回表达式的结果\n1 2 3 4 5 6 7  selectifnull((selectdistinctsalaryfromEmployeeORDERBYsalaryDESClimit1,1),null)asSecondHighestSalary  ","description":"查询犹如算法","id":109,"section":"problems","tags":["Sql"],"title":"Sql题目","uri":"https://www.zhugeqing.top/problems/mysql/sql/"},{"content":"算法  19. 删除链表的倒数第 N 个结点——第二遍  锻炼身心 思念 思念祖母的第101天\n记：持续行动的一百一十一天！\n","description":"纸上得来终觉浅，绝知此事要躬行","id":110,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-24/"},{"content":"1. 进程与线程有什么区别 了解进程与线程——\u0026gt;进程与线程的一个简单解释\n答：   调度：进程是资源管理的基本单位，线程是程序执行的基本单位\n  拥有资源：进程是拥有资源的一个独立单位，线程不拥有资源，只拥有一点在运行中必不可少的资源（如程序计数器,一组寄存器和栈），和同属于本进程的线程共享本进程的资源（cpu，I/O，内存等）\n  切换：进程上下文切换比线程上下文切换要快得多。（因为进程切换需要保存进程当前的整个环境的保存和被调度运行的新进程环境的设置，而线程切换只需要保存和设置少量的寄存器）\n  系统开销：创建或撤销进程时，系统都要为之分配和回收系统资源，如内存空间，I/O设备等，操作系统所付出的开销显著大于在创建或撤销线程的开销，所以进程的切换开销也远大于线程切换的开销\n  通信：线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行\n  线程依赖于进程而存在，一个进程至少有一个线程\n  多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮\n   同一进程中的线程可以共享哪些数据？  展开答案  进程代码段 进程的公有数据（全局变量、静态变量...） 进程打开的文件描述符 进程的当前目录 信号处理器/信号处理函数：对收到的信号的处理方式 进程ID与进程组ID   线程独占哪些资源？  展开  线程ID 一组寄存器的值 线程自身的栈（堆是共享的） 错误返回码：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其它线程修改 信号掩码/信号屏蔽字(Signal mask)：表示是否屏蔽/阻塞相应的信号（SIGKILL,SIGSTOP除外）  ","description":"一个工厂：进程，工厂里面的工人：线程","id":111,"section":"problems","tags":["操作系统题目"],"title":"进程和线程","uri":"https://www.zhugeqing.top/problems/os/process_thread/"},{"content":"三色标记原理 第一步\n第二步\n第三步\n第四步\n","description":"垃圾回收机制","id":112,"section":"problems","tags":["GO题目"],"title":"Go语言Gc","uri":"https://www.zhugeqing.top/problems/go/gc/"},{"content":"算法  面试题 03.02. 栈的最小值  锻炼身心 思念 思念祖母的第100天\n记：持续行动的一百一十天！\n","description":"纸上得来终觉浅，绝知此事要躬行","id":113,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-23/"},{"content":"有一个包含20亿个全是32位整数的大文件，在其中找到出现次数最多的数 分析：首先采用hash表用于统计，key为整数的值，value为整数出现的次数，而key为int32，占4字节，value也应为int32（最坏情况20亿个数都相同，只用int32正好cover，而又不浪费空间），占4字节，所以对于hash表一条记录需要8字节，最坏情况20亿个数都不相同，需要20亿条记录，大约就需要16GB的内存（简单估计大小，实际并没有16GB），而显然2GB内存空间无法加载一个16GB的hash表。\n解决方法：把包含20亿个整数的大文件用hash函数拆分成16个小文件，根据hash函数的性质可知，相同的数是不会被分配到不同的文件的，只要hash函数足够好，每一个小文件的hash表的所占空间就会小于2GB。拆分之后，对于每一个小文件，都用hash表来统计每一种数出现的次数，就可以得出16个小文件各自出现次数最多的数，再将这16个数进行比较，即可得出出现次数最多的数\n 进阶版——\u0026gt;点击此处\n","description":"如何处理大数据，内存限制 的问题","id":114,"section":"problems","tags":["海量数据"],"title":"海量数据","uri":"https://www.zhugeqing.top/problems/massive-data/"},{"content":"题目 实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。 要求\n1.pop、push、getMin操作的时间复杂度都是O（1）。\n2.设计的栈类型可以使用现成的栈结构。\n\n解法 在设计上我们使用两个栈，一个栈用来保存当前栈中的元素，其功能和一个正常的栈没有区别，这个栈记为stackData；另一个栈用于保存每一步的最小值，这个栈记为stackMin。具体的实现方式有两种。\n实现方式一  压入数据规则\n假设当前数据为newNum，先将其压入stackData。然后判断stackMin是否为空： 如果为空，则newNum也压入stackMin。 如果不为空，则比较newNum和stackMin的栈顶元素中哪一个更小： 如果newNum更小或两者相等，则newNum也压入stackMin； 如果stackMin中栈顶元素小，则stackMin不压入任何内容。  举例：依次压入3、4、5、1、2、1的过程中，stackData和stackMin的变化如下图所示。\n\n  弹出数据规则\n  先在stackData中弹出栈顶元素，记为value。然后比较当前stackMin的栈顶元素和value哪一个更小。\n通过上文提到的压入规则可知，stackMin中存在的元素是从栈底到栈顶逐渐变小的，stackMin栈顶的元素既是stackMin栈的最小值，也是当前stackData栈的最小值。所以不会出现value比stackMin的栈顶元素更小的情况，value只可能大于或等于stackMin的栈顶元素。\n  当value等于stackMin的栈顶元素时，stackMin弹出栈顶元素；当value大于stackMin的栈顶元素时，stackMin不弹出栈顶元素；返回value。\n很明显可以看出，压入与弹出规则是对应的。\n   查询当前栈中的最小值操作\n由上文的压入数据规则和弹出数据规则可知，stackMin始终记录着stackData中的最小值，所以，stackMin的栈顶元素始终是当前stackData中的最小值。\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  type MinStack struct { //普通栈（后进先出）  stackData []int //辅助栈，维护一个最小元素在data栈相对顺序的栈  stackMin []int //记录当前两个栈的大小，减少遍历  lengthData, lengthMin int } /** initialize your data structure here. */ func Constructor() MinStack { return MinStack{ stackData : []int{}, //加一个int64最大值，可以减少对min栈为空的判断  stackMin : []int{math.MaxInt64}, lengthMin : 1, } } func (this *MinStack) Push(x int) { this.stackData = append(this.stackData, x) this.lengthData++ //最小元素大于x时无需加入  if this.stackMin[this.lengthMin-1] \u0026gt;= x{ this.stackMin = append(this.stackMin, x) this.lengthMin++ } } func (this *MinStack) Pop() { x := this.stackData[this.lengthData-1] //出栈  this.stackData = this.stackData[:this.lengthData-1] this.lengthData-- //若data栈出栈的元素是最小元素，那么min栈也需要进行弹出操作  if this.stackMin[this.lengthMin-1] == x { this.stackMin = this.stackMin[:this.lengthMin-1] this.lengthMin-- } } func (this *MinStack) Top() int { return this.stackData[this.lengthData-1] } func (this *MinStack) GetMin() int { return this.stackMin[this.lengthMin-1] }   实现方式二  压入数据规则\n假设当前数据为newNum，先将其压入stackData。然后判断stackMin是否为空。 如果为空，则newNum也压入stackMin；如果不为空，则比较newNum和stackMin的栈顶元素中哪一个更小：如果newNum更小或两者相等，则newNum也压入stackMin；如果stackMin中栈顶元素小，则把stackMin的栈顶元素重复压入stackMin，即在栈顶元素上再压入一个栈顶元素。\n举例：依次压入3、4、5、1、2、1的过程中，stackData和stackMin的变化如下图所示。    弹出数据规则\n在stackData中弹出数据，弹出的数据记为value；弹出stackMin中的栈顶；返回value。\n很明显可以看出，压入与弹出规则是对应的\n  查询当前栈中的最小值操作\n由上文的压入数据规则和弹出数据规则可知，stackMin始终记录着stackData中的最小值，所以stackMin的栈顶元素始终是当前stackData中的最小值。\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  type MinStack struct { //保存当前栈的元素  stackData []int //保存每一步的最小值  stackMin []int //记录当前两个栈的大小，减少遍历  lengthData, lengthMin int } /** initialize your data structure here. */ func Constructor() MinStack { //给stackMin一个初始元素，是为了减少判断stackMin为空的情况  return MinStack{stackMin: []int{math.MaxInt64}, lengthMin: 1} } func (this *MinStack) Push(x int) { this.stackData = append(this.stackData, x) //压入栈，将栈顶元素和新元素比较，压入最小的元素  this.stackMin = append(this.stackMin, min(x, this.stackMin[this.lengthMin-1])) this.lengthData++ this.lengthMin++ } func (this *MinStack) Pop() { this.stackData = this.stackData[:this.lengthData-1] this.stackMin = this.stackMin[:this.lengthMin-1] this.lengthMin--; this.lengthData-- } func (this *MinStack) Top() int { return this.stackData[this.lengthData-1] } func (this *MinStack) GetMin() int { return this.stackMin[this.lengthMin-1] } func min(a, b int) int { if a \u0026lt; b { return a } return b }   总结 方案一和方案二其实都是用stackMin栈保存着stackData每一步的最小值。共同点是所有操作的时间复杂度都为O（1）、空间复杂度都为O（n）。区别是：方案一中stackMin压入时稍省空间，但是弹出操作稍费时间；方案二中stackMin压入时稍费空间，但是弹出操作稍省时间\n","description":"生命没有极限，除非你自己定义","id":115,"section":"interview","tags":[""],"title":"设计一个有getMin功能的栈","uri":"https://www.zhugeqing.top/interview/quality_questions/%E6%9C%80%E5%B0%8F%E6%A0%88/"},{"content":"算法  85. 最大矩形——第三遍  锻炼身心 思念 思念祖母的第98天\n记：持续行动的一百零八天！\n","description":"假如我们把自己力所能及的事情全部完成，我们的成就会让自己惊愕不已。","id":116,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-21/"},{"content":"算法   实现 strStr()——第二遍    反转字符串中的单词 III——第二遍    锻炼身心 思念 思念祖母的第99天\n记：持续行动的一百零九天！\n","description":"纸上得来终觉浅，绝知此事要躬行","id":117,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-22/"},{"content":"算法  677. 键值映射——第三遍  锻炼身心 思念 思念祖母的第97天\n记：持续行动的一百零七天！\n","description":"假如我们把自己力所能及的事情全部完成，我们的成就会让自己惊愕不已。","id":118,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-20/"},{"content":"算法  557. 反转字符串中的单词 III——第一遍  锻炼身心 思念 思念祖母的第96天\n记：持续行动的一百零六天！\n","description":"假如我们把自己力所能及的事情全部完成，我们的成就会让自己惊愕不已。","id":119,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-19/"},{"content":"算法  85. 最大矩形——第二遍  锻炼身心 思念 思念祖母的第95天\n记：持续行动的一百零五天！\n","description":"假如我们把自己力所能及的事情全部完成，我们的成就会让自己惊愕不已。","id":120,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-18/"},{"content":"算法  677. 键值映射——第二遍  锻炼身心 思念 思念祖母的第95天\n记：持续行动的一百零四天！\n","description":"假如我们把自己力所能及的事情全部完成，我们的成就会让自己惊愕不已。","id":121,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-17/"},{"content":"算法 300. 最长递增子序列——第三遍  锻炼身心 思念 思念祖母的第94天\n记：持续行动的一百零三天！\n","description":"假如我们把自己力所能及的事情全部完成，我们的成就会让自己惊愕不已。","id":122,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-16/"},{"content":"算法  85. 最大矩形——第一遍  锻炼身心 思念 思念祖母的第93天\n记：持续行动的一百零二天！\n","description":"见贤思齐焉 见不贤而内自省也","id":123,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-15/"},{"content":"算法  677. 键值映射——第一遍  锻炼身心 思念 思念祖母的第92天\n记：持续行动的一百零一天！\n","description":"见贤思齐焉 见不贤而内自省也","id":124,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-14/"},{"content":"算法  746. 使用最小花费爬楼梯——第三遍 300. 最长递增子序列——第二遍  锻炼身心 思念 思念祖母的第92天\n记：持续行动的一百零一天！\n","description":"见贤思齐焉 见不贤而内自省也","id":125,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-13/"},{"content":"REST REST为Representational State Transfer的缩写，中文翻译为表现层状态转换，本质是一种架构的原则，如果一个架构符合REST原则，就称它为RESTful架构。\n 严格来说，REST是设计风格而不是标准\n Representation（表现层） 资源（html，xml，txt，json，png，jpg...）是信息实体，可以拥有多种表现的形式，而资源所呈现的形式，就叫做资源的表现层（Representation）\nState Transfer（状态转换） 在客户端和服务器的通信的过程中，客户端通过使用HTTP协议的操作（Get，Put，Post，Delete）来改变服务端资源。让服务器端发生\u0026quot;状态转化\u0026quot;（State Transfer）\nRESTful API  直观简短的资源地址：URI，比如：http://example.com/resources。 传输的资源：Web服务接受与返回的互联网媒体类型，比如：JSON，XML，YAML等。 对资源的操作：Web服务在该资源上所支持的一系列请求方法（比如：POST，GET，PUT或DELETE）。  ","description":"简单理解RESTful","id":126,"section":"tips","tags":["tips"],"title":"RESTful","uri":"https://www.zhugeqing.top/tips/restful/"},{"content":"算法  32. 最长有效括号——一个月后  锻炼身心 思念 思念祖母的第92天\n记：持续行动的一百零一天！\n","description":"wang + innante + now","id":127,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-12/"},{"content":"基础概念  Request   Request是http请求，是用户请求的信息，用来解析用户的请求信息，包括post、get、cookie、url等信息，可以访问源码地址（源码103行）来查看Request结构体的详细定义\n Response   Response是http请求的响应，是服务器需要反馈给客户端的信息，可以访问源码地址（源码35行）来查看Response结构体的详细定义\n Conn   Conn是http的请求连接（用户的每次请求连接），可以访问源码地址（源码248行）来查看Conn结构体的详细定义\n Handler   Handler是接收请求后逻辑处理和生成返回信息的逻辑，可以访问源码地址（源码86行）来查看Handler接口\n http包运行机制 Go实现Web服务的工作模式的流程图\nhttp包执行流程😡   创建Listen Socket, 监听指定的端口, 等待客户端请求到来。\n  Listen Socket接受客户端的请求, 得到Client Socket, 接下来通过Client Socket与客户端通信。\n  处理客户端的请求, 首先从Client Socket读取HTTP请求的协议头, 如果是POST方法, 还可能要读取客户端提交的数据, 然后交给相应的handler处理请求, handler处理完毕准备好客户端需要的数据, 通过Client Socket写给客户端。\n  三个应该清楚的问题😃  如何监听端口？  Go是通过一个函数ListenAndServe来处理这些事情的，这个底层其实这样处理的：初始化一个server对象，然后调用了net.Listen(\u0026quot;tcp\u0026quot;, addr)，也就是底层用TCP协议搭建了一个服务，然后监控我们设置的端口。\n如何接收客户端请求？  执行监控端口之后，调用了srv.Serve(net.Listener)函数（代码如下），这个函数就是处理接收客户端的请求信息。这个函数里面起了一个for{}，首先通过Listener接收请求，其次创建一个Conn，最后单独开了一个goroutine，把这个请求的数据当做参数扔给这个conn去服务：go c.serve()。用户的每一次请求都是在一个新的goroutine去服务，相互不影响\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  func (srv *Server) Serve(l net.Listener) error { defer l.Close() var tempDelay time.Duration // how long to sleep on accept failure  for { rw, e := l.Accept() if e != nil { if ne, ok := e.(net.Error); ok \u0026amp;\u0026amp; ne.Temporary() { if tempDelay == 0 { tempDelay = 5 * time.Millisecond } else { tempDelay *= 2 } if max := 1 * time.Second; tempDelay \u0026gt; max { tempDelay = max } log.Printf(\u0026#34;http: Accept error: %v; retrying in %v\u0026#34;, e, tempDelay) time.Sleep(tempDelay) continue } return e } tempDelay = 0 c, err := srv.newConn(rw) if err != nil { continue } go c.serve() //创建一个Goroutine来处理  } }   如何分配handler？  conn首先会解析request:c.readRequest(),然后获取相应的handler:handler := c.server.Handler，也就是在调用函数ListenAndServe时候的第二个参数，如果传递的是nil，也就是为空，那么默认获取handler = DefaultServeMux,这个变量是一个路由器，它用来匹配url跳转到其相应的handle函数，而http.HandleFunc(\u0026quot;/\u0026quot;, handle)就是注册了请求/的路由规则，当请求uri为\u0026quot;\u0026quot;，路由就会转到函数handle，DefaultServeMux会调用ServeHTTP方法，这个方法内部其实就是调用handle本身，最后通过写入response的信息反馈到客户端\n一个http连接处理流程\n代码分析 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { http.Handle(\u0026#34;/\u0026#34;, \u0026amp;ThisHandler{}) http.Handle(\u0026#34;/彩虹海\u0026#34;, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\u0026#34;恭喜你已经成抵达彩虹海！\u0026#34;)) })) http.HandleFunc(\u0026#34;/诸葛青\u0026#34;, sayHi) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } func sayHi(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;Hi,诸葛青,%v\u0026#34;, \u0026#34;恭喜你已经初步掌握Go http包的基本工作原理了\u0026#34;) } type ThisHandler struct{} func (m *ThisHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\u0026#34;我实现了Hanler这个接口\u0026#34;)) }   分析  第9行的http.Handle(\u0026quot;/\u0026quot;, \u0026amp;ThisHandler{})表示为请求路径/注册了一个默认的路由器，而且ThisHanler这个struct实现了ServeHTTP方法，所以也就实现了接口Handler，固可以传入到函数http.Handle中。http.Handle函数的源码如下：  1 2 3  func Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }   第10~12行同样调用了函数http.Handle，但所传入参数与上面调用的不同，上面的第二个参数是因为这个结构体实现了Handle接口的方法，所以可以传入，而这里的http.HandlerFunc实际是type HandlerFunc func(ResponseWriter, *Request)，而在源码中这个类型别名同样实现了ServeHTTP(w ResponseWriter, r *Request)这个方法，所以这里相当于是一个类型转换，将实际的处理函数转换成http.HandleFunc类型，所以也可以传入到http.Handle中。具体源码如下：  1 2 3 4 5 6 7  //HandlerFunc类型是一个适配器，允许使用作为 HTTP处理程序的普通函数 type HandlerFunc func(ResponseWriter, *Request) // ServeHTTP 调用这个函数自身 func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) { f(w, r) }   第13行调用了http.HandleFunc这个函数，功能与http.Handle差不多。只不过http.Handle的第二个参数是一个Handler接口类型，也就是说只要实现了这个接口的类型都能作为参数传入，而http.HandleFunc的第二个参数就是一个函数类型，只要传入的函数以func(http.ResponseWriter, *http.Request)形式声明即可。具体源码如下：  1 2 3  func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { DefaultServeMux.HandleFunc(pattern, handler) }   第14行调用了http.ListenAndServe函数，第一个参数为监听的address，第二个参数为Handler接口类型，因为传入的是nil，所以handler就是默认的DefaultServeMux，也就是上面调用的函数源码中的DefaultServeMux。部分源码如下：  1 2 3 4  func ListenAndServe(addr string, handler Handler) error { server := \u0026amp;Server{Addr: addr, Handler: handler} return server.ListenAndServe() }   http包核心 Go的http有两个核心功能：Conn、ServeMux\nConn Go使用了goroutines来处理Conn的读写事件, 这样每个请求都能保持独立，相互不会阻塞，可以高效的响应网络事件。\nGo在等待客户端请求的源码如下：\n1 2 3 4 5  c, err := srv.newConn(rw) if err != nil { continue } go c.serve()   ServeMux  相当于是http内部的路由器\n ServeMux的结构如下\n1 2 3 4 5 6 7 8 9 10 11  type ServeMux struct { mu sync.RWMutex //读写锁 \tm map[string]muxEntry // 路由 map，pattern-\u0026gt;HandleFunc \tes []muxEntry // 从长到短排序好的的切片 \thosts bool // 是否包含hosts } type muxEntry struct { h Handler //路由对应的Handler \tpattern string //路由路径 }   在ServeMux中的成员m就是关于不同的路由路径所对应的处理函数的映射，如果找不到对于的路径映射，那么就是默认返回404，但是如果配置了/的处理函数，那么对于没有对应路由路径的会调用/的处理函数\n总结  首先调用http.Handle和http.HandleFunc   按顺序做了几件事\n1.调用了DefaultServeMux的Handle\n2.调用了DefaultServeMux的HandleFunc\n3.往DefaultServeMux的map[string]muxEntry中增加对应的handler和路由规则\n \n 其次调用http.ListenAndServe(\u0026quot;:8080\u0026quot;, nil)   按顺序做了几件事情\n1.实例化Server\n2.调用Server的ListenAndServe()\n3.调用net.Listen(\u0026quot;tcp\u0026quot;, addr)监听端口\n4.启动一个for循环，在循环体中Accept请求\n5.对每个请求实例化一个Conn，并且开启一个goroutine为这个请求进行服务go c.serve()\n6.读取每个请求的内容w, err := c.readRequest()\n7.根据request选择handler，并且进入到这个handler的ServeHTTP\n8.判断handler是否为空，如果没有设置handler，handler就设置为DefaultServeMux\n9.选择handler：\nA 判断是否有路由能满足这个request（循环遍历ServeMux的muxEntry）\nB 如果有路由满足，调用这个路由handler的ServeHTTP\nC 如果没有路由满足，调用NotFoundHandler的ServeHTTP\n ","description":"net/http包的学习","id":128,"section":"golang","tags":["Go"],"title":"Go语言http详解","uri":"https://www.zhugeqing.top/golang/http/"},{"content":"算法  91. 解码方法——一个月后  锻炼身心 思念 思念祖母的第91天\n记：持续行动的一百天！\n","description":"wang + innante + now","id":129,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-11/"},{"content":"算法  746. 使用最小花费爬楼梯——第二遍 72. 编辑距离——第三遍 912. 排序数组——第三遍 300. 最长递增子序列——第二遍  锻炼身心 思念 思念祖母的第90天\n记：持续行动的九十九天！\n","description":"wang + innante + now","id":130,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-10/"},{"content":"最小编辑代价是编辑距离的变形题目\n题目 给定两个字符串str1和str2，再给定三个整数ic、dc和rc，分别代表插入、删除和替换一个字符的代价，返回将str1编辑成str2的最小代价。 【举例】\nstr1=\u0026ldquo;abc\u0026rdquo;，str2=\u0026ldquo;adc\u0026rdquo;，ic=5，dc=3，rc=2。\n从\u0026quot;abc\u0026quot;编辑成\u0026quot;adc\u0026quot;，把\u0026rsquo;b\u0026rsquo;替换成\u0026rsquo;d\u0026rsquo;是代价最小的，所以返回2。\nstr1=\u0026ldquo;abc\u0026rdquo;，str2=\u0026ldquo;adc\u0026rdquo;，ic=5，dc=3，rc=100。\n从\u0026quot;abc\u0026quot;编辑成\u0026quot;adc\u0026quot;，先删除\u0026rsquo;b'，然后插入\u0026rsquo;d\u0026rsquo;是代价最小的，所以返回8。\nstr1=\u0026ldquo;abc\u0026rdquo;，str2=\u0026ldquo;abc\u0026rdquo;，ic=5，dc=3，rc=2。\n不用编辑了，本来就是一样的字符串，所以返回0。\n\n解法 如果str1的长度为M，str2的长度为N，经典动态规划的方法可以达到时间复杂度为O（M×N），额外空间复杂度为O（M×N）。如果结合空间压缩的技巧，可以把额外空间复杂度减至O（min{M，N}）。 先来介绍经典动态规划的方法。首先生成大小为（M+1）×（N+1）的矩阵dp，dp[i][j]的值代表str1[0..i-1]编辑成str2[0..j-1]的最小代价。举个例子，str1=\"ab12cd3\"，str2=\"abcdf\"，ic=5，dc=3，rc=2。dp是一个8×6的矩阵，最终计算结果如下 下面具体说明dp矩阵每个位置的值是如何计算的。\n dp[0][0]=0，表示str1空的子串编辑成str2空的子串的代价为0。 矩阵dp第一列即dp[0..M-1][0]。dp[i][0]表示str1[0..i-1]编辑成空串的最小代价，毫无疑问，是把str1[0..i-1]所有的字符删掉的代价，所以dp[i][0]=dc*i。 矩阵dp第一行即dp[0][0..N-1]。dp[0][j]表示空串编辑成str2[0..j-1]的最小代价，毫无疑问，是在空串里插入str2[0..j-1]所有字符的代价，所以dp[0][j]=ic*j。 其他位置按照从左到右，再从上到下来计算，dp[i][j]的值只可能来自以下四种情况。  str1[0..i-1]可以先编辑成str1[0..i-2]，也就是删除字符str1[i-1]，然后由str1[0..i-2]编辑成 str2[0..j-1]，dp[i-1][j]表示 str1[0..i-2]编辑成 str2[0..j-1]的最小代价，那么dp[i][j]可能等于dc+dp[i-1][j]。 str1[0..i-1]可以先编辑成str2[0..j-2]，然后将str2[0..j-2]插入字符str2[j-1]，编辑成str2[0..j-1]，dp[i][j-1]表示 str1[0..i-1]编辑成 str2[0..j-2]的最小代价，那么 dp[i][j]可能等于dp[i][j-1]+ic。 如果str1[i-1]！=str2[j-1]。先把str1[0..i-1]中str1[0..i-2]的部分变成str2[0..j-2]，然后把字符str1[i-1]替换成str2[j-1]，这样str1[0..i-1]就编辑成str2[0..j-1]了。dp[i-1][j-1]表示str1[0..i-2]编辑成str2[0..i-2]的最小代价，那么dp[i][j]可能等于dp[i-1][j-1]+rc。 如果 str1[i-1]==str2[j-1]。先把 str1[0..i-1]中 str1[0..i-2]的部分变成 str2[0..j-2]，因为此时字符 str1[i-1]等于 str2[j-1]，所以 str1[0..i-1]已经编辑成 str2[0..j-1]了。dp[i-1][j-1]表示 str1[0..i-2]编辑成 str2[0..i-2]的最小代价，那么 dp[i][j]可能等于dp[i-1][j-1]。\n5.以上四种可能的值中，选最小值作为dp[i][j]的值。dp最右下角的值就是最终结果。    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  package main import \u0026#34;fmt\u0026#34; func main() { var str1, str2 string var ic, dc, rc int fmt.Scanln(\u0026amp;str1) fmt.Scanln(\u0026amp;str2) fmt.Scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;ic, \u0026amp;dc, \u0026amp;rc) m, n := len(str1), len(str2) //选择较长的字符串作为行字符串  if m \u0026lt; n { m, n = n, m str1, str2 = str2, str1 //原字符串成为短的列字符串，需要进行替换和插入操作，所以需要交换一下ic和dc  ic, dc = dc, ic } dp := make([][]int, m+1) for i := range dp { dp[i] = make([]int, n+1) dp[i][0] = i * dc } for j := range dp[0] { dp[0][j] = j * ic } for i := 1; i \u0026lt;= m; i++ { for j := 1; j \u0026lt;= n; j++ { if str1[i-1] == str2[j-1] { dp[i][j] = dp[i-1][j-1] } else { dp[i][j] = min(dp[i-1][j]+dc, min(dp[i][j-1]+ic, dp[i-1][j-1]+rc)) } } } fmt.Println(dp[m][n]) } func min(a, b int) int { if a \u0026gt; b { return b } return a }   压缩状态\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  package main import \u0026#34;fmt\u0026#34; func main() { var str1, str2 string var ic, dc, rc int fmt.Scanln(\u0026amp;str1) fmt.Scanln(\u0026amp;str2) fmt.Scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;ic, \u0026amp;dc, \u0026amp;rc) m, n := len(str1), len(str2) if m \u0026lt; n { m, n = n, m str1, str2 = str2, str1 //需要交换ic与dc  ic, dc = dc, ic } //压缩状态  dp := make([]int, n+1) //base case（处理空字符串的word1, word2子字符串的编辑记录）  for i := 1; i \u0026lt;= n; i++ { dp[i] = i * ic } pre := 0 //记录dp[i-1][j-1]  //状态转移方程  for i := 1; i \u0026lt;= m; i++ { dp[0], pre = i * dc, dp[0] for j := 1; j \u0026lt;= n; j++ { if str1[i-1] == str2[j-1] { dp[j], pre = pre, dp[j] } else { dp[j], pre = min(dp[j]+dc, min(dp[j-1]+ic, pre+rc)), dp[j] } } } fmt.Println(dp[n]) } // func minDistance(str1, str2 string, ic, dc, rc int) int { // //动态规划 // //状态定义 // //dp[i][j]表示str1[0:i+1]与str2[0:j+1]的编辑距离  // }  func min(a, b int) int { if a \u0026lt; b { return a } return b }    ","description":"生命没有极限，除非你自己定义","id":131,"section":"interview","tags":[""],"title":"最小编辑代价","uri":"https://www.zhugeqing.top/interview/quality_questions/%E6%9C%80%E5%B0%8F%E7%BC%96%E8%BE%91%E4%BB%A3%E4%BB%B7/"},{"content":"题目 给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。\n输入格式\n第一行包含整数 N。\n第二行包含 N 个整数，表示完整序列。\n输出格式\n输出一个整数，表示最大长度。\n\n数据范围 1≤N≤1000， −109≤数列中的数≤109\n输入样例： 7 3 1 2 1 8 5 6 输出样例： 4 解法 动态规划 思路：定义dp[i]为考虑数组前i个元素，以nums[i]结尾的最长上升子序列，从小到大计算dp[i]的值。 状态转移方程为：dp[i] = max(dp[j]) + 1，（其中 0 nums[j]） 当计算dp[i]的值时（初始dp[i]=1），j需要从0遍历到i-1，其中当nums[j] 时间复杂度 O(n^2)：遍历nums数组需要O(n)，计算每一个dp[i]需要O(n) \n空间复杂度 O(n)：dp数组需要O(n)的空间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  package main import ( \u0026#34;fmt\u0026#34; ) func main() { n := 0 fmt.Scanln(\u0026amp;n) nums := make([]int, n) for i := range nums { fmt.Scan(\u0026amp;nums[i]) } fmt.Println(lengthOfLIS(nums)) } func lengthOfLIS(nums []int) int { n := len(nums) dp := make([]int, n) dp[0] = 1 res := 1 for i := 1; i \u0026lt; n; i++ { //初始 \tdp[i] = 1 for j := 0; j \u0026lt; i; j++ { if nums[i] \u0026gt; nums[j] { dp[i] = max(dp[i], dp[j]+1) } } res = max(res, dp[i]) } return res } func max(a, b int) int { if a \u0026gt; b { return a } return b }   二分 + 动态规划 单纯的动态规划做法，计算每一个i的dp值需要从0遍历到i-1，这样太耗费时间，所以可以考虑维护一个数组dp，dp中的元素是严格递增的，每当遍历一个数组中元素v时，如果v比dp末尾元素还大，那就直接插入尾部，否则将dp数组中第一个大于v的元素改成v（除非有和v相同大小的元素，那么就不用改变），在遍历的同时需要维护一个res，记录dp数组的长度（不是真实长度，而是维护的虚拟长度），最终返回res\n时间复杂度 O(NlogN) ： 遍历 nums 列表需 O(N)，在每个 nums[i] 二分法需 O(logN)。\n空间复杂度 O(N)：dp数组需要O(n)的空间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  package main import \u0026#34;fmt\u0026#34; func main() { var n int fmt.Scan(\u0026amp;n) nums := make([]int, n) for i := range nums { fmt.Scan(\u0026amp;nums[i]) } fmt.Println(lengthOfLIS(nums)) } func lengthOfLIS(nums []int) int { // 二分查找 + 动态规划 \tn := len(nums) dp := make([]int, n) res := 0 for _, v := range nums { l, r := 0, res for l \u0026lt; r { mid := l + (r-l)\u0026gt;\u0026gt;1 if dp[mid] \u0026lt; v { l = mid + 1 } else { r = mid } } dp[l] = v //如果r依然等于res，说明v要大于dp数组内的所有元素，res++ \tif res == r { res++ } } return res }   ","description":"生命没有极限，除非你自己定义","id":132,"section":"interview","tags":[""],"title":"最长上升子序列","uri":"https://www.zhugeqing.top/interview/quality_questions/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"},{"content":"算法  242. 有效的字母异位词——第三遍 56. 合并区间——第三遍 315. 计算右侧小于当前元素的个数——第三遍 493. 翻转对——第三遍不稳  锻炼身心 思念 思念祖母的第89天\n记：持续行动的九十八天！\n","description":"wang + innante + now","id":133,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-9/"},{"content":"算法  146. LRU 缓存机制  锻炼身心 思念 思念祖母的第88天\n记：持续行动的九十七天！\n","description":"wang + innante + now","id":134,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-8/"},{"content":"算法  746. 使用最小花费爬楼梯——第一遍 72. 编辑距离——第二遍 912. 排序数组——第三遍  锻炼身心 思念 思念祖母的第87天\n记：持续行动的九十六天！\n","description":"wang + innante + now","id":135,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-7/"},{"content":"算法  242. 有效的字母异位词——第二遍 56. 合并区间——第二遍 315. 计算右侧小于当前元素的个数——第二遍 493. 翻转对——第二遍  锻炼身心 思念 思念祖母的第86天\n记：持续行动的九十五天！\n","description":"wang + innante + now","id":136,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-6/"},{"content":"算法  714. 买卖股票的最佳时机含手续费 309. 最佳买卖股票时机含冷冻期 188. 买卖股票的最佳时机 IV 123. 买卖股票的最佳时机 III 122. 买卖股票的最佳时机 II 121. 买卖股票的最佳时机 146. LRU 缓存机制——第二遍 237. 删除链表中的节点  锻炼身心 思念 思念祖母的第85天\n记：持续行动的九十四天！\n","description":"wang + innante + now","id":137,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-5/"},{"content":"算法 912. 排序数组——第二遍\n锻炼身心 思念 思念祖母的第84天\n记：持续行动的九十三天！\n","description":"wang + innante + now","id":138,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-4/"},{"content":"算法  242. 有效的字母异位词——第一遍 56. 合并区间——第一遍 493. 翻转对——第一遍 315. 计算右侧小于当前元素的个数——第一遍 912. 排序数组——第二遍  锻炼身心 思念 思念祖母的第83天\n记：持续行动的九十二天！\n","description":"坚持问“为什么”","id":139,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-3/"},{"content":"算法  面试题 16.25. LRU 缓存——第一遍 237. 删除链表中的节点——第二遍 146. LRU 缓存机制——第一遍  锻炼身心 思念 思念祖母的第82天\n记：持续行动的九十一天！\n","description":"坚持问“为什么”","id":140,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-2/"},{"content":"算法  52. N皇后 II——第三遍 51. N 皇后——第三遍 338. 比特位计数——第三遍  锻炼身心 小故事 一天，一位国王在观看魔术大师表演。表演吸引了很多群众驻足围观，国王也在聚精会神地观看表演。表演结束时，观众们爆发出热烈的喝彩之声。国王说：“这个人天赋异禀，这是上天赐予的才华。”\n但是有位睿智的大臣对国王说：“殿下，天才是后天锻造而成的，并不是与生俱来的，魔术师的技艺是他严格自律和刻苦练习的结果。天才靠的是坚定决心、严守纪律、长时间的学习和训练。”\n大臣的话显然让国王有些心烦意乱，也破坏了他对魔术师精湛技艺的兴趣，“你不仅目光短浅，而且言辞歹毒。你胆敢批评一位真正的天才。如我所说，人要么天生有才，要么天生无才，我敢肯定，你没有”。\n国王对侍卫说：“来人，把他扔进最深的地牢！”国王还补充道：“为了让你不寂寞，我会让两个你的同类陪伴你，我会让两只小猪和你做狱友。”\n从入狱的第一天起，这位聪明的大臣就开始练习两只手各抓一只小猪，跑上牢房的台阶，跑到监狱门口。他每日、每周、每月从不间断练习，小猪也逐渐长成健壮的成年猪。通过每日的练习，这位聪明的大臣的体力和力量有了大幅度地提升。\n忽然有一天，国王想起了那位聪明的大臣，他想知道锒铛入狱是否让那位大臣变得谦卑，他召来了那位大臣。\n那位大臣出现在国王面前时，国王看到的是一个体格强健的男子，两只手各抓着一只猪。国王惊呼道：“这人天赋异禀。这是上天赐予的才华。”\n聪明的大臣回答道：“陛下，天才是后天培养的，不是与生俱来的。我的技能是自律和实践的结果。天才靠的是坚定决心、严守纪律、长时间的学习和训练。”\n思念 思念祖母的第81天\n记：持续行动的九十天！\n","description":"坚持问“为什么”","id":141,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-11-1/"},{"content":"算法  190. 颠倒二进制位  锻炼身心 小故事 一天，一位国王在观看魔术大师表演。表演吸引了很多群众驻足围观，国王也在聚精会神地观看表演。表演结束时，观众们爆发出热烈的喝彩之声。国王说：“这个人天赋异禀，这是上天赐予的才华。”\n但是有位睿智的大臣对国王说：“殿下，天才是后天锻造而成的，并不是与生俱来的，魔术师的技艺是他严格自律和刻苦练习的结果。天才靠的是坚定决心、严守纪律、长时间的学习和训练。”\n大臣的话显然让国王有些心烦意乱，也破坏了他对魔术师精湛技艺的兴趣，“你不仅目光短浅，而且言辞歹毒。你胆敢批评一位真正的天才。如我所说，人要么天生有才，要么天生无才，我敢肯定，你没有”。\n国王对侍卫说：“来人，把他扔进最深的地牢！”国王还补充道：“为了让你不寂寞，我会让两个你的同类陪伴你，我会让两只小猪和你做狱友。”\n从入狱的第一天起，这位聪明的大臣就开始练习两只手各抓一只小猪，跑上牢房的台阶，跑到监狱门口。他每日、每周、每月从不间断练习，小猪也逐渐长成健壮的成年猪。通过每日的练习，这位聪明的大臣的体力和力量有了大幅度地提升。\n忽然有一天，国王想起了那位聪明的大臣，他想知道锒铛入狱是否让那位大臣变得谦卑，他召来了那位大臣。\n那位大臣出现在国王面前时，国王看到的是一个体格强健的男子，两只手各抓着一只猪。国王惊呼道：“这人天赋异禀。这是上天赐予的才华。”\n聪明的大臣回答道：“陛下，天才是后天培养的，不是与生俱来的。我的技能是自律和实践的结果。天才靠的是坚定决心、严守纪律、长时间的学习和训练。”\n思念 思念祖母的第80天\n记：持续行动的八十九天！\n","description":"坚持问“为什么”","id":142,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10.31/"},{"content":"算法  142. 环形链表 II  锻炼身心 思念 思念祖母的第79天\n记：持续行动的八十八天！\n","description":"坚持问“为什么”","id":143,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-30/"},{"content":"算法  52. N皇后 II 51. N 皇后 338. 比特位计数  锻炼身心 思念 思念祖母的第78天\n记：持续行动的八十七天！\n","description":"坚持问“为什么”","id":144,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-29/"},{"content":"算法  191. 位1的个数——第三遍 190. 颠倒二进制位——第二遍 231. 2 的幂——第三遍  锻炼身心 思念 思念祖母的第77天\n记：持续行动的八十六天！\n","description":"坚持问“为什么”","id":145,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-28/"},{"content":"算法  773. 滑动谜题——第三遍 142. 环形链表 II——第二遍  锻炼身心 思念 思念祖母的第76天\n记：持续行动的八十五天！\n","description":"坚持问“为什么”","id":146,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-27/"},{"content":"算法  52. N皇后 II——第一遍 51. N 皇后——第一遍 338. 比特位计数——第一遍  锻炼身心 英语 思念 思念祖母的第75天\n记：持续行动的八十四天！\n","description":"坚持问“为什么”","id":147,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-26/"},{"content":"算法  191. 位1的个数——第二遍 231. 2 的幂——第二遍 190. 颠倒二进制位——第一遍 1091. 二进制矩阵中的最短路径——第三遍  锻炼身心 英语 思念 思念祖母的第74天\n记：持续行动的八十三天！\n","description":"坚持问“为什么”","id":148,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-25/"},{"content":"算法  142. 环形链表 II——第一遍  锻炼身心 英语 思念 思念祖母的第73天\n记：持续行动的八十二天！\n","description":"坚持问“为什么”","id":149,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-24/"},{"content":"算法  773. 滑动谜题——第二遍 212. 单词搜索 II——第三遍 127. 单词接龙——第三遍 433. 最小基因变化——第三遍  锻炼身心 英语 思念 思念祖母的第72天\n记：持续行动的八十一天！\n","description":"坚持问“为什么”","id":150,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-23/"},{"content":"算法  22. 括号生成——动态规划第三遍 1091. 二进制矩阵中的最短路径——BFS/A*第二遍  锻炼身心 英语 思念 思念祖母的第71天\n记：持续行动的八十天！\n","description":"坚持问“为什么”","id":151,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-22/"},{"content":"算法  200. 岛屿数量——第三遍 130. 被围绕的区域——第三遍  锻炼身心 英语 思念 思念祖母的第70天\n记：持续行动的七十九天！\n","description":"坚持问“为什么”","id":152,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-21/"},{"content":"算法  773. 滑动谜题——第一遍 212. 单词搜索 II——第三遍 127. 单词接龙——第二遍 433. 最小基因变化——第二遍  锻炼身心 英语 思念 思念祖母的第69天\n记：持续行动的七十八天！\n","description":"生命没有极限，除非你自己设置","id":153,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-20/"},{"content":"算法  22. 括号生成——动态规划第二遍 52. N皇后 II——第三遍 36. 有效的数独——第三遍 37. 解数独——第三遍 1091. 二进制矩阵中的最短路径——第一遍  锻炼身心 傻瓜英语 思念 思念祖母的第68天\n记：持续行动的七十七天！\n","description":"生命没有极限，除非你自己设置","id":154,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-19/"},{"content":"算法  200. 岛屿数量——第二遍（并查集） 130. 被围绕的区域——第二遍（并查集）  锻炼身心 思念 思念祖母的第67天\n记：持续行动的七十六天！】\n","description":"生命没有极限，除非你自己设置","id":155,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-18/"},{"content":"算法  212. 单词搜索 II——第二遍 547. 省份数量——第二遍 127. 单词接龙——双向BFS第一遍 433. 最小基因变化——双向BFS第一遍  菲记单词  复习 1 - 100  锻炼身心 思念 思念祖母的第66天\n记：持续行动的七十五天！\n","description":"生命没有极限，除非你自己设置","id":156,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-17/"},{"content":"算法  22. 括号生成——动态规划第一遍 70. 爬楼梯——强化 52. N皇后 II——第二遍 36. 有效的数独——第二遍 37. 解数独——第二遍  菲记单词 锻炼身心 思念 思念祖母的第65天\n记：持续行动的七十四天！\n","description":"生命没有极限，除非你自己设置","id":157,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-16/"},{"content":"1. forget(忘记)    忘记以前所掌握的东西 ，让大脑像一个空荡荡的容器，像一个小孩子一样可以快速学习，用一种“初学者心态”来读一本书，或者是学习其他知识，当觉得自己对即将要学习的知识有所了解时，会妨碍我们吸收新的信息\n\n  忘记不紧张或者不重要的事情，学习的过程中必须专注，才能全身心地投入，高效地进行学习。如果在学习中，思想已经飘到了其他事情上，这件事情可能比较重要，但是并不紧急，这种情况不可避免，不要挣扎不去想这件事情，越是克制，越是难以抵抗。相反，可以打开备忘录，或者打开一个笔记本，写下这些事情，等学习完成之后再做处理\n\n  忘掉自己的极限，生命没有极限，除非你自己设置，如果你不敢挑战极限，就永远无法突破自我。你的能力绝不是一个定值，在学习的世界里，一切皆有可能\n\n  2. act(行动) 抛弃被动式学习，学习态度越是积极主动，学习速度就越快，学到的知识的质量就越高，学到的内容就越多。\n\n3. statue(状态) 所有学习过程都依赖于个人的状态。当你把情感与信息结合在一起时，你对这个信息的印象会更深刻，改变你学习时的姿势或者呼吸方式。想象你精力充沛，对于即将开始的学习感到兴奋，按照这个情绪选择你的坐姿或站姿。在即将开始的学习中，你会有所收获，而且会应用新知识，你一定会对此感到兴奋。切记，所有学习过程都依赖于你的状态。请主动选择快乐、入迷和好奇的学习状态吧！  4. teach(教授) 如果你想大幅缩短学习曲线，就把你的学习目标定位为学习之后能把学习内容教授给别人。思考一下：如果知道你需要就学习内容做一场演讲，那么你学习的目标肯定是充分掌握所学内容，这样才能更好地向其他人解释。你的注意力会更加集中，你的笔记会更加详细，你甚至还会提出更好的问题。当你授课的时候，实际上你经历了两次学习，第一次是你自己学习，第二次是通过给别人讲课学习。  5. enter(输入) 改善个人表现最简单、最强大的方法是什么？答案是善用你的日程表。我们会在日程表上写下或者输入重要的事情：参加工作会议、出席家长会、牙医就诊时间、带宠物去看兽医等。大家的日程表上到底缺了什么？答案是缺少给自己的成长和发展安排时间。如果你的日程表上没有这样的安排，那么你很难实现个人的成长和发展。如果你“忘记”锻炼身体和大脑，一天的时间转瞬就会溜走。  6. Review（复习） 要想减少遗忘曲线对你的影响，最好的方法之一就是每隔一段时间积极地回忆此前学过的内容。在多个分散的时段进行复习，你可以让信息更好地留存在大脑之中。每隔一段时间就复习一下学过的内容可以强化大脑对它的记忆。\n\n","description":"生命有如铁砧，愈被敲打，愈能发出火花。","id":158,"section":"about","tags":[""],"title":"faster学习法（快速学习法）","uri":"https://www.zhugeqing.top/about/faster/"},{"content":"算法  200. 岛屿数量——第一遍（并查集） 130. 被围绕的区域——第一遍（并查集）  锻炼身心 思念 思念祖母的第64天\n记：持续行动的七十三天！\n","description":"生命没有极限，除非你自己设置","id":159,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-15/"},{"content":"算法  212. 单词搜索 II——第一遍 547. 省份数量——第一遍  菲记单词 锻炼身心 思念 思念祖母的第63天\n记：持续行动的七十二天！\n","description":"生命没有极限，除非你自己设置","id":160,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-14/"},{"content":"算法  208. 实现 Trie (前缀树)——第二遍、 221. 最大正方形——第三遍  菲记单词 锻炼身心 思念 思念祖母的第62天\n记：持续行动的七十一天！\n","description":"如果鸡蛋被外力打碎，那是生命的结束； 如果鸡蛋被内力打破，那是生命的开始。 奇迹的开端永远在事物内部 ","id":161,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-13/"},{"content":"算法  188. 买卖股票的最佳时机 IV——强化第三遍  最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)——强化第三遍   32. 最长有效括号——第三遍 91. 解码方法——强化第三遍 154. 寻找旋转排序数组中的最小值 II——强化第三遍  思念 思念祖母的第61天\n记：持续行动的七十天！\n","description":"如果鸡蛋被外力打碎，那是生命的结束； 如果鸡蛋被内力打破，那是生命的开始。 奇迹的开端永远在事物内部 ","id":162,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-12/"},{"content":"第一式　肩倒立深蹲 动作：\n平躺，双膝弯曲，双手下压。双脚蹬离地面，直到举到空中。在将双腿举起的过程中，顺势把双手撑在下背部，注意上臂要紧贴地面。你现在摆出的姿势是肩倒立——靠双肩、上背部以及上臂支撑身体。要记住，始终用这几个部位支撑身体，不要让颈部受到压力。身体要锁定伸直，髋部不要弯曲。这是该动作的起始姿势（图21）。上半身要尽可能伸直，弯曲髋部与膝关节，直到膝盖轻触前额，这是该动作的结束姿势（图22）。然后伸直双腿，直到身体回到起始姿势，如此重复\n图21　把双手撑在下背部，注意上臂要紧贴地面 \n\n\n图22　上半身要尽可能伸直，弯曲髋部与膝关节，直到膝盖轻触前额 解析：\n对任何开始练习深蹲的人来说，肩倒立深蹲都是完美的起点。由于做该动作时身体处于倒立姿势，所以膝盖和下背部无需承受身体的重量，这就使得该动作成为一个理想的恢复性训练动作——可以帮助那些背部和膝盖有伤的健身者，或是刚做完手术正处于恢复期的健身者重新开始腿部训练。从力量角度来说，做肩倒立其实对健身者上身的要求更高。但是这一动作能让紧绷的关节放松，增加关节的活动幅度，从而能让初学者为练就完美的深蹲打下基础。\n\n训练目标：\n初级标准：1组，10次\n中级标准：2组，各25次\n升级标准：3组，各50次\n\n稳扎稳打：\n第一次尝试该动作时，不是人人都能做到膝盖轻触前额。你可以在每次锻炼时试着加大动作幅度，这样你的关节很快就会得到放松。另外，有啤酒肚的人几乎无法完成这个动作，因为他的大肚子会碍事。对这类人来说，坚持空腹练习会好一些——直到他们减掉肚子上的赘肉\n第二式　折刀深蹲 动作：\n站在一个稳固的物体前，此物体的高度大约与你的膝盖等高，至少也要达到胫骨上部，小咖啡桌、椅子、床铺都是不错的选择。双腿分开，与肩同宽或略宽。双腿伸直，弯腰俯身，直到双手与面前的物体接触。身体前倾，使一部分体重落在双手上。这是该动作的起始姿势（图23）。上半身尽量与地面平行，弯曲膝关节和髋部，直到大腿后侧紧贴小腿，无法蹲得更低为止。这是该动作的最低点（图24）。下蹲过程中你还需要弯曲双臂，在下降到最低点后腿部与手臂要同时发力，将身体推回到起始姿势。在整个动作过程中，脚跟始终不能抬离地面。\n\n图23　身体前倾，使一部分体重落在双手上。 \n\n\n图24　弯曲膝关节和髋部，直到大腿后侧紧贴小腿，无法蹲得更低为止。 解析：\n做折刀深蹲时上半身前倾，并不直接位于双腿上方，因此两条手臂会承担一部分体重。该动作的难度大约只有标准深蹲（第五式）的一半，但这是能帮助下身肌肉与肌腱为之后的动作做准备的最佳动作。只要正确练习，这个动作就能让初级健身者拥有足够的平衡能力和跟腱的柔韧性，来征服标准深蹲中的最低点。\n训练目标\n\n训练目标：\n初级标准：1组，10次\n中级标准：2组，各20次\n升级标准：3组，各40次\n\n稳扎稳打：\n下降到最低点时该动作的难度最大，因为此时下肢需要承担身体的大部分重量。如果你觉得动作有难度，那就逐步加大动作幅度来慢慢适应。还有一种方法就是让双臂分担更多的身体重量，这样能够帮助你从最低点站起来。等腿部更强壮之后，你就可以试着减少双臂的用力，更多地依赖双腿。\n第三式　支撑深蹲 动作：\n直立，双脚分开，与肩同宽或略宽。手臂向斜下方伸出，双手放在比自己的大腿略高的稳固物体上，书桌、高脚凳或椅背都可以。这是该动作的起始姿势（图25）。弯曲髋部与膝关节，身体慢慢下降，背部尽可能保持挺直，直到大腿后侧紧贴小腿，无法蹲得更低为止，这是该动作的最低点（图26）。暂停一会，然后主要靠腿部发力站起来。为了分担双腿的一部分压力，尤其是在最低点时，你要通过向下按压面前的物体，来借用手臂的一部分力量。手臂要尽量伸直，在整个动作过程中都不要让脚跟抬离地面\n图25　手臂向斜下方伸出，双手放在比自己的大腿略高的稳固物体上。 \n\n\n图26　弯曲髋部与膝关节，身体慢慢下降，背部尽可能保持挺直。 解析：\n支撑深蹲是半深蹲之前的最后一式。它是折刀深蹲（双腿承受大部分身体重量）与半深蹲（双腿承受全部身体重量）之间理想的过渡动作。支撑深蹲能够进一步加强下肢的柔韧性和力量，锻炼膝盖的肌腱、韧带及软组织。它能让你的深蹲动作更标准，锻炼你仅仅使用肌肉力量而非惯性从最低点推起身体的能力。\n\n训练目标：\n初级标准：1组，10次\n中级标准：2组，各15次\n升级标准：3组，各30次\n\n稳扎稳打：\n要想对该练习所需的腿部力量进行微调，方法非常简单。要使该练习对下身来说更容易，只要更多地使用上身的力量即可。随着你在动作最低点时感觉越来越轻松，你可以逐渐减少在起身过程中臂力的使用。\n第四式　半深蹲 动作：\n站立，双脚分开，与肩同宽或略宽。脚尖不要指向正前方，而要略微向外。双手放在髋部、胸部、肩部都可以——以舒适为前提。这是该动作的起始姿势（图27）。弯曲髋部和膝盖，直到膝关节弯曲成90°——换句话说就是大腿与地面平行。这是该动作的最低点（图28）。刚开始你可以借助一面镜子或是找朋友帮忙，直到能够自如地控制动作幅度。不要求快，也不要借助惯性起身，而要完全在肌肉控制下做整个动作。在最低点（半空中）坚持1秒钟，然后再回到起始姿势。在整个动作过程中，背部始终要挺直，双脚脚跟始终不能抬离地面。膝盖与脚尖应该始终朝向同一方向，深蹲时膝盖绝不要向内转，脚尖指向外有助于你做到这一点。\n图27　脚尖不要指向正前方，而要略微向外 \n\n\n图28　弯曲髋部和膝盖，直到膝关节弯曲成90° 解析：\n在深蹲系列中，半深蹲是双腿在没有任何辅助的情况下承受全部体重的第一式。因此，它应该受到重视。该动作教你在无辅助的情况下保持平衡和身体姿势，这些对于后面的深蹲练习都是必要的。此外，该动作也能够让你了解如何让膝盖与双脚摆出对你来说最适合的姿势。这个动作对大腿而言难度并不大，因此下面给出的训练目标量比正常的量要大。攻克了这个动作之后，你会发现自己髋部和大腿内侧的肌肉变得更强了。\n\n训练目标：\n初级标准：1组，8次\n中级标准：2组，各35次\n升级标准：2组，各50次\n稳扎稳打：\n如果做不了半深蹲，那就先做四分之一深蹲，每当你感到有余力时，就可以适当加大动作幅度。\n第五式　标准深蹲 动作：\n直立，双脚分开，与肩同宽或略宽（取决于个人偏好）。双脚略微向外转，双臂随意摆放，只要舒服即可。这是该动作的起始姿势（图29）。髋部与膝关节弯曲，背部始终挺直。当大腿达到几乎与地面平行时，把你的身体重心向后转移，就像要坐下一样。有控制地继续放低身体，直到大腿后侧紧贴小腿。这是该动作的最低点（图30）。暂停一会，然后仅靠腿部发力将自己推回到起始姿势。起身过程和下蹲过程应该是完全相反的。脚跟始终不要抬离地面，膝盖也不能向内转。\n图29　直立，双脚分开，与肩同宽或略宽（取决于个人偏好） \n\n\n图30　有控制地继续放低身体，直到大腿后侧紧贴小腿 解析：\n标准深蹲是经典的自身体重练习动作。数千年来该动作始终流行于世，是有一定原因的。标准深蹲能够强化膝关节，并增强大腿肌肉、臀部肌肉、脊椎肌肉和髋部肌肉的力量和运动能力。另外，这个动作也能使小腿、胫骨前肌、脚踝，甚至包括脚掌得到相应的锻炼。标准深蹲有助于让双腿保持年轻活力。\n\n训练目标：\n初级标准：1组，5次\n中级标准：2组，各10次\n升级标准：2组，各30次\n稳扎稳打：\n如果你已经达到了半深蹲的升级标准，那么做标准深蹲就不会有太大问题。由于杠杆原理，当动作到达最低点时难度最大，对个子较高的人来说尤其如此。如果你达不到初级标准的目标，那就继续去做半深蹲。如果你感到自己变强了，那就增加几厘米的动作幅度。不要心急，一定不要借助惯性起身、让脚跟离地或是摇晃前倾。要纯粹使用肌肉力量，否则就别练了！\n第六式　窄距深蹲 动作：\n直立，双脚脚跟相碰，脚尖微微向外，双臂前伸。这是该动作的起始姿势（图31）。弯曲膝盖和髋部，直到大腿后侧紧贴小腿，无法蹲得更低为止。此时，你的胸部应该紧贴大腿（图32）。注意，脚跟始终不要抬离地面。为避免后倾，你得收缩胫骨肌肉使身体微微前倾。保持这一姿势，然后仅靠腿部发力将自己推回到起始姿势。\n\n图31　直立，双脚脚跟相碰，脚尖微微向外，双臂前伸 \n\n\n图32　为避免后倾，你得收缩胫骨肌肉使身体微微前倾 解析：\n窄距深蹲具有标准深蹲的所有益处，但是对股四头肌的影响更大。经常练习该动作真的能强化你的膝盖、胫骨和臀部肌肉，让你的臀部更紧实，效果比任何一种器械训练都好。\n训练目标：\n初级标准：1组，5次\n中级标准：2组，各10次\n升级标准：2组，各20次\n\n稳扎稳打：\n很多训练者练习前几式时进展神速，但到了窄距深蹲就会碰到问题——在动作最低点或接近最低点时，身体有可能失去平衡而后倾。这些问题在腿骨长、个头高的训练者身上尤为突出。之所以会出现这些问题，是因为训练者胫骨前侧的肌肉缺乏力量以及平衡能力不强。如果练习前几式时你的进度太快，那就回到标准深蹲，在练习过程中逐渐缩小双脚之间的距离——每次缩小几厘米。双臂前伸能够让重心前移。此外，你也可以手拿重物——如哑铃、书或矿泉水瓶等——练习该动作，不过最好还是空手能完成。有些训练者由于身体结构的原因，做该动作真的很困难，如果你就是这样，那么可以让双脚脚跟保持一掌的距离。\n第七式　偏重深蹲 动作：\n直立，一只脚踩在地上，另一只脚的脚跟放在位于自己前方、距身体约一步远的篮球上。双脚分开，与肩同宽或略宽，双臂在胸前伸直。这是该动作的起始姿势（图33）。弯曲膝盖和髋部，直到踩在地上的那条腿的大腿后侧紧贴小腿后侧。这是该动作的最低点（图34）。刚开始练习时，到达最低点后可能出现身体后倾的情况，所以要确保身后有足够的干净空间，这一点对所有全幅深蹲都适用。暂停一下，然后双腿发力把自己推回到起始姿势。在动作过程中，脚跟始终不要抬离地面，身体不要向前摇晃，尽管你可能不自觉地想这样做。切记，要有控制地完成整个动作。\n\n图33　直立，一只脚踩在地上，另一只脚的脚跟放在位于自己前方、距身体约一步远的篮球上。 \n\n\n图34　弯曲膝盖和髋部，直到踩在地上的那条腿的大腿后侧紧贴小腿后侧。 解析：\n偏重深蹲是到挑战单腿深蹲的第一步。到现在为止，深蹲系列中各式的动作都是对称的——都能够均衡地锻炼双腿。练习该动作时，放在篮球上的那条腿位置相对较高，而且又必须控制篮球，所以无法完全发力。踩在地上的那条腿需要承担大部分工作，要有足够的力量在另一条腿的辅助下把身体从最低点推起。这个动作还可以很好地改善你的平衡能力与协调能力。\n训练目标：\n初级标准：1组，5次（每侧） 中级标准：2组，各10次（每侧） 升级标准：2组，各20次（每侧）  稳扎稳打：\n与前几式相比，该动作需要更多的技巧和更大的力量。如果把脚架在篮球上难以保持平衡，那你可以选用稳固的物体（如三块垒起的砖头）代替篮球。如果这样还是有问题，你可以选择降低物体的高度（如一块砖）。随着你的信心与平衡能力的增强，可以逐渐增加物体的高度。\n第八式　单腿半深蹲 动作：\n直立，只靠一条腿站立，另一条腿向前抬起，伸直或略微弯曲，抬起的脚大约处在另一条腿大腿的高度上，双手向胸前伸出。这是该动作的起始姿势（图35）。弯曲髋部和支撑腿的膝盖，直到膝关节几乎弯曲成90°，即大腿几乎与地面平行。在此过程中，抬起的那条腿应该始终在空中。这是该动作的最低点（图36）。暂停一会，然后单腿发力把自己推回到起始姿势。在动作过程中，背部始终要保持平直，而且支撑腿的脚跟始终不能抬离地面。\n图35　抬起的脚大约处在另一条腿大腿的高度上 \n\n\n图36　在动作过程中，背部始终要保持平直，而且支撑腿的脚跟始终不能抬离地面 解析：\n该练习是深蹲系列中第一个完全的单腿动作。攻克这个动作很重要，因为这可以让健身者的平衡能力得到极大的提升，从而为标准单腿深蹲打下基础。通过这个动作，健身者能够逐步掌握非支撑腿长时间离地的技巧。这可不容易，因为这需要非常强壮的髋部屈肌，可大多数人的髋部屈肌都很弱。由于只有一条腿支撑身体，所以这个动作可以更好地增强我们的腿部力量。不过由于该动作的运动幅度只有正常的一半，所以在练习该动作时，应该辅以一个全幅动作——窄距深蹲或偏重深蹲都可以。\n训练目标：\n初级标准：1组，5次（每侧）\n中级标准：2组，各10次（每侧）\n升级标准：2组，各20次（每侧）\n稳扎稳打：\n达到偏重深蹲升级标准的健身者，做该动作应该不成问题。如果你发现这个动作对你来说还是个挑战的话，那就先使用更小的动作幅度，随着体能的发展再逐步增加下蹲的深度即可\n第九式　单腿辅助深蹲 动作：\n把篮球放在要练的那条腿的外侧。直立，一只脚平放在地面上，另一只脚在你前方抬起——同单腿半深蹲（第八式）的起始姿势。抬起那条腿的同侧手臂向前伸出，另一只手臂自然垂于体侧（图37）。然后弯曲髋部和支撑腿的膝盖，直到大腿后侧紧贴小腿，无法继续下蹲为止。此时，你的手应该稳稳地放在篮球上，这是该动作的最低点（图38）。起身时主要依靠腿部力量，但你也要用手按压篮球，以便在反向动作的最初阶段借力。注意，在动作过程中，支撑腿的脚跟始终不能抬离地面\n图37　直立，一只脚平放在地面上，另一只脚在你前方抬起 \n\n\n图38　用手按压篮球，以便在反向动作的最初阶段借力 解析：\n任何一种深蹲动作的最低点都是最难的，单腿深蹲尤其如此。该动作通过允许你做反向动作时在至关重要的最初几厘米中用手辅助、借力，安全地解决了在最低位置时的问题。通过练习该动作，你膝关节处的韧带与肌腱将变强，之后你就可以信心十足地开始挑战最终式——单腿深蹲。另外，该动作还会迫使髋部屈肌更加用力，以保持抬起的那条腿比做单腿半深蹲时抬得更高，而这可能需要你花点儿时间才能适应。在这重要的一式上投入点时间。\n\n训练目标：\n初级标准：1组，5次（每侧）\n中级标准：2组，各10次（每侧）\n升级标准：2组，各20次（每侧）\n稳扎稳打：\n如果你还达不到该练习的初级标准，那就试着使用比篮球高的物体，椅子或矮咖啡桌都是不错的选择。相比于使用篮球，这些物体可以在更大的运动范围内为你的手臂提供支撑。一旦你借助更高物体能完成该动作，就可以换用矮一些的物体，就这样循序渐进地练习，直到你准备好再次尝试用篮球做该动作。\n最终式 单腿深蹲 动作：\n直立，抬起一条腿，直到脚大约与髋部等高，腿要尽量伸直，双臂在胸前前伸。如果你在之前几式上已经花了大量时间，那么这些对你来说不会太难。这是该动作的起始姿势（图39）。然后弯曲髋部与支撑腿的膝盖。你应该有控制地放低身体，不要一下蹲到底。缓慢地下蹲，直到支撑腿的大腿后侧紧贴小腿，无法继续下蹲为止。此时，你的腹部应该与支撑腿的大腿紧贴在一起。这是该动作的最低点（图40）。在紧张状态下，暂停一下（数一个数），然后单腿发力把自己推回到起始姿势。注意，千万不要借助惯性起身。在动作过程中，背部始终挺直，抬起的腿始终离地，而支撑腿则应稳稳地踩在地上。到达动作最高点时暂停一下，然后再下蹲。\n图39　抬起一条腿，直到脚大约与髋部等高，腿要尽量伸直。 \n\n\n图40　缓慢地下蹲，直到支撑腿的大腿后侧紧贴小腿，无法继续下蹲为止。 解析：\n单腿深蹲是深蹲动作之王，也是锻炼下身力量的终极练习。它可以锻炼脊椎、髋部、大腿、小腿和双脚，还能增强我们的耐力和运动能力。久而久之，皮包骨的双腿将变成强有力的支柱——有钢索般的股四头肌、硬如岩石的臀大肌、壮硕有形的小腿。掌握这个动作，你的双腿就绝不会衰老。而且，它还会保护你免受髋部病痛与膝关节损伤的折磨。\n\n训练目标：\n初级标准：1组，5次（每侧）\n中级标准：2组，各10次（每侧）\n精英标准：2组，各50次（每侧）\n稳扎稳打：\n如果你达不到单腿深蹲的初级标准，那就回到第九式（单腿辅助深蹲），并使用比篮球略小的物体，如三块摞起的砖。逐渐使用越来越小的物体，直到根本无需支撑。\n总结 ","description":"股四头肌、臀肌、绳肌、大腿内侧肌肉、髋部、小腿、双脚","id":163,"section":"exercise","tags":[""],"title":"升降机般的大腿","uri":"https://www.zhugeqing.top/exercise/%E6%B7%B1%E8%B9%B2/"},{"content":"菲记单词 思念 思念祖母的第60天\n记：持续行动的六十九天！\n","description":"如果鸡蛋被外力打碎，那是生命的结束； 如果鸡蛋被内力打破，那是生命的开始。 奇迹的开端永远在事物内部 ","id":164,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-11/"},{"content":"第一式 墙壁俯卧撑 动作： 面对墙壁站立，双脚并拢，双臂伸直，与肩同宽，双手平放在墙上，手掌与胸等高。这是该动作的起始姿势（图1）。弯曲肘部，直到前额轻触墙面。这是该动作的结束姿势（图2）。然后将自己推回到起始姿势，如此重复。\n图一 \n\n\n图2 解析:\n俯卧撑动作共有十式，墙壁俯卧撑只是第一式。既然是第一式，也就最容易的，毫无疑问普通人都能做。墙壁俯卧撑也是第一个有治疗效果的练习。刚受伤、做过手术或身体正处于恢复期的人若想加快恢复速度、尽快拥有强健的体魄，可以选择这个动作。肘、腕、肩（尤其是柔弱的肩袖）极易出现慢性或急性损伤，这项练习能够轻柔地刺激这些部位，并改善血液循环。不熟悉徒手体操的初学者应该以较轻柔的动作开始训练，然后逐步提高自己的运动技巧，循序渐进地增强自己的运动能力。我建议就从这个练习动作开始。\n\n训练目标：\n初级标准：1组，10次\n中级标准：2组，各25次\n升级标准：3组，各50次\n\n稳扎稳打：\n只要身体没有残疾、没有严重的伤病或疾病，一般人应该都能完成这个动作。如果你刚好处于伤病或手术的恢复期，那么这个动作就是很好的“测试”，能让你了解自己的身体在恢复期的弱点。\n\n第二式 上斜俯卧撑 动作： 做这个动作需要借助一个稳固的物体，高度大约是你身高的一半（大概到臀部位置）。桌子、高一些的椅子、工作台、厨房操作台、矮墙、结实的栅栏都是不错的选择。大多数监狱牢房里的洗漱台高度就正好，不过你得保证它足够结实。双脚并拢，身体成一条直线，然后前倾上身，双臂伸直，双手抓住所选物体，与肩同宽。这是该动作的起始姿势（图3）。弯曲肘部，放低身体，直到胸部轻触物体顶部。如果你选择的物体高度合适，那么此时你的身体与地面的夹角约为45°（图4）。暂停一会，然后将自己推回到起始姿势，如此重复。\n图3　双脚并拢，身体成一条直线，然后前倾上身，双臂伸直，双手抓住所选物体，与肩同宽 \n\n\n图4　弯曲肘部，放低身体，直到胸部轻触物体顶部 解析：\n这个动作的难度比第一式（墙壁俯卧撑）高，因为你将自己推回到起始姿势时，身体与地面的夹角更小，这意味着你的上肢肌肉要承受更大的重量。上斜俯卧撑比标准俯卧撑（第五式）容易，对大多数人来说，这个动作对肌肉的要求并不太高，而且它能帮助初学者平稳进步，对康复期的健身者也非常有帮助。\n\n训练目标：\n初级标准：1组，10次\n中级标准：2组，各20次\n升级标准：3组，各40次\n 稳扎稳打：\n达动作的最低点时，你的身体与地面的夹角约为45°。初学者如果达不到这么高的水平，那就降低难度（加大倾斜角度，也就是让身体更接近直立）——只要选择高度高于你身体中间点的物体即可。然后，再逐渐减小角度，直到可以轻而易举地完成倾斜45°的上斜俯卧撑。如果你还想尝试更小的角度，可以利用台阶做此动作——随着能力的提高，你可以逐渐降低支撑物的高度。\n第三式 膝盖俯卧撑 动作:\n双脚并拢，双膝着地。双臂伸直，与肩同宽。双手在胸部的正下方，两个手掌平放在地面上。脚踝搭在一起，大腿与上身及头部成一条直线，不要撅屁股或者塌腰。这是该动作的起始姿势（图5）。然后以膝盖为支点，弯曲肘部，直到胸部与地面仅一拳之隔（图6）。暂停一下，然后将自己推回到起始姿势，如此重复。\n\n图5　双脚并拢，双膝着地。双臂伸直，两个手掌平放在地面上 图6　以膝盖为支点，弯曲肘部，直到胸部与地面仅一拳之隔。  解析：\n膝盖俯卧撑是俯卧撑系列的第三式，是初学者要掌握的重要动作。它是在地面上做的俯卧撑中最容易的一个，起着承前启后的作用——此前的俯卧撑都是站立完成的，后面的俯卧撑全是地面动作，而且难度更高。女士们经常会做膝盖俯卧撑，因为她们的上肢力量相对较弱，不易完成标准俯卧撑，不过这个动作对男士也大有好处。对那些超重或身材走形的人来说，膝盖俯卧撑是不错的起点。因为采用这样的姿势推起上半身相对容易，所以在开始做更难的俯卧撑之前，膝盖俯卧撑是绝佳的热身练习\n训练目标：\n初级标准：1组，10次\n中级标准：2组，各15次\n升级标准：3组，各30次\n\n稳扎稳打\n如果你不能完成标准的膝盖俯卧撑，可以减小动作幅度——不要降低到离地面一拳的距离，而是把动作幅度缩短到你能舒服地完成的程度，同时增加次数（约20次）。你要不断练习（保持高反复次数），逐渐增加动作深度，直至可以完成标准的膝盖俯卧撑\n\n第四式　半俯卧撑 动作：\n跪在地板上，双手撑地，双腿向后蹬直。双手与肩同宽，并处于上胸部的正下方。双腿双脚并拢，锁紧身体，使上身、髋部和双腿成一条直线。先伸直手臂，然后降低身体到大约一半臂长的高度，或者直到肘部弯成直角。控制下降高度的绝佳方式就是使用篮球或橄榄球——将球放在髋部下方。这是该动作的起始姿势（图7）。接下来，弯曲肘部，直到髋部与球轻轻接触（图8）。对大多数人\n\n图7　控制下降高度的绝佳方式就是使用篮球或橄榄球——将球放在髋部下方 \n\n\n图8　弯曲肘部，直到髋部与球轻轻接触 解析：\n半俯卧撑非常重要，要熟练掌握。很多人做俯卧撑的方法都不正确——撅屁股或者塌腰，这是因为他们的腰部肌肉和脊椎肌肉不发达。这个动作可以锻炼你的腰部肌肉和脊椎肌肉，从而能够锁定髋部，使身体成一条直线。\n训练目标：\n初级标准：1组，8次\n中级标准：2组，各12次\n升级标准：2组，各25次\n\n稳扎稳打：\n如果你做不了半俯卧撑，可以减小动作幅度。如果你选用的是篮球，那就将其放在膝盖下，而不是髋部下方。伸直手臂，然后慢慢降低身体，直到膝盖与球接触，这相当于四分之一俯卧撑。如果你能做10次以上四分之一俯卧撑，那就可以把篮球向上移一点儿，就这样逐步移动篮球，直到其位于髋部下方为止。\n\n第五式　标准俯卧撑 动作：\n跪在地板上，双手撑地，双腿向后蹬直。双腿双脚并拢，双手与肩同宽，并处于上胸部的正下方。双臂伸直，臀部与脊椎成一条直线。这是该动作的起始姿势（图9）。接着，弯曲肘部，直至胸部与地面仅一拳之隔。监狱里进行俯卧撑比赛时，计数者会握拳，让小拇指一侧紧贴地面，这样只需数参赛者胸部接触自己大拇指的次数即可。若你是单独锻炼，又想控制动作幅度，并想让身体与地面保持正确距离，可以在胸部正下方放一个棒球或网球（图10）。你在做动作的过程中，待胸部碰到球后暂停一下，然后回到起始姿势。\n图9　在胸部正下方放一个棒球或网球 \n\n\n图10　胸部碰到球后暂停一下，然后回到起始姿势 解析：\n这就是“经典”俯卧撑。大多数人在体育课上学到的就是这个动作。说到俯卧撑，大多数人脑海中浮现的也是这个动作。标准俯卧撑是极好的上身练习动作，可以锻炼我们的手臂、胸部和上肢带肌，而且效果明显。然而无论如何，标准俯卧撑的难度并不是最高的，它在十式中只排第五。\n训练目标：\n初级标准：1组，5次\n中级标准：2组，各10次\n升级标准：2组，各20次\n\n稳扎稳打：\n你可能感到费解，很多看上去很健硕的家伙都不能正确地完成标准俯卧撑。如果你也一样，那还是找个篮球做半俯卧撑吧！如果你已能很好地完成第四式——当球放在髋部下面时，你能重复此动作25次，那么每次训练时你可以把球向前移动几厘米，在次数保持不变的情况下继续练习。当你的下颚能碰到球时，你再尝试做标准俯卧撑\n\n第六式　窄距俯卧撑 动作：\n窄距俯卧撑的起始姿势与标准俯卧撑基本相同（见第五式），只不过需要双手相触——无需重叠，也不需要让双手的拇指与食指构成一个“钻石”，只要两个食指指尖相触就可以了。从手臂伸直的起始姿势开始（图11），慢慢放低身体，直到胸部轻触手背（图12）。暂停一下，然后将自己推回到起始姿势。\n\n图11　两个食指指尖相触就可以了 \n\n\n图12　慢慢放低身体，直到胸部轻触手背 解析：\n窄距俯卧撑很古老，它在俯卧撑十式中至关重要，但人们通常更喜欢弹震式俯卧撑或下斜俯卧撑这些花哨的动作，而忽略窄距俯卧撑。这简直是悲剧，因为窄距俯卧撑在攻克单臂俯卧撑之旅中必不可少。大多数人做单臂俯卧撑都会感到吃力，他们会发现很难在身体降到最低点之后再把自己推起来。这是因为此时肘部的弯曲程度最大，而肘部的弯曲角度超过直角时胳膊就很难使上力气。做窄距俯卧撑时，由于双手的特殊位置，当你的身体降到最低点时，肘部的弯曲度比做标准俯卧撑时的更大。这个动作可以锻炼三头肌，并且强化你的肘部与腕部的肌腱。因此，能舒服地做窄距俯卧撑的人在终于要挑战单臂俯卧撑的时候，会更从容一些。\n训练目标：\n初级标准：1组，5次\n中级标准：2组，各10次\n升级标准：2组，各20次\n\n稳扎稳打：\n如果你做不了双手相触的窄距俯卧撑（如上所述），可以继续做标准俯卧撑，在次数不变的前提下，让双手逐渐靠近，每次靠近几厘米。\n\n第七式　偏重俯卧撑 动作：\n双脚并拢，双腿、髋部、上身成一条直线。双臂伸直，双手撑地，并处于上胸部的正下方。一只手稳固地支撑身体，另一只手撑在篮球上，这是该动作的起始姿势（图13）。找到平衡之后，尽力将身体的重量均匀地分摊在两只手上。这样做虽然不容易，但一定要坚持。接下来，弯曲肘部，慢慢降低身体，直到胸部轻触撑在篮球上的那只手（图14）。暂停一下，然后将自己推回到起始姿势。\n图13　一只手稳固地支撑身体，另一只手撑在篮球上 \n\n\n图14　弯曲肘部，慢慢降低身体，直到胸部轻触撑在篮球上的那只手 解析：\n这是第一个高级俯卧撑动作，它能够帮助健身者适应由双手俯卧撑向单臂俯卧撑的过渡。你也可以选用一个固定的物体（如砖块），而不用篮球，不过篮球是最好的选择。控制篮球的同时可以锻炼你的肩袖，这有助于你完成难度更高的动作。你还可以选用足球，但篮球还是首选，因为篮球表面粗糙更容易抓握。\n训练目标：\n初级标准：1组，5次（每侧）\n中级标准：2组，各10次（每侧）\n升级标准：2组，各20次（每侧）\n\n稳扎稳打：\n能正确地完成窄距俯卧撑的人都可以信心十足地尝试这个动作。如果刚开始你觉得有些困难，那是因为你的协调性不好，而不是力量不足。你可以用固定的物体，而不用会滚来滚去的篮球。砖块是个不错的选择，等你可以在一块砖上重复此动作20次之后，你就可以尝试将两块砖摞起来做这个动作。在你可以在三块垒起的砖上重复此动作20次之后，你就可以尝试用篮球练习了\n第八式　单臂半俯卧撑 动作：\n摆出半俯卧撑最高点时的姿势，即将篮球放在髋部下方（见第四式）。将一只手撑在胸部下方的地面上，手臂伸直，另一只手背在身后。这是该动作的起始姿势（图15）。接着弯曲肘部，直到髋部轻触篮球。这是该动作的最低点（图16）。暂停一下，然后将自己推回到起始姿势。如果你的肱三头肌不够发达，那做该动作时上身很容易发生扭曲。坚持住，整个身体保持一条直线，做所有俯卧撑都应如此。\n图15　将一只手撑在胸部下方的地面上，手臂伸直，另一只手背在身后 \n\n\n图16　弯曲肘部，直到髋部轻触篮球 解析：\n单臂半俯卧撑是俯卧撑系列的第八式。通过这个练习，训练者可以逐步从双侧练习转为单侧练习。该动作可以提高你的平衡能力，而这对做单臂俯卧撑极其重要。因为只靠单臂发力，所以这个动作也会让手部、腕部和肩部关节为之后的动作做好准备。单臂半俯卧撑在这个系列中不可或缺，你必须掌握。不过由于肘关节只是部分弯曲，所以对一次完整的俯卧撑训练来说，只做这样的练习是不够的。你需要再做一些肘部弯曲角度小于90°的练习来补充，比如在之后加上窄距俯卧撑或偏重俯卧撑。\n\n训练目标：\n初级标准：1组，5次（每侧）\n中级标准：2组，各10次（每侧）\n升级标准：2组，各20次（每侧）\n稳扎稳打：\n如果做不了单臂半俯卧撑，你可以把篮球放在膝下，做四分之一单臂俯卧撑。练习一段时间之后，就一点点向前移动篮球，加大动作幅度。\n第九式　杠杆俯卧撑 动作：\n摆出做俯卧撑的姿势，身体成一条直线，一只手撑在胸部正下方的地面上，另一只手放在身体外侧的篮球上，靠双脚和撑在地上的那只手支撑身体。双臂伸直，放在球上的手要尽量向远处伸。这是该动作的起始姿势（图17）。要有控制地慢慢放低身体，直到胸部与地面只有一拳之隔。如果你是独自锻炼，可以像做标准俯卧撑那样，借助棒球或网球控制动作幅度。放低身体时手会顺势把篮球推到远离身体的位置（图18）。身体降至最低点时，暂停一下，然后将自己推回到起始姿势。\n图17　一只手撑在胸部正下方的地面上，另一只手放在身体外侧的篮球上 \n\n\n图18　要有控制地慢慢放低身体，直到胸部与地板只有一拳之隔 解析：\n标准杠杆俯卧撑的难度与单臂俯卧撑相差无几，这也正是杠杆俯卧撑在俯卧撑十式中排在第九的原因。你会发现，撑在篮球上的那只手臂几乎帮不上什么忙，这就迫使支撑身体的手臂必须使出全力。如果你还没强大到足以在做单臂俯卧撑时把自己撑起，那你可以先练习杠杆俯卧撑。\n训练目标：\n初级标准：1组，5次（每侧）\n中级标准：2组，各10次（每侧）\n升级标准：2组，各20次（每侧）\n稳扎稳打：\n由于杠杆原理，撑在篮球上的那只手臂如果完全伸直的话就很难用力。你可以让这只手臂的肘部稍稍弯曲，从而让篮球离你的身体近一点儿，这样做杠杆俯卧撑会容易一些。不过不要太过，要是你把篮球放在身体正下方，那这个动作就变成了第七式——偏重俯卧撑。随着你越来越强壮，你可以逐渐让球远离身体，直到可以将手臂伸直做标准的杠杆俯卧撑\n最终式 单臂俯卧撑 动作：\n跪在地板上，一只手撑在你前方的地面上。双腿向后蹬直，用脚趾支撑身体。脊柱与髋部成一条直线，支撑身体的手臂在胸部下方伸直——不要在身体侧面或是靠前的位置。稳定之后，把不起支撑作用的那只手背在身后。这是该动作的起始姿势（图19）。弯曲肘部，有控制地放低身体，直到下巴与地面大约有一拳之隔（图20）。在动作的最低点暂停一下，然后将自己推回到起始姿势。\n图19　脊柱与髋部成一条直线，支撑身体的手臂在胸部下方伸直。 \n\n\n图20　弯曲肘部，有控制地放低身体，直到下巴与地面大约有一拳之隔。 解析：\n姿势正确的单臂俯卧撑是检验胸部与肘部力量的黄金标准，而且能够让人一见难忘。许多健身者都声称自己能做单臂俯卧撑，但你千万不要被他们蒙骗。当你让他们动真格的时候，你就会发现，他们所谓的单臂俯卧撑就是个笑话：双腿朝两边分开，上身丑陋地扭曲——这是为了更容易做动作，然后他们会用摇摇摆摆、虚弱无力的胳膊猛地将自己推起，而且他们只能完成少数几次反复。毫无疑问，真正能做单臂俯卧撑的人可谓是危险的稀有动物，你要对自己有点儿信心，相信自己也能跻身其间。\n训练目标：\n初级标准：1组，5次（每侧） 中级标准：2组，各10次（每侧） 精英标准：1组，100次（每侧）  稳扎稳打：\n如果你已经攻克了杠杆俯卧撑，那么单臂俯卧撑对你而言就不是特别恐怖了。但是，如果你还不能标准地完成5次单臂俯卧撑，那么你还是回到第九式，确保自己可以标准地完成20次杠杆俯卧撑。如果你能做到这一点，但做单臂俯卧撑还是有问题，那么请你继续练习杠杆俯卧撑，直到你可以完成30次反复，然后再挑战单臂俯卧撑。\n总结 ","description":"胸肌（胸大肌和胸小肌）、三角肌前束、肱三头肌","id":165,"section":"exercise","tags":[""],"title":"铠甲般的胸肌与钢铁般的肱三头肌","uri":"https://www.zhugeqing.top/exercise/%E4%BF%AF%E5%8D%A7%E6%92%91/"},{"content":"算法  221. 最大正方形——第二遍 152. 乘积最大子数组——第三遍 322. 零钱兑换——第三遍  思念 思念祖母的第59天\n记：持续行动的六十八天！\n","description":"人生如棋，我愿为卒，行动虽慢，可谁曾见我后退半步？","id":166,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-10/"},{"content":"选择框架 目前常用的两个Go语言操作redis的框架分别为go-redis和redigo，推荐使用go-redis\nInstallation go get github.com/go-redis/redis/v8\n查询使用文档点击此处或者点击此处\n快速使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/go-redis/redis/v8\u0026#34; ) //最新版的go-redis参数必须有context var ctx = context.Background() //初始化客户端连接 var rdb = redis.NewClient(\u0026amp;redis.Options{ Addr: \u0026#34;localhost:6379\u0026#34;, //redis-serverip地址和端口号 \tPassword: \u0026#34;\u0026#34;, //密码设置 \tDB: 0, //选择数据库 \tPoolSize: 100, //连接池大小 }) func main() { //设置一个字符串类型的key，key为“key”，value为“value”，过期时间设置为永不过期 \terr := rdb.Set(ctx, \u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;, 0).Err() if err != nil { panic(err) } //查询\u0026#34;key\u0026#34;的值 \tval, err := rdb.Get(ctx, \u0026#34;key\u0026#34;).Result() if err != nil { panic(err) } //输出查询结果 \tfmt.Println(\u0026#34;key\u0026#34;, val) val2, err := rdb.Get(ctx, \u0026#34;key2\u0026#34;).Result() if err == redis.Nil { fmt.Println(\u0026#34;key2 does not exist\u0026#34;) } else if err != nil { panic(err) } else { fmt.Println(\u0026#34;key2\u0026#34;, val2) } // 输出: key value \t// key2 does not exist }   set/get 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  func Example() { err := rdb.Set(ctx, \u0026#34;score\u0026#34;, 100, 0).Err() if err != nil { fmt.Printf(\u0026#34;set score failed, err:%v\\n\u0026#34;, err) return } val, err := rdb.Get(ctx, \u0026#34;score\u0026#34;).Result() if err != nil { fmt.Printf(\u0026#34;get score failed, err:%v\\n\u0026#34;, err) return } fmt.Println(\u0026#34;score\u0026#34;, val) val2, err := rdb.Get(ctx, \u0026#34;name\u0026#34;).Result() if err == redis.Nil { fmt.Println(\u0026#34;name does not exist\u0026#34;) } else if err != nil { fmt.Printf(\u0026#34;get name failed, err:%v\\n\u0026#34;, err) return } else { fmt.Println(\u0026#34;name\u0026#34;, val2) } }   zset 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  func Example2() { zsetKey := \u0026#34;language_rank\u0026#34; //当做可变参数传入 \tlanguages := []*redis.Z{ \u0026amp;redis.Z{Score: 90.0, Member: \u0026#34;Golang\u0026#34;}, \u0026amp;redis.Z{Score: 98.0, Member: \u0026#34;Java\u0026#34;}, \u0026amp;redis.Z{Score: 95.0, Member: \u0026#34;Python\u0026#34;}, \u0026amp;redis.Z{Score: 97.0, Member: \u0026#34;JavaScript\u0026#34;}, \u0026amp;redis.Z{Score: 99.0, Member: \u0026#34;C/C++\u0026#34;}, } // ZADD \tnum, err := rdb.ZAdd(ctx, zsetKey, languages...).Result() if err != nil { fmt.Printf(\u0026#34;zadd failed, err:%v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;zadd %d succ.\\n\u0026#34;, num) // 把Golang的分数加10 \tnewScore, err := rdb.ZIncrBy(ctx, zsetKey, 10.0, \u0026#34;Golang\u0026#34;).Result() if err != nil { fmt.Printf(\u0026#34;zincrby failed, err:%v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;Golang\u0026#39;s score is %f now.\\n\u0026#34;, newScore) // 取分数最高的3个 \tret, err := rdb.ZRevRangeWithScores(ctx, zsetKey, 0, 2).Result() if err != nil { fmt.Printf(\u0026#34;zrevrange failed, err:%v\\n\u0026#34;, err) return } for _, z := range ret { fmt.Println(z.Member, z.Score) } // 取95~100分的 \top := redis.ZRangeBy{ Min: \u0026#34;95\u0026#34;, Max: \u0026#34;100\u0026#34;, } ret, err = rdb.ZRangeByScoreWithScores(ctx, zsetKey, \u0026amp;op).Result() if err != nil { fmt.Printf(\u0026#34;zrangebyscore failed, err:%v\\n\u0026#34;, err) return } for _, z := range ret { fmt.Println(z.Member, z.Score) } }   Sentinel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func Sentinel() error { SentinelRdb := redis.NewFailoverClient(\u0026amp;redis.FailoverOptions{ MasterName: \u0026#34;master\u0026#34;, //Sentinel密码 \tSentinelPassword: \u0026#34;8888\u0026#34;, //Sentinel地址和端口 \tSentinelAddrs: []string{\u0026#34;x.x.x.x:26379\u0026#34;, \u0026#34;xx.xx.xx.xx:26379\u0026#34;, \u0026#34;xxx.xxx.xxx.xxx:26379\u0026#34;}, }) //产是否连接成功 \t_, err := SentinelRdb.Ping(ctx).Result() if err != nil { return err } return nil }   Cluster 1 2 3 4 5 6 7 8 9 10  func Cluster() error { ClusterRdb := redis.NewClusterClient(\u0026amp;redis.ClusterOptions{ Addrs: []string{\u0026#34;:7000\u0026#34;, \u0026#34;:7001\u0026#34;, \u0026#34;:7002\u0026#34;, \u0026#34;:7003\u0026#34;, \u0026#34;:7004\u0026#34;, \u0026#34;:7005\u0026#34;}, }) _, err := ClusterRdb.Ping(ctx).Result() if err != nil { return err } return nil }   Pipeline Pipeline 主要是一种网络优化。它本质上意味着客户端缓冲一堆命令并一次性将它们发送到服务器。这些命令不能保证在事务中执行。这样做的好处是节省了每个命令的网络往返时间（RTT）。\nPipeline 示例：\n1 2 3 4 5 6 7 8  func Pipeline() { pipe := rdb.Pipeline() _, _ = pipe.Set(ctx, \u0026#34;诸葛青\u0026#34;, \u0026#34;健康开心\u0026#34;, 0).Result() _, _ = pipe.Set(ctx, \u0026#34;诸葛青1\u0026#34;, \u0026#34;无限可能\u0026#34;, 0).Result() _, _ = pipe.Incr(ctx, \u0026#34;22\u0026#34;).Result() //执行Pipeline里面的所有命令 \t_, _ = pipe.Exec(ctx) }   事务 Redis是单线程的，因此单个命令始终是原子的，但是来自不同客户端的两个给定命令可以依次执行，例如在它们之间交替执行。但是，Multi/exec能够确保在multi/exec两个语句之间的命令之间没有其他客户端正在执行命令。\n在这种场景我们需要使用TxPipeline。TxPipeline总体上类似于上面的Pipeline，但是它内部会使用MULTI/EXEC包裹排队的命令。\ntransaction 示例：\n1 2 3 4 5 6 7  func transaction() { tx := rdb.TxPipeline() _ = tx.Set(ctx, \u0026#34;number 1\u0026#34;, \u0026#34;One\u0026#34;, 0) _ = tx.Set(ctx, \u0026#34;number 2\u0026#34;, \u0026#34;two\u0026#34;, 0) _ = tx.Incr(ctx, \u0026#34;22\u0026#34;) _, _ = tx.Exec(ctx) }   Watch 在某些场景下，除了要使用MULTI/EXEC命令外，还需要配合使用WATCH命令。在用户使用WATCH命令监视某个键之后，直到该用户执行EXEC命令的这段时间里，如果有其他用户抢先对被监视的键进行了替换、更新、删除等操作，那么当用户尝试执行EXEC的时候，事务将失败并返回一个错误，用户可以根据这个错误选择重试事务或者放弃事务。\nWatch示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  func Watch() { // 监视watch_count的值，并在值不变的前提下将其值+1 \tkey := \u0026#34;watch_count\u0026#34; err := rdb.Watch(ctx,func(tx *redis.Tx) error { n, err := tx.Get(ctx,key).Int() if err != nil \u0026amp;\u0026amp; err != redis.Nil { return err } _, err = tx.Pipelined(ctx,func(pipe redis.Pipeliner) error { pipe.Set(ctx,key, n+1, 0) return nil }) return err }, key) if err != nil { fmt.Printf(\u0026#34;error: %v\\n\u0026#34;, err) } fmt.Println(\u0026#34;Exec succeeded\u0026#34;) }   ","description":"redis-go的学习","id":167,"section":"golang","tags":["Go"],"title":"Go语言对Redis进行操作","uri":"https://www.zhugeqing.top/golang/redis-go/"},{"content":"算法  123. 买卖股票的最佳时机 III——第三遍 188. 买卖股票的最佳时机 IV——第三遍 309. 最佳买卖股票时机含冷冻期——第三遍 714. 买卖股票的最佳时机含手续费——第三遍 32. 最长有效括号——第二遍 64. 最小路径和——第三遍 91. 解码方法——第三遍 154. 寻找旋转排序数组中的最小值 II——第三遍  思念 思念祖母的第58天\n记：持续行动的六十七天！\n","description":"人生如棋，我愿为卒，行动虽慢，可谁曾见我后退半步？","id":169,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-9/"},{"content":"算法  1143. 最长公共子序列——第三遍 198. 打家劫舍——第三遍 213. 打家劫舍 II——第三遍 121. 买卖股票的最佳时机——第三遍 122. 买卖股票的最佳时机 II——第三遍  不熟悉单词  outstanding apart deserve fierce emotion lorry fare  思念 思念祖母的第57天\n记：持续行动的六十六天！\n","description":"人生如棋，我愿为卒，行动虽慢，可谁曾见我后退半步？","id":170,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-8/"},{"content":"算法  221. 最大正方形——第一遍 120. 三角形最小路径和——第三遍 53. 最大子序和——第三遍 152. 乘积最大子数组 322. 零钱兑换——第二遍  思念 思念祖母的第56天\n记：持续行动的六十五天！\n","description":"生命的奖赏远在旅途终点，而非起点附近。我不知道要走多少步才能达到目标，踏上第一千步的时候，仍然可能遭到失败。但我不会因此放弃，我会坚持不懈，直至成功！","id":171,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-7/"},{"content":"算法  123. 买卖股票的最佳时机 III——第二遍 188. 买卖股票的最佳时机 IV——第二遍 309. 最佳买卖股票时机含冷冻期——第二遍 714. 买卖股票的最佳时机含手续费——第二遍 32. 最长有效括号——第一遍 64. 最小路径和——第二遍 91. 解码方法——第二遍 69. Sqrt(x)——第三遍 33. 搜索旋转排序数组——第三遍 153. 寻找旋转排序数组中的最小值——第三遍 154. 寻找旋转排序数组中的最小值 II——第二遍 45. 跳跃游戏 II  思念 思念祖母的第55天\n记：持续行动的六十四天！\n","description":"生活就是本能脑，情绪脑，理智脑的较量","id":172,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-6/"},{"content":"算法   62. 不同路径——第三遍\n  63. 不同路径 II——第三遍\n  1143. 最长公共子序列——第二遍\n  198. 打家劫舍——第二遍\n  213. 打家劫舍 II——第二遍\n  121. 买卖股票的最佳时机——第二遍\n  122. 买卖股票的最佳时机 II——第二遍\n思念 思念祖母的第54天\n记：持续行动的六十三天！\n  ","description":"望着镜子里的自己，不知是想起来从前那个对自己有着无限期望的小男孩，还是觉得此生已经注定要过没有勇气的生活","id":173,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-5/"},{"content":"算法  120. 三角形最小路径和——第二遍 53. 最大子序和——第二遍 152. 乘积最大子数组——第一遍 322. 零钱兑换——第一遍  菲记单词 思念 思念祖母的第53天\n记：持续行动的六十二天！\n","description":"光阴已去十九载，原来多愁善感是长大的标志","id":174,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-4/"},{"content":"算法  69. Sqrt(x)——第二遍 33. 搜索旋转排序数组——第二遍 529. 扫雷游戏——第三遍 74. 搜索二维矩阵——第三遍 153. 寻找旋转排序数组中的最小值——第三遍 55. 跳跃游戏——第三遍 874. 模拟行走机器人——第三遍 45. 跳跃游戏 II——第三遍  思念 思念祖母的第52天\n记：持续行动的六十一天！\n","description":"前不算，后要乱","id":175,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-3/"},{"content":"算法  509. 斐波那契数——第N遍 62. 不同路径——第二遍 63. 不同路径 II——第二遍 1143. 最长公共子序列——第二遍  菲记单词 思念 思念祖母的第51天\n记：持续行动的六十天！\n","description":"前不算，后要乱","id":176,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-2/"},{"content":"算法  433. 最小基因变化 127. 单词接龙  情  祝祖国生日快乐\n 思念 思念祖母的第50天\n记：持续行动的第五十九天！\n","description":"前不算，后要乱","id":177,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-10-1/"},{"content":"算法  455. 分发饼干 122. 买卖股票的最佳时机 II 55. 跳跃游戏 860. 柠檬水找零 874. 模拟行走机器人 45. 跳跃游戏 II  思念 思念祖母的第49天\n记：持续行动的第五十八天！\n","description":"前不算，后要乱","id":178,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-9-30/"},{"content":"算法  69. Sqrt(x) 33. 搜索旋转排序数组 529. 扫雷游戏 74. 搜索二维矩阵 153. 寻找旋转排序数组中的最小值  菲记单词 思念 思念祖母的第48天\n记：持续行动的第五十七天！\n","description":"前不算，后要乱","id":179,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-9-29/"},{"content":"算法  51. N 皇后 17. 电话号码的字母组合 433. 最小基因变化 200. 岛屿数量 127. 单词接龙  菲记单词 思念 思念祖母的第47天\n记：持续行动的第五十六天！\n","description":"前不算，后要乱","id":180,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-9-28/"},{"content":"算法  455. 分发饼干 122. 买卖股票的最佳时机 II 55. 跳跃游戏 860. 柠檬水找零 874. 模拟行走机器人 45. 跳跃游戏 II  思念 思念祖母的第46天\n记：持续行动的第五十五天！\n","description":"前不算，后要乱","id":181,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-9-27/"},{"content":"##　算法\n 529. 扫雷游戏  菲记单词 思念 思念祖母的第45天\n记：持续行动的第五十四天！\n","description":"前不算，后要乱","id":182,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-9-26/"},{"content":"算法  127. 单词接龙 50. Pow(x, n) 78. 子集  菲记单词 思念 思念祖母的第44天\n记：持续行动的第五十三天！\n","description":"前不算，后要乱","id":183,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-9-25/"},{"content":"算法  102. 二叉树的层序遍历 433. 最小基因变化 22. 括号生成 200. 岛屿数量  思念 思念祖母的第43天\n记：持续行动的第五十二天！\n","description":"前不算，后要乱","id":184,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-9-24/"},{"content":"算法  17. 电话号码的字母组合 51. N 皇后 77. 组合 46. 全排列 47. 全排列 II  菲记单词 思念 思念祖母的第42天\n记：持续行动的第五十一天！\n","description":"前不算，后要乱","id":185,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-9-23/"},{"content":"算法  94. 二叉树的中序遍历 144. 二叉树的前序遍历 589. N 叉树的前序遍历 105. 从前序与中序遍历序列构造二叉树 236. 二叉树的最近公共祖先 104. 二叉树的最大深度 98. 验证二叉搜索树 22. 括号生成  菲记单词 思念 思念祖母的第41天\n记：持续行动的第五十天！\n","description":"前不算，后要乱","id":186,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-9-22/"},{"content":"算法  50. Pow(x, n) 78. 子集  菲记单词 思念 思念祖母的第40天\n记：持续行动的第四十九天！\n","description":"前不算，后要乱","id":187,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-9-21/"},{"content":"算法  73. 矩阵置零 47. 全排列 II 46. 全排列 77. 组合  思念 思念祖母的第39天\n记：持续行动的第四十八天！\n","description":"前不算，后要乱","id":188,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-9-20/"},{"content":"算法  49. 字母异位词分组 242. 有效的字母异位词 105. 从前序与中序遍历序列构造二叉树 236. 二叉树的最近公共祖先 104. 二叉树的最大深度 98. 验证二叉搜索树 22. 括号生成## 菲记单词  思念 思念祖母的第38天\n记：持续行动的第四十七天！\n","description":"前不算，后要乱","id":189,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-9-19/"},{"content":"算法 94. 二叉树的中序遍历\n144. 二叉树的前序遍历\n589. N 叉树的前序遍历\n429. N 叉树的层序遍历\n590. N 叉树的后序遍历\n菲记单词 思念 思念祖母的第37天\n记：持续行动的第四十六天！\n","description":"前不算，后要乱","id":190,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-9-18/"},{"content":"算法 力扣73. 矩阵置零\n菲记单词 思念 思念祖母的第36天\n记：持续行动的第四十五天！\n","description":"前不算，后要乱","id":191,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-9-17/"},{"content":"算法 力扣242. 有效的字母异位词\n力扣49. 字母异位词分组\n菲记单词 思念 思念祖母的第35天\n记：持续行动的第四十四天！\n","description":"前不算，后要乱","id":192,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-9-16/"},{"content":"跑步 再次挑战五公里，我可以失败一百次，但我一定要成功一次！\n算法  力扣42. 接雨水——第三遍 力扣29. 两数相除——第三遍  菲记单词 思念 思念祖母的第34天\n记：持续行动的第四十四天！\n","description":"前不算，后要乱","id":193,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-9-15/"},{"content":"Golang   内存逃逸：每一个函数都有自己的局部变量，当函数返回（函数被销毁）之后，这些局部变量都不能使用，因为每一个函数都在栈区分配到了一个栈帧。而在函数里面申请在堆上分配，函数销毁后，该变量依旧能够使用，从而就形成了一种栈区逃逸到堆区的现象\n  new函数可以分配内存，并将内存清零，返回一个指类型的零值指针\n  make函数相当于是一个工厂函数，仅可以为slice,map,chan分配内存\n  算法  力扣26. 删除有序数组中的重复项——第三遍 力扣20. 有效的括号——第三遍 力扣155. 最小栈——第三遍 力扣84. 柱状图中最大的矩形——第三遍 力扣239. 滑动窗口最大值——第三遍  菲记单词 思念 思念祖母的第33天\n记：持续行动的第四十三天！\n","description":"前不算，后要乱","id":194,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-9-14/"},{"content":"跑步  重回五公里，期间有想过放弃，但心中越有不甘就越是不能轻易放弃  算法  力扣641. 设计循环双端队列——第一遍  Golang  值得去看一些http库的源码 从《Go web编程》了解web程序的形成  操作系统  了解进程的api 了解进程的状态 了解进程创建的过程  思念 思念祖母的第32天\n记：持续行动的四十二天！\n","description":"前不算，后要乱","id":195,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-9-13/"},{"content":"1.Golang  实现ServeHttp方法可以实现http.Handler这个接口，http.Handle(\u0026quot;/haha\u0026quot;, \u0026amp;Handler)可以处理请求，同时需要创建结构体http.Server（假设实例为server），并使用server.ListenAndServe()进行监听 也可以使用http.HandleFunc()进行注册处理，http.HandleFunc实际上是一个类型，也实现了ServerHttp方法，相当于也是一个http.Handler 尝试制作微信小程序  2.vscode  选中单词按F2进行批量修改  3.算法  力扣42. 接雨水——第二遍 力扣29. 两数相除——第二遍  思念 今天距离奶奶离开已经一个月了，思念涌上心头，伤心无法停留——思念祖母的第31天\n记：持续行动的四十一天！\n","description":"前不算，后要乱","id":196,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-9-12/"},{"content":"今日完成任务 1.算法  力扣20. 有效的括号——第二遍 力扣155. 最小栈——第二遍 力扣84. 柱状图中最大的矩形——第二遍 力扣239. 滑动窗口最大值——第二遍 力扣189. 旋转数组——第三遍 力扣560. 和为 K 的子数组——第三遍 力扣21. 合并两个有序链表——第三遍 力扣88. 合并两个有序数组——第三遍 力扣1. 两数之和——第三遍 力扣66. 加一——第三遍  记：持续行动的四十天！\n","description":"前不算，后要乱","id":197,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-9-11/"},{"content":"今日完成任务 1.算法  力扣15题三数之和——第三遍 力扣206题反转链表——第三遍 力扣141题环形链表——第三遍 力扣26题删除有序数组中的重复项——第三遍  2.Golang  练习go test（注意点：1.测试文件要以_test结尾，测试函数要以Test开头且之后要大写首字母。2.使用*testing.T）   go test .\n 测试代码覆盖率（覆盖率是指在测试中至少被运行一次的代码占总代码数的比例）   第一种:go test -cover\n第二种:go test -coverprofile=cover go tool cover -html=cover\n 性能测试（1.使用*testing.B。2.使用b.N来提高测试次数。3. b.ResetTimer()用来重置测试时间）   go test -bench . 用于查看性能\ngo test -bench . -cpuprofile cpu.out 再用  go tool pprof cpu.out可以详细查看，在交互界面输入web，可以更加详细查看，并分析性能，修改代码\n 记：持续行动的第三十九天！\n","description":"前不算，后要乱","id":198,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-9-10/"},{"content":"记：持续行动的第三十八天！\n","description":"2021-09-09","id":199,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-9-9/"},{"content":"记：持续行动的第三十七天！\n","description":"2021-09-08","id":200,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-9-8/"},{"content":"记：持续行动的第三十六天！\n","description":"2021-09-07","id":201,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-9-7/"},{"content":"记：持续行动的第三十五天！\n","description":"2021-09-06","id":202,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-9-6/"},{"content":"记：持续行动的第三十四天！\n","description":"2021-09-05","id":203,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-9-5/"},{"content":"记：持续行动的第三十三天！\n","description":"2021-09-04","id":204,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-9-4/"},{"content":"记：持续行动的第三十二天！\n","description":"2021-09-03","id":205,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-9-3/"},{"content":"记：持续行动的第三十一天！\n","description":"2021-09-02","id":206,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-9-2/"},{"content":"记：持续行动的第三十天！\n","description":"2021-09-01","id":207,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-9-1/"},{"content":"记：持续行动的第二十九天！\n","description":"2021-08-31","id":208,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-8-31/"},{"content":"记：持续行动的第二十八天！\n","description":"2021-08-30","id":209,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-8-30/"},{"content":"记：持续行动的第二十七天！\n","description":"2021-08-29","id":210,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-8-29/"},{"content":"记：持续行动的第二十六天！\n","description":"2021-08-28","id":211,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-8-28/"},{"content":"记：持续行动的第二十五天！\n","description":"2021-08-27","id":212,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-8-27/"},{"content":"记：持续行动的第二十四天！\n","description":"2021-08-26","id":213,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-8-26/"},{"content":"记：持续行动的第二十三天！\n","description":"2021-08-25","id":214,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-8-25/"},{"content":"记：持续行动的第二十二天！\n","description":"2021-08-24","id":215,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-8-24/"},{"content":"记：持续行动的第二十一天！\n","description":"2021-08-23","id":216,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-8-23/"},{"content":"四个用于终端的快捷键 Tab键: 在Bash解释器的快捷键中，Tab绝对是使用频率最高的，它能够实现对命令、参数或文件的内容补全。\nCtrl+c键：当同时按下键盘上的“Ctrl”和字母“c”的时候，意味着对当前进程进行终止操作。假如执行了一个错误命令，又或者执行命令后无法结束了，这种情形下一定要保持冷静的按下“Ctrl+c”键，可以立刻夺回命令行终端的控制权。\nCtrl+d键：当同时按下键盘上的“Ctrl”和字母“d”的时候，代表键盘输入结束（End OF Input），简称EOF。\nCtrl+l键：清空当前终端中已有的内容，相当于清屏操作(类似于命令“clear”)。\n 常用系统工作命令   echo: echo命令用于在终端设备上输出字符串或变量提取后的值，语法格式为：“echo [字符串] [$变量]”。\n  date: date命令用于显示或设置系统的时间与日期，语法格式为：“ date [+指定的格式]”。还可以使用date设置本地时间，例:date -s \u0026ldquo;20210822 8:30:00\u0026rdquo;\n  timedatectl: timedatectl命令用于设置系统的时间，英文全称为：“time date control”，语法格式为：“ timedatectl [参数]”。\n  reboot: reboot命令用于重启系统，输入后回车执行即可。\n  5．poweroff: poweroff命令用于关闭系统，输入后回车执行即可。\n6．wget: wget命令用于在终端命令行里下载网络文件，英文全称为：“web get”，语法格式为：“wget [参数] 网址”。\n7．ps: ps命令用于查看系统中的进程状态，英文全称为：“processes”，语法格式为：“ps [参数]”。\n ```pstree``: pstree命令用于以树状图的形式展示进程之间的关系，英文全称为：“process tree”，输入后回车执行即可。\n  top: top命令用于动态地监视进程活动及系统负载等信息，输入后回车执行即可。\n  nice: nice命令用于调整进程的优先级，语法格式为：“nice 优先级数字 服务名称”，数字越低（取值范围是-20到19）、优先级越高。\n  pidof: pidof命令用于查询某个指定服务进程的PID号码值，语法格式为：“pidof [参数] 服务名称”。\n  kill: kill命令用于终止某个指定PID值的服务进程，语法格式为：“kill [参数] 进程的PID”。\n  killall: killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为：“killall [参数] 服务名称”。\n  系统状态检测命令   ifconfig: ifconfig命令用于获取网卡配置与网络状态等信息，英文全称为：“interface config”，语法格式为：“ifconfig [参数] [网络设备]”。\n  uname: uname命令用于查看系统内核版本与系统架构等信息，英文全称为：“Unix name”，语法格式为：“uname [-a]”。\n  uptime: uptime命令用于查看系统的负载信息，输入后回车执行即可。它可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息。平均负载值指的是系统在最近1分钟、5分钟、15分钟内的压力情况（下面加粗的信息部分），负载值越低越好。\n  free: free命令用于显示当前系统中内存的使用量信息，语法格式为：“free [-h]”。\n  who: who命令用于查看当前登入主机的用户终端信息，输入后回车执行即可。\n  last: last命令用于调取主机的被访记录，输入后回车执行即可。\n  ping: ping命令用于测试主机之间的网络连通性，语法格式为：“ping [参数] 主机地址”。\n  tracepath: tracepath命令用于显示数据包达到目的主机途中所经过的路由信息，语法格式为：“tracepath [参数] 域名”。\n  netstat: netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为：“network status”，语法格式为：“netstat [参数]”。\n  history: history命令用于显示执行过的命令历史，语法格式为：“history [-c]”。\n  sosreport: sosreport命令用于收集系统配置及架构信息并输出诊断文档，输入后回车执行即可。\n  查找定位文件命令   pwd: pwd命令用于显示用户当前所处的工作目录，英文全称为：“print working directory”，输入后回车执行即可。\n  cd: cd命令用于切换当前的工作路径，英文全称为：“change directory”，语法格式为：“cd [参数] [目录]”。\n  ls: ls命令用于显示目录中的文件信息，英文全称为：“list”，语法格式为：“ls [参数] [文件名称]”。\n  tree: tree命令用于以树状图的形式列出目录内容及结构，输入后回车执行即可。\n  find: find命令用于按照指定条件来查找文件所对应的位置，语法格式为：“find [查找范围] 寻找条件”。\n  locate: locate命令用于按照名称快速搜索文件所对应的位置，语法格式为：“locate 文件名称”。\n  whereis: whereis命令用于按照名称快速搜索二进制程序（命令）、源代码以及帮助手册文件所对应的位置，语法格式为：“whereis 命令名称”。\n  which: which命令用于按照指定名称快速搜索二进制程序（命令）所对应的位置，语法格式为：“which 命令名称”。\n  文本文件编辑命令   cat: cat命令用于查看纯文本文件（内容较少的），英文全称为：“concatenate”，语法格式为：“cat [参数] 文件名称”。\n  more: more命令用于查看纯文本文件（内容较多的），语法格式为：“more [参数] 文件名称”。\n  head: head命令用于查看纯文本文件的前N行，语法格式为：“head [参数] 文件名称”。\n  tail: tail命令用于查看纯文本文件的后N行或持续刷新文件的最新内容，语法格式为：“tail [参数] 文件名称”。\n  tr: tr命令用于替换文本内容中的字符，英文全称为：“translate”，语法格式为：“tr [原始字符] [目标字符]”。\n  wc: wc命令用于统计指定文本文件的行数、字数或字节数，英文全称为：“word counts”，语法格式为：“wc [参数] 文件名称”。\n  stat: stat命令用于查看文件的具体存储细节和时间等信息，英文全称为：“status”，语法格式为：“stat 文件名称”。在Linux系统中文件包含三种时间状态，分别是Access Time（最后一次内容被访问的时间，简称Atime），Modify Time（最后一次内容被修改的时间，简称Mtime）以及Change Time（文件属性最后一次被修改的时间，简称Ctime）。\n  grep: grep命令用于按行提取文本内容，语法格式为：“grep [参数] 文件名称”。\n  cut: cut命令用于按列提取文本内容，语法格式为：“cut [参数] 文件名称”。\n  diff: diff命令用于比较多个文件之间内容的差异，英文全称为：“different”，语法格式为：“diff [参数] 文件名称A 文件名称B”。\n  uniq: uniq命令用于去除文本中连续的重复行，英文全称为：“unique”，语法格式为：“uniq [参数] 文件名称”。\n  sort: sort命令用于对文本内容进行再排序，语法格式为：“sort [参数] 文件名称”。\n  文件目录管理命令   touch: touch命令用于创建空白文件或设置文件的时间，语法格式为：“touch [参数] 文件名称”。\n  mkdir: mkdir命令用于创建空白的目录，英文全称为：“make directory”，语法格式为：“mkdir [参数] 目录名称”。\n  cp: cp命令用于复制文件或目录，英文全称为：“copy”，语法格式为：“cp [参数] 源文件名称 目标文件名称”。\n  mv: mv命令用于剪切或重命名文件，英文全称为：“move”，语法格式为：“mv [参数] 源文件名称 目标文件名称”。\n  rm: rm命令用于删除文件或目录，英文全称为：“remove”，语法格式为：“rm [参数] 文件名称”。\n  dd: dd命令用于按照指定大小的数据块个数来复制文件或转换文件，语法格式为：“dd if=参数值 of=参数值 count=参数值 bs=参数值”。\n  file: file命令用于查看文件的类型，语法格式为：“file 文件名称”。\n  tar: tar命令用于对文件进行打包压缩或解压，语法格式为：“tar 参数 文件名称”。\n   记：持续行动的第二十天！\n","description":"2021-08-22","id":217,"section":"write","tags":[""],"title":"Linux就该这么学","uri":"https://www.zhugeqing.top/write/2021-8-22/"},{"content":"记：持续行动的第十九天！\n","description":"2021-08-21","id":218,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-8-21/"},{"content":"记：持续行动的第十八天！\n","description":"2021-08-20","id":219,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-8-20/"},{"content":"记：持续行动的第十七天！\n","description":"2021-08-19","id":220,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-8-19/"},{"content":"记：持续行动的第十六天！\n","description":"2021-08-18","id":221,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-8-18/"},{"content":"记：持续行动的第十五天！\n","description":"2021-08-17","id":222,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-8-17/"},{"content":"记：持续行动的第十四天！\n","description":"2021-08-16","id":223,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-8-16/"},{"content":"记：持续行动的第十三天！\n","description":"2021-08-15","id":224,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-8-15/"},{"content":"记：持续行动的第十二天！\n","description":"2021-08-14","id":225,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-8-14/"},{"content":"记：持续行动的第十一天！\n","description":"2021-08-13","id":226,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-8-13/"},{"content":"悲痛 从我记事起就一直是祖母带着我，虽然在前几天就得到祖母可能要离开人世了的消息，但我并没有赶回家去看祖母，这是暑假，我离开了家，去了广州。在我离开之前我依然记得祖母精神虽然不是很好，但也绝不是快要离开人世的状态，而随后又听到其他家人发的信息，说祖母也不想在拖累家人，就不吃饭就算喝水也不愿意。奶奶一个生育了七个儿女，我家是最小的，而祖母也一直在我家住，从出生到如今离开。今天虽然我听了祖母已经离开的消息，但没有非常悲伤，因为前几天我听到祖母快不行得到消息时，已经哭了一晚上，那是我真正体会到心痛的感觉，比我以前为自己哭还要痛。而家里人也已经通知我赶紧回家参加祖母的葬礼，但我并没有回应。我不会回去参加的，尽管我会顶着一个不孝的名号。但我知道，祖母确实永远离开了我，我甚至都没能和祖母留下一个合照，让我更心痛的是，我似乎从小到大都没有对祖母说过一句谢谢，而我如今只能不断的流泪，写下这篇文章来证明，果然，人总是在失去的时候的时候才懂得珍惜，写到这里，我的脸庞已经是有种麻木的感觉，也无法阻止眼泪的留下\u0026hellip;\u0026hellip;\n我这辈子从来没有在梦里哭过，而得到祖母身体快不行的消息时的那一天，我一个人在床上哭，我也知道了什么叫做“无声地痛哭”，也不知道过来多久才睡着，当我醒来的时候，眼角依然湿润，我感觉做了一个很长的梦。我梦见我已经回到家，祖母也离世了，我将梦中的悲痛带到了现实，我却在心里疯狂暗示：这不是真的！,我知道我还有时间回去看祖母，但已经晚了，我亏欠祖母的这十多年是无法用几天来弥补的。想起来小时候：我小时候有很长一段时间都是和祖母还有姐姐呆在一起，我依然记得许多想笑又想哭的事情，我记得那还是我小学，应该不会超过4年级，我家离小学有大约一公里左右的距离，而当我才走出家门100米不远就看到几只公鸡在马路边拦路，我尝试走过去的时候，它们就竖起鸡毛，好像要揍我的感觉，因为要快迟到了，我感觉回家告诉奶奶，我奶奶从家门出来帮我把它们赶走，然后嘱咐我路上小心，那时候奶奶就像我唯一的保护伞。现在想起来，我是真傻，怎么会想着长大，长大不仅有各种各样的烦恼。亲人也在慢慢老去，现在想起来，小时候有奶奶陪伴的日子是多么的幸福，开心，当我的父亲因为病情没有去外打工回到家中后，有时会经常打我，因为我玩游戏的缘故，我经常被打得离家出走，除了我奶奶，没有人叫我回家，不管我每次跑到离家100米，200米的地方躲着，不管是白天还夜晚，奶奶都会呼喊我的名字，叫我回家，但现在我已经再也听不到那呼喊我回家的那个熟悉的声音了，脑海里记忆的声音也会被时间慢慢抹去，但我尽力记住和奶奶在一起的画面，那是我人生的一部分，也是我永远不想忘记的一部分，童年的事情太多了，我也无力在继续写下去，我会尽快走出悲伤，因为眼泪和鼻涕刺激让我不敢再继续写下去\u0026hellip;\n续写（2021-9-16补写） 最近刷抖音时老是刷到一些人怀念自己奶奶的视频，对于以前的我，我都只是会引发心中的同情和对奶奶的思念，但现在，我只能对着自己怒吼，真是伤心啊！就是只是续写，眼泪依然还是留了下来，不断回忆，续写我和祖母的故事。\n还记得小时候舅舅给我买了一个小霸王游戏机。跟电视机连上之后，就可以尽情的玩游戏，我也时常叫朋友来家里玩，那时候，家里挤满了人，热闹且快乐，对比现在的我，内向且不问世事，只想一个人好好的生活。而游戏机上让我记忆犹新的游戏有《超级玛丽》，《魂斗罗》，《超级玛丽》，《赤色要塞》，《忍者神龟》\u0026hellip;\u0026hellip;等一些记得画面却想不起名字的游戏，那时候，白天我都会小伙伴们玩得十分开心，而晚上我一个人玩也能感到无比的欢乐，到睡觉点后，奶奶会叫我去睡觉，那时候我还是跟奶奶一起睡的，似乎初中之前我都是和奶奶一起睡的，那时候我还很听话，会认真去睡觉，而对比如今，奶奶跟我说话，我常常会表现一副不耐烦的表情，当然，现在我也再也听不到奶奶的啰嗦了，我的那点懦弱和不耐烦只能埋藏于心中了。还记得小时候的冬天，那时候还很冷，没到晚上睡觉的时候，我的脚都是冰凉的，奶奶都会夹住我的脚，给我冬天夜晚最炙热的温度。如今的自己，多加一床被子，也无法再次得到那一份温暖了。\n时间的流逝，我没有牢牢抓住，它却偷偷带着了我的亲人，现在才体会到“寸金难买寸光阴”的意思，不止碌碌无为，还在亲人离开之后留下巨大的伤痛\u0026hellip;\n续写（2021-9-22补写） 现在每天晚上还是会听一些以前的动画片的主题曲，每一首歌都是一个很长的故事，每个人都会有一段最开心的时光，而我最开心的时光就是小时候坐在电视机前看动画片的时候，我的同龄人可能正在参加各种竞赛，各种特长培训，我过得比他们要平凡100倍，但我无悔我的童年，小时候奶奶守在我身边看动画片的日子是我不会忘记的时光，因为那是我记忆最重要的一部分，我希望我外甥女也有一个快乐的童年，当然，也希望我小外甥女在她家也能开心的成长，新旧交替虽然是自然规律，但我相信，时间的任何身体上的折磨不会比亲人离去还要痛哭，我很喜欢《魔角侦探》片尾曲《成长的路口》里面的歌词，成长的路口 - 咖啡因乐队\n\n成长的路口（点击听歌）\n但是人生\n难免会有些不快乐\n告别今天\n总是让人觉得失落\n看看明天\n在地平线向我招手\n每天就在日升日落\n抓紧时间幻想更多\n期待生命中每秒每一刻\n哇哦\n明亮的眼睛在闪烁\n映着阳光的笑容\n勇敢说出心里珍藏的那份小小感动\n迎面吹来清晨的微风\n将童年心愿带走\n它会悄悄种在成长的路口\n它会悄悄种在成长的路口\n 续写（2022-9-25补写）  没有相当，上一次续写已经是一年之前的事，很抱歉，奶奶，我当初的承诺又没有实现，我才知道人为什么不能够改变，原来我没有下定决心，我依旧想过这以前一样慵懒的生活，今日午睡，睡了两个小时，等醒来时，发现梦到了您，我才知道我的眼角又湿润了，我也一年没回家了，也是一年没有来看您，我现在只能无能地哭泣，好吧，我会调整自己的，今日就到这吧，再哭，就有嘶哑了\u0026hellip;  未完待续\u0026hellip;\n以后的路 1.以后少触碰网络游戏（奶奶前面日子还会叫我去吃饭，而我为了享受网络游戏的强及时反馈，每次都是对奶奶说：你别说了，我又不是小孩子了，我饿了会自己吃饭，可能我这些话会让在家本来没有什么事干的奶奶感觉是个累赘） 2.早睡早起（我寒暑家在家老是喜欢熬夜，奶奶每次半夜1，2点都要来叫我赶紧去睡觉，是我为了自己熬夜带来的快感而忽视了奶奶的关心）\n3.努力赚钱（奶奶最后也是因为摔了一跤，把腿摔断了，而奶奶养育的七个儿女也没有做出送医院的打算，最后奶奶觉得自己确实老了，走不动了，才会不吃不喝，离开人世，世界上果然只有一种病——“穷”）\n\n记：持续行动的第十天！\n","description":"以此文章来记下我与祖母的过去","id":227,"section":"write","tags":[""],"title":"我的祖母离开了","uri":"https://www.zhugeqing.top/write/2021-8-12/"},{"content":"记：持续行动的第九天！\n","description":"2021-08-11","id":228,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-8-11/"},{"content":"记：持续行动的第八天！\n","description":"2021-08-10","id":229,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-8-10/"},{"content":"记：持续行动的第七天！\n","description":"2021-08-09","id":230,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-8-9/"},{"content":"记：持续行动的第五天！\n","description":"2021-08-07","id":231,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-8-7/"},{"content":"记：持续行动的第六天！\n","description":"2021-08-08","id":232,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-8-8/"},{"content":"记：持续行动的第四天！\n","description":"2021-08-06","id":233,"section":"write","tags":[""],"title":"无","uri":"https://www.zhugeqing.top/write/2021-8-6/"},{"content":"字符集 众所周知，变量都存在在计算机内存中，同时以二进制的形式存储， 比如int8类型的6在计算机中就应该是0000 0110，这很容易理解，因为这就是6的二进制形式，而加入是一个字符\u0026rsquo;a\u0026rsquo;呢，在没学到ASCII码集的时候，让你写出字符\u0026rsquo;a\u0026rsquo;的二进制形式你可能会相当懵。所以就诞生了字符集，通俗点讲，字符串就是用阿拉伯数字对字符进行编号，ASCII码集最初一共收录了128个字符，我们所常用的字母字符，数字字符，常用符号字符都包含于ASCII码集，直接上图吧\n而之后ASCII码字符集的扩展收录了256个字符，但是后面发现缺少汉字也不行，所以又出现了GB2312,而这也没有繁体字啊,随后又出现了BIG5，但是依然有许多字符没有被收录，比如日语，而后又有了GBK等等字符集，但最后本着全球统一化标准的的目的，Unicode字符集就诞生了，实现了跨语言，跨平台的文本转换和处理，字符集促成了字符与二进制的合作。\n但是这并不代表这结束，来看另外一个问题，如何存储一个字符串，比如s := \u0026ldquo;hello世界\u0026rdquo;，那么它在如何以二进制形式存储于计算机中呢，可能你会想直接代入字符集的编号不就行了，这确实可以，但是，这一串二进制数应该如何划分呢？如果没有一个划分规则的话，可能你存储的和取出的不是一个字符串了，有一种方法叫定长编码，就是一个字符由n个字节组成，如果这个字符位数不够，那么就高位补零，这样假如这个字符串每一个字符都占2个字节，那么我们解码的时候就直接每2个字节做一个字符翻译，但是这有很大的不足，可能像汉字这样的一些字符需要2个字节，但是常用的字母只需要一个字节就能表示，所以显然定长编码造成了显著的浪费。那就换一种，使用不定长编码，小编号只占少字节，而高编号就占多字节，但这样同样需要一个划分规则，直接上图\n比如字符\u0026rsquo;e\u0026rsquo;的编码就是0110 0101（在区间[0,127]），而字符\u0026rsquo;世\u0026rsquo;的编码就是11100100 10111000 10010110 \n可以尝试运行下面代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  package main import ( \u0026#34;fmt\u0026#34; ) func main() { s := \u0026#34;e世\u0026#34; for i := 0; i \u0026lt; len(s); i++ { fmt.Printf(\u0026#34;%b\\t\u0026#34;, s[i]) } }   而这个编码方式也就是go语言的默认编码方式UTF-8编码\n字符串类型的结构 首先在内存中找到这个字符串得有一个起始地址，而对于结尾，内存非常大，无法得知这个字符串的结尾在哪里，对于C语言字符串采取的是在尾部放一个编号为0的字符'\\0'，而go语言设计者并没有这样做，而是在放一个长度，这个长度指的是的字符串的字节个数，如下图\ngo语言的字符串可以进行读，但是不能进行修改，所以go语言编译器会把定义的字符串分配的只读内存段。假如能够对字符串进行修改，那么如果有两个字符串变量同时指向了一个字符串，由于字符串变量是可以共用底层字符串内容的，通过其中一个变量对字符串进行修改，那么另个一个字符串变量同样被修改，这样的影响是不可预测的，所以要修改字符串变量就只能重新指向一个字符串\n记：持续行动的第三天！\n","description":"学习Golang字符串","id":234,"section":"write","tags":[""],"title":"Golang字符串","uri":"https://www.zhugeqing.top/write/2021-8-5/"},{"content":"改变趁现在 对于一个好的习惯，也许只要一些偶然的机会就可以使得一个好习惯永远消失。可能你会想：“这怎么可能？无论是好习惯还是坏习惯都是习惯，而习惯是很难改变的”，习惯是指“长期形成的不易改变的行为、生活方式或社会风尚”。“不易改变”很重要，但也代表着不是不能改变，举一个例子，我们每个人在小时候都有的好习惯“早睡早起”，这是无法反驳的，青少年小时候都会早睡早起，因为那时的晚上并没有太多诱惑，而如今，信息化的社会充斥着诱惑，比如“网络游戏”，“抖音”，“QQ聊天”，等等娱乐方式都在潜移默化的影响我们的习惯，而早睡早起这一样好的习惯早就成为了云烟。但不可否认的是，现在的生活节奏很快，有些人忙不过来，也有些人玩不过来，显然，我更偏向于后者，没有人是天生爱学习的，但是所有人都应该是爱成长的，无论哪一个方面的成长，就算是打游戏，也代表你在玩某款游戏方面有了些许进步。回到原话题，好习惯太难发掘了，可能还没有人发现这个好习惯，就随这一些坏的变化而发展成坏习惯。而对于坏习惯，它很狡猾，它很容易让人察觉到它，但一个人很难消灭它，因为它每天都会给人多巴胺，使人沉浸于其中而不能自拔，这是无法或者“极其困难”通过某些偶然的机会改变的。\n如何发现一个坏习惯？很简单，问问自己的身体就知道了，或者去医院问问医生也能知道，比如你的皮肤有了什么变化，你的体态有了什么变化，你的器官有了什么变化？举个最简单的例子，就算所有的人都知道“吸烟有害身体”这个事实，但还是有不少人依旧吸烟，而这一坏习惯往往和“瘾”相关联。吸烟能得到什么？我小时候抽过烟，我那时的感受有两个，一是“我感觉抽烟的我好帅，我要在别人面前抽烟（当然，排除在家长面前抽烟）”；二是“抽烟有点呛人呀”。所以我到目前为止抽过的烟要低于十只，现在想想，还好我没有抽烟的习惯，不然钱没了，肺也在不断受到伤害。一个客观的事实，“你很难劝一个人去戒烟”，不要问我为什么，因为我劝了好多次了，但如上文所述，一个坏习惯很难改变，而不抽烟的好习惯可能在经过几次诱惑之后就变成爱抽烟了。慢慢发觉自己的坏习惯，要慢慢改变，循循善诱，比如以前一天要抽五只烟的，可以变成4只，然后发现自己还能少抽一点，再然后发现自己原来不抽烟也没什么关系，从而戒掉烟瘾！\n对于改变要学会慢慢来，不要急，而我，今天是坚持写作的第二天，因为坚持和“慢慢来”使我今天还能继续写作，我写作是为了寻求内在，问问自己的心，从而也发现一些坏习惯，再慢慢改变。每一次改变总要有个第一天，那就从下定决心的那天开始，改变趁现在！\n记：持续行动的第二天！\n","description":"如何不能彻底改变，那就学会慢慢来","id":235,"section":"write","tags":[""],"title":"慢慢来，事情会办好的！","uri":"https://www.zhugeqing.top/write/2021-8-4/"},{"content":"为什么要持续行动 从小到大，每个人都听过各种各样的技巧，比如，小时候的数学培训（这也算是一个技巧，以为报了班就能过练就出一身功夫），考试时候的投机取巧，比如小时候写作文，字数不够，写不出真材实料，就开始胡编乱造，甚至题目要求写了需要流露出真实情感，也需要用技巧来填充，等等\u0026hellip;\u0026hellip;\n\n\n我是一个很懒惰的人，如果有种东西可以通过技巧来快速获得，我肯定乐意学习该技巧，前提是这东西对我有所帮助。值得一说的是，这个类似东西似乎常常伴于学生，就是考试成绩，对于考试，每个人都有不同的技巧，而对那些学霸拥有的技巧更是数不胜数，而对于技巧，有个东西值得一说，那就是——“努力”。努力的范围很广阔，今天记录几十个单词是努力，今天跑上了5公里是努力，今天做了家务是努力，只要你愿意，努力就可以由你自己来定义，而努力就需要用一个“持续”来修饰。假如没有持续，今天我跑上了5公里，明天、后天、大后天、甚至几个星期后都没有去跑步，那么今天的5公里只能说是脑子突然一股狂热，认为自己该努力，该锻炼身体了，但这种不持续的努力只能有非常短暂的效果。\n\n\n那么持续努力的周期应该如何定义呢，这完全可以取决于自身，地球的自转周期为一天，所以一天就是一个很好的参考单位，比如记单词，每天都愿意花上半的小时来记单词，再愿意花上半个小时来复习以前的单词。这就是一种持续，所以扯了这么多，持续行动和技巧有什么关系？有，有关系的，如今的互联网，就如微信公众号文章，短视频都会取一些标题来吸引读者和观者，例如，“英语如何到达高分的技巧”，“数学如何学好？”，这样的数不胜数，技巧的背后是什么？技巧的背后是由经验支撑的，所谓经验就是通过不断摸索，不断学习所得出的认识，而技巧就是副产物，就好比一个超级玛丽，本来你是一步一步往前进的，结果你旁边的小伙计告诉你，哪里有管道，可以快速通过一段距离，更有甚者告诉你哪里有个隐藏的地方可以直接跳过这个大关，然后你想：这不是挺好吗？使用这些“技巧”就可以快速过关，省下时间和躲避一些危险，甚至可以通关。但，人生不是游戏，人生抛弃死亡，是没有终点的，但你定下的目标有终点，如果你的目标是下次英语考试或者数学考试及格，采用一些技巧那绝对是明智的选择，但如果在后面几年里都需要这种数学，英语能力，那么所谓技巧可能能够帮到我们的可能性会大大降低，对于一个可以轻松通关游戏的高手，必然是经过了不断的努力，当他有了持续行动后，在持续行动的过程中还产生了快速通过此关的“技巧”，而这些技巧的产生的起因只是为了帮它的造物主（持续行动的高手）在以后再遇到关卡时，能够简单从容地过关，而对于新手而言，掌握这些技巧可能在一些关卡面前有用，但是越到后面就会感到越吃力，越力不从心。\n\n持续行动的好处 现在我们每一个人的环境都承载了所有前辈的过去，包括出生的家庭环境、所处的城市，都是前辈逐渐积攒下来的结果。这是我们无法选择的“默认参数”，我们一出生，身上就带了这些参数，需要背着它不断去优化，走完此生。\n\n\n陶渊明先生有一句话叫作“悟已往之不谏，知来者之可追”，意思是过去的事情已经无法改变，只有现在、未来才是可以触及的。如果我们想要重构现在和未来的话，就像我们的过去被定义的方式一样，都是一个缓慢而持续的过程。也就是说，即使我们想改变，但改变的效果要显现，也需要非常漫长的时间。\n\n世界是残酷的，我们大部分人都不能拥有衣食无忧，家庭富裕的生活，世界是公平的，无论是穷人还是富人所拥有的时间是一样的，而对于我们这样的普通人，持续行动就是我们变得越来越优秀的最大技巧。\n持续行动是容易被动摇的，但不能被孤独打败，不能说“我感觉今天所记的单词没有一点用处，过几天肯定忘了”而变得犹豫，甚至有了放弃在后面的日子记单词的想法。持续行动是孤独的，当你一个人默默的学习，锻炼身体，而同龄人在游戏，娱乐时，你会变得感觉像是一个与世界格格不入的人，但这份孤独是正向的，连这份孤独都抗下来了，那相信你以后面对其他消极情绪也能轻松消灭掉。\n记：持续行动的第一天！\n","description":"持续行动是最大的技巧","id":236,"section":"write","tags":[""],"title":"持续行动","uri":"https://www.zhugeqing.top/write/2021-8-3/"},{"content":"此文章选自微信公众号“景禹”\n 以前的计算机刚被发明的时候，主要作用是做一些科学和工程的计算工作，科学家发明计算机的时候压根儿不可能想到后人还可以用来KMP。\n刚开始的计算机都是处理数值工作，后来引入了字符串的概念，计算机开始可以处理非数值的概念了（当然原理还是用数值来模拟非数值，通过ASCII码表）。\n总之在工作当中字符串的处理操作非常普遍，今日主要分享字符串模式匹配算法KMP的相关操作。\n在分享KMP算法之前，我们先看一下蛮力法进行模式匹配的过程：\n 对应力扣28. 实现 strStr()\n代码实现如下 c golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  int strStr(char* haystack, char* needle) { //暴力法  //haystack为主串，needle为模式串  int n = strlen(haystack), m = strlen(needle); for (int i = 0; i \u0026lt;= n-m; i++) { int flag = 1;//标记是否匹配成功  for (int j = 0; j \u0026lt; m; j++) { if (haystack[i + j] != needle[j]) { flag = 0; break; } } if (flag) { //成功返回i下标  return i; } } return -1; //匹配失败 }     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  func strStr(haystack string, needle string) int { //暴力法  //haystack为主串，needle为模式串  j:=0 //遍历模式串的下标  for i:=0;i\u0026lt;=len(haystack)-len(needle);i++{ for j=0;j\u0026lt;len(needle);j++{ if haystack[i+j] != needle[j]{ break //不匹配，主串从下一个下标再开始匹配  } } if j == len(needle){ return i //匹配成功  } } return -1 }       'use strict'; var containerId = JSON.parse(\"\\\"21a1473cb1c69f53\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  显然蛮力法的执行效率太低了，为此有大佬提出了KMP算法。在详细介绍KMP算法之前，我们看一下字符串的前缀与后缀的概念：\n有了字符串前缀与后缀的概念，我们就可以计算出一个字符串前缀与后缀的公共子串的最大长度。\n此时，我们就可以来看KMP算法的执行过程了。\n第一步：\n第二步：\n第三步：\n第四步：\n第五步：\n理解KMP算法的执行过程中，一定要注意景禹在图片中标注的文字。最后我们来看一下动图演示：\n代码实现如下 c golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  int* getNext(char *needle){ int n = strlen(needle); int* next = (int*)malloc(sizeof(int)*n); //为next数组分配空间  int maxMatch = 0; //最大匹配长度  next[0] = 0; for(int i=1;i\u0026lt;n;i++){//下标0没有对应的前缀和后缀，直接从1开始  while(maxMatch\u0026gt;0 \u0026amp;\u0026amp; needle[i] != needle[maxMatch]){ maxMatch = next[maxMatch-1]; //如果不匹配就用之前的next值直到匹配或者maxMatch再次为0  } if (needle[i] == needle[maxMatch]){//匹配成功直接加一  maxMatch++; } next[i] = maxMatch;//此下标的next值就等于当前匹配的最大值  } return next; } int strStr(char * haystack, char * needle){ //KMP算法  //haystack为主串，needle为模式串  int n = strlen(haystack), m = strlen(needle);//主串和模式串的长度  if(m==0){ return 0; } int* next = getNext(needle); int j = 0;//遍历模式串  for(int i=0;i\u0026lt;n;i++){//遍历主串  while(j\u0026gt;0 \u0026amp;\u0026amp; haystack[i] != needle[j]){ j = next[j-1];//不匹配，寻找下一次匹配需要的next值  } if(haystack[i] == needle[j]){ j++; } if(j == m){ //当j等于模式串长度时，说明已经完全匹配  return i-j+1; } } return -1; }     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  func getNext(needle string)[]int{ next := make([]int,len(needle)) //长度为len(needle)  //根据前后缀来求Next数组  maxMatch := 0 //最长匹配长度  //i从1开始，因为0下标的next值一定为0  for i:=1;i\u0026lt;len(needle);i++{ for maxMatch \u0026gt; 0 \u0026amp;\u0026amp; needle[i] != needle[maxMatch]{//当前不匹配，只能用前面的next值，直到匹配，或者maxMatch=0  maxMatch = next[maxMatch-1] //回溯求最长匹配长度  } if needle[i] == needle[maxMatch]{//匹配也只会在原来的基础上+1  maxMatch++ } next[i] = maxMatch//赋next值，  } return next } func strStr(haystack string, needle string) int { if needle == \u0026#34;\u0026#34;{ return 0 } if len(haystack) \u0026lt; len(needle){ return -1 } //第一步先求next数组  next := getNext(needle) //第二步开始匹配  for i,j:=0,0;i\u0026lt;len(haystack);i++{ //  for j \u0026gt; 0 \u0026amp;\u0026amp; haystack[i] != needle[j]{ j = next[j-1] } if haystack[i] == needle[j]{ j++ } if j == len(needle){//全部匹配完，返回  return i-j+1 } } return -1 //没找到，返回-1 }       'use strict'; var containerId = JSON.parse(\"\\\"2ef5793b5d1f93ab\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  总结 仔细观察KMP算法的代码后，你就会发现，它与带备忘录的动态规划解法惊人的相似，我们用一个next数组(备忘录)来记录下一个字符匹配失败，如果再次匹配成功应该移动的步数(当前匹配字符数-next值)，然后下一次匹配直接从可以在移动步数之后进行匹配，从而跳过一些已经知道不可能再匹配成功的字符(好比递归树的剪枝)\n","description":"一文解析KMP算法","id":237,"section":"article","tags":["算法"],"title":"图解|KMP算法","uri":"https://www.zhugeqing.top/article/algorithm/kmp/"},{"content":"快速生成一个模板代码  我们平常在goland的go文件中输入一个main，再回车就自动生成了main函数，类似的还有init，forr，这些都是goland实时模板（Live Templates）的功能\n  一次打开 goland \u0026gt; 设置 \u0026gt; 编辑器 \u0026gt; 实时模板 可以自己创建一个模板组，也可以直接在gol模板组里面增加一个动态模板 比如缩写为max，适用于Go 文件，模板文本如下  1 2 3 4 5 6  func min(a, b $Type$) $Type$ { if a \u0026lt; b { return a } return b }    我们可以将自己经常写的代码加入到模板组中，比如修改err   快速生成对应接口方法代码  按下 生成方法的快捷键（可去设置进行修改），输入需要实现的对应接口（比如:heap.Interface）   友好的快捷键  ctrl +, ctrl -折叠，展开代码或者注释 doubule shift（按两次shift），使用最强搜索功能   插件  tabnine——友好的AI代码补全 One Dark theme——热爱的暗黑模式   ","description":"Goland实用技巧","id":238,"section":"golang","tags":["Go"],"title":"Goland","uri":"https://www.zhugeqing.top/golang/goland/"},{"content":"题目：65,8,50,15,37,24,()。括号中的数字是()？ A. 25\nB. 26\nC. 22\nD. 27\n答案：\r65=8^2+1 这里将8作为65的特征\r8=3^2-1 这里得到3\r50=7^2+1 这里得到7\r15=4^2-1 这里得到4\r37=6^2+1 这里得到6\r24=5^2-1 这里得到5\r我们发现8,3,7,4,6,5 这组数的特点，以奇数项开始 奇数项加偶数项的和为11，\r以偶数项开始的话 偶数项+奇数项的和为10 8+3=7+4=6+5 3+7=4+6=5+x 这里得到x为5 特征为5 转换为5^2+1 得到26\r","description":"括号中的数字是什么?","id":239,"section":"intelligence","tags":null,"title":"智力题2.1","uri":"https://www.zhugeqing.top/intelligence/niuke_part2/%E6%8B%AC%E5%8F%B7%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88_1/"},{"content":"题目：5 , 6 , 6 , 9 ,（）, 90。括号中的数字是()？ A. 12\nB. 15\nC. 18\nD. 21\n答案：整个数列规律为：\r（5-3）*（6-3）=6\r（6-3）*（6-3）=9\r（6-3）*（9-3）=18\r（9-3）*（18-3）=90\r规律很多，仅供参考，自我挖掘！\r","description":"括号中的数字是什么?","id":240,"section":"intelligence","tags":null,"title":"智力题2.2","uri":"https://www.zhugeqing.top/intelligence/niuke_part2/%E6%8B%AC%E5%8F%B7%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88_2/"},{"content":"题目：2 ，3 ，10 ，15 ，26 ，35 ，( )。括号中的数字是是什么？ A. 40\nB. 45\nC. 50\nD. 55\n1^2+1=2 2^2-1=3 3^2+1=10 4^2-1=15 5^2+1+26 6^2-1=35 奇数项平方加一，偶数项平方减一\r","description":"括号中的数字是什么?","id":241,"section":"intelligence","tags":null,"title":"智力题2.3","uri":"https://www.zhugeqing.top/intelligence/niuke_part2/%E6%8B%AC%E5%8F%B7%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88_3/"},{"content":"题目：一台指针式钟表的时针和分针指向的重合的时间间隔是？\n答案：\r由于分针总是比时针走的快，所以问题就转换成时针在一圈的范围内追击分针的问题：\r分针走的角速度是360°/60分 = 6°/分\r时针走的角速度是360°/720分 = 0.5°/分\r下一次追到比上一次追到，分针比时针多走过的角度是360°，\r那么在一圈的角度内 360°/(6°/分-0.5°/分) = 720/11 分钟，\r经过这么多时间 分针和时间重合一次，\r所以引申到一昼夜时间内分针 时针相遇多少次：24*60/(720/11) = 22 次\r","description":"时针和分针指向的重合的时间间隔是？","id":242,"section":"intelligence","tags":null,"title":"智力题1.3","uri":"https://www.zhugeqing.top/intelligence/niuke_part1/%E6%97%B6%E9%92%88%E4%B8%8E%E5%88%86%E9%92%88%E9%87%8D%E5%90%88/"},{"content":"题目：对一批编号为1～100，全部开关朝上(开)的灯进行以下操作：\n凡是1的倍数反方向拨一次开关；2的倍数反方向又拨一次开关；\n3的倍数反方向又拨一次开关……100的倍数反方向又拨一次开关 ,\n问：最后为关熄状态的灯有几个?\n答案：分析：所有的灯都会根据它是否是某数的倍数来拨动开关，比如1是1的倍数，\r但它不是其他剩余99个数的倍数，故只拨动一次开关，初始状态为开，\r只要经过奇数次拨动开关，最终状态都会是关着的灯\r进一步分析：上述分析又可以根据题意来化解为只有这个编号含有奇数个因数的灯，\r在经过所有关灯操作之后，它的最终状态就是关闭的，所以2不是（1，2），\r3不是（1,3）,4是(1，2，4)，...9是（1,3,9）,...16是（1,2,4,8,16），\r发现规律的吧，1的平方，2的平方，3的平方，4的平方，\r所有1-100一共有10个最后为关熄状态的灯。\r","description":"最后为关熄状态的灯有几个?","id":243,"section":"intelligence","tags":null,"title":"智力题1.4","uri":"https://www.zhugeqing.top/intelligence/niuke_part1/%E6%9C%80%E5%90%8E%E4%B8%BA%E5%85%B3%E7%86%84%E7%8A%B6%E6%80%81%E7%9A%84%E7%81%AF%E6%9C%89%E5%87%A0%E4%B8%AA/"},{"content":"题目：假设一个5位数字的180度旋转图像是另一个5位数字，并且这两个数字之间的差是78633，那么原始的5位数字是什么？\n答案：\r首先，只有0，1，2，6，8，9，6个数字反转仍有效。另外要注意，旋转180度，\r数字所在位也变了。考虑首位和末位，要求差为7和3，只有1和8满足。\r1xxx8和8xxx1。考虑倒数第二位3，由于末位退位，要求差4，只有0和6。\r所以是10x68和89x01。最后看中间，78633+10x68=89x01。\r所有原始数字是10968或者89601\r","description":"原始的5位数字是什么？","id":244,"section":"intelligence","tags":null,"title":"智力题1.5","uri":"https://www.zhugeqing.top/intelligence/niuke_part1/%E5%8E%9F%E5%A7%8B%E7%9A%845%E4%BD%8D%E6%95%B0%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88/"},{"content":"题目：医院里的医务人员，包括我在内，总共是16名医生和护士。下面讲到的人员情况，无论是否把我计算在内，都不会有任何变化。在这些医务人员中： (1)护士多于医生;(2)男医生多于男护士;(3)男护士多於女护士;(4)至少有一位女医生。 这位说话的人是什么性别和职务？\n答案：\r先考虑不把说话者计算在内的情况，这时医生和护士共有15名。\r首先由条件（1）可知，则护士至少应有8名；再由条件（3）可知，\r则男护士至少有5名；接着由条件（2）可知，男医生至少有6名；\r结合条件（4）可知，医生至少有7名，则护士至多8名。所以，\r要满足条件，只能是护士8名，其中男护士5名，女护士3名，医生7名，\r其中男医生6名，女医生1名。加上说话者后，要仍满足这四个条件，\r由条件（1）可知，说话者是护士；由条件（2）可知，说话者不能是男护士，\r所以只能是女护士。\r","description":"题目：这位说话的人是什么性别和职务","id":245,"section":"intelligence","tags":null,"title":"智力题3.1","uri":"https://www.zhugeqing.top/intelligence/niuke_part3/%E8%BF%99%E4%BD%8D%E8%AF%B4%E8%AF%9D%E7%9A%84%E4%BA%BA%E6%98%AF%E4%BB%80%E4%B9%88%E6%80%A7%E5%88%AB%E5%92%8C%E8%81%8C%E5%8A%A1/"},{"content":"题目：\n已知每个城市的用水需求相同，每月水库的进水速率恒定不变。现有一座水库供水，如果供应10个城市的话，一个月水库就会枯竭；如果供应8个城市的话，一个半月水库就会枯竭。当前城市化进程不断加快，新的城市不断产生，为了能够持续满足12个城市的供水，还至少需要建设几个这样的水库？\n假设水库库存的水量为M\r水库每月进水为X\r每个城市每月消耗水m\r由题意：\rM + X = 10 * m\rM + 1.5 * X = 8 * m * 1.5\r解得：\rX = 4m\r因此：\r要维持12个城市每月持续不断的供水，要满足：(?) * X = m * 12\r解得：(?) = 3\r题目问的是：\u0026quot;还至少需要建设几个这样的水库？\u0026quot;\r不应该是2个吗？(因为现在已经有一个水库了...)\r","description":"还至少需要建设几个这样的水库?","id":246,"section":"intelligence","tags":null,"title":"智力题4.1","uri":"https://www.zhugeqing.top/intelligence/niuke_part4/%E8%BF%98%E8%87%B3%E5%B0%91%E9%9C%80%E8%A6%81%E5%BB%BA%E8%AE%BE%E5%87%A0%E4%B8%AA%E8%BF%99%E6%A0%B7%E7%9A%84%E6%B0%B4%E5%BA%93/"},{"content":"题目：把21、26、65、99、10、35、18、77分成若干组，要求每组中任意两个数都互质，至少要分成多少组。\n答案：1.首先把含有相同因数的数分到一组，或者是没有相同因数的质数分为一组\r2.列出来：含有因数3的：21，99，18。含有因数5的：10，35，65。\r是质数（77不是质数，但剩下的数里面没有和它有相同因数的，故分到一组）的：26，77\r3.然后把这些组组合起来，所以至少是三组。\r解惑（思路有很多，比如也可以在第一第二步选择将偶数分为一组，然后再细分）\r","description":"题目：至少要分为多少组？","id":247,"section":"intelligence","tags":null,"title":"智力题4.2","uri":"https://www.zhugeqing.top/intelligence/niuke_part4/%E8%87%B3%E5%B0%91%E8%A6%81%E5%88%86%E4%B8%BA%E5%A4%9A%E5%B0%91%E7%BB%84/"},{"content":"数组的定义 根据 维基百科 的定义，在计算机科学中，数组数据结构（英语：array data structure），简称数组（英语：Array），是由相同类型的元素（element）的集合所组成的数据结构，分配一块连续的内存来存储。利用元素的索引（index）可以计算出该元素对应的存储地址\n数组的分类 数组 分为两种类型：一维数组 和 多维数组。\n一维数组：一维（或单维）数组是一种线性数组，其中元素的访问是以行或列索引的单一下标表示。\n多维数组：多维数组是由多个低维数组组成的一种数组，其中元素的访问是以多个下标为索引来表示。\n多维数组的存储空间本质上跟一维数组一样，都是连续存储的，只不过多维数组将一个大容量的数组分隔开来，分成多个小的数组，比如二维数组是由0个或多个一维数组组成的数组，三维数组是由0个或多个二维数组组成数组，以此类推\u0026hellip;.\n数组的查找  当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：  a[i]_address = base_address + i * data_type_size 其中 data_type_size 表示数组中每个元素的大小（即存储数据类型的大小），假如数组中存放的是int类型，那么data_type_size就是4个字节，a[i]_address就是需要查找的元素的内存地址，base_address就是数组的首地址（即：a[0]的内存地址）\n通过一个简单的例子来明白数组元素的内存地址的计算  从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前面也讲到，如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 data_type_size 的位置，所以计算 a[k] 的内存地址只需要用这个公式：\na[k]_address = base_address + k * data_type_size 1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; int main() { int a[3] = {0}; int k = 2; //（这里k应该在区间[0,3)内）  if (\u0026amp;a[k] == (a + k)) printf(\u0026#34;a[k]_address = base_address + k * type_size式子成立~\u0026#34;); else printf(\u0026#34;a[k]_address = base_address + k * type_size式子不成立！\u0026#34;); return 0; }   因为当一个地址与一个整型数相加时，在进行加法运算之前会自动将整型数转换k*data_type_size的形式，所以当请不要尝试k+sizeof(int)，以免混淆记忆。 为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？  答案：从刚才那个计算公式就可以知道，倘若从数组1开始编号，那么计算数组元素 a[k] 的内存地址就会变为：\na[k]_address = base_address + (k-1)*type_size\n对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。\n数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。\n不过我认为，上面解释得再多其实都算不上压倒性的证明，说数组起始编号非 0 开始不可。所以我觉得最主要的原因可能是历史原因 。\nC 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。实际上，很多语言中数组也并不是从 0 开始计数的，比如 Matlab。甚至还有一些语言支持负数下标，比如 Python。\n 数据结构与算法之美作者——王争 的原话\n  \n总结：数组根据下标随机访问的时间复杂度为 O(1)，用给定元素查找的时间复杂度为O(n)。（上述内容虽然未涉及到查找操作，但理解的可以自行尝试，最好的情况，从下标0开始就找到，最坏情况，在最后一个下标才找到）\n数组的插入 假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。那插入操作的时间复杂度是多少呢？\n如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)/n=O(n)。\n如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 k 之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数组插入到第 k 个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。\n利用这种处理技巧，在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)\n总结：数组在需要保持有序的状态下，将元素插入到第k个位置的时间复杂度O(n)，数组在无需保持有序的状态下，将元素插入到第k个位置的时间复杂度为O(1)\n数组的删除 跟插入数据类似，如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。\n和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)\n警惕数组的访问越界问题 请分析如下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13  #include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { int i = 0; int arr[3] = {0}; for (; i \u0026lt;= 3; i++) { arr[i] = 0; printf(\u0026#34;hello world\\n\u0026#34;); } return 0; }   你发现问题了吗？这段代码的运行结果并非是打印三行“hello word”，而是会无限打印“hello world”，这是为什么呢？\n因为，数组大小为 3，a[0]，a[1]，a[2]，而我们的代码因为书写错误，导致 for 循环的结束条件错写为了 i\u0026lt;=3 而非 i\u0026lt;3，所以当 i=3 时，数组 a[3] 访问越界。\n我们知道，在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。\n所有只需再随便加一个变量即可，使得i不再变为0，就可解决无限循环问题，因为它会将j变为0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { int i = 0; int j = 99; int arr[3] = {0}; for (; i \u0026lt;= 3; i++) { arr[i] = 0; printf(\u0026#34;hello world\\n\u0026#34;); } printf(\u0026#34;j = %d\u0026#34;, j); return 0; }   数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，``只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。\n这种情况下，一般都会出现莫名其妙的逻辑错误，而且，很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统，所以写代码的时候一定要警惕数组越界。\n目前的主流的语言如java这样的会自己检查数组越界，而无须程序员自己检查。 ","description":"战略上藐视技术，战术上重视技术——闪客","id":248,"section":"data_structure_and_sort","tags":["数据结构"],"title":"数组","uri":"https://www.zhugeqing.top/data_structure_and_sort/datastructure/array/"},{"content":"题目：1000 个瓶子中有一瓶毒药，一只老鼠吃到毒药一周之内会死，如果要在一周之内检测出有毒药的一瓶，问至少需要几只老鼠？\nA:8\nB:10\nC:24\nD:999\n答案是十只 000=0\r001=1\r010=2\r011=3\r100=4\r101=5\r110=6\r111=7\r一位表示一个老鼠，0-7表示8个瓶子。\r也就是分别将1、3、5、7号瓶子的药混起来给老鼠1吃，\r2、3、6、7号瓶子的药混起来给老鼠2吃，\r4、5、6、7号瓶子的药混起来给老鼠3吃，\r哪个老鼠死了，相应的位标为1。\r如老鼠1死了、老鼠2没死、老鼠3死了，\r那么就是101=5号瓶子有毒。\r同样道理10个老鼠可以确定1000个瓶子\r","description":"问至少需要几只老鼠？","id":249,"section":"intelligence","tags":null,"title":"智力题1.1","uri":"https://www.zhugeqing.top/intelligence/niuke_part1/%E8%80%81%E9%BC%A0%E6%B5%8B%E6%AF%92%E8%8D%AF/"},{"content":"1\n1 1\n2 1\n1 2 1 1\n1 1 1 2 2 1\n下一行是什么\nA:1111211\nB:312211\nC:312112\nD:213112\n微软的题\r答案：后一行数是前一行数的描述，把“个”字去掉组成新的数：\r-1：1个1 ——11\r- 11：2个1——21\r- 21：1个2，1个1——1211\r- 1211：1个1,1个2,2个1——111221\r- 111221：3个1，2个2，1个1——312211\r","description":"题目：下一行输出什么","id":250,"section":"intelligence","tags":null,"title":"智力题1.2","uri":"https://www.zhugeqing.top/intelligence/niuke_part1/%E4%B8%8B%E4%B8%80%E8%A1%8C%E8%AF%A5%E8%BE%93%E5%87%BA%E4%BB%80%E4%B9%88/"},{"content":"堆的定义 根据 维基百科 的定义，堆 是一种特别的二叉树，满足以下条件的二叉树，可以称之为 堆：\n 1.完全二叉树； 2.每一个节点的值都必须 大于等于或者小于等于 其孩子节点的值。  堆 具有以下的特点：\n 1.可以在 O(logN) 的时间复杂度内向 堆 中插入元素； 2.可以在 O(logN) 的时间复杂度内向 堆 中删除元素； 3.可以在 O(1) 的时间复杂度内获取 堆 中的最大值或最小值。  堆的分类 堆 分为两种类型：最大堆 和 最小堆。\n最大堆（大顶堆）：堆中每一个节点的值 都大于等于 其孩子节点的值。最大堆的特性是 堆顶元素（根节点）是堆中的最大值。\n最小堆（小顶堆）：堆中每一个节点的值 都小于等于 其孩子节点的值。最小堆的特性是 堆顶元素（根节点）是堆中的最小值。\n堆的存储 堆的逻辑结构是一棵二叉树，所以可以考虑使用二叉树的表示方法来表示堆。但是因为堆中元素按照一定的优先顺序排列，因此可以使用 数组来表示，这样可以节省子节点指针空间，并且可以快速访问每个节点。堆的数组表示其实就是堆层级遍历的结果，如下图所示：\n堆的操作 在堆的数据结构中，我们常用堆的初始化、插入、删除、获取堆顶元素的操作。\n接下来我们一一进行学习：\n堆初始化操作  1.确定堆包含的属性：堆的最大空间，堆的当前大小，堆的存放数组 2.初始化堆，为其分配内存空间  代码实现如下（大顶堆）：\ngolang c  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  type MaxHeap struct { // 使用数组创建完全二叉树的结构，然后使用二叉树构建一个「堆」  maxHeap []int // heapSize用于数组的大小，因为数组在创建的时候至少需要指明数组的元素个数  heapSize int // realSize用于记录「堆」的元素个数  realSize int } //大顶堆初始化函数 func MaxHeapInit(size int)MaxHeap{ return MaxHeap{ maxHeap: make([]int, size+1), heapSize: size, realSize: 0, } }     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  typedef struct { //堆的数组  int *maxHeap; //堆的元素个数  int realSize; //堆的大小  int MaxSize; } MaxHeap; //初始化堆函数 void initMaxHeap(MaxHeap *mh, int size) { mh-\u0026gt;MaxSize = size; mh-\u0026gt;maxHeap = (int *)malloc((mh-\u0026gt;MaxSize + 1) * sizeof(int)); //从1开始存储  mh-\u0026gt;realSize = 0; }       'use strict'; var containerId = JSON.parse(\"\\\"da4c3546d49916ea\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \n堆插入操作 堆可以看成一个完全二叉树，每次总是先填满上一层，再从下一层从左往右依次插入。堆插入操作的步骤（大顶堆）：\n 1.将新元素增加到堆的末尾 2.按照优先顺序，将新元素与其父节点比较，如果新元素大于父节点则将两者交换位置 3.不断进行第2步操作，直到不需要交换新元素和父节点，或者达到堆顶 4.最后得到一个大顶堆  代码实现如下（大顶堆）：\ngolang c  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  //添加元素函数 func (Maxheap *MaxHeap)insert(element int){ //如果当前元素个数已经和堆想等，那就输出错误信息  if Maxheap.realSize+1 \u0026gt; Maxheap.heapSize{ fmt.Println(\u0026#34;Add too many elements!\u0026#34;) return } Maxheap.realSize++ //新增加元素的下标  index := Maxheap.realSize //父节点下标  parent := index / 2 Maxheap.maxHeap[index] = element //如果大于父节点就不断向上交换  for Maxheap.maxHeap[index] \u0026gt; Maxheap.maxHeap[parent] \u0026amp;\u0026amp; index \u0026gt; 1{ //因为下标1没有父节点，所有index不能等于或者小于1  //进行交换  Maxheap.maxHeap[index],Maxheap.maxHeap[parent] = Maxheap.maxHeap[parent],Maxheap.maxHeap[index] index = parent parent = index / 2 //继续比较  } }     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  //添加元素函数 void insert(MaxHeap *mh, int element) { //如果当前元素个数已经满了，那就输出错误信息  if (mh-\u0026gt;realSize + 1 \u0026gt; mh-\u0026gt;MaxSize) { printf(\u0026#34;Add too many elements!\u0026#34;); return; } mh-\u0026gt;realSize++; //插入元素到堆的末尾  mh-\u0026gt;maxHeap[mh-\u0026gt;realSize] = element; //调整堆  int index = mh-\u0026gt;realSize; //父节点的下标  int parent = index / 2; while (mh-\u0026gt;maxHeap[index] \u0026gt; mh-\u0026gt;maxHeap[parent] \u0026amp;\u0026amp; index \u0026gt; 1) //堆下标从1开始，1没有父节点  { //交换元素  int temp = mh-\u0026gt;maxHeap[index]; mh-\u0026gt;maxHeap[index] = mh-\u0026gt;maxHeap[parent]; mh-\u0026gt;maxHeap[parent] = temp; //为了不断向上调整  index = parent; parent = index / 2; } }       'use strict'; var containerId = JSON.parse(\"\\\"a235620a8425ba32\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  堆删除操作 堆的删除操作与插入操作相反，插入操作是从下往上调整堆，而删除操作却是从上往下调整堆，堆删除操作的步骤（大顶堆）：\n 1.删除堆顶元素（通常是将堆顶元素放置在数组的末尾） 2.比较左右子节点，将大的元素上调 3.不断进行步骤2，直到不需要调整或者调整到堆底  代码实现如下：（大顶堆）\ngolang c  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  //删除堆顶元素函数 func (Maxheap *MaxHeap)delete()int{ // 如果当前「堆」的元素个数为0， 则返回「Don\u0026#39;t have any element」  removeElement := Maxheap.maxHeap[1] if Maxheap.realSize \u0026lt; 1{ fmt.Println(\u0026#34;Don\u0026#39;t have any element!\u0026#34;) return math.MaxInt64 }else { //当前堆中有元素，Maxheap.realSize \u0026gt;= 1  // 将「堆」中的最后一个元素赋值给堆顶元素  Maxheap.maxHeap[1] = Maxheap.maxHeap[Maxheap.realSize] //去除最后一个元素  Maxheap.maxHeap[Maxheap.realSize] = math.MinInt64 Maxheap.realSize-- index := 1 // 不断向下调整堆  // 当删除的元素不是孩子节点时  for index \u0026lt; Maxheap.realSize \u0026amp;\u0026amp; index \u0026lt;= Maxheap.realSize/2 { // 被删除节点的左孩子节点  left := index * 2; // 被删除节点的右孩子节点  right := (index * 2) + 1; // 当删除节点的元素小于 左孩子节点或者右孩子节点，代表该元素的值小，此时需要将该元素与左、右孩子节点中最大的值进行交换  if Maxheap.maxHeap[index] \u0026lt; Maxheap.maxHeap[left] || Maxheap.maxHeap[index] \u0026lt; Maxheap.maxHeap[right] { if Maxheap.maxHeap[left] \u0026gt; Maxheap.maxHeap[right] { temp := Maxheap.maxHeap[left] Maxheap.maxHeap[left] = Maxheap.maxHeap[index] Maxheap.maxHeap[index] = temp index = left } else { // maxHeap[left] \u0026lt;= maxHeap[right]  temp := Maxheap.maxHeap[right] Maxheap.maxHeap[right] = Maxheap.maxHeap[index] Maxheap.maxHeap[index] = temp index = right } } else { break } } } return removeElement }     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  //堆元素删除函数 int delete (MaxHeap *mh) { // 如果当前「堆」的元素个数为0， 则返回「Don\u0026#39;t have any element」  if (mh-\u0026gt;realSize \u0026lt; 1) { printf(\u0026#34;Don\u0026#39;t have any element!\u0026#34;); return intMIN; } //保留删除的元素，以便返回  int removeElement = mh-\u0026gt;maxHeap[1]; //删除堆顶元素，把最后一个元素移至堆顶  mh-\u0026gt;maxHeap[1] = mh-\u0026gt;maxHeap[mh-\u0026gt;realSize]; //把最后一个元素置为最小(已经宏定义IntMin为4字节int类型最小值)  mh-\u0026gt;maxHeap[mh-\u0026gt;realSize] = intMIN; //元素长度大小减1  mh-\u0026gt;realSize--; //向下调整  int index = 1; while (index \u0026lt; mh-\u0026gt;realSize \u0026amp;\u0026amp; index \u0026lt;= mh-\u0026gt;realSize / 2) { //左节点  int left = index * 2; //右节点  int right = index * 2 + 1; if (mh-\u0026gt;maxHeap[index] \u0026lt; mh-\u0026gt;maxHeap[left] || mh-\u0026gt;maxHeap[index] \u0026lt; mh-\u0026gt;maxHeap[right]) { if (mh-\u0026gt;maxHeap[left] \u0026gt; mh-\u0026gt;maxHeap[right]) { int temp = mh-\u0026gt;maxHeap[index]; mh-\u0026gt;maxHeap[index] = mh-\u0026gt;maxHeap[left]; mh-\u0026gt;maxHeap[left] = temp; index = left; } else { int temp = mh-\u0026gt;maxHeap[index]; mh-\u0026gt;maxHeap[index] = mh-\u0026gt;maxHeap[right]; mh-\u0026gt;maxHeap[right] = temp; index = right; } } else { break; } } return removeElement; }       'use strict'; var containerId = JSON.parse(\"\\\"ee313d4e690b8810\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \n获取堆顶元素操作 直接返回堆顶元素就行\n代码如下：（大顶堆）\ngolang c  1 2 3 4  //获取堆顶元素函数 func (Maxheap MaxHeap)peek()int{ return Maxheap.maxHeap[1] }     1 2 3 4 5 6  //获取堆顶元素函数 int peek(MaxHeap mh) { return mh.maxHeap[1]; }       'use strict'; var containerId = JSON.parse(\"\\\"29be8967f7045099\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \n总结 对于堆这种数据结构，我们只需要掌握如何来初始化，删除元素，添加元素，堆的应用十分广泛，如下：\n 1.堆排序 2.快速找出一个集合中的最小值（或者最大值） 3.构建优先队列 4.在朋友面前装逼（开个玩笑）  总体代码如下（包含大顶堆和小顶堆）：\ngo go c c  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) //构建大顶堆 type MaxHeap struct { // 使用数组创建完全二叉树的结构，然后使用二叉树构建一个「堆」  maxHeap []int // heapSize用于数组的大小，因为数组在创建的时候至少需要指明数组的元素个数  heapSize int // realSize用于记录「堆」的元素个数  realSize int } //添加元素函数 func (Maxheap *MaxHeap)insert(element int){ //如果当前元素个数已经和堆想等，那就输出错误信息  if Maxheap.realSize+1 \u0026gt; Maxheap.heapSize{ fmt.Println(\u0026#34;Add too many elements!\u0026#34;) return } Maxheap.realSize++ //新增加元素的下标  index := Maxheap.realSize //父节点下标  parent := index / 2 Maxheap.maxHeap[index] = element //如果大于父节点就不断向上交换  for Maxheap.maxHeap[index] \u0026gt; Maxheap.maxHeap[parent] \u0026amp;\u0026amp; index \u0026gt; 1{ //因为下标1没有父节点，所有index不能等于或者小于1  //进行交换  Maxheap.maxHeap[index],Maxheap.maxHeap[parent] = Maxheap.maxHeap[parent],Maxheap.maxHeap[index] index = parent parent = index / 2 //继续比较  } } //获取堆顶元素函数 func (Maxheap MaxHeap)peek()int{ return Maxheap.maxHeap[1] } //删除堆顶元素函数 func (Maxheap *MaxHeap)delete()int{ // 如果当前「堆」的元素个数为0， 则返回「Don\u0026#39;t have any element」  removeElement := Maxheap.maxHeap[1] if Maxheap.realSize \u0026lt; 1{ fmt.Println(\u0026#34;Don\u0026#39;t have any element!\u0026#34;) return math.MaxInt64 }else { //当前堆中有元素，Maxheap.realSize \u0026gt;= 1  // 将「堆」中的最后一个元素赋值给堆顶元素  Maxheap.maxHeap[1] = Maxheap.maxHeap[Maxheap.realSize] //去除最后一个元素  Maxheap.maxHeap[Maxheap.realSize] = math.MinInt64 Maxheap.realSize-- index := 1 // 不断向下调整堆  // 当删除的元素不是孩子节点时  for index \u0026lt; Maxheap.realSize \u0026amp;\u0026amp; index \u0026lt;= Maxheap.realSize/2 { // 被删除节点的左孩子节点  left := index * 2; // 被删除节点的右孩子节点  right := (index * 2) + 1; // 当删除节点的元素小于 左孩子节点或者右孩子节点，代表该元素的值小，此时需要将该元素与左、右孩子节点中最大的值进行交换  if Maxheap.maxHeap[index] \u0026lt; Maxheap.maxHeap[left] || Maxheap.maxHeap[index] \u0026lt; Maxheap.maxHeap[right] { if Maxheap.maxHeap[left] \u0026gt; Maxheap.maxHeap[right] { temp := Maxheap.maxHeap[left] Maxheap.maxHeap[left] = Maxheap.maxHeap[index] Maxheap.maxHeap[index] = temp index = left } else { // maxHeap[left] \u0026lt;= maxHeap[right]  temp := Maxheap.maxHeap[right] Maxheap.maxHeap[right] = Maxheap.maxHeap[index] Maxheap.maxHeap[index] = temp index = right } } else { break } } } return removeElement } // 返回「堆」的元素个数 func (Maxheap MaxHeap)size()int{ return Maxheap.realSize } //大顶堆初始化函数 func MaxHeapInit(size int)MaxHeap{ return MaxHeap{ maxHeap: make([]int, size+1), heapSize: size, realSize: 0, } } func main(){ //指明需要构建堆的大小  size := 5 var MaxHeap MaxHeap = MaxHeapInit(size) //此堆的下标从1开始，有些是从0开始  for i:=0;i\u0026lt;MaxHeap.heapSize+1;i++{ //大顶堆，先把所有元素初始化为最小值  MaxHeap.maxHeap[i] = math.MinInt64 } //当前堆中元素个数为0  MaxHeap.realSize = 0 //添加1  MaxHeap.insert(1) fmt.Println(MaxHeap.maxHeap) fmt.Println(MaxHeap.realSize) //添加2  MaxHeap.insert(2) //添加3  MaxHeap.insert(3) fmt.Println(MaxHeap.maxHeap) //添加5  MaxHeap.insert(5) //删除堆顶  fmt.Println(MaxHeap.delete()) fmt.Println(MaxHeap.maxHeap) //取堆顶  fmt.Println(MaxHeap.peek()) //取堆元素个数  fmt.Println(MaxHeap.size()) }     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) //构建小顶堆 type MinHeap struct { // 使用数组创建完全二叉树的结构，然后使用二叉树构建一个「堆」  minHeap []int // heapSize用于数组的大小，因为数组在创建的时候至少需要指明数组的元素个数  heapSize int // realSize用于记录「堆」的元素个数  realSize int } //添加元素函数 func (Minheap *MinHeap)insert(element int){ //如果当前元素个数已经和堆想等，那就输出错误信息  if Minheap.realSize+1 \u0026gt; Minheap.heapSize{ fmt.Println(\u0026#34;Add too many elements!\u0026#34;) return } Minheap.realSize++ //新增加元素的下标  index := Minheap.realSize //父节点下标  parent := index / 2 Minheap.minHeap[index] = element //如果大于父节点就不断向上交换  for Minheap.minHeap[index] \u0026lt; Minheap.minHeap[parent] \u0026amp;\u0026amp; index \u0026gt; 1{ //因为下标1没有父节点，所有index不能等于或者小于1  //进行交换  Minheap.minHeap[index],Minheap.minHeap[parent] = Minheap.minHeap[parent],Minheap.minHeap[index] index = parent parent = index / 2 //继续比较  } } //获取堆顶元素函数 func (Minheap MinHeap)peek()int{ return Minheap.minHeap[1] } //删除堆顶元素函数 func (Minheap *MinHeap)delete()int{ // 如果当前「堆」的元素个数为0， 则返回「Don\u0026#39;t have any element」  removeElement := Minheap.minHeap[1] if Minheap.realSize \u0026lt; 1{ fmt.Println(\u0026#34;Don\u0026#39;t have any element!\u0026#34;) return math.MaxInt64 }else { //当前堆中有元素，Minheap.realSize \u0026gt;= 1  // 将「堆」中的最后一个元素赋值给堆顶元素  Minheap.minHeap[1] = Minheap.minHeap[Minheap.realSize] //去除最后一个元素  Minheap.minHeap[Minheap.realSize] = math.MinInt64 Minheap.realSize-- index := 1 // 不断向下调整堆  // 当删除的元素不是孩子节点时  for index \u0026lt; Minheap.realSize \u0026amp;\u0026amp; index \u0026lt;= Minheap.realSize/2 { // 被删除节点的左孩子节点  left := index * 2; // 被删除节点的右孩子节点  right := (index * 2) + 1; // 当删除节点的元素小于 左孩子节点或者右孩子节点，代表该元素的值小，此时需要将该元素与左、右孩子节点中最大的值进行交换  if Minheap.minHeap[index] \u0026gt; Minheap.minHeap[left] || Minheap.minHeap[index] \u0026gt; Minheap.minHeap[right] { if Minheap.minHeap[left] \u0026lt; Minheap.minHeap[right] { temp := Minheap.minHeap[left] Minheap.minHeap[left] = Minheap.minHeap[index] Minheap.minHeap[index] = temp index = left } else { // MinHeap[left] \u0026gt;= MinHeap[right]  temp := Minheap.minHeap[right] Minheap.minHeap[right] = Minheap.minHeap[index] Minheap.minHeap[index] = temp index = right } } else { break } } } return removeElement } // 返回「堆」的元素个数 func (Minheap MinHeap)size()int{ return Minheap.realSize } //小顶堆初始化函数 func MinHeapInit(size int)MinHeap{ return MinHeap{ minHeap: make([]int, size+1), heapSize: size, realSize: 0, } } func main(){ //指明需要构建堆的大小  size := 5 var MinHeap MinHeap = MinHeapInit(size) //此堆的下标从1开始，有些是从0开始  for i:=0;i\u0026lt;MinHeap.heapSize+1;i++{ //大顶堆，先把所有元素初始化为最小值  MinHeap.minHeap[i] = math.MinInt64 } //当前堆中元素个数为0  MinHeap.realSize = 0 //添加1  MinHeap.insert(1) fmt.Println(MinHeap.minHeap) fmt.Println(MinHeap.realSize) //添加2  MinHeap.insert(2) //添加3  MinHeap.insert(3) fmt.Println(MinHeap.minHeap) //添加5  MinHeap.insert(5) //删除堆顶  fmt.Println(MinHeap.delete()) fmt.Println(MinHeap.minHeap) //取堆顶  fmt.Println(MinHeap.peek()) //取堆元素个数  fmt.Println(MinHeap.size()) }     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;// 宏定义最小值 #define intMIN 0x80000000;  typedef struct { //堆的数组  int *maxHeap; //堆的元素个数  int realSize; //堆的大小  int MaxSize; } MaxHeap; void insert(MaxHeap *mh, int element) { //如果当前元素个数已经满了，那就输出错误信息  if (mh-\u0026gt;realSize + 1 \u0026gt; mh-\u0026gt;MaxSize) { printf(\u0026#34;Add too many elements!\u0026#34;); return; } mh-\u0026gt;realSize++; //插入元素到堆的末尾  mh-\u0026gt;maxHeap[mh-\u0026gt;realSize] = element; //调整堆  int index = mh-\u0026gt;realSize; //父节点的下标  int parent = index / 2; while (mh-\u0026gt;maxHeap[index] \u0026gt; mh-\u0026gt;maxHeap[parent] \u0026amp;\u0026amp; index \u0026gt; 1) //堆下标从1开始，1没有父节点  { //交换元素  int temp = mh-\u0026gt;maxHeap[index]; mh-\u0026gt;maxHeap[index] = mh-\u0026gt;maxHeap[parent]; mh-\u0026gt;maxHeap[parent] = temp; //为了不断向上调整  index = parent; parent = index / 2; } } //堆元素删除函数 int delete (MaxHeap *mh) { // 如果当前「堆」的元素个数为0， 则返回「Don\u0026#39;t have any element」  if (mh-\u0026gt;realSize \u0026lt; 1) { printf(\u0026#34;Don\u0026#39;t have any element!\u0026#34;); return intMIN; } //保留删除的元素，以便返回  int removeElement = mh-\u0026gt;maxHeap[1]; //删除堆顶元素，把最后一个元素移至堆顶  mh-\u0026gt;maxHeap[1] = mh-\u0026gt;maxHeap[mh-\u0026gt;realSize]; //把最后一个元素置为最小(已经宏定义IntMin为4字节int类型最小值)  mh-\u0026gt;maxHeap[mh-\u0026gt;realSize] = intMIN; //元素长度大小减1  mh-\u0026gt;realSize--; //向下调整  int index = 1; while (index \u0026lt; mh-\u0026gt;realSize \u0026amp;\u0026amp; index \u0026lt;= mh-\u0026gt;realSize / 2) { //左节点  int left = index * 2; //右节点  int right = index * 2 + 1; if (mh-\u0026gt;maxHeap[index] \u0026lt; mh-\u0026gt;maxHeap[left] || mh-\u0026gt;maxHeap[index] \u0026lt; mh-\u0026gt;maxHeap[right]) { if (mh-\u0026gt;maxHeap[left] \u0026gt; mh-\u0026gt;maxHeap[right]) { int temp = mh-\u0026gt;maxHeap[index]; mh-\u0026gt;maxHeap[index] = mh-\u0026gt;maxHeap[left]; mh-\u0026gt;maxHeap[left] = temp; index = left; } else { int temp = mh-\u0026gt;maxHeap[index]; mh-\u0026gt;maxHeap[index] = mh-\u0026gt;maxHeap[right]; mh-\u0026gt;maxHeap[right] = temp; index = right; } } else { break; } } return removeElement; } //初始化堆函数 void initMaxHeap(MaxHeap *mh, int size) { mh-\u0026gt;MaxSize = size; mh-\u0026gt;maxHeap = (int *)malloc((mh-\u0026gt;MaxSize + 1) * sizeof(int)); //从1开始存储  mh-\u0026gt;realSize = 0; } //获取堆的大小函数 int size(MaxHeap *mh) { return mh-\u0026gt;MaxSize; } //遍历堆函数 void traversal(MaxHeap mh) { for (int i = 1; i \u0026lt;= mh.realSize; i++) { printf(\u0026#34;%d\\n\u0026#34;, mh.maxHeap[i]); } } //获取堆顶元素函数 int peek(MaxHeap mh) { return mh.maxHeap[1]; } int main() { MaxHeap mh; initMaxHeap(\u0026amp;mh, 5); insert(\u0026amp;mh, 3); insert(\u0026amp;mh, 1); insert(\u0026amp;mh, 5); insert(\u0026amp;mh, 8); traversal(mh); printf(\u0026#34;\\n删除堆顶的元素为%d\\n\\n\u0026#34;, delete (\u0026amp;mh)); traversal(mh); system(\u0026#34;pause\u0026#34;); }     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;// 宏定义最大值 #define intMax 0x1fffffff;  //构建小顶堆 typedef struct { //堆的数组  int *minHeap; //堆的元素个数  int realSize; //堆的大小  int MinSize; } MinHeap; void insert(MinHeap *mh, int element) { //如果当前元素个数已经满了，那就输出错误信息  if (mh-\u0026gt;realSize + 1 \u0026gt; mh-\u0026gt;MinSize) { printf(\u0026#34;Add too many elements!\u0026#34;); return; } mh-\u0026gt;realSize++; //插入元素到堆的末尾  mh-\u0026gt;minHeap[mh-\u0026gt;realSize] = element; //调整堆  int index = mh-\u0026gt;realSize; //父节点的下标  int parent = index / 2; while (mh-\u0026gt;minHeap[index] \u0026lt; mh-\u0026gt;minHeap[parent] \u0026amp;\u0026amp; index \u0026gt; 1) //堆下标从1开始，1没有父节点  { //交换元素  int temp = mh-\u0026gt;minHeap[index]; mh-\u0026gt;minHeap[index] = mh-\u0026gt;minHeap[parent]; mh-\u0026gt;minHeap[parent] = temp; //为了不断向上调整  index = parent; parent = index / 2; } } //堆元素删除函数 int delete (MinHeap *mh) { // 如果当前「堆」的元素个数为0， 则返回「Don\u0026#39;t have any element」  if (mh-\u0026gt;realSize \u0026lt; 1) { printf(\u0026#34;Don\u0026#39;t have any element!\u0026#34;); return intMax; } //保留删除的元素，以便返回  int removeElement = mh-\u0026gt;minHeap[1]; //删除堆顶元素，把最后一个元素移至堆顶  mh-\u0026gt;minHeap[1] = mh-\u0026gt;minHeap[mh-\u0026gt;realSize]; //把最后一个元素置为最小(已经宏定义IntMin为4字节int类型最小值)  mh-\u0026gt;minHeap[mh-\u0026gt;realSize] = intMax; //元素长度大小减1  mh-\u0026gt;realSize--; //向下调整  int index = 1; while (index \u0026lt; mh-\u0026gt;realSize \u0026amp;\u0026amp; index \u0026lt;= mh-\u0026gt;realSize / 2) { //左节点  int left = index * 2; //右节点  int right = index * 2 + 1; if (mh-\u0026gt;minHeap[index] \u0026gt; mh-\u0026gt;minHeap[left] || mh-\u0026gt;minHeap[index] \u0026gt; mh-\u0026gt;minHeap[right]) { if (mh-\u0026gt;minHeap[left] \u0026lt; mh-\u0026gt;minHeap[right]) { int temp = mh-\u0026gt;minHeap[index]; mh-\u0026gt;minHeap[index] = mh-\u0026gt;minHeap[left]; mh-\u0026gt;minHeap[left] = temp; index = left; } else { int temp = mh-\u0026gt;minHeap[index]; mh-\u0026gt;minHeap[index] = mh-\u0026gt;minHeap[right]; mh-\u0026gt;minHeap[right] = temp; index = right; } } else { break; } } return removeElement; } //初始化堆函数 void initMinHeap(MinHeap *mh, int size) { mh-\u0026gt;MinSize = size; mh-\u0026gt;minHeap = (int *)malloc((mh-\u0026gt;MinSize + 1) * sizeof(int)); //从1开始存储  mh-\u0026gt;realSize = 0; } //获取堆的大小函数 int size(MinHeap *mh) { return mh-\u0026gt;MinSize; } //遍历堆函数 void traversal(MinHeap mh) { for (int i = 1; i \u0026lt;= mh.realSize; i++) { printf(\u0026#34;%d\\n\u0026#34;, mh.minHeap[i]); } } //获取堆顶元素函数 int peek(MinHeap mh) { return mh.minHeap[1]; } int main() { MinHeap mh; initMinHeap(\u0026amp;mh, 5); insert(\u0026amp;mh, 3); insert(\u0026amp;mh, 1); insert(\u0026amp;mh, 5); insert(\u0026amp;mh, 8); traversal(mh); printf(\u0026#34;\\n删除堆顶的元素为%d\\n\\n\u0026#34;, delete (\u0026amp;mh)); traversal(mh); system(\u0026#34;pause\u0026#34;); }       'use strict'; var containerId = JSON.parse(\"\\\"4b306c38a7c25e6a\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"战略上藐视技术，战术上重视技术——闪客","id":251,"section":"data_structure_and_sort","tags":["数据结构"],"title":"堆","uri":"https://www.zhugeqing.top/data_structure_and_sort/datastructure/heap/"},{"content":"此文章借鉴于微信公众号“小林coding”\n　Go语言之父Rob Pike大神曾吐槽：不能掌握正则表达式或浮点数就不配当码农！\nYou should not be permitted to write production code if you do not have an journeyman license in regular expressions or floating point math. 来看看一个有趣的问题，在编程语言中，0.1 + 0.2 == 0.3？，你认为是true还是false。\n来直接看看下面代码吧（下面只展示c和golang）\nc golang  1 2 3 4 5 6 7 8  #include \u0026lt;stdio.h\u0026gt; int main() { int bool_num = (0.1 + 0.2 == 0.3); printf(\u0026#34;%d\u0026#34;, bool_num); return 0; }    \r1 2 3 4 5 6 7 8 9 10  package main import( \u0026#34;fmt\u0026#34; ) func main(){ fmt.Printf(0.1+0.2==0.3) }    \r  'use strict'; var containerId = JSON.parse(\"\\\"6f73777d25daab3d\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  结果出其所料，答案是false\n你可能会怀疑自己？我以前的数学老师教错了吗？或者是这计算机太蠢了吧，连这都算不清？\n别急，听我一一道来\n关于这个计算其实是两个问题了：\n1.我们日常或者说是人脑计算0.1+0.2，答案当然是0.3\n2.你把这个计算交给计算机，它得到的是0.30000000000000004（单精度）\n为什么会出现这个结果呢？这就需要一定计算机知识的人才会知道。\n什么是浮点数 我们知道，数学中并没有浮点数的概念，虽然小数看起来像浮点数，但从不这么叫。那为什么计算机中不叫小数而叫浮点数呢？\n因为资源的限制，数学中的小数无法直接在计算机中准确表示。为了更好地表示它，计算机科学家们发明了浮点数，这是对小数的近似表示。维基百科中关于浮点数的概念说明如下：\nThe term floating point refers to the fact that a number's radix point (decimal point, or, more commonly in computers, binary point) can float; that is, it can be placed anywhere relative to the significant digits of the number.（浮点数是指一个数字的小数点(小数点,或者更常见的在电脑、二进制点)可以浮动;也就是说,它可以放置在任何地方相对于数量的有效数字。\r） 具体来说，浮点数是指用符号、尾数、基数和指数这四部分来表示的小数。\n知道了浮点数的概念，但需要确定一套具体的表示、运算标准。其中最有名的就是 IEEE754 标准。William Kahan 正是因为浮点数标准化的工作获得了图灵奖。\n　标准中规定：\nfloat32位单精度浮点数在机器中表示用 1 位表示数字的符号，用 8 位表示指数，用 23 位表示尾数。\ndouble64位双精度浮点数，用 1 位表示符号，用 11 位表示指数，52 位表示尾数。\n今天，我们来一步一步思考下面这些问题，然后最后再来说说为什么计算机里 0.1 + 0.2 != 0.3。\n  为什么负数要用补码表示？\n  十进制小数怎么转成二进制？\n  计算机是怎么存小数的？\n  0.1 + 0.2 == 0.3 吗？\n  别看这些问题都看似简单，但是其实还是有点东西。\n为什么负数要用补码表示？ 十进制转换二进制的方法相信大家都熟能生巧了，如果你说你还不知道，我觉得你还是太谦虚，可能你只是忘记了，即使你真的忘记了，不怕，让我们一起来重新回顾一下\n十进制数转二进制采用的是除 2 取余法，比如数字 8 转二进制的过程如下图：\n \n接着，我们看看「整数类型」的数字在计算机的存储方式，这其实很简单，也很直观，就是将十进制的数字转换成二进制即可。\n我们以 int 类型的数字作为例子，int 类型是 32 位的，其中最高位是作为「符号标志位」，正数的符号位是 0，负数的符号位是 1，剩余的 31 位则表示二进制数据。\n那么，对于 int 类型的数字 1 的二进制数表示如下：\n \n而负数就比较特殊了点，负数在计算机中是以「补码」表示的，所谓的补码就是把正数的二进制全部取反再加 1，比如 -1 的二进制是把数字 1 的二进制取反后再加 1，如下图：\n \n不知道你有没有想过，为什么计算机要用补码的方式来表示负数？在回答这个问题前，我们假设不用补码的方式来表示负数，而只是把最高位的符号标志位变为 1 表示负数，如下图过程：\n \n如果采用这种方式来表示负数的二进制的话，试想一下 -2 + 1 的运算过程，如下图：\n \n按道理，-2 + 1 = -1，但是上面的运算过程中得到结果却是 -3，所可以发现，这种负数的表示方式是不能用常规的加法来计算了，就需要特殊处理，要先判断数字是否为负数，如果是负数就要把加法操作变成减法操作才可以得到正确对结果。\n到这里，我们就可以回答前面提到的「负数为什么要用补码方式来表示」的问题了。\n如果负数不是使用补码的方式表示，则在做基本对加减法运算的时候，还需要多一步操作来判断是否为负数，如果为负数，还得把加法反转成减法，或者把减法反转成加法，这就非常不好了，毕竟加减法运算在计算机里是很常使用的，所以为了性能考虑，应该要尽量简化这个运算过程。\n而用了补码的表示方式，对于负数的加减法操作，实际上是和正数加减法操作一样的。你可以看到下图，用补码表示的负数在运算 -2 + 1 过程的时候，其结果是正确的：\n \n十进制小数与二进制的转换 好了，整数十进制转二进制我们知道了，接下来看看小数是怎么转二进制的，小数部分的转换不同于整数部分，它采用的是乘 2 取整法，将十进制中的小数部分乘以 2 作为二进制的一位，然后继续取小数部分乘以 2 作为下一位，直到不存在小数为止。\n话不多说，我们就以 8.625转二进制作为例子，直接上图：\n \n最后把「整数部分 + 小数部分」结合在一起后，其结果就是 1000.101。\n但是，并不是所有小数都可以用二进制表示，前面提到的 0.625 小数是一个特例，刚好通过乘 2 取整法的方式完整的转换成二进制。\n如果我们用相同的方式，来把 0.1 转换成二进制，过程如下：\n \n可以发现，0.1 的二进制表示是无限循环的。\n由于计算机的资源是有限的，所以是没办法用二进制精确的表示 0.1，只能用「近似值」来表示，就是在有限的精度情况下，最大化接近 0.1 的二进制数，于是就会造成精度缺失的情况。\n对于二进制小数转十进制时，需要注意一点，小数点后面的指数幂是负数。\n比如，二进制 0.1 转成十进制就是 2^(-1)，也就是十进制 0.5，二进制 0.01转成十进制就是 2^-2，也就是十进制 0.25，以此类推。\n举个例子，二进制 1010.101 转十进制的过程，如下图：\n \n计算机是怎么存小数的？ 1000.101 这种二进制小数是「定点数」形式，代表着小数点是定死的，不能移动，如果你移动了它的小数点，这个数就变了， 就不再是它原来的值了。\n然而，计算机并不是这样存储的小数的，计算机存储小数的采用的是浮点数，名字里的「浮点」表示小数点是可以浮动的。\n比如 1000.101 这个二进制数，可以表示成 1.000101 x 2^3，类似于数学上的科学记数法。\n既然提到了科学计数法，我再帮大家复习一下。\n比如有个很大的十进制数 1230000，我们可以也可以表示成 1.23 x 10^6，这种方式就称为科学记数法。\n该方法在小数点左边只有一个数字，而且把这种整数部分没有前导 0 的数字称为规格化，比如 1.0 x 10^(-9) 是规格化的科学记数法，而 0.1 x 10^(-9) 和 10.0 x 10^(-9) 就不是了。\n因此，如果二进制要用到科学记数法，同时要规范化，那么不仅要保证基数为 2，还要保证小数点左侧只有 1 位，而且必须为 1。\n所以通常将 1000.101 这种二进制数，规格化表示成 1.000101 x 2^3，其中，最为关键的是 000101 和 3 这两个东西，它就可以包含了这个二进制小数的所有信息：\n  000101 称为尾数，即小数点后面的数字；\n  3 称为指数，指定了小数点在数据中的位置；\n  现在绝大多数计算机使用的浮点数，一般采用的是 IEEE 制定的国际标准，这种标准形式如下图：\n \n这三个重要部分的意义如下：\n  符号位：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；\n  指数位：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，指数位的长度越长则数值的表达范围就越大；\n  尾数位：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且尾数的长度决定了这个数的精度，因此如果要表示精度更高的小数，则就要提高尾数位的长度；\n  用 32 位来表示的浮点数，则称为单精度浮点数，也就是我们编程语言中的 float 变量，而用 64 位来表示的浮点数，称为双精度浮点数，也就是 double 变量，它们的结构如下：\n \n可以看到：\n  double 的尾数部分是 52 位，float 的尾数部分是 23 位，由于同时都带有一个固定隐含位（这个后面会说），所以 double 有 53 个二进制有效位，float 有 24 个二进制有效位，所以所以它们的精度在十进制中分别是 log10(2^53)约等于 15.95和 log10(2^24)约等于 7.22 位，因此 double 的有效数字是 15~16 位，float 的有效数字是 7~8 位，这些是有效位是包含整数部分和小数部分；\n  double 的指数部分是 11 位，而 float 的指数位是 8 位，意味着 double 相比 float 能表示更大的数值范围；\n  那二进制小数，是如何转换成二进制浮点数的呢？\n我们就以 10.625作为例子，看看这个数字在 float 里是如何存储的。\n \n首先，我们计算出 10.625 的二进制小数为 1010.101。\n然后把小数点，移动到第一个有效数字后面，即将 1010.101 右移 3 位成 1.010101，右移 3 位就代表 +3，左移 3 位就是 -3。\nfloat 中的「指数位」就跟这里移动的位数有关系，把移动的位数再加上「偏移量」，float 的话偏移量是 127，相加后就是指数位的值了，即指数位这 8 位存的是 10000010（十进制 130），因此你可以认为「指数位」相当于指明了小数点在数据中的位置。\n1.010101 这个数的小数点右侧的数字就是 float 里的「尾数位」，由于尾数位是 23 位，则后面要补充 0，所以最终尾数位存储的数字是 01010100000000000000000。\n在算指数的时候，你可能会有疑问为什么要加上偏移量呢？\n前面也提到，指数可能是正数，也可能是负数，即指数是有符号的整数，而有符号整数的计算是比无符号整数麻烦的，所以为了减少不必要的麻烦，在实际存储指数的时候，需要把指数转换成无符号整数。\nfloat 的指数部分是 8 位，IEEE 标准规定单精度浮点的指数取值范围是 -126 ~ +127，于是为了把指数转换成无符号整数，就要加个偏移量，比如 float 的指数偏移量是 127，这样指数就不会出现负数了。\n比如，指数如果是 8，则实际存储的指数是 8 + 127（偏移量）= 135，即把 135 转换为二进制之后再存储，而当我们需要计算实际的十进制数的时候，再把指数减去「偏移量」即可。\n细心的朋友肯定发现，移动后的小数点左侧的有效位（即 1）消失了，它并没有存储到 float 里。\n这是因为 IEEE 标准规定，二进制浮点数的小数点左侧只能有 1 位，并且还只能是 1，既然这一位永远都是 1，那就可以不用存起来了。\n于是就让 23 位尾数只存储小数部分，然后在计算时会自动把这个 1 加上，这样就可以节约 1 位的空间，尾数就能多存一位小数，相应的精度就更高了一点。\n那么，对于我们在从 float 的二进制浮点数转换成十进制时，要考虑到这个隐含的 1，转换公式如下：\n \n举个例子，我们把下图这个 float 的数据转换成十进制，过程如下：\n \n0.1 + 0.2 == 0.3 ? 前面提到过，并不是所有小数都可以用「完整」的二进制来表示的，比如十进制 0.1 在转换成二进制小数的时候，是一串无限循环的二进制数，计算机是无法表达无限循环的二进制数的，毕竟计算机的资源是有限。\n因此，计算机只能用「近似值」来表示该二进制，那么意味着计算机存放的小数可能不是一个真实值。\n现在基本都是用 IEEE 754 规范的「单精度浮点类型」或「双精度浮点类型」来存储小数的，根据精度的不同，近似值也会不同。\n那计算机是存储 0.1 是一个怎么样的二进制浮点数呢？\n偷个懒，我就不自己手动算了，可以使用 baseconvert 这个工具，将十进制 0.1 小数转换成 float 浮点数：\n \n可以看到，8 位指数部分是 01111011，23 位的尾数部分是 10011001100110011001101，可以看到尾数部分是 0011 是一直循环的，只不过尾数是有长度限制的，所以只会显示一部分，所以是一个近似值，精度十分有限。\n接下来，我们看看 0.2 的 float 浮点数：\n \n可以看到，8 位指数部分是 01111100，稍微和 0.1 的指数不同，23 位的尾数部分是 10011001100110011001101和 0.1 的尾数部分是相同的，也是一个近似值。\n0.1的二进制浮点数转换成十进制的结果是 0.100000001490116119384765625：\n \n0.2 的二进制浮点数转换成十进制的结果是 0.20000000298023223876953125：\n \n这两个结果相加就是 0.300000004470348358154296875：\n \n所以，你会看到在计算机中 0.1 + 0.2 并不等于完整的 0.3。\n这主要是因为有的小数无法可以用「完整」的二进制来表示，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。\n总结 为什么负数要用补码表示？ 负数之所以用补码的方式来表示，主要是为了统一和正数的加减法操作一样，毕竟数字的加减法是很常用的一个操作，就不要搞特殊化，尽量以统一的方式来运算。\n十进制小数怎么转成二进制？ 十进制整数转二进制使用的是「除 2 取余法」，十进制小数使用的是「乘 2 取整法」。\n计算机是怎么存小数的？ 计算机是以浮点数的形式存储小数的，大多数计算机都是 IEEE 754 标准定义的浮点数格式，包含三个部分：\n  符号位：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；\n  指数位：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，指数位的长度越长则数值的表达范围就越大；\n  尾数位：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且尾数的长度决定了这个数的精度，因此如果要表示精度更高的小数，则就要提高尾数位的长度；\n  用 32 位来表示的浮点数，则称为单精度浮点数，也就是我们编程语言中的 float 变量，而用 64 位来表示的浮点数，称为双精度浮点数，也就是 double 变量。\n0.1 + 0.2 == 0.3 吗？ 不是的，0.1 和 0.2 这两个数字用二进制表达会是一个一直循环的二进制数，比如 0.1 的二进制表示为 0.0 0011 0011 0011… （0011 无限循环)，对于计算机而言，0.1 无法精确表达，这是浮点数计算造成精度损失的根源。\n因此，IEEE 754 标准定义的浮点数只能根据精度舍入，然后用「近似值」来表示该二进制，那么意味着计算机存放的小数可能不是一个真实值。\n0.1 + 0.2 并不等于完整的 0.3，这主要是因为这两个小数无法用「完整」的二进制来表示，只能根据精度舍入，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。\n学到的伙计顺便教一下身边的朋友吧（没学到的再看一遍）\n","description":"一篇文章带你了解浮点数","id":252,"section":"article","tags":["计算机"],"title":"你真的了解浮点数吗？","uri":"https://www.zhugeqing.top/article/computer/float/"},{"content":"1\r此文章取自于微信公众号“低并发编程”\n正文开始：\n小宇：闪客，我最近在研究动态规划，但感觉就是想不明白，你能不能给我讲讲呀？ \n闪客：没问题，这个我擅长，你先说说提到动态规划，你最先想到的是什么？\n小宇：就什么子问题呀、状态转移方程呀乱七八糟的，哎呀不行不行，我一想到这些脑子又嗡嗡响了。\n闪客：你先别急，你先把所有的名词都抛在脑后，听我讲。\n小宇：好滴，你说吧。\n闪客：小宇我问你，从 1 一直加到 100 等于多少？\n1 + 2 + 3 + ... + 100 = ？\r小宇：5050！\n闪客：你这，怎么不按套路出牌呀，你应该说不知道。\n小宇：人家高斯早就算出来了，我还装不知道，这也太假了吧。\n全剧终...\r2\r闪客：好吧，那我再给你出一个题。\n小宇：行，你说吧，这回我肯定说不知道。\n闪客：一个楼梯有 10 级台阶，你从下往上走，每跨一步只能向上迈 1 级或者 2 级台阶，请问一共有多少种走法？\n小宇：额，这我真不知道了，我想想哈。\n \n小宇：不行了不行了，实在想不明白，想了后面的就忘了前面的。\n闪客：你还是陷入了穷举的思想，你仔细想想我给你出的第一个题，看看有没有思路。\n小宇：啊！原来是有关联的呀。\n闪客：对呀，我本来想说假如我告诉你 1+\u0026hellip;+99 是多少，你是不是就直接能算出 1+\u0026hellip;+100 的值了。\n小宇：哦你这么一提示我有点感觉了！要想走到第 10 级台阶，要么是先走到第 9 级，然后再迈一步 1 级台阶上去，要么是先走到第 8 级，然后一次迈 2 级台阶上去。\n 闪客：太棒了！你找到感觉了！接着往下说。\n小宇：这样的话，走到 10 级台阶的走法数，就等于走到 9 级台阶的走法数，加上走到 8 级台阶的走法数。\n闪客：很好，那假如走到第 x 级台阶的走法数我们定义为 F(x)，那你能把刚刚的描述公式化么？\n小宇：那太简单了，公式就是：\nF(10) = F(9) + F(8)\r闪客：没错，而且不光是 10 级台阶如此，走到任何一级台阶的走法数，都符合这个逻辑，因此就可以得出一个通用公式：\nF(x) = F(x-1) + F(x-2)\r小宇：嗯嗯，这样计算 F(10)，只需要知道 F(9) 和 F(8) 就可以了，而计算 F(8)，就只需要知道 F(7) 和 F(6) 就可以了，依次类推。\n闪客：没错，那你想想看 F(2) 和 F(1) 怎么计算？\n小宇：简单，还是刚刚都逻辑被，想知道 F(2)，只需要知道 F(1) 和 F(0)，诶不对 F(0) 是什么鬼？还有 F(1) 的计算需要知道 F(0) 和 F(-1)，不行呀，这解释不通了。\n闪客：哈哈，别急，在这道题里，如果只迈到 1 级台阶，那一共就一种走法；如果只迈到 2 级台阶，就只有两种走法。可以直接很直观地得出，没必要推导。\n 小宇：哦哦我懂了，这道题里由于每一个递推项都需要前两项的支持，所以必须有最开头的两项作为已知，就是你说的 F(1) = 1 和 F(2) = 2。\n闪客：没错。\n小宇：嗯嗯，感觉这样就推出全部结果了！我写一下程序你看看。\n闪客：先别急，由于这道题是一道经典的动态规划题，所以我们以这道题为例子来定义动态规划的三要素，在本题中\nF(x-1) 和 F(x-2) 被称为 F(x) 的最优子结构\nF(x) = F(x-1) + F(x-2) 叫状态转移方程\nF(1) = 1, F(2) = 2 是问题的边界\n之后做动态规划问题，只要找好这三个要素就好了。\n小宇：哇，升华了诶，逼格瞬间高了不少呢。\n闪客：先别说这些废话了，那接下来你看看能不能写出程序，计算出 F(10) 的结果，这才是难点。\n小宇：编程的话这似乎是个递归问题，简单！\n c golang  1 2 3 4 5 6 7 8 9  int getWays(int n) { if (n == 1) { return 1; } if (n == 2) { return 2; } return getWays(n-1) + getWays(n-2); }    \r1 2 3 4 5 6 7 8 9  func getways(n int)int{ if n == 1 { return 1 } if n == 2 { return 2 } return getWays(n-1) + getways(n-2) }    \r  'use strict'; var containerId = JSON.parse(\"\\\"d8fc5767ad4e26de\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \n闪客：嗯不错，这样很简洁，但复杂度太高了，是 O(2^n)，具体你可以之后想想为什么。现在你看看能不能将复杂度降低。\n小宇：我想想看，计算 F(10) 时需要计算 F(9) 和 F(8)，而在递归计算 F(9) 时要计算 F(8) 和 F(7)，这样 F(8) 在这里重复计算了，浪费了时间。\n \n闪客：没错，其实计算新一个阶段的值，只需要一直将其前两个阶段的值保存起来，就可以一直算到最终的结果了。比如定义两个变量 a 和 b 用于存储前两个阶段的值，在计算 F(3) 时。\n\n\r\r台阶\r1\r2\r3\r4\r...\r10\r\r\r走法\ra=1\rb=2\r3\r\r\r\r\r\r\n计算 F(4) 时，F(1) 的值就不用保存了，a 和 b 依次替换新值。\n\r\r台阶\r1\r2\r3\r4\r...\r10\r\r\r走法\r\ra=2\rb=3\r5\r\r\r\r\r\n依此类推，最终就算出了 F(10) 的值。\n\r\r台阶\r1\r2\r...\r8\r9\r10\r\r\r走法\r\r\r\ra=33\rb=55\r89\r\r\r\n当然你也可以把之前的值都保留，但这样就增加了空间复杂度，看你的需求了。\n小宇：好的，那这样代码也很好写，就这样。\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  int getWays2(int n) { if (n == 1) { return 1; } if (n == 2) { return 2; } int a = 1; int b = 2; int temp = 0; for (int i = 3; i \u0026lt;= n; i++) { temp = a + b; a = b; b = temp; } return temp; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func getWays2(int n)int{ if n == 1 { return 1 } if n == 2 { return 2 } var a int = 1 var b int = 2 var temp int = 0 for i := 3; i \u0026lt;= n; i++ { temp = a + b a = b b = temp } return temp }    \r  'use strict'; var containerId = JSON.parse(\"\\\"9c07575b1fd9a686\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  闪客：不错，这就是这道题正确的动态规划解法，而且时间复杂度是 O(N)，空间复杂度是 O(1)\n小宇：哇，这就是动态规划呀，原来这么简单。\n3\r闪客：不错，动态规划理解起来不难，难在当需要考虑的因素，也就是变化的维度多起来的时候，有的人就会头脑发蒙，不好找递推公式了，而且这也确实是个难点。\n小宇：哦是吗？\n闪客：那当然，我再给你出一道题。\n小宇：来吧兄弟。\n闪客：咳咳，那你听好了。\n有一个背包，可以装载重量为 5kg 的物品。\r有 4 个物品，他们的重量和价值如下。\r\n \n那么请问，在不得超过背包的承重的情况下，将哪些物品放入背包，可以使得总价值最大？\r小宇：明白了，就是我用这个背包最多能装走多少钱的东西。\n闪客：是的。\n小宇：哎呀不行，我又陷入走楼梯时的遍历思想了。\n闪客：没关系，这道题能想出遍历思想，其实也不容易了，你可以先说一下，找找感觉。\n小宇：嗯嗯，那就是每个物品都可以有放入背包和不放入背包两种选择。\n如果总重量超过了背包承重，那就不算，或者说将价值记为 0，然后将所有情况中价值最大的那个作为结果。\n这样的复杂度也很容易得出，就是 O(2^N)\n闪客：没错，这个复杂度很高的算法你已经说的很明白了，那接下来你想想看用动态规划思想，能不能解决这个问题。\n小宇：好的，你之前说过，动态规划的三要素是最优子结构、状态转移方程和边界\n闪客：没错，之前的变量很少所以比较简单，现在变量多了，定义就变得难了起来，我们先来几个定义方便描述。我们将 4 个物品的重量和价值分别表示为：w1，w2，w3，w4，v1，v2，v3，v4。\n \n假如我们用\nF(W,i) \r表示\n用载重为 W 的背包，装前 i 件物品的最大价值\r那本题其实就是\nF(5,4) 其实就是求解 你能找到状态转移方程么？\n小宇：我想想，单看这个物品 4，有两种可能：\n第一种可能：如果选择把它装入背包，那已经得到了 6 元钱。\n此时背包剩余载重为 1kg（5kg-4kg），剩余物品是除去物品 4 后的前 3 件物品。\n那这部分能获取到的最大价值，相当于\n用一个载重为 1kg 的背包，装前 3 件物品的最大价值 \n哇，那这部分就是\nF(1,3) 闪客：哈哈，你这自己说着说着就说对啦！\n小宇：所以最终，如果选择将物品 4 放入背包，这种情况下，最大价值就等于二者之和。\nF(1, 3) + 6\r\n \n闪客：太好了小宇，那另一种情况呢？\n小宇：第二种可能：如果选择不装这个物品 4，那更简单了，就直接等于用一个载重为 5 的背包装前 3 件物品的价值。\nF(5, 3)\r\n \n闪客：没错，而且就只有这两种情况！所以你看看 F(5,4)是否能用这两种情况的值表示呢？\n小宇：哈哈，很简单，就等于这两种情况当中的最大值呗。\nF(5,4) = max { F(1, 3) + 6，F(5, 3) }\r闪客：太好了，现在状态转移方程出来了，此时我们画个表格。\n 我们的目标就是要计算右下角那个值，即背包载重 W = 5 时，选择前 4 件物品放入背包的最大价值 F(5,4)\n小宇：哇这个表格好清晰呀，根据上面的公式\nF(5,4) = max { F(1,3) + 6, F(5,3) }\r\n那也就是说只要知道 F(1,3) 和 F(5,3) 的值就可以了对吧？\n 闪客：没错，那你再看看 F(1,3) 怎么计算？\n小宇：好的，F(1,3) 此时背包重量为 1，如果选择放第三件物品的话，诶？好像不行，第三件物品根本放不下呀！\n闪客：是的，所以这种情况就没必要讨论放第三件物品的情况了，因为根本放不下，因此 F(1,3) 直接就等于 F(1,2)，所以只需要知道 F(1,2) 即可。\n \n同理 F(1,2) 也直接等于 F(1,1)，因为在背包重量为 1 时第二件物品也放不下。\n闪客：小宇你想想看，那 F(1,1) 又等于什么呢？\n小宇：显然嘛，现在只有一件物品可以选了，那能放下当然就放咯，所以最大价值就是第一件物品的价值 3，即 F(1,1) = 3\n闪客：没错，这样我们就找到了一个边界值，小宇你想想看还有哪些边界值可以直接得出？你写在表格里吧。\n小宇：好的，首先第一列表示背包重量为 0 时的情况，那显然什么都装不了，就全都是 0 了。\n \n然后第一行也比较好算，背包重量 \u0026gt;= 1 时可以放下第一件物品，所以最大价值都等于 3\n \n闪客：很好，接下来，就依次把表格的所有项都填出来，自然就可以算出 F(5,4) 啦。\n \n小宇：哇塞，这样看好清晰呀！\n闪客：是呀，不过刚刚我们用的都是具体的数字，那我们试着把这个问题抽象化，用一个载重为 W 的背包，装载 N 件物品，每件物品的重量和价值分别用 wi 和 vi 来表示，那刚刚的状态转移方程是什么呢？\n小宇：emm，刚刚 F(5,4) = max { F(1,3) + 6, F(5,3) }，如果都用变量表示的话，就是\n\nF(W,N) = max { F(W-wn, N-1) + vn，F(W, N-1) }\r闪客：很好，这就是状态转移方程。\nF(W-wn, N-1) 和 F(W, N-1) 就是 F(W,N) 的最优子结构。\n而刚刚表格中的第一行和第一列，即 F(0,\u0026hellip;) 和 F(\u0026hellip;,1) 就是边界值！\n小宇：哇塞我爱你闪客！终于有点理解动态规划的思想了呢！\n4\r闪客：别高兴太早，虽然过程看着清晰了，但代码写起来还是有难度的，你今天回去就把代码试着实现一下吧。\n小宇：好的，保证完成任务。\n闪客：快到晚饭时间了，旁边新开了家饺子馆，要不要一块去吃呀？\n小宇：哦不了，晚上想利用晚饭时间再去消化消化动态规划的知识，不是还得代码实现呢么，下次吧，\n闪客：哦好吧~\n后记\r本文通过直观演示 01 背包问题的解题思路，简单说明了动态规划思想的算法核心。可能不少人觉得动态规划难在理解，所以花很多时间在理解其思想上。但其实理解核心思想，这一篇文章就够了，更多的是通过不断做题，反过来帮助自己理解动态规划的思想。所以希望读者在读完本文后，和小宇一样，动手将其代码实现，并找来其他变种题目，继续巩固。\n","description":"了解什么是动态规划","id":253,"section":"article","tags":["算法"],"title":"图解 | 你管这破玩意叫动态规划","uri":"https://www.zhugeqing.top/article/algorithm/dynamic-programming/"},{"content":"从字面上理解微服务  微服务（micro service）,解读微（micro）和服务（service） 微（micro）可以通过亚马逊CEO JeffBezos提出的“The two pizza principle”（两个比萨）的例子来解读。两个比萨就是指单个服务从设计到开发、测试、运维加起来的参与人数不能多到两个比萨还不够吃，也就是说要控制单个服务的规模和成本 服务（service）是可以直接使用的一个或一组功能，用户不需要关心具体的实现，只需关心输入和输出  严谨定义微服务  微服务是一种细粒度的分布式解决方案，这些细粒度的服务独立性强并且会协同工  微服务的优缺点  微服务架构是一种具体的设计实现或者设计方案，而微服务是通过这种实现或方案最终完成的服务\n   优点\n 开发效率高：将一个单体应用拆分成多个微服务，可以使得每个微服务功能单一，便于理解与高效开发 新增需求响应快：因为将服务进行充分拆分，每个新的服务开发都非常高效，响应新的需求也很快，适合于敏捷开发    缺点\n 部署难度提升：微服务是天然分布式的，也是因为必须采用分布式，所以部署和调度管理的难度就增加了 运维难度提升：微服务的服务接口数量接口比较多，如果整个服务出现问题，要找到出了问题的微服务将会有难度 接口修改成本高：众多微服务彼此调用，当一个微服务的接口进行修改调整时，依赖该接口的其他的接口也需要进行检查或者修改，所以接口修改成本将有所提升 部分代码重复：每一个微服务的测试，部署，开发都是独立的，运行环境也是独立的，所以有一些重复性的功能需要重复开发    ","description":"简单理解微服务","id":254,"section":"tips","tags":["tips"],"title":"微服务","uri":"https://www.zhugeqing.top/tips/microservice/"},{"content":"在面对面试中的算法问题时，有一个合理的思考路径  面对算法问题，不畏惧 不代表能够“正确”回答每一个算法问题，但合理的思考方向其实更重要 算法面试优秀不意味着技术面试优秀 技术面试优秀不意味着能够拿到offer 算法面试不是高考，把这个过程看作是和面试官一起探讨一个问题的解决方案，对于问题的细节和应用环境，可以和面试官沟通  比如：我们需要对一组数据进行排序\n看使用的具体环境：\n这组数据有什么样的特征：\n 有没有可能包含有大量重复的元素 如果有这种可能的话，三路快排（请自行百度）是更好的选择\n  这组数据有什么样的特征：\n 是否大部分数据离它正确的位置很近？是否近乎有序？ 如果是这样的话，插入排序（请自行百度）是更好的选择\n  这组数据有什么样的特征：\n 是否数据的取值范围非常有限？比如对学生成绩排序。 如果是这样的话，计数排序（请自行百度）是更好的选择\n  对排序有什么额外的要求？\n 是否需要稳定的排序 如果是的话，归并排序（请自行百度）是更好的选择\n  数据的存储状况是怎样的？\n 是否是使用链表存储的？ 如果是的话，归并排序（请自行百度）是更好的选择\n  数据的存储状况是怎样的？\n 数据的大小是否可以装载在内存里 数据量很大，或者内存很小，不足以装载在内存里，需要使用外排序算法\n  排序算法思考总结\n 有没有可能包含有大量重复的元素 是否大部分数据离它正确的位置很近？是否近乎有序？ 是否数据的取值范围非常有限？比如对学生成绩排序。 是否需要稳定的排序 是否是使用链表存储的？ 数据的大小是否可以装载在内存里  \n“正确”的回答一个算法问题    “正确”包含对问题的独到见解；优化；代码规范；容错性；关键在于你所表达出解决问题的思路。\n  通过表达解题思路的方向，得出结论：这个问题的解决方案，应该在哪一个领域，我可以通过查阅或者进一步学习解决问题。\n  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":255,"section":"interview","tags":["算法"],"title":"第一章第一节","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter1/1/"},{"content":"到底什么是大O n表示数据规模\nO(f(n))表示运行算法所需要执行的指令数，和f(n)成正比\n举例：（其中a,b,c,d都为常数，不随n变化而变化）\n 二分查找法O(logn) 所需执行的指令数：a*logn 寻找数组中的最大/最小值O(n) 所需执行的指令数：b*n 归并排序算法O(nlogn) 所需执行的指令数：c*nlogn 选择排序法O(n^2) 所需执行的指令数：d*n^2  Tips：在学术界，严格地讲，O(f(n))表示算法执行的上界\n比如：归并排序的算法复杂度是O(nlogn)，同时也是O(n^2)\n在业界，我们就使用O来表示算法执行的最低上界\n我们一般不会说归并排序是O(n^2)的\n   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":256,"section":"interview","tags":["算法"],"title":"第二章第一节","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter2/1/"},{"content":"算法优秀不意味着技术面试优秀  算法面试只是技术面试的一部分\n根据你的简历和应聘职位的不同，势必要考察其他技术方面\n比如：\n1.项目经历和项目中遇到的实际问题\n2.你遇到的印象最深的bug是什么\n3.面向对象\n4.设计模式\n5.网络相关；安全相关；内存相关；并发相关；\u0026hellip;\n6.系统设计：scalability（近些年比较重视）  技术面试优秀不意味着能够拿到offer  技术面试只是面试的一部分，面试不仅仅是考察你的技术水平，还是了解你的过去以及形成的思考行为方式\n比如：\n1.参与项目至关重要，对于本科生，毕业设计和其他的课程设计本身就是一个项目经历\n2.如何找到项目：实习，参与实战课程学习（慕课网，等等，我博客的推荐网站\u0026hellip;）\n3.创建自己的项目：自己做小应用：计划表，备忘录，播放器\u0026hellip;；自己解决小问题：爬虫，数据分析，词频统计\u0026hellip;；“不是项目”的项目：一本优秀的技术书籍的代码整理等\u0026hellip;；分享：自己的技术博客,github等等\n4.行为类问题：遇到的最大的挑战？犯过最大的错误？遭遇的失败？最享受的工作内容？遇到冲突的处理方式？做的最与众不同的事？\n  准备好合适的问题问面试官\n比如：\n1.整个小组的大概运行模式是怎样的？\n2.整个项目的后续规划是如何的？\n3.这个产品的某个问题是如何解决的？\n4.为什么会选择某些技术？标准?来实现某个需求\n5.我对某个技术很感兴趣，在你的小组中我会有怎样的机会深入这种技术？\n  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":257,"section":"interview","tags":["算法"],"title":"第一章第二节","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter1/2/"},{"content":"数据规模的概念 如果想要在1s之内解决问题：\nO(n^2)的算法可以处理大约10^4级别的数据；\nO(n)的算法可以处理大约10^8级别的数据；\nO(nlogn)的算法可以处理大约10^7的数据；\n空间复杂度 多开一个辅助的数组：O(n)\n多开一个辅助的二维数组：O(n^2)\n多开常数空间：O(1)\n递归的调用是有空间代价的\n","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":258,"section":"interview","tags":["算法"],"title":"第二章第二节","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter2/2/"},{"content":"算法面试并没有那么难 远远不需要啃完一本《算法导论》   强理论证明\n高级数据结构和算法在面试时提及的概率很低\n红黑树 计算几何 B-Tree 数论 斐波那契堆 FFT\n  远远不需要到达信息学竞赛的水平\n  算法面试的准备范围  不要轻视基础算法和数据结构，而只关注“有意思”的题目   各种排序算法(特点与比较) 基础数据结构和算法的实现：如堆、二叉树、图\u0026hellip; 基础数据结构的使用：如链表、栈、队列、哈希表、图、Trie、并查集\u0026hellip; 基础算法：深度优先、广度优先、二分查找、递归\u0026hellip; 基本的算法思想：递归、分治、回溯搜索、贪心、动态规划\u0026hellip;  选择合适的OJ(online judge在线判题系统)   LeetCode(http://www.leetcode.com)(专门为面试的一个OJ) HackerRank(http://www.hackerrank.com)(对问题的分类很详细)  （Tips:在学习和实践做题之间，要掌握平衡）\n","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":259,"section":"interview","tags":["算法"],"title":"第一章第三节","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter1/3/"},{"content":"解决算法面试问题的整体思路  注意题目中的条件  比如：\n给定一个有序的数组\u0026hellip;（二分查找）\n设计一个O(nlogn)的算法\n无需考虑额外的空间（开辟额外的空间来换取时间）\n数据规模大概是10000\n当没有思路的时候   自己给自己几个简单的测试用例，实验一下 不要忽视暴力解法。暴力解法通常是思考的起点  优化算法   遍历常见的算法思路 遍历常见的数据结构 空间与时间的交换（哈希表） 预处理信息（排序 ）  实际编写问题   极端条件的判断\n数组为空？字符串为空？数量为0？指针为NULL？ 变量名的撰写规范 模块化，复用性  对于基本问题，做到白板编程  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":260,"section":"interview","tags":["算法"],"title":"第一章第四节","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter1/4/"},{"content":"git 配置  git config --global user.name \u0026quot;xing-you-ji\u0026quot; git config --global user.email \u0026quot;2110833194@qq.com\u0026quot;   配置用户名和邮箱，不加\u0026ndash;global参数就相当于只对当前目录仓库有效\n\u0026ndash;system表示对系统登录的所有用户有效\n  git config --global --list    查看git当前用户仓库配置，不加\u0026ndash;global参数就相当于显示当前目录仓库\n同样还可以用\u0026ndash;system\n git 仓库初始化  已经有项目代码，在项目目录执行git init 还未开始创建仓库，执行git init project_name git config --global user.name \u0026quot;xing-you-ji\u0026quot; git config --global user.email \u0026quot;2110833194@qq.com\u0026quot; 新加入文件，使用git add .   将最新修改从工作区加入暂存区\n  git commit -m \u0026quot;init\u0026quot;   将暂存区的内容加入版本历史中（git commit -am \u0026quot;init\u0026quot; 可以将已经进行过追踪（track）的文件直接提交到版本历史）\n  git status   查看工作区与暂存区状态\n  git add .   将当前目录及子孙目录里的变动都加到暂存区\n  git add -A   将当前仓库所有变动加入暂存区\n  git mv a.txt b.txt   将仓库的a.txt文件修改成b.txt（并将修改加入暂存区）\n  git rm a.txt   将仓库的a.txt文件进行删除（并将修改加入暂存区）\n  git log   查看版本提交历史\ngit log master 查看指定分支提交历史\n参数--oneline简洁地查看提交历史\n参数--all查看所有分支的提交历史\n参数--graph带图形的查看\n参数-n2查看最近2次提交历史（数字可修改）\n  git branch   查看分支 git branch a 从当前commit创建一个名叫a的分支\ngit branch -d a 删除分支a\ngit branch -v 查看分支以及对应的commit\n  git checkout   切换分支\ngit checkout master 切换到master分支\ngit checkout -b a 创建分支a并切换到分支a\n  git commit --amend   修改最新一次commit 的message（编辑文件类似vim）\n  git rebase -i 83b81348aa04   83b81348aa04为想要修改commit message的上一个分支\n修改文件的pick为r，保存退出，再进行修改message，保存退出\n  git reset HEAD   从当前提交回退版本\ngit reset HEAD^1；1代表上一次，2表示上上次，以此类推（win的cmd可能需要给HEAD^1加双引号）\n  git cherry-pick 83b81348aa04   将提交83b81348aa04应用到当前提交\n  git rebase master dev   将dev分支合并到maser分支之后，\n  git merge dev   将dev分支和当前分支的提交合并成一个\n  gitk   图形化界面工具（查看有中文乱码，需在gitconfig中加入）\n[gui]\nencoding = utf-8\n git 探秘  .git文件夹用于帮助git工具来管理仓库，进入.git/objects可以查看对应的git类型 git分为commit, tree, blob三种类型，每一个commit对应一个或者多个tree，一个tree可以对应其他tree（可以看作是文件夹）和blob（相当于是一个文件） .git/config文件可以用于配置当前仓库的信息，比如远程仓库，user，email .git/logs下可以查看各分支commit的哈希值， .git/HEAD记录当前指向的分支  git 特殊知识  如果使用git checkout 切换到某一个commit上而不生成分支，这种分离HEAD指针的情况，如果只会再切换到其他分支上，那么将可能丢失在这个commit上后产生的修改（需要自行记住提交的hash值，再切换回来），（HEAD要尽量与分支绑定在一起进行操作） 使用git cat-file -t可以查看git 产生的hash值的类型，使用git cat-file -p可以查看类型具体的内容，  ","description":"关于git 的使用","id":261,"section":"about","tags":null,"title":"git笔记","uri":"https://www.zhugeqing.top/about/git/"},{"content":"题目入口\n难度：简单\n找出数组中重复的数字。\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n示例 1：\n输入：\n[2, 3, 1, 0, 2, 5, 3]\n输出：2 或 3\n解题思路：使用哈希表来记录每一个数组出现的次数，如果有一个索引的值超过1，就是重复元素元素，则返回该索引\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  //时间复杂度o(n)，空间复杂度o(n) int findRepeatNumber(int* nums, int numsSize){ int hash[numsSize];//定义哈希表  memset(hash,0,sizeof(hash));//初始化为零  for(int i=0;i\u0026lt;numsSize;i++) { if(++(hash[nums[i]]) == 2){ return nums[i]; } } return nums[numsSize-1]; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  //时间复杂度o(n),空间复杂度o(n) func findRepeatNumber(nums []int) int { if len(nums) \u0026lt;=1 { return 0 } hash := make([]int,len(nums))//定义哈希表  for i:=0;i\u0026lt;len(nums);i++{ hash[nums[i]]++ if hash[nums[i]] \u0026gt;= 2{ return nums[i] } } return 0 }    \r  'use strict'; var containerId = JSON.parse(\"\\\"d2c25b2a207fe165\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":262,"section":"interview","tags":["算法"],"title":"剑指 Offer 03. 数组中重复的数字","uri":"https://www.zhugeqing.top/interview/algorithm/offer/03/"},{"content":"题目入口\n难度：中等\n在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n示例:\n现有矩阵 matrix 如下：\n[\n[1, 4, 7, 11, 15],\n[2, 5, 8, 12, 19],\n[3, 6, 9, 16, 22],\n[10, 13, 14, 17, 24],\n[18, 21, 23, 26, 30]\n]\n给定 target = 5，返回 true。\n给定 target = 20，返回 false。\n限制：\n0 \u0026lt;= n \u0026lt;= 1000\n0 \u0026lt;= m \u0026lt;= 1000\n解题思路：从左下角开始找，利用递增关系，大于往右边找，小于往上找，超出返回false。\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  bool findNumberIn2DArray(int** matrix, int matrixSize, int* matrixColSize, int target){ //时间复杂度o(m+n)，空间复杂度o(1)  int x = matrixSize-1;//行标  int y = 0;//列标  while(x\u0026gt;=0 \u0026amp;\u0026amp; y\u0026lt;*(matrixColSize+x)){ if(target == matrix[x][y]){ return true ; } if (target \u0026gt; matrix[x][y]){ y++; }else if(target \u0026lt; matrix[x][y]){ x--; } } return false; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  func findNumberIn2DArray(matrix [][]int, target int) bool { //时间复杂度o(m+n)，空间复杂度o(1)  xindex := len(matrix) - 1 yindex := 0 for xindex \u0026gt;= 0 \u0026amp;\u0026amp; yindex \u0026lt;= len(matrix[0])-1 { if target == matrix[xindex][yindex] { return true } if target \u0026gt; matrix[xindex][yindex] { yindex++ }else if target \u0026lt; matrix[xindex][yindex] { xindex-- } } return false }    \r  'use strict'; var containerId = JSON.parse(\"\\\"5782663b05eba8e8\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":263,"section":"interview","tags":["算法"],"title":"剑指 Offer 04. 二维数组中的查找","uri":"https://www.zhugeqing.top/interview/algorithm/offer/04/"},{"content":"题目入口\n难度：简单\n请实现一个函数，把字符串 s 中的每个空格替换成\u0026quot;%20\u0026quot;。\n示例 1：\n输入：s = \u0026ldquo;We are happy.\u0026rdquo; 输出：\u0026ldquo;We%20are%20happy.\u0026rdquo;\n限制：\n0 \u0026lt;= s 的长度 \u0026lt;= 10000\n解题思路：构建一个长度为3*len(s)的返回数组res，遍历字符串s，遇到等于' \u0026lsquo;的字符就进行替换，并赋给res。\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  char* replaceSpace(char* s){ int n = 0; for(int i = 0; s[i] != \u0026#39;\\0\u0026#39;; ++i) { ++n; } // printf(\u0026#34;%d\u0026#34;, n);  char* res; res = (char*)malloc(3 * (n + 3) * sizeof(char)); int k = 0; for(int i = 0; i \u0026lt; n; ++i) { if(s[i] != \u0026#39; \u0026#39;){ res[k++] = s[i]; }else { res[k++] = \u0026#39;%\u0026#39;; res[k++] = \u0026#39;2\u0026#39;; res[k++] = \u0026#39;0\u0026#39;; } } res[k] = \u0026#39;\\0\u0026#39;;//c语言字符串需要在末尾加上\u0026#39;\\0\u0026#39;  return res; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  func replaceSpace(s string) string { //时间复杂度o(n)，空间复杂度o(3*n)  res := make([]rune, 3*len(s)) //乘以三的目的是为了假设s字符串都是空格,就使用3个字符%20替换  i := 0 for _, v := range s { if v == \u0026#39; \u0026#39; { res[i] = \u0026#39;%\u0026#39; res[i+1] = \u0026#39;2\u0026#39; res[i+2] = \u0026#39;0\u0026#39; i += 3 //下标移到后三位  } else { res[i] = v i++ } } return string(res[:i]) }    \r  'use strict'; var containerId = JSON.parse(\"\\\"dcb22d1888da909b\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":264,"section":"interview","tags":["算法"],"title":"剑指 Offer 05. 替换空格","uri":"https://www.zhugeqing.top/interview/algorithm/offer/05/"},{"content":"题目入口\n难度：简单\n输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。\n示例 1：\n输入：head = [1,3,2]\n输出：[2,3,1]\n限制：\n0 \u0026lt;= 链表长度 \u0026lt;= 10000\n解题思路：1.构建数组，存储到数组中，然后倒置数组2.递归法\n第一种方法：\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  int* reversePrint(struct ListNode* head, int* returnSize){ //时间复杂度o(n)，空间复杂度o(n)  //先确定数组长度，再倒序存储  struct ListNode *p; int *res; p=head; int j=0; while(p!=NULL) { p=p-\u0026gt;next; j++; } res=(int *)malloc(sizeof(int)*j); p=head; *returnSize=j; j=j-1; while(j\u0026gt;=0) { res[j]=p-\u0026gt;val; p=p-\u0026gt;next; j--; } return res; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  func reversePrint(head *ListNode) []int { //时间复杂度o(n)，空间复杂度o(n)  //先用数组存起来，然后逆转数组  if head == nil { return make([]int, 0) } res := make([]int, 0) for head != nil { res = append(res, head.Val) head = head.Next } //倒置数组  len_s := len(res) for i := 0; i \u0026lt; len_s/2; i++ { res[i], res[len_s-i-1] = res[len_s-i-1], res[i] } return res }    \r  'use strict'; var containerId = JSON.parse(\"\\\"c44d09f137279e7e\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \n第二种方法\nc golang  1 2 3 4 5 6 7 8 9 10  int* reversePrint(struct ListNode* head, int* returnSize){ //递归，直到最后一个节点的下一个节点为空时，存储值并返回上一个栈  if(head == NULL){ *returnSize = 0; return malloc(sizeof(int) * 10000); } int *ans = reversePrint(head-\u0026gt;next, returnSize); ans[(*returnSize)++] = head-\u0026gt;val; return ans; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14  func reversePrint(head *ListNode) []int { var dfs func(head *ListNode) res := make([]int, 0) dfs = func(head *ListNode) { if head == nil { return } dfs(head.Next) res = append(res, head.Val) } dfs(head) return res }    \r  'use strict'; var containerId = JSON.parse(\"\\\"8c47a3b6b0f1cb88\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \n","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":265,"section":"interview","tags":["算法"],"title":"剑指 Offer 06. 从尾到头打印链表","uri":"https://www.zhugeqing.top/interview/algorithm/offer/06/"},{"content":"题目入口\n难度：中等\n输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n例如，给出\n前序遍历 preorder = [3,9,20,15,7]\n中序遍历 inorder = [9,3,15,20,7]\n返回如下的二叉树：\n 限制：\n0 \u0026lt;= 节点个数 \u0026lt;= 5000\n解题思路：递归：\n对于任意一颗树而言，前序遍历的形式总是[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]\n即根节点总是前序遍历中的第一个节点。\n而中序遍历的形式总是[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]\n只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。\n这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。\n\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  //1.先看前序遍历数组第一个位置得到根节点，再到中序遍历数组得到根节点在中序遍历中的位置 //2.求出左右子树节点数，而左子树节点数对应了[0,left),右子树节点对应[left,left+right) //不断缩小前序 中序遍历数组区间; struct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize){ //递归终止条件  if(preorderSize == 0 || inorderSize == 0) return NULL; //根节点：  struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode)); root-\u0026gt;val = preorder[0]; //在中序遍历数组中寻找index  int left; for(left=0;left\u0026lt;inorderSize;left++) { if(inorder[left]==root-\u0026gt;val)//从中序遍历里面找到与前序遍历子节点值相同的节点  break; } int right = inorderSize-left-1;//右边区间长度  //前序数组左子树首地址为preorder+1，意为在根节点的基础上加一，left为前序数组当前根节点的左子树数组的首地址  //中序数组左子树首地址依然不变，可重看解题思路，下同  root-\u0026gt;left = buildTree(preorder+1,left,inorder,left); root-\u0026gt;right = buildTree(preorder+left+1,right,inorder+left+1,right); return root; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder) == 0 { return nil } root := \u0026amp;TreeNode{preorder[0], nil, nil} i := 0 for ; i \u0026lt; len(inorder); i++ { if inorder[i] == preorder[0] { break } } root.Left = buildTree(preorder[1:i+1], inorder[:i]) root.Right = buildTree(preorder[i+1:], inorder[i+1:]) return root }    \r  'use strict'; var containerId = JSON.parse(\"\\\"2fdd64dc23f9dbdf\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":266,"section":"interview","tags":["算法"],"title":"剑指 Offer 07. 重建二叉树","uri":"https://www.zhugeqing.top/interview/algorithm/offer/07/"},{"content":"题目入口\n难度：中等\n用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )\n示例 1：\n输入：\n[\u0026ldquo;CQueue\u0026rdquo;,\u0026ldquo;appendTail\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;]\n[[],[3],[],[]]\n输出：[null,null,3,-1]\n示例 2：\n输入：\n[\u0026ldquo;CQueue\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;,\u0026ldquo;appendTail\u0026rdquo;,\u0026ldquo;appendTail\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;]\n[[],[],[5],[2],[],[]]\n输出：[null,-1,null,null,5,2]\n提示：\n 1 \u0026lt;= values \u0026lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用  解题思路：栈的性质：先进后出，只能在栈顶进行操作。\n队列的性质：先进先出，之只能在队头进行删除（出队）操作，在队尾进行插入（入队）操作。\n本题是用两个栈来构建一个队列，使得一个队列具有队列尾部插入整数（队尾入队）和在队列头部删除整数（队头出队），考虑到栈的性质，所以构建两个栈，一个入队栈，一个出队栈，入队栈负责队尾入队操作，出队栈负责对头出队操作。\n1.初始化，实例化一个队列，并将两个栈顶赋值为-1。\n2.队尾入队，直接将入队栈栈顶（top_in）加1，并插入数值。\n3.队头出队：首先判断是否两个栈均为空，若为空，则返回-1，然后有两种情况，入队栈为空 or 出队栈为空，若只是入队栈为空，则无需理会，直接删除出队栈的一个栈顶元素，top_out减一;若是出队栈为空，则需要将入队栈的元素移至出队栈，然后再进行出队栈出队，top_out减一。\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  typedef struct { int out_stack[500];//出队栈（进行出队操作-队列头部） int top_out;//出队栈栈顶 int in_stack[500];//入队栈（进行入队操作-队列尾部） int top_in;//入队栈栈顶 } CQueue; CQueue* cQueueCreate() { CQueue* res = (CQueue*)malloc(sizeof(CQueue));//队列实例化  res-\u0026gt;top_out = -1;//初始化出队栈栈顶  res-\u0026gt;top_in = -1;//初始化入队栈栈顶  return res; } void cQueueAppendTail(CQueue* obj, int value) { obj-\u0026gt;top_in++;//入队栈栈顶加1  obj-\u0026gt;in_stack[obj-\u0026gt;top_in] = value;//入队 } int cQueueDeleteHead(CQueue* obj) { if(obj-\u0026gt;top_out == -1 \u0026amp;\u0026amp; obj-\u0026gt;top_in == -1){//如果两个栈都为空，返回-1  return -1; }else if(obj-\u0026gt;top_out == -1){//出队栈为空，把入队栈的数移到出队栈  while(obj-\u0026gt;top_in \u0026gt;=0){ obj-\u0026gt;out_stack[++obj-\u0026gt;top_out] = obj-\u0026gt;in_stack[obj-\u0026gt;top_in--]; } return obj-\u0026gt;out_stack[obj-\u0026gt;top_out--];//出队  }else{//入队栈为空，直接对出队栈进行出队操作  return obj-\u0026gt;out_stack[obj-\u0026gt;top_out--];//出队  } } void cQueueFree(CQueue* obj) { free(obj); } /** * Your CQueue struct will be instantiated and called as such: * CQueue* obj = cQueueCreate(); * cQueueAppendTail(obj, value); * int param_2 = cQueueDeleteHead(obj); * cQueueFree(obj); */    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  //剑指 Offer 09. 用两个栈实现队列 type CQueue struct { IntStack []int //入队栈  OutStack []int //出队栈  } func Constructor() CQueue { return CQueue{} //队列初始化 } func (this *CQueue) AppendTail(value int) { this.IntStack = append(this.IntStack, value) //对入队栈进行入队操作 } func (this *CQueue) DeleteHead() int { if len(this.OutStack) == 0 { //判断出队栈是否有数据，如果没有就把入队栈的数据移到出队上来  if len(this.IntStack) == 0 { return -1 //如果入队栈也没有数，那就返回-1  } //如果有,那就把入队栈的数据全部转移到出队栈（而且是转移所有数据）  for len(this.IntStack) \u0026gt; 0 { value := this.IntStack[len(this.IntStack)-1] //找到出队栈的栈顶  this.IntStack = this.IntStack[:len(this.IntStack)-1] //移除一个栈顶元素  this.OutStack = append(this.OutStack, value) //将元素添加到出队栈里面  } } //如果出队栈当中有数据则出栈  res := this.OutStack[len(this.OutStack)-1] //选中出队栈最后一个元素  this.OutStack = this.OutStack[:len(this.OutStack)-1] //出队栈移除一个栈顶元素  return res }    \r  'use strict'; var containerId = JSON.parse(\"\\\"1ae1ef8d62768e8f\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":267,"section":"interview","tags":["算法"],"title":"剑指 Offer 09. 用两个栈实现队列","uri":"https://www.zhugeqing.top/interview/algorithm/offer/09/"},{"content":"题目入口\n难度：简单\n写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：\nF(0) = 0, F(1) = 1\nF(N) = F(N - 1) + F(N - 2), 其中 N \u0026gt; 1.\n斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n示例 1：\n输入：n = 2\n输出：1\n示例 2：\n输入：n = 5\n输出：5\n提示：\n 0 \u0026lt;= n \u0026lt;= 100  解题思路：1.递归，地球人都知道，就不解答了。2.动态规划（递推，这里可以讲成是迭代，递推：一个主观意志选择的第k个计算值，或者每一个计算值。迭代：不是第k个，也不是第k+1个，而是最终收敛的那一个，），已知斐波拉契数由之前两数相加得出，即f(n) = f(n-1) + f(n-2)，最优子结构：dp[i]表示第斐波拉契数列第i个数的值，动态转移方程：dp[n] = dp[n-1]+dp[n-2]，边界：dp[0]=0,dp[1]=1\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  int fib(int n){ //动态规划  if (n==0 || n==1){ return n; } int dp1 = 0;//为了节省空间，可以理解为dp[n-2]  int dp2 = 1;//dp[n-1]  int res = 0;//dp[n]  for(int i=2;i\u0026lt;=n;i++){ res = (dp1 + dp2) % (1000000007);//dp[n] = dp[n-1]+dp[n-2]  dp1 = dp2;//记录数列下一个数的值  dp2 = res;//同上  } return res; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func fib(n int) int { //动态规划  if n == 0 || n == 1 { return n } dp1 := 0//为了节省空间，可以理解为dp[n-2]  dp2 := 1//dp[n-1]  res := 0//dp[n]  for i := 2; i \u0026lt;= n; i++ { res = (dp1 + dp2) % (1000000007)//dp[n] = dp[n-1]+dp[n-2]  dp1 = dp2 //记录数列下一个数的值  dp2 = res //同上  } return res }    \r  'use strict'; var containerId = JSON.parse(\"\\\"85c724cc09316a76\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":268,"section":"interview","tags":["算法"],"title":"剑指 Offer 10- I. 斐波那契数列","uri":"https://www.zhugeqing.top/interview/algorithm/offer/10-1/"},{"content":"题目入口\n难度：简单\n一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n示例 1：\n输入：n = 2\n输出：2\n示例 2：\n输入：n = 7\n输出：21\n示例 3：\n输入：n = 0\n输出：1\n提示：\n 0 \u0026lt;= n \u0026lt;= 100  解题思路：不了解动态规划的第一想法肯定是穷举，比如到第一级台阶有一种方法（跳一阶），到第二级台阶有两种（跳一阶，或者跳两阶），第三级有三种（(1,1,1),(1,2),(2,1)），第四级有\u0026hellip;，虽然计算机最擅长的就是穷举，但是我们人脑不行（至少，数大了，我不行），所以动态规划请先学习图解 | 你管这破玩意叫动态规划，\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  int numWays(int n){ if(n==0 || n==1){ return 1; } if(n==2){ return 2; } //类似于斐波拉契的动态规划  int dp1 = 1;//dp[n-2]  int dp2 = 2;//dp[n-1]  int res = 2; for(int i=3;i\u0026lt;=n;i++){ res = (dp1 + dp2) % (1000000007);//状态转移方程  dp1 = dp2; dp2 = res; } return res; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  func numWays(n int) int { //动态规划  //1.最优子结构  //f(n)表示n级台阶共有f(n)种跳法  //f(n) = f(n-1) + f(n-2) + 2  //2.边界  //f(1) = 1,f(2) = 2  if n == 1 || n == 2 { return n } dp1 := 1 dp2 := 2 res := 1 for i := 3; i \u0026lt;= n; i++ { res = (dp1 + dp2) % (1e9 + 7) dp1 = dp2 dp2 = res } return res }    \r  'use strict'; var containerId = JSON.parse(\"\\\"398ee2139cffb733\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":269,"section":"interview","tags":["算法"],"title":"剑指 Offer 10- II. 青蛙跳台阶问题","uri":"https://www.zhugeqing.top/interview/algorithm/offer/10-2/"},{"content":"题目入口\n难度：简单\n把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例 1：\n输入：[3,4,5,1,2]\n输出：1\n示例 2：\n输入：[2,2,2,0,1]\n输出：0\n解题思路：二分法，参考力扣官方题解\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  int minArray(int* numbers, int numbersSize){ int low = 0; int high = numbersSize-1; int center = (low+high)/2; if(numbers[low]\u0026lt;numbers[high]){//只要low下标的数小于high下标的数即可返回  return numbers[low]; } while(low \u0026lt; high){ if(numbers[low]\u0026lt;numbers[high]){ return numbers[low]; } center = (low+high)/2; if(numbers[low] == numbers[high]){ low++; continue; } if(numbers[center] \u0026lt;= numbers[high]){//若相等，也是向左缩小区间  high = center; low ++; }else{//向右缩小区间  low = center+1; } } return numbers[low]; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  func minArray(numbers []int) int { //二分法  //旋转之后有三种情况：  //1.最小值在数组中间，  //2.最小值在数组中心的左边，  //3.最小值在数组中心的右边  low,high := 0,len(numbers)-1 if numbers[low] \u0026lt; numbers[high]{ return numbers[low]//旋转之后若第一个数仍然小于最后一个数，则是旋转之后仍然与原数组相同  } for low \u0026lt; high{ if numbers[low] \u0026lt; numbers[high]{ return numbers[low] } if numbers[low] == numbers[high]{ low++ //跳过  continue } private := (low+high)/2 if numbers[private] \u0026gt; numbers[high]{ //说明最小数在中心的右边  low = private+1//加1因为privat已经不可能是最小的了  }else { //说明最小数在中心的左边  high = private } } return numbers[low] }    \r  'use strict'; var containerId = JSON.parse(\"\\\"b7566b8bccecfcac\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":270,"section":"interview","tags":["算法"],"title":"剑指 Offer 11. 旋转数组的最小数字","uri":"https://www.zhugeqing.top/interview/algorithm/offer/11/"},{"content":"题目入口\n难度：中等\n给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n例如，在下面的 3×4 的矩阵中包含单词 \u0026ldquo;ABCCED\u0026rdquo;（单词中的字母已标出）。\n 示例 1：\n输入：board = [[\u0026ldquo;A\u0026rdquo;,\u0026ldquo;B\u0026rdquo;,\u0026ldquo;C\u0026rdquo;,\u0026ldquo;E\u0026rdquo;],[\u0026ldquo;S\u0026rdquo;,\u0026ldquo;F\u0026rdquo;,\u0026ldquo;C\u0026rdquo;,\u0026ldquo;S\u0026rdquo;],[\u0026ldquo;A\u0026rdquo;,\u0026ldquo;D\u0026rdquo;,\u0026ldquo;E\u0026rdquo;,\u0026ldquo;E\u0026rdquo;]], word = \u0026ldquo;ABCCED\u0026rdquo;\n输出：true\n示例 2：\n输入：board = [[\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;],[\u0026ldquo;c\u0026rdquo;,\u0026ldquo;d\u0026rdquo;]], word = \u0026ldquo;abcd\u0026rdquo;\n输出：false\n 提示：\n 1 \u0026lt;= board.length \u0026lt;= 200 1 \u0026lt;= board[i].length \u0026lt;= 200 board 和 word 仅由大小写英文字母组成  \n解题思路：dfs（深度优先搜索），首先逐个遍历矩阵，找到起点（不过所有数都得进入search函数），然后进入search函数，递归true终止条件：当递归遍历word的下标k等于word长度时，则终止递归，递归false终止条件：超出矩阵边界；搜索过程\n\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  bool dfs(char** board, int boardSize,int* boardColSize,char* word,int i,int j,int k) { if(k == strlen(word)){ return true; } //递归终止条件  if(i\u0026lt;0 || j\u0026lt;0 || i== boardSize || j == *boardColSize) { return false;//超出边界，直接返回false  } if(word[k] == board[i][j]){ //匹配成功，往下递归  int temp = board[i][j]; board[i][j] = \u0026#39; \u0026#39;;//记录当前字符，防止向下递归重复遍历  if (dfs(board,boardSize,boardColSize,word,i-1,j,k+1)|| //向上递归 dfs(board,boardSize,boardColSize,word,i+1,j,k+1) || //向下递归 dfs(board,boardSize,boardColSize,word,i,j-1,k+1) || //向左递归 dfs(board,boardSize,boardColSize,word,i,j+1,k+1)) //向右递归  { return true; }else{ board[i][j] = temp;//还原字符  } } return false; } bool exist(char** board, int boardSize, int* boardColSize, char* word) { for(int i=0;i\u0026lt;boardSize;i++){ for(int j=0;j\u0026lt;*boardColSize;j++){ if(dfs(board,boardSize,boardColSize,word,i,j,0)) { return true; } } } return false; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  func exist(board [][]byte, word string) bool { m,n := len(board), len(board[0]) for i := 0; i \u0026lt; m; i++ {//行范围  for j := 0; j \u0026lt; n; j++ {//列范围  //如果在数组中找得到第一个数，就执行下一步，否则返回false  if search(board, i, j, 0,word) { //dsf深度优先搜索，从一个起点开始搜索，若搜索到，则返回true，否则，下一个矩阵单元  return true } } } return false } func search(board [][]byte, i,j,k int, word string) bool { //如果找到最后一个数，则返回true,搜索成功  if k == len(word) { //k表示word当前遍历下标  return true } //i,j的约束条件  if i \u0026lt; 0 || j \u0026lt; 0 || i == len(board) || j == len(board[0]) { return false } //进入DFS深度优先搜索  //先把正在遍历的该值重新赋值，如果在该值的周围都搜索不到目标字符，则再把该值还原  //如果在数组中找到第一个字符，则进入下一个字符的查找  if board[i][j] == word[k] { temp := board[i][j] board[i][j] = \u0026#39; \u0026#39;//防止递归重复搜索  //下面这个if语句，如果成功进入，说明找到该字符，然后进行下一个字符的搜索,直到所有的搜索都成功，  //即k == len(word) - 1 的大小时，会返回true，进入该条件语句，然后返回函数true值。  if search(board, i, j + 1, k + 1, word) || //向下搜索  search(board, i, j - 1, k + 1, word) || //向上搜索  search(board, i + 1, j, k + 1, word) || //向右搜索  search(board, i - 1, j, k + 1, word) { //向左搜索  return true }else { //没有找到目标字符，还原之前重新赋值的board[i][j]  board[i][j] = temp } } return false }    \r  'use strict'; var containerId = JSON.parse(\"\\\"19acff9892e41956\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":271,"section":"interview","tags":["算法"],"title":"剑指 Offer 12. 矩阵中的路径","uri":"https://www.zhugeqing.top/interview/algorithm/offer/12/"},{"content":"题目入口\n难度：中等\n地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、\n上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格\n[35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？\n示例 1：\n输入：m = 2, n = 3, k = 1\n输出：3\n示例 2：\n输入：m = 3, n = 1, k = 0\n输出：1\n提示：\n 1 \u0026lt;= n,m \u0026lt;= 100 0 \u0026lt;= k \u0026lt;= 20  解题思路：\n1.三个函数，第一个movingCount用来调用dfs函数，初始化，第二个dfs函数用来深度优先搜索来递归，第三个getDigGitSum函数用来求i，j的各位数之和\n2.额外空间flag来判断是否遍历过该方格\n3.继续向下向右dfs（深度优先搜索）\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  int digitSum(int i, int j) { int res = 0; while (i \u0026gt; 0 || j \u0026gt; 0) { res += i % 10; res += j % 10; i /= 10; j /= 10; } return res; } int dfsTraversal(int i, int j, int m, int n, int **visited, int k) { /* 特判，返回0表示不能到达。 * 1、超出边界 * 2、位数和不满足小于等于k的条件 * 3、当前节点已经访问过 */ if (i \u0026gt;= m || j \u0026gt;= n || digitSum(i, j) \u0026gt; k || visited[i][j] == 1) { return 0; } /* 标记当前节点已到达 */ visited[i][j] = 1; /* 再次进入下一层递归 * 这里只遍历了右、下，左、上不需要遍历， * 因为是从左上开始的，到右n下结束，所以当前节点都是从左上来的 */ return 1 + dfsTraversal(i, j + 1, m, n, visited, k) + dfsTraversal(i + 1, j, m, n, visited, k); } int movingCount(int m, int n, int k) { /* 路径数组，用于存放遍历结果 */ int **visited = (int **)calloc(m, sizeof(int *)); for (int i = 0; i \u0026lt; m; i++) { *(visited + i) = (int *)calloc(sizeof(int), n); } /* dfs深度搜索 */ return dfsTraversal(0, 0, m, n, visited, k); }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  var flag [][]int //全局变量数组，记录机器人是否曾访问过此方格  func movingCount(m int, n int, k int) int { //也不能进入行坐标和列坐标的数位之和大于k的格子  //递归深度搜索  if k == 0 { //机器人不移动，只访问一个方格  return 1 } var getDigGitSum func(i int, j int) int //用来计算行列坐标的数位之和  getDigGitSum = func(i int, j int) int { //求各位数之和的函数  res := 0 //返回结果  for i \u0026gt; 0 || j \u0026gt; 0 { res += i % 10 //求个位数值  res += j % 10 i /= 10 //整除  j /= 10 } return res } var dfs func(i, j int) int //用深度优先搜索  dfs = func(i, j int) int { //一个flag数组  //递归终止条件  //1.行标超出边界，列标超出边界  //2.行坐标和列坐标的数位之和大于k的格子  //3.方格已经被遍历过  if i \u0026gt;= m || j \u0026gt;= n || getDigGitSum(i, j) \u0026gt; k { return 0 } if flag[i][j] == 1 { //判断该方格是否被遍历过  return 0 } flag[i][j] = 1 //设置遍历位  return 1 + dfs(i+1, j) + dfs(i, j+1) //深度优先搜索（向右递归向下递归）  } flag = make([][]int, m) //初始化flag数组  for i := range flag { flag[i] = make([]int, n)//初始化各一维数组  } return 1 + dfs(1, 0) + dfs(0, 1) //  }    \r  'use strict'; var containerId = JSON.parse(\"\\\"f35c387cb0820143\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":272,"section":"interview","tags":["算法"],"title":"剑指 Offer 13. 机器人的运动范围","uri":"https://www.zhugeqing.top/interview/algorithm/offer/13/"},{"content":"题目入口\n难度：中等\n给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n\u0026gt;1并且m\u0026gt;1），每段绳子的长度记为 k[0],k[1]\u0026hellip;k[m-1] 。请问 k[0]k[1]\u0026hellip;*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。\n示例 1：\n输入: 2\n输出: 1\n解释: 2 = 1 + 1, 1 × 1 = 1\n示例 2:\n输入: 10\n输出: 36\n解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36\n1.解题思路：使用动态规划\n1.最优子结构：dp[i]表示长度为i的绳子被剪成m段的最大乘积；\n2.状态转移方程：dp[i] = max(dp[i],max(j*(i-j)),j*dp[i-j])，比较不进行分割、进行分割一次、进行多次分割，取最大值。其中j为当前分割长度，i为绳子的总长度；\n3.case base:dp[1]=1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  func cuttingRope(n int) int { //动态规划  dp := make([]int,n+1) //最优子结构  dp[1] = 1 //base case  var max func(a,b int)int max = func(a,b int)int{ if a \u0026gt; b{ return a } return b } var max3 func(a,b,c int)int max3 = func(a,b,c int)int{ return max(a,max(b,c)) } for i:=2;i\u0026lt;=n;i++{ for j:=1;j\u0026lt;=i-1;j++{ dp[i] = max3(dp[i],j*(i-j),j*dp[i-j]) //状态转移方程  } } return dp[n] }   2.解题思路：数学推导，推论：尽可能分割为长度为3的绳子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func cuttingRope(n int) int { if n \u0026lt;= 3{ return n-1 } res := 1 for n \u0026gt;4 { res *= 3 n -= 3 //分割一段为3的绳子  } return n * res //乘上剩余的长度 }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":273,"section":"interview","tags":["算法"],"title":"剑指 Offer 14- I. 剪绳子","uri":"https://www.zhugeqing.top/interview/algorithm/offer/14-1/"},{"content":"题目入口\n难度：中等\n给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n\u0026gt;1并且m\u0026gt;1），每段绳子的长度记为 k[0],k[1]\u0026hellip;k[m - 1] 。请问 k[0]k[1]\u0026hellip;*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n解题思路：数学推导，推论：尽可能分割为长度为3的绳子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func cuttingRope(n int) int { if n \u0026lt;= 3 { return n-1 } res := 1 for n \u0026gt; 4{ res *= 3 res %= 1000000007 n -= 3 } return (n * res )%1000000007 }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":274,"section":"interview","tags":["算法"],"title":"剑指 Offer 14- II. 剪绳子 II","uri":"https://www.zhugeqing.top/interview/algorithm/offer/14-2/"},{"content":"题目入口\n难度：简单\n编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 \u0026lsquo;1\u0026rsquo; 的个数（也被称为 汉明重量).）。\n提示：\n 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。\n\n\n解题思路：根据位运算知识，我们可以知道当 n \u0026amp; (n-1)时，会消除一位最低位的1，可以通过此方法来不断消除n的1，直到n等于0  1 2 3 4 5 6 7 8 9 10 11 12  func hammingWeight(num uint32) int { res := 0 //只要大于0,就说明还有1  for num \u0026gt; 0{ //相与移除最低位的1  num = num \u0026amp; (num-1) res ++ } return res }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":275,"section":"interview","tags":["算法"],"title":"剑指 Offer 15. 二进制中1的个数","uri":"https://www.zhugeqing.top/interview/algorithm/offer/15/"},{"content":"题目入口\n难度：中等\n实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。\n解题思路：因为受到时间复杂度的影响，不能直接采取for循环求解，这题就相当于是需要设计一个时间复杂度为log n的算法，实际上就是使用二分法，每次都把幂除以2，直到幂等于0或者1，递归处理，然后再判断是奇数幂还是偶数幂，当是奇数幂的时候，需要再乘一次x，因为除以2的时候会忽略，同时这种递归算法没有重叠子问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  func myPow(x float64, n int) float64 { //二分法  if n \u0026gt;=0{//判断是正数幂还是负数幂  return pre(x,n) }else{ return 1/pre(x,n) } } func pre(x float64, n int)float64{ if n == 1{ return x } if n == 0{ return 1 } y := pre(x,n/2)//二分查找  if n % 2 == 0{//判断是奇数幂还是偶数幂  return y * y }else { return x * y * y } }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":276,"section":"interview","tags":["算法"],"title":"剑指 Offer 16. 数值的整数次方","uri":"https://www.zhugeqing.top/interview/algorithm/offer/16/"},{"content":"题目入口\n难度：简单\n输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。\n解题思路：先求出需要给返回数组分配的空间，然后给返回数组一一赋值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func printNumbers(n int) []int { if n == 0{ return nil } l := 1 for ;n \u0026gt; 0;n--{ l = l*10 } //因为最大数数10^n-1,所以再减少一次  l-- val := make([]int,l,l) for n = 0;n\u0026lt;l;n++{ val[n] = n + 1 } return val }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":277,"section":"interview","tags":["算法"],"title":"剑指 Offer 17. 打印从1到最大的n位数","uri":"https://www.zhugeqing.top/interview/algorithm/offer/17/"},{"content":"题目入口\n难度：简单\n给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。\n返回删除后的链表的头节点。\n解题思路：先判断第一个节点是否是要删除的节点，若是，则返回第一个节点之后的节点当做头节点，若不是，设立一个curr和pre指针，curr指针用于判断是否是要删除的节点，而pre指向curr前面的节点，便于进行删除操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  func deleteNode(head *ListNode, val int) *ListNode { if head.Val == val { head = head.Next return head } pre := head curr := head.Next //因为需要删除的节点一定存在于链表之中，所以不需要考虑访问到空指针  for curr.Val != val{ pre = curr curr = curr.Next } //删除操作  pre.Next = curr.Next return head }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":278,"section":"interview","tags":["算法"],"title":"剑指 Offer 18. 删除链表的节点","uri":"https://www.zhugeqing.top/interview/algorithm/offer/18/"},{"content":"题目入口\n难度：困难\n题解：网上一大神讲得比较好——\u0026gt;地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  func isMatch(s string, p string) bool { //动态规划  s_len, p_len:= len(s),len(p) //2.最优子结构：dp[i][j]表示s字符串的前i个字符与p字符串的前j个字符匹配的情况  dp := make([][]bool,s_len+1) for i:=0;i\u0026lt;=s_len;i++{ dp[i] = make([]bool,p_len+1) } dp[0][0] = true //2.base case  for col:=1;col\u0026lt;=p_len;col++{ ch := p[col-1] if col \u0026gt; 1 { if ch == \u0026#39;*\u0026#39;{ dp[0][col] = dp[0][col-2]; } else { dp[0][col] = false; } } else { if (ch == \u0026#39;*\u0026#39;) { dp[0][col] = true; } } } //3.状态转移方程  for row:=1;row\u0026lt;=s_len;row++{ ch1 := s[row-1] for col:=1;col\u0026lt;=p_len;col++{ ch2 := p[col-1] if ch1 == ch2 || ch2 == \u0026#39;.\u0026#39;{ dp[row][col] = dp[row-1][col-1] }else if ch2 == \u0026#39;*\u0026#39;{ if col \u0026gt; 1{ if dp[row][col-2]{ dp[row][col] = true //0个字符的情况  }else{ prev := p[col-2] if prev == ch1 || prev == \u0026#39;.\u0026#39;{ dp[row][col] = dp[row-1][col] } } } } } } return dp[s_len][p_len] }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":279,"section":"interview","tags":["算法"],"title":"剑指 Offer 19. 正则表达式匹配","uri":"https://www.zhugeqing.top/interview/algorithm/offer/19/"},{"content":"题目入口\n难度：中等\n解题思路：\n1.采用if-else的形式把所有情况列举出来；\n2.采用有限状态自动机，画出状态转换图，再化成代码(情况较多，需多次尝试)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103  type State int type CharType int const ( state_start State = iota //开始  state_sign //符号位  state_int //整数  state_point //小数点  state_withoutInt_point //左侧没有整数的小数点  state_float //小数部分  state_exp //字符E/e  state_exp_sign //指数的符号  state_exp_int //指数的整数部分  state_end //结束 ) const ( char_intger CharType = iota //整数  char_exp //指数符号e/E  char_point //小数点  char_sign //正负号  char_space //空格  char_illegal //不合法的字符 ) func toCharType(ch byte) CharType { switch ch { case \u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;: return char_intger case \u0026#39;e\u0026#39;, \u0026#39;E\u0026#39;: return char_exp case \u0026#39;.\u0026#39;: return char_point case \u0026#39;+\u0026#39;, \u0026#39;-\u0026#39;: return char_sign case \u0026#39; \u0026#39;: return char_space default: return char_illegal } } func isNumber(s string) bool { //状态转移图  transfer := map[State]map[CharType]State{ state_start : map[CharType]State{ char_space : state_start, char_sign : state_sign, char_intger : state_int, char_point : state_withoutInt_point, }, state_sign : map[CharType]State{ char_intger : state_int, char_point : state_withoutInt_point, }, state_int : map[CharType]State{ char_point : state_point, char_intger : state_int, char_exp : state_exp, char_space : state_end, }, state_point : map[CharType]State{ char_intger : state_float, char_exp : state_exp, char_space : state_end, }, state_withoutInt_point : map[CharType]State{ char_intger : state_float, }, state_float : map[CharType]State{ char_intger : state_float, char_exp : state_exp, char_space : state_end, }, state_exp : map[CharType]State{ char_sign : state_exp_sign, char_intger : state_exp_int, }, state_exp_sign : map[CharType]State{ char_intger : state_exp_int, }, state_exp_int : map[CharType]State{ char_intger : state_exp_int, char_space : state_end, }, state_end : map[CharType]State{ char_space : state_end, }, } //字符串初始状态  state := state_start for i := 0; i \u0026lt; len(s); i++ { typ := toCharType(s[i]) if _, ok := transfer[state][typ]; !ok { return false } else { state = transfer[state][typ] } fmt.Println(state) } fmt.Print(state==state_point) return state == state_int || state == state_float || state == state_point || state == state_exp_int || state == state_end }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":280,"section":"interview","tags":["算法"],"title":"剑指 Offer 20. 表示数值的字符串","uri":"https://www.zhugeqing.top/interview/algorithm/offer/20/"},{"content":"题目入口\n难度：简单\n解题思路：采用对撞指针，实际操作类似于快排\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  func exchange(nums []int) []int { //对撞指针  l := 0 r := len(nums)-1 for l \u0026lt; r{ //能整除2是奇数，不能整除2是偶数  for nums[l] % 2 != 0 \u0026amp;\u0026amp; l \u0026lt; r{ l++ } for nums[r] % 2 == 0 \u0026amp;\u0026amp; l \u0026lt; r{ r-- } //exchange  t := nums[l] nums[l] = nums[r] nums[r] = t } return nums }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":281,"section":"interview","tags":["算法"],"title":"剑指 Offer 21. 调整数组顺序使奇数位于偶数前面","uri":"https://www.zhugeqing.top/interview/algorithm/offer/21/"},{"content":"题目入口\n难度：简单\n解题思路：采用快慢指针，开始快指针和慢指针都指向链表头节点，让快指针先走k步，然后快慢指针一起走，当快指针为空时，说明此时慢指针也走到了链表的倒数第k个节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  func getKthFromEnd(head *ListNode, k int) *ListNode { //快慢指针  fast := head slow := head //快指针先走k步  for i:=0;i\u0026lt;k;i++{ fast = fast.Next } //直到fast为nil时，就说明slow已经到达了倒数第k个节点第位置，返回slow  for fast != nil{ fast = fast.Next slow = slow.Next } return slow }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":282,"section":"interview","tags":["算法"],"title":"剑指 Offer 22. 链表中倒数第k个节点","uri":"https://www.zhugeqing.top/interview/algorithm/offer/22/"},{"content":"题目入口\n难度：简单\n解题思路：采用三个指针，next指向下一个需要反转的节点，curr指向当前需要反转的节点，pre指向上一个反转的节点，不断进行Next指针赋值来达到反转\n1 2 3 4 5 6 7 8 9 10 11 12 13  func reverseList(head *ListNode) *ListNode { var pre *ListNode curr := head next := head for curr != nil{ next = next.Next //next后移  curr.Next = pre //翻转一个节点  pre = curr //pre后移  curr = next //curr后移  } return pre }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":283,"section":"interview","tags":["算法"],"title":"剑指 Offer 24. 反转链表","uri":"https://www.zhugeqing.top/interview/algorithm/offer/24/"},{"content":"题目入口\n难度：简单\n解题思路：采用归并排序，再因为两个链表已经是有序的，所以无需进行归并排序的拆分操作，直接比较合并到另一个链表即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { //归并排序  //虚拟节点，为了方便返回链表  dummy := \u0026amp;ListNode{ Next : nil, } //当前遍历节点  curr := dummy //不断比较，将每次较小节点连接到返回链表中  for l1 != nil \u0026amp;\u0026amp; l2 != nil{ if l1.Val \u0026lt;= l2.Val{ curr.Next = l1 curr = curr.Next l1 = l1.Next }else{ curr.Next = l2 curr = curr.Next l2 = l2.Next } } //连接可能剩余节点的链表  if l1 != nil{ curr.Next = l1 } if l2 != nil{ curr.Next = l2 } return dummy.Next }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":284,"section":"interview","tags":["算法"],"title":"剑指 Offer 25. 合并两个排序的链表","uri":"https://www.zhugeqing.top/interview/algorithm/offer/25/"},{"content":"题目入口\n难度：中等\n解题思路：构造两个递归函数，一个就是原递归函数，另一个search函数用来判断以A为根节点开始和B的根节点不断比较，B是否是A的子结构，具体细节：\n任何关于树的问题都可以在先序、中序、后序中找到对应解法，最重要的是明确递归函数的含义：1.search函数来求A树不断和B树比较，是否能够将B树比较成功，2.isSubStructur函数来求A树中是否含有B树这样的子结构\n原递归函数isSubStructur（前序遍历解法）：\n1.当A或者B为空时，直接返回false，因为题意，B为空时，不能当作子结构，而A为空时，同样不可能含有子结构\n2.判断A树不断和B树比较，是否能够将B树比较成功\n3.判断此时A的左子树是否含有B树这样的子结构或者A的右子树含有B树这样的子结构\n递归函数search：\n1.当B为空时，表示此子树和A比较成功，返回true\n2.当A为空时，表示A已经没有可以和B比较的节点了，返回false\n3.当A.Val不等于B.Val时，表示比较失败，返回false\n4.当A.Val等于B.Val时，表示这两个节点比较成功，继续向左右子树比较（进行递归）\n\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  func search(A *TreeNode,B *TreeNode)bool{ //比较完毕，返回true  if B == nil { return true } //比较失败，返回false  if A == nil || A.Val != B.Val { return false } //比较成功，继续递归比较  return search(A.Left,B.Left) \u0026amp;\u0026amp; search(A.Right,B.Right) } func isSubStructure(A *TreeNode, B *TreeNode) bool { //如果B是空树就不可能是A的子结构，返回false，如果A为空树就不可能有子结构，返回false  if B == nil || A == nil { return false } //进行递归操作  return search(A,B) || isSubStructure(A.Left,B) || isSubStructure(A.Right,B) }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":285,"section":"interview","tags":["算法"],"title":"剑指 Offer 26. 树的子结构","uri":"https://www.zhugeqing.top/interview/algorithm/offer/26/"},{"content":"题目入口\n难度：简单\n解题思路：分析需要将左子树和右子树交替位置，可以有多种解法；\n前序遍历解法：从根节点开始，直接交换左右子树，再对左子树、右子树递归处理。\n后序遍历解法：先对左右子树进行递归处理，再进行交换\n前序递归解法 1 2 3 4 5 6 7 8 9 10 11 12  func mirrorTree(root *TreeNode) *TreeNode { //后序遍历解法  if root == nil{ return nil } //先交换再递归  root.Left,root.Right = root.Right,root.Left mirrorTree(root.Left) mirrorTree(root.Right) return root }   后序遍历解法 1 2 3 4 5 6 7 8 9 10 11 12  func mirrorTree(root *TreeNode) *TreeNode { //后序遍历解法  if root == nil{ return nil } //先递归再交换  mirrorTree(root.Left) mirrorTree(root.Right) root.Left,root.Right = root.Right,root.Left return root }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":286,"section":"interview","tags":["算法"],"title":"剑指 Offer 27. 二叉树的镜像","uri":"https://www.zhugeqing.top/interview/algorithm/offer/27/"},{"content":"题目入口\n难度：简单\n解题思路：前序遍历，用root构造一棵p和一棵q树，p的左子树和q的右子树比较，p的右子树和q的左子树比较，不断递归返回结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  func compare(p *TreeNode,q *TreeNode)bool{ //如果q和p都为空，比较成功，返回true  if q == nil \u0026amp;\u0026amp; p == nil{ return true } //如果q和p有且只有一个为空，返回false  if q == nil || p == nil{ return false } //如果q和p的值不相同，返回false  if q.Val != p.Val{ return false } //递归比较，用p的左子树和q右子树去比较，p的右子树和q的左子树比较  return compare(p.Left,q.Right) \u0026amp;\u0026amp;compare(p.Right,q.Left) } func isSymmetric(root *TreeNode) bool { //用两root树来比较  return compare(root,root) }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":287,"section":"interview","tags":["算法"],"title":"剑指 Offer 28. 对称的二叉树","uri":"https://www.zhugeqing.top/interview/algorithm/offer/28/"},{"content":"题目入口\n难度：简单\n解题思路：类似于走迷宫，不过这个迷宫只有一条路线，所以需要确定好一条路线。\n然后让“一个人”走这条路线。\n1.首先起始位置是坐标（0，0），可以设置变量i,j来分别表示当前所在位置的横坐标和纵坐标，接着设置这个迷宫的边界，上边界为横坐标为-1的那一层，代表最高层，不能到达或者超过这一层（横坐标小于等于-1），下边界为横坐标为矩阵的的行数len(matrix)的那一层，代表最低层，不能达到或者超过这一层（横坐标大于等于len(matrix)）；左边界为纵坐标为-1的那一层，表示最左层，不能达到或者超过这一层（纵坐标小于等于-1），右边界为纵坐标为len(matrix[0])的那一层，代表最右层，不能到达或者超过这一层（纵坐标大于等于len(matrix[0])）\n2.确定了迷宫的边界，接下来应该确定迷宫的这一条唯一的路线，走需要一个状态，而由题可知，只会有四个方向，上下左右，所以定义一个行走状态status，接下来是状态转换，由顺时针可知，状态转换只能是：右-\u0026gt;下，下-\u0026gt;左，左-\u0026gt;上，上-\u0026gt;右。由题可知，初始状态是向右边走的，不停的走会超过右边界，当超过右边界时，要回退到上一个位置，然后状态转换，向下行走，此时还需要更新边界，因为一直右走，最高层已经遍历完毕，缩小最高层，以此类推。\n\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86  func spiralOrder(matrix [][]int) []int { if len(matrix) == 0{ return []int{} } //一个矩阵，四个边界  m0,n0 := -1,-1 m,n := len(matrix),len(matrix[0]) res:=make([]int,0) size:= n*m status := \u0026#34;right\u0026#34; i,j:=0,0 for k:=0;k\u0026lt;size;{ if status == \u0026#34;right\u0026#34;{ if noInArea(i,j,m,n,m0,n0) {//判断是否超出边界，若超出，状态转换，回退一个后继续前进  status = \u0026#34;down\u0026#34; //缩小一次边界  m0++ //改变坐标  i=i+1 j-- continue } res = append(res,matrix[i][j]) j++ k++ } if status == \u0026#34;down\u0026#34;{ if noInArea(i,j,m,n,m0,n0){ status = \u0026#34;left\u0026#34; //缩小一次边界  n-- j=j-1 i-- continue } res = append(res,matrix[i][j]) i++ k++ } if status == \u0026#34;left\u0026#34;{ if noInArea(i,j,m,n,m0,n0){ status = \u0026#34;up\u0026#34; //缩小一次边界  m-- i=i-1 j++ continue } res = append(res,matrix[i][j]) j-- k++ } if status == \u0026#34;up\u0026#34;{ if noInArea(i,j,m,n,m0,n0) { status = \u0026#34;right\u0026#34; //缩小一次边界  n0++ i=i+1 j++ continue } res = append(res,matrix[i][j]) i-- k++ } } return res } func noInArea(i,j int,m,n int,m0,n0 int)bool{ if i\u0026lt;=m0 || j\u0026lt;=n0 || i\u0026gt;=m || j \u0026gt;= n{ return true } return false }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":288,"section":"interview","tags":["算法"],"title":"剑指 Offer 29. 顺时针打印矩阵","uri":"https://www.zhugeqing.top/interview/algorithm/offer/29/"},{"content":"题目入口\n难度：简单\n解题思路：设置两个栈，一个普通栈，负责常规的出栈、入栈、取栈顶元素操作，一个辅助栈，维护一个相对于普通栈非严格降序的栈，使得无论进行出栈入栈操作都能取得最小的元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  type MinStack struct { //普通栈（后进先出）  Astack []int //辅助栈，维护一个最小元素在A栈相对顺序的栈  Bstack []int } /** initialize your data structure here. */ func Constructor() MinStack { return MinStack{ Astack : []int{}, Bstack : []int{}, } } func (this *MinStack) Push(x int) { this.Astack = append(this.Astack, x) //A栈加入元素时，需要与B栈元素比较大小，若x小于等于，则加入最小栈B中  //最小元素大于x时无需加入，因为，x始终会比最小元素先出栈  if len(this.Bstack) == 0 || this.Bstack[len(this.Bstack)-1] \u0026gt;= x{ this.Bstack = append(this.Bstack, x) } } func (this *MinStack) Pop() { x := this.Astack[len(this.Astack)-1] //出栈  this.Astack = this.Astack[:len(this.Astack)-1] //若A栈出栈的元素是最小元素，那么B栈也需要进行弹出操作  if this.Bstack[len(this.Bstack)-1] == x{ this.Bstack = this.Bstack[:len(this.Bstack)-1] } } func (this *MinStack) Top() int { return this.Astack[len(this.Astack)-1] } func (this *MinStack) Min() int { return this.Bstack[len(this.Bstack)-1] }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":289,"section":"interview","tags":["算法"],"title":"剑指 Offer 30. 包含min函数的栈","uri":"https://www.zhugeqing.top/interview/algorithm/offer/30/"},{"content":"题目入口\n难度：中等\n解题思路：设立一个stack栈来模拟出栈入栈过程，只有等stack栈顶元素与当前弹出序列索引为index元素相等时，才进行出栈操作，当stack为空或者与弹出序列索引为index元素不相等时，进行入栈操作；当无法出栈且压入序列到达末尾时，返回false，表示无法模拟。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  func validateStackSequences(pushed []int, popped []int) bool { index := 0 stack := make([]int, 0) //建立一个hash映射  top := 0 for index != len(popped){ //弹出操作  if len(stack) != 0 \u0026amp;\u0026amp; stack[len(stack)-1] == popped[index]{ stack = stack[:len(stack)-1] index++ }else{ if top == len(pushed){ return false } //压入操作  stack = append(stack,pushed[top] ) top++ } } return true }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":290,"section":"interview","tags":["算法"],"title":"剑指 Offer 31. 栈的压入、弹出序列","uri":"https://www.zhugeqing.top/interview/algorithm/offer/31/"},{"content":"题目入口\n难度：中等\n解题思路：利用队列来解决，每一次外循环实现遍历一层的节点并加入结果集，同时遍历这一层队列节点的左右节点，若不为空，加入队列，下一轮循环遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  func levelOrder(root *TreeNode) []int { //迄今为止的人生大写着失败，但并不妨碍我继续向前  //使用队列来辅助进行层序遍历  if root == nil{ return []int{} } queue := make([]*TreeNode, 0) queue = append(queue, root) //返回结果数组  res := make([]int, 0) for len(queue) != 0{ size := len(queue) for i:=0;i\u0026lt;size;i++{ res = append(res, queue[i].Val) if queue[i].Left != nil{ //入队  queue = append(queue, queue[i].Left) } if queue[i].Right != nil{ queue = append(queue, queue[i].Right) } } //出队  queue = queue[size:] } return res }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":291,"section":"interview","tags":["算法"],"title":"剑指 Offer 32 - I. 从上到下打印二叉树","uri":"https://www.zhugeqing.top/interview/algorithm/offer/32/"},{"content":"题目入口\n难度：中等\n解题思路：利用队列来解决，每一次外循环实现遍历一层的节点并加入结果集，同时遍历这一层队列节点的左右节点，若不为空，加入队列，下一轮循环遍历，多加入一个层级属性，来区分返回数组的行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ type queue struct{ node *TreeNode level int //当前节点的层级 } func levelOrder(root *TreeNode) [][]int { //用队列解决  if root == nil{ return [][]int{} } res := make([][]int, 0) //结果数组  q := make([]queue, 0)//初始化队列  q = append(q, queue{node:root,level:0}) //根节点先入队  for len(q) != 0{ size := len(q) for i:=0;i\u0026lt;size;i++{ node := q[i].node //获取队列中的元素  level := q[i].level //获取队列中的层级  if level == len(res){//说明此时res[level]还不存在  res =append(res, []int{}) } res[level] = append(res[level] ,node.Val) //如果存在添加左右节点到队列中，层级+1  if node.Left != nil{ q = append(q, queue{node:node.Left,level:level+1}) } if node.Right != nil{ q = append(q, queue{node:node.Right,level:level+1}) } } q = q[size:] //出队  } return res }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":292,"section":"interview","tags":["算法"],"title":"剑指 Offer 32 - II. 从上到下打印二叉树 II","uri":"https://www.zhugeqing.top/interview/algorithm/offer/33/"},{"content":"题目入口\n难度：中等\n和上题一样，不过这题要求之字型打印，所以需要将奇数行倒置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  type queue struct{ node *TreeNode //队列元素存储的节点  level int //队列元素存储的节点的层级 } func levelOrder(root *TreeNode) [][]int { res := make([][]int,0) //构造返回数组  if root == nil{ return res } q := make([]queue, 0) //构造队列  q = append(q, queue{node:root,level:0})//初始化队列  for len(q) != 0{ node := q[0].node level := q[0].level q = q[1:] //出队  if level == len(res){//想等说明还需要添加一个切片数组来存放本层因为下标0开始嘛...  res = append(res, []int{}) } res[level] = append(res[level], node.Val) //捋一下，偶数层从右到左，奇数层从左到右//多加一个判断  if node.Left != nil{ q = append(q,queue{node:node.Left,level:level+1}) } if node.Right != nil{ q = append(q,queue{node:node.Right,level:level+1}) } } //只需要把奇数层的节点值倒置一一下就行了  for i:=1;i\u0026lt;len(res);i+=2{ length := len(res[i]) for j:=0;j\u0026lt;length/2;j++{ res[i][j],res[i][length-1-j] = res[i][length-1-j],res[i][j] } } return res }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":293,"section":"interview","tags":["算法"],"title":"剑指 Offer 32 - III. 从上到下打印二叉树 III","uri":"https://www.zhugeqing.top/interview/algorithm/offer/34/"},{"content":"题目入口\n难度：中等\n解题思路：递归分治，后序遍历序列的根节点为最后一个，然后遍历序列，找到第一个大于跟根节点的节点，此节点之前到左边是左子树，到最后一个节点（根节点）前都是右子树，由此性质递归分治判断，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  func verifyPostorder(postorder []int) bool { return recur(postorder,0,len(postorder)-1) } func recur(postorder []int,i,j int)bool{ if i \u0026gt;= j{ return true } //先找到第一个比根节点大的节点  p := i for postorder[p] \u0026lt; postorder[j]{ p++ } m := p //然后看区间（p,j]之间还是否有小于根节点的节点  for postorder[p] \u0026gt; postorder[j]{ p++ } return p == j \u0026amp;\u0026amp; recur(postorder,i,m-1) \u0026amp;\u0026amp; recur(postorder,m,j-1) }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":294,"section":"interview","tags":["算法"],"title":"剑指 Offer 33. 二叉搜索树的后序遍历序列","uri":"https://www.zhugeqing.top/interview/algorithm/offer/35/"},{"content":"题目入口\n难度：中等\n求解某一条路径，前序遍历框架，回溯即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  func pathSum(root *TreeNode, target int) [][]int { res := make([][]int, 0) var path = []int{} var search func(*TreeNode,int) search = func(root *TreeNode,curr int){ if root == nil{ return } curr = curr + root.Val if curr == target \u0026amp;\u0026amp; root.Left == nil \u0026amp;\u0026amp; root.Right == nil{ res = append(res, append([]int(nil), append(path, root.Val)...)) return } path = append(path, root.Val) search(root.Left,curr) search(root.Right,curr) path = path[:len(path)-1] } search(root,0) return res }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":295,"section":"interview","tags":["算法"],"title":"剑指 Offer 34. 二叉树中和为某一值的路径","uri":"https://www.zhugeqing.top/interview/algorithm/offer/36/"},{"content":"题目入口\n难度：中等\n解题思路：遍历旧链表，赋值节点形成一条新的链表，同时创建一个旧链表节点与复制节点的映射，最后再遍历一次来通过映射给Random赋值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  func copyRandomList(head *Node) *Node { dummy := \u0026amp;Node{} //哑巴节点  hash := make(map[*Node]*Node) //创建映射  x := head y := dummy for x != nil{ temp := \u0026amp;Node{Val:x.Val} hash[x] = temp y.Next = temp y = y.Next x = x.Next } y = dummy.Next x = head for x != nil{ if x.Random != nil{ y.Random = hash[x.Random] } x = x.Next y = y.Next } return dummy.Next }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":296,"section":"interview","tags":["算法"],"title":"剑指 Offer 35. 复杂链表的复制","uri":"https://www.zhugeqing.top/interview/algorithm/offer/37/"},{"content":"题目入口\n难度：中等\n解题思路：由二叉搜索树的性质可知，可以用中序遍历框架解决\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  func treeToDoublyList(root *Node) *Node { if root == nil{ return nil } //标记最小的节点  var head *Node //标记最大的节点  var pre *Node var search func(root *Node) search = func(root *Node){ if root == nil{ return } search(root.Left) if pre != nil{ pre.Right = root }else{ head = root } root.Left = pre pre = root search(root.Right) } search(root) head.Left = pre pre.Right = head return head }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":297,"section":"interview","tags":["算法"],"title":"剑指 Offer 36. 二叉搜索树与双向链表","uri":"https://www.zhugeqing.top/interview/algorithm/offer/38/"},{"content":"题目入口\n难度：困难\n解题思路：先序遍历框架进行序列化和反序列化，也可用后序或者层序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  type Codec struct { } func Constructor() Codec { return Codec{} } func (Codec) serialize(root *TreeNode) string { sb := \u0026amp;strings.Builder{} var dfs func(*TreeNode) dfs = func(node *TreeNode) { if node == nil { sb.WriteString(\u0026#34;null,\u0026#34;) return } sb.WriteString(strconv.Itoa(node.Val)) sb.WriteByte(\u0026#39;,\u0026#39;) dfs(node.Left) dfs(node.Right) } dfs(root) return sb.String() } // Deserializes your encoded data to tree. func (this *Codec) deserialize(data string) *TreeNode { temp := strings.Split(data, \u0026#34;,\u0026#34;) var dfs func() *TreeNode dfs = func() *TreeNode { if temp[0] == \u0026#34;null\u0026#34; { temp = temp[1:len(temp)] return nil } Val, _ := strconv.Atoi(temp[0]) temp = temp[1:len(temp)] return \u0026amp;TreeNode{ Val:Val, Left:dfs(), Right:dfs(), } } root := dfs() return root }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":298,"section":"interview","tags":["算法"],"title":"剑指 Offer 37. 序列化二叉树","uri":"https://www.zhugeqing.top/interview/algorithm/offer/39/"},{"content":"题目入口\n难度：中等\n典型的回溯法，解决排列问题，还需多加一个排序字符串里的字符方便递归，进行剪枝操作防止重复的字符串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  func permutation(s string) []string { //回溯解法 \t//返回数组 \tn := len(s) //因为字符串可能会有相同的字符，所以先对字符串进行排序 \t//转成[]byte排序 \tt := []byte(s) sort.Slice(t, func(i, j int) bool { return t[i] \u0026lt; t[j] }) s = string(t) ans := make([]string, 0) //求单结果组合的临时的数组 \tres := make([]byte, 0) var dfs func(index int) //用来标记是否使用，剪枝操作 \tused := make([]bool, n) dfs = func(index int) { if index == n { ans = append(ans, string(res)) return } //递归细节 \tfor i := 0; i \u0026lt; n; i++ { //如果该字符已经被使用，则跳过 \t//若字符相同，进行剪枝 \tif used[i] { continue } if i \u0026gt; 0 \u0026amp;\u0026amp; s[i] == s[i-1] \u0026amp;\u0026amp; !used[i-1] { continue } res = append(res, s[i]) used[i] = true //递归 \tdfs(index + 1) //回溯 \tused[i] = false res = res[:len(res)-1] } return } dfs(0) return ans }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":299,"section":"interview","tags":["算法"],"title":"剑指 Offer 38. 字符串的排列","uri":"https://www.zhugeqing.top/interview/algorithm/offer/40/"},{"content":"题目入口\n难度：简单\n解题思路：解法众多，1.可以采用排序，排序之后取数组中间的数字即可，2.用查找表，记录出现最大次数的数字，不断更新，3.推荐使用，工兵抢占营地\n工兵抢占营地 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func majorityElement(nums []int) int { //工兵抢占营地，一个一个消耗，剩下了的就是多数元素  index := nums[0]//记录当前工兵  current := 1 //当前工兵类的人数  for i:=1;i\u0026lt;len(nums);i++{ if index != nums[i]{ current-- }else{ current++ } if current \u0026lt;= 0 {//若当前所有工兵牺牲，就选择下一个工兵  index = nums[i+1]//不需要考虑越界问题，因为当派出最后一个工兵时，一定会有一个胜利的工兵  } } return index }   排序解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  //快排解法 func majorityElement(nums []int) int { quicksort(nums,0,len(nums)-1) return nums[len(nums)/2] } func swap(arr []int,i,j int){ arr[i] = arr[i] ^ arr[j] arr[j] = arr[j] ^ arr[i] arr[i] = arr[i] ^ arr[j] } func quicksort(nums []int,start,end int){ if start \u0026gt;= end{ return //递归终止条件  } middle := partition(nums,start,end) quicksort(nums,start,middle-1) quicksort(nums,middle+1,end) } func partition(arr []int,start,end int)int{ if start\u0026gt;= end{ return start } index := rand.Intn(end+1)%(end-start)+start if start != index{ swap(arr,start,index) } pivot := arr[start] low := start+1 high := end //双指针区间法  for low \u0026lt; high{ for low \u0026lt; high \u0026amp;\u0026amp; arr[low] \u0026lt;= pivot{ low++ } for low \u0026lt; high \u0026amp;\u0026amp; arr[high] \u0026gt;= pivot{ high-- } if low \u0026lt; high{ swap(arr,low,high) low++ high-- } } // 为了判断特殊情况  //1.数组只有最后一个大于基数，但low一直加到high，会退出for循环，没有指向最后一个小于基数的下标  //2.除了基数以外只有一个数，但是此时low和high相等，他们没有和基数比较  //  if low == high \u0026amp;\u0026amp; arr[low] \u0026gt; pivot { low-- } if start != low{ swap(arr,start,low)//把基数交换到中轴  } return low }   查找表解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func majorityElement(nums []int) int { hash := make(map[int]int) max := nums[0] hash[nums[0]]++ n := len(nums) for i:=1;i\u0026lt;n;i++{ hash[nums[i]]++ if hash[nums[i]] \u0026gt; hash[max]{ max = nums[i] } } return max }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":300,"section":"interview","tags":["算法"],"title":"剑指 Offer 39. 数组中出现次数超过一半的数字","uri":"https://www.zhugeqing.top/interview/algorithm/offer/41/"},{"content":"题目入口\n难度：简单\n解题思路：Top k问题，可以采用堆和快速排序思想解决\n基于快排思想的快速选择 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  func getLeastNumbers(arr []int, k int) []int { if len(arr)==0 || k==0 { return nil } return quicksearch(arr, 0, len(arr)-1, k) } func partition(nums []int,i,j int) int { l,m,r:=i,i,j for l\u0026lt;r { for l\u0026lt;r \u0026amp;\u0026amp; nums[r]\u0026gt;=nums[m] { r-- } for l\u0026lt;r \u0026amp;\u0026amp; nums[l]\u0026lt;=nums[m] { l++ } if l\u0026lt;r { nums[l],nums[r]=nums[r],nums[l] } } nums[m],nums[l]=nums[l],nums[m] return l } func quicksearch(nums []int,i,j,k int) []int{ middle:=partition(nums,i,j) if middle==k-1 { return nums[:k] } if middle\u0026lt;k-1 { return quicksearch(nums,middle+1,j,k) } return quicksearch(nums,i,middle-1,k) }   堆排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  func getLeastNumbers(arr []int, k int) []int { if k == 0 { return []int{} } if len(arr) == k || len(arr) == 0{ return arr } minHeapSort(arr,k)//先堆排序  return arr[len(arr)-k:] } func swap(nums []int, i, j int) { if nums[i] == nums[j]{ return } nums[i] = nums[i] ^ nums[j] nums[j] = nums[j] ^ nums[i] nums[i] = nums[i] ^ nums[j] } //小顶堆 func minHeapSort(nums []int,k int) { buildMinheap(nums) //初建顶堆 \t//需要调整堆k-1次（初建堆已经完成一次）  n := len(nums) for i := len(nums) - 1; i \u0026gt;= n-k; i-- { swap(nums, 0, i) //最后一次无需调整  if i == n-k{ break } minHeapify(nums, 0, i) } } func buildMinheap(nums []int) { for i := len(nums)/2 - 1; i \u0026gt;= 0; i-- { //建初堆 \tminHeapify(nums, i, len(nums)) } } func minHeapify(nums []int, index, heapSize int) { //调整堆 \tl := (index\u0026lt;\u0026lt;1) + 1 r := l + 1 smallest := index if l \u0026lt; heapSize \u0026amp;\u0026amp; nums[l] \u0026lt; nums[smallest] { smallest = l } if r \u0026lt; heapSize \u0026amp;\u0026amp; nums[r] \u0026lt; nums[smallest] { smallest = r } if smallest != index { //交换,使其满足最小堆性质 \tswap(nums, smallest, index) //向下递归调整 \tminHeapify(nums, smallest, heapSize) } }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":301,"section":"interview","tags":["算法"],"title":"剑指 Offer 40. 最小的k个数","uri":"https://www.zhugeqing.top/interview/algorithm/offer/42/"},{"content":"题目入口\n难度：困难\n解题思路：参考Krahets大神的题解\n\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79  type MedianFinder struct { //保留较大的一半  minHeap *MinHeap //保留较小的一半  maxHeap *MaxHeap } /** initialize your data structure here. */ func Constructor() MedianFinder { minHeap := \u0026amp;MinHeap{} maxHeap := \u0026amp;MaxHeap{} heap.Init(minHeap) heap.Init(maxHeap) return MedianFinder{minHeap,maxHeap} } func (this *MedianFinder) AddNum(num int) { if this.minHeap.Len() != this.maxHeap.Len(){ //两边不相等，说明数组的大小为奇数，需要向大顶堆加入元素  heap.Push(this.minHeap,num) heap.Push(this.maxHeap,heap.Pop(this.minHeap)) }else{ heap.Push(this.maxHeap,num) heap.Push(this.minHeap,heap.Pop(this.maxHeap)) } } func (this *MedianFinder) FindMedian() float64 { if this.minHeap.Len() != this.maxHeap.Len(){ return float64(this.minHeap.Peek()) }else{ return float64(this.minHeap.Peek()+this.maxHeap.Peek())/2 } } type MinHeap []int type MaxHeap []int func (h *MinHeap) Len() int { return len(*h) } func (h *MinHeap) Less(i, j int) bool { return (*h)[i] \u0026lt; (*h)[j] } func (h *MinHeap) Swap(i, j int) { (*h)[i], (*h)[j] = (*h)[j], (*h)[i] } func (h *MinHeap) Peek()int {return (*h)[0]} func (h *MinHeap) Push(x interface{}) { // Push and Pop use pointer receivers because they modify the slice\u0026#39;s length, \t// not just its contents. \t*h = append(*h, x.(int)) } func (h *MinHeap) Pop() interface{} { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1]\treturn x } func (h *MaxHeap) Len() int { return len(*h) } func (h *MaxHeap) Less(i, j int) bool { return (*h)[i] \u0026gt; (*h)[j] } func (h *MaxHeap) Swap(i, j int) { (*h)[i], (*h)[j] = (*h)[j], (*h)[i] } func (h *MaxHeap) Peek()int {return (*h)[0]} func (h *MaxHeap) Push(x interface{}) { // Push and Pop use pointer receivers because they modify the slice\u0026#39;s length, \t// not just its contents. \t*h = append(*h, x.(int)) } func (h *MaxHeap) Pop() interface{} { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1]\treturn x }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":302,"section":"interview","tags":["算法"],"title":"剑指 Offer 41. 数据流中的中位数","uri":"https://www.zhugeqing.top/interview/algorithm/offer/43/"},{"content":"题目入口\n难度：简单\n解题思路：\n动态规划：\n1.最优子结构 :dp[i]表示以数组下标i结尾连续最大和\n2.base case :dp[0] = nums[0]\n3.状态转换方程:dp[i] = max(dp[i-1]+nums[i],nums[i])\n\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  func maxSubArray(nums []int) int { //base case  max := nums[0] ans := max for i:=1;i\u0026lt;len(nums);i++{ if max + nums[i] \u0026gt; nums[i]{ max = max + nums[i] }else{ max = nums[i] } if ans \u0026lt; max{ ans = max } } return ans }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":303,"section":"interview","tags":["算法"],"title":"剑指 Offer 42. 连续子数组的最大和","uri":"https://www.zhugeqing.top/interview/algorithm/offer/44/"},{"content":"题目入口\n难度：困难\n解题思路：寻找数学规律(暴力破解法会超时)，一个详细的题解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  func countDigitOne(n int) int { if n \u0026lt;= 1{ return n } //1表示个位，10、100表示十位，百位，以此类推  digit := 1 //表示当前的数位  curr := n % 10 //最初先求个位上的1，  high := n / 10 //因为此时当前位就是个位，没有低位，直接设置为0  low := 0 //返回结果  res := 0 for n \u0026gt; 0{ if curr == 0{ res += high*digit }else if curr == 1{ res += high*digit+low+1 }else{ res += (high+1)*digit } n /= 10 low += curr*digit digit *= 10 curr = n %10 high = n /10 } return res }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":304,"section":"interview","tags":["算法"],"title":"剑指 Offer 43. 1～n 整数中 1 出现的次数","uri":"https://www.zhugeqing.top/interview/algorithm/offer/45/"},{"content":"题目入口\n难度：中等\n解题思路 -\u0026gt;k神题解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  func findNthDigit(n int) int { //看了k神的解析  //数位  digit := 1 // 1,2,3  //此数位开始的数字  start := 1 //1,10,100  //此数位一共有的数位  count := 9 for n \u0026gt; count{ n -= count start *= 10 digit += 1 count = digit * 9 * start } //求出数位所在的数字(减去1是因为start从0开始)  num := start + (n-1)/digit //再得出数位在数字中的第几位  index := (n-1) % digit str := strconv.Itoa(num) return int(str[index] - \u0026#39;0\u0026#39;) }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":305,"section":"interview","tags":["算法"],"title":"剑指 Offer 44. 数字序列中某一位的数字","uri":"https://www.zhugeqing.top/interview/algorithm/offer/46/"},{"content":"题目入口\n难度：中等\\\n解题思路：采用常规的排序方法即可，注意的是，比较的不是两个数字的大小，而是比较两个数字前后拼接起来的大小，比如，12，21这两个数字，只有两种拼接方法，1221和2112，由此比较大小进行排序即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  func minNumber(nums []int) string { //快排  quickSort(nums, 0, len(nums)-1) str := \u0026#34;\u0026#34; for i := 0; i \u0026lt; len(nums); i++ { str += strconv.Itoa(nums[i]) } return str } func quickSort(nums []int, start, end int) { if start \u0026gt;= end { return } middle := partition(nums, start, end) quickSort(nums, start, middle-1) quickSort(nums, middle+1, end) } func partition(nums []int, start, end int) int { if start \u0026gt;= end { return start } //取基准 \tindex := nums[start] //挖坑法 \tl := start r := end for l \u0026lt; r { for l \u0026lt; r \u0026amp;\u0026amp; !compare(nums[r], index) { r-- } if l \u0026lt; r { nums[l] = nums[r] l++ } for l \u0026lt; r \u0026amp;\u0026amp; compare(nums[l], index) { l++ } if l \u0026lt; r { nums[r] = nums[l] r-- } } nums[l] = index return l } //ab小于ba返回true，否则false func compare(a, b int) bool { return strconv.Itoa(a)+strconv.Itoa(b) \u0026lt;= strconv.Itoa(b)+strconv.Itoa(a) }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":306,"section":"interview","tags":["算法"],"title":"剑指 Offer 45. 把数组排成最小的数","uri":"https://www.zhugeqing.top/interview/algorithm/offer/47/"},{"content":"题目入口\n难度：中等\n解题思路：动态规划，字符翻译类问题，以当前字符结尾的翻译方案直接由前一个字符的方案数赋值，再如果前一个字符和当前字符能组合成一个符合题意的字符，那还需要再加上前前一个字符的方案数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func translateNum(num int) int { src := strconv.Itoa(num) //p,q,r分别表示dp[i-2],dp[i-1],dp[i]  p, q, r := 0, 0, 1 for i := 0; i \u0026lt; len(src); i++ { p, q, r = q, r, 0 r += q if i == 0 { continue } pre := src[i-1:i+1] if pre \u0026lt;= \u0026#34;25\u0026#34; \u0026amp;\u0026amp; pre \u0026gt;= \u0026#34;10\u0026#34; { r += p } } return r }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":307,"section":"interview","tags":["算法"],"title":"剑指 Offer 46. 把数字翻译成字符串","uri":"https://www.zhugeqing.top/interview/algorithm/offer/48/"},{"content":"题目入口\n难度：中等\n解题思路：直接使用动态规划\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  func maxValue(grid [][]int) int { //动态规划  m := len(grid) n := len(grid[0]) dp := make([][]int,m) for i:=0;i\u0026lt;m;i++{ dp[i] = make([]int,n) } //因为只能向右和下走，很容易得到状态转移方程  // dp[i][j] = max(dp[i-1][j],dp[i][j-1])+grid[i][j]  //base case  dp[0][0] = grid[0][0] for i:=0;i\u0026lt;m;i++{ for j:=0;j\u0026lt;n;j++{ if (i == 0 \u0026amp;\u0026amp; j == 0){ continue } if i-1 \u0026lt;0{ dp[i][j] = dp[i][j-1] + grid[i][j] }else if j-1\u0026lt;0{ dp[i][j] = dp[i-1][j] + grid[i][j] }else{ dp[i][j] = max(dp[i-1][j],dp[i][j-1])+grid[i][j] } } } return dp[m-1][n-1] } func max(a,b int)int{ if a \u0026gt; b{ return a } return b }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":308,"section":"interview","tags":["算法"],"title":"剑指 Offer 47. 礼物的最大价值","uri":"https://www.zhugeqing.top/interview/algorithm/offer/49/"},{"content":"题目入口\n难度：中等\n解题思路：\n1.动态规划\n2.滑动窗口\n\ngo go  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  func lengthOfLongestSubstring(s string) int { //滑动窗口  //窗口边界[l...r]  l,r := 0,-1 freq := make([]int, 128) //字符串长度  n := len(s) //返回结果  res := 0 for l \u0026lt; n{ //判断r的下一步  if r+1 \u0026lt; n \u0026amp;\u0026amp; freq[s[r+1]] == 0{ //r前进一步（扩大窗口）  r++ freq[s[r]]++ }else{ //l前进一步（缩小窗口）  freq[s[l]]-- l++ } //更新结果  if res \u0026lt; r-l+1{ res = r-l+1 } } return res }     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  func lengthOfLongestSubstring(s string) int { //动态规划  if len(s) == 0{ return 0 } n := len(s) //字符串的长度  hash := make(map[byte]int) tmp := 0 res := 0 for j:=0;j\u0026lt;n;j++{ //获取索引  i,ok := hash[s[j]] if !ok{ i-- } //更新hash表  hash[s[j]] = j if tmp \u0026lt; j-i{ tmp = tmp+1 }else{ tmp = j-i } if tmp \u0026gt; res{ res = tmp } } return res }       'use strict'; var containerId = JSON.parse(\"\\\"6f88ff0ad34391b7\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":309,"section":"interview","tags":["算法"],"title":"剑指 Offer 48. 最长不含重复字符的子字符串","uri":"https://www.zhugeqing.top/interview/algorithm/offer/50/"},{"content":"题目入口\n难度：中等\n解题思路：\n动态规划\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  func nthUglyNumber(n int) int { //动态规划 \t//dp[i]表示第i个丑数的值(状态方程) \t//dp[i] = dp[n]*2 or dp[n]*3 or dp[n]*5(转移方程) \tp2, p3, p5 := 0, 0, 0 //设置三个指针， \tdp := make([]int, n) dp[0] = 1 //第一个丑数为1 \tfor i := 1; i \u0026lt; n; i++ { //自下而上 \t//第i个丑数一定是由之前的丑数*2 or *3 or *5而来 \tdp[i] = MinNums(dp[p2]*2, MinNums(dp[p3]*3, dp[p5]*5)) if dp[i] == dp[p2]*2 { p2++ } if dp[i] == dp[p3]*3 { p3++ } if dp[i] == dp[p5]*5 { p5++ } } return dp[n-1] } func MinNums(a int, b int) int { if a \u0026lt; b { return a } else { return b } }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":310,"section":"interview","tags":["算法"],"title":"剑指 Offer 49. 丑数","uri":"https://www.zhugeqing.top/interview/algorithm/offer/51/"},{"content":"题目入口\n难度：简单\n解题思路：\n查找表\n1 2 3 4 5 6 7 8 9 10 11 12 13  func firstUniqChar(s string) byte { //查找表 \thash := make([]int,26) for i := 0; i \u0026lt; len(s); i++ { hash[s[i]-\u0026#39;a\u0026#39;]++ } for i := 0; i \u0026lt; len(s); i++ { if hash[s[i]-\u0026#39;a\u0026#39;] == 1 { return s[i] } } return \u0026#39; \u0026#39; }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":311,"section":"interview","tags":["算法"],"title":"剑指 Offer 50. 第一个只出现一次的字符","uri":"https://www.zhugeqing.top/interview/algorithm/offer/52/"},{"content":"题目入口\n难度：困难\n解题思路：\n归并排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  // 使用归并排序统计 func reversePairs(nums []int) int { res := make([]int,len(nums)) return mergeSort(nums,0,len(res)-1,res) } func mergeSort(nums []int,start,end int,res []int)int{ if start \u0026gt;= end{ return 0 } middle := (start+end)/2 //向左区间递归  left := mergeSort(nums,start,middle,res) //向右区间递归  right := mergeSort(nums,middle+1,end,res) return left + right + merge(nums,start,end,res) } func merge(nums []int,start,end int,res []int)int{ end1 := (start+end)/2 start2 := end1 + 1 //记录逆序对  count := 0 //遍历指针  index1,index2 := start,start2 for index1 \u0026lt;= end1 \u0026amp;\u0026amp; index2 \u0026lt;= end{ if nums[index1] \u0026lt;= nums[index2]{ res[index1+index2-start2] = nums[index1] index1++ }else{ res[index1+index2-start2] = nums[index2] index2++ //此时右边的数小于左边的数，记录逆序对  count += end1 - index1 + 1 } } //补全剩余的数字  for index1 \u0026lt;= end1{ res[index1+index2-start2] = nums[index1] index1++ } for index2 \u0026lt;= end{ res[index1+index2-start2] = nums[index2] index2++ } for start\u0026lt;=end{ nums[start] = res[start] start++ } return count }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":312,"section":"interview","tags":["算法"],"title":"剑指 Offer 51. 数组中的逆序对","uri":"https://www.zhugeqing.top/interview/algorithm/offer/53/"},{"content":"题目入口\n难度：简单\n解题思路：\n双指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  func getIntersectionNode(headA, headB *ListNode) *ListNode { if headA == nil || headB == nil{ return nil } preA := headA preB := headB for preA != preB{ if preA == nil{ preA = headB }else{ preA = preA.Next } if preB == nil{ preB = headA }else{ preB = preB.Next } } return preA }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":313,"section":"interview","tags":["算法"],"title":"剑指 Offer 52. 两个链表的第一个公共节点","uri":"https://www.zhugeqing.top/interview/algorithm/offer/54/"},{"content":"题目入口\n难度：简单\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  func search(nums []int, target int) int { if len(nums) == 0{ return 0 } //二分查找  count := 1 l := 0 r := len(nums)-1 mid := (l+r)/2 for l \u0026lt;= r \u0026amp;\u0026amp; nums[mid] != target{ if nums[mid] \u0026lt; target{ l = mid+1 }else{ r = mid-1 } mid = (l+r)/2 } if nums[mid] != target{ return 0 } //再向左右搜索  left := mid-1 right:= mid+1 for left \u0026gt;=0 \u0026amp;\u0026amp; nums[left] == target{ count++ left-- } for right \u0026lt; len(nums) \u0026amp;\u0026amp; nums[right] == target{ count++ right++ } return count }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":314,"section":"interview","tags":["算法"],"title":"剑指 Offer 53 - I. 在排序数组中查找数字 I","uri":"https://www.zhugeqing.top/interview/algorithm/offer/55/"},{"content":"题目入口\n难度：简单\n解题思路：\n二分查找\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  func missingNumber(nums []int) int { //二分查找法  //在不缺失数字的情况下nums[i] = i  //如果nums[mid] != mid,说明左区间缺失了数字，否则就是右区间  l := 0 r := len(nums)-1 mid := (l+r)/2 for l \u0026lt;= r{ if nums[mid] != mid{ r = mid - 1 }else{ l = mid + 1 } mid = (l+r)/2 } return l }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":315,"section":"interview","tags":["算法"],"title":"剑指 Offer 53 - II. 0～n-1中缺失的数字","uri":"https://www.zhugeqing.top/interview/algorithm/offer/56/"},{"content":"题目入口\n难度：简单\n解题思路：\n1.中序遍历得到一个排序的数组，返回倒数第k个数即可\n2.中序遍历倒序（右根左）可以保证每次都按大到小访问，k减少直到等于0，返回root.Val\n1. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  func kthLargest(root *TreeNode, k int) int { var search func(*TreeNode) var nums []int //利用二叉搜索树的特点，中序遍历得到的序列为一个递增序列，选取第len(nums)-k号元素  search = func(root *TreeNode){ if root == nil{ return } search(root.Left) nums = append(nums,root.Val) search(root.Right) } search(root) return nums[len(nums)-k] }   2. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  func kthLargest(root *TreeNode, k int) int { var search func(*TreeNode) res := 0 //利用二叉搜索树的特点，中序遍历倒序（右根左）  search = func(root *TreeNode){ if root == nil || k == 0{ return } search(root.Right) k-- if k == 0{ res = root.Val } search(root.Left) } search(root) return res }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":316,"section":"interview","tags":["算法"],"title":"剑指 Offer 54. 二叉搜索树的第k大节点","uri":"https://www.zhugeqing.top/interview/algorithm/offer/57/"},{"content":"题目入口\n难度：简单\n解题思路：\n后序遍历框架\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  func maxDepth(root *TreeNode) int { if root == nil{ return 0 } left := maxDepth(root.Left) right := maxDepth(root.Right) return max(left,right)+1 } func max(a,b int)int{ if a \u0026gt; b{ return a } return b }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":317,"section":"interview","tags":["算法"],"title":"剑指 Offer 55 - I. 二叉树的深度","uri":"https://www.zhugeqing.top/interview/algorithm/offer/58/"},{"content":"题目入口\n难度：简单\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func max(a,b int)int{ //求左右子树树高最大值  if a \u0026gt; b{ return a } return b } func H(root *TreeNode)int{ //求树高函数  if root == nil{ return 0 } return max(H(root.Left),H(root.Right)) + 1 } func isBalanced(root *TreeNode) bool{ //判断是否为平衡二叉树  if root == nil{ return true } //如果满足AVL树条件，就继续向下判断，直到遍历完所有节点  if H(root.Left) - H(root.Right) \u0026lt;= 1 \u0026amp;\u0026amp; H(root.Right) - H(root.Left) \u0026lt;= 1{ return isBalanced(root.Left) \u0026amp;\u0026amp; isBalanced(root.Right) //如果不满足条件，就返回false  }else{ return false } }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":318,"section":"interview","tags":["算法"],"title":"剑指 Offer 55 - II. 平衡二叉树","uri":"https://www.zhugeqing.top/interview/algorithm/offer/59/"},{"content":"题目入口\n难度：中等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  func singleNumbers(nums []int) []int { //先把所有的数都异或  x := 0 n := len(nums) for i:=0;i\u0026lt;n;i++{ x ^= nums[i] } //随便取x一个为1的二进制位  m := 1 for x \u0026amp; m == 0{ m \u0026lt;\u0026lt;= 1 //向左移位（1，10，100...）  } a, b := 0, 0 //然后用m进行分组，和m想与等于0为一组，不等于0为一组  for i:=0;i\u0026lt;n;i++{ if nums[i] \u0026amp; m == 0{ a ^= nums[i] }else{ b ^= nums[i] } } return []int{a,b} }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":319,"section":"interview","tags":["算法"],"title":"剑指 Offer 56 - I. 数组中数字出现的次数","uri":"https://www.zhugeqing.top/interview/algorithm/offer/60/"},{"content":"题目入口\n难度：中等\n解题思路：\n1.位运算，由于其他数字都有三个，所有某一位二进制1的个数如果不能被3整除，就说明这一位二进制是唯一只出现过一次的数字里面的，将这一位与结果相或\n2.查找表，返回值为1的键\n1. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func singleNumber(nums []int) int { ans := 0 for i:=0;i\u0026lt;32;i++{ sum := 0 for _,v:=range nums{ sum += v\u0026gt;\u0026gt;i \u0026amp; 1 } if sum % 3 != 0{ ans |= 1\u0026lt;\u0026lt;i } } return ans }   2. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func singleNumber(nums []int) int { hash := make(map[int]int) for i:=0;i\u0026lt;len(nums);i++{ hash[nums[i]]++ } for i,v :=range hash{ if v % 3 != 0{ return i } } return 0 }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":320,"section":"interview","tags":["算法"],"title":"剑指 Offer 56 - II. 数组中数字出现的次数 II","uri":"https://www.zhugeqing.top/interview/algorithm/offer/61/"},{"content":"题目入口\n难度：简单\n解题思路：\n滑动窗口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  func findContinuousSequence(target int) [][]int { //滑动窗口  l := 1 r := 2 ans := make([][]int,0) temp := l+r for l \u0026lt; r{ if temp \u0026lt; target{ r++ temp += r }else if temp \u0026gt; target{ temp -= l l++ }else{ res := make([]int,0) for i:=l;i\u0026lt;=r;i++{ res = append(res,i) } ans = append(ans,append([]int(nil),res...)) temp -= l l++ } } return ans }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":321,"section":"interview","tags":["算法"],"title":"剑指 Offer 57 - II. 和为s的连续正数序列","uri":"https://www.zhugeqing.top/interview/algorithm/offer/63/"},{"content":"题目入口\n难度：简单\n双指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  func twoSum(nums []int, target int) []int { //双指针  l := 0 r := len(nums)-1 for l!=r{ temp := nums[l]+nums[r] if temp == target{ return []int{nums[l],nums[r]} }else if temp \u0026gt; target{ r-- }else{ l++ } } return []int{} }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":322,"section":"interview","tags":["算法"],"title":"剑指 Offer 57. 和为s的两个数字","uri":"https://www.zhugeqing.top/interview/algorithm/offer/62/"},{"content":"题目入口\n难度：简单\n解题思路：\n1.双指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  func reverseWords(s string) string { if len(s) == 0{ return s } // str := []byte(s)  n := len(s) //0，1分别表示单词，空格  status := 0 l,r:=0,0 words := make([]string,0) for r\u0026lt;n{ if status == 0{ if s[r] == \u0026#39; \u0026#39;{ r++ continue }else{ status = 1 l = r r++ } }else{ if s[r] == \u0026#39; \u0026#39;{ words = append(words,string(s[l:r])) status = 0 r++ }else{ r++ } } } if status != 0{ words = append(words,string(s[l:r])) } res := \u0026#34;\u0026#34; for i:=len(words)-1;i\u0026gt;=0;i--{ res += words[i] if i != 0{ res += \u0026#34; \u0026#34; } } return res }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":323,"section":"interview","tags":["算法"],"title":"剑指 Offer 58 - I. 翻转单词顺序","uri":"https://www.zhugeqing.top/interview/algorithm/offer/64/"},{"content":"题目入口\n难度：简单\n解题思路：\n1.切片操作\n2.直接赋值\n","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":324,"section":"interview","tags":["算法"],"title":"剑指 Offer 58 - II. 左旋转字符串","uri":"https://www.zhugeqing.top/interview/algorithm/offer/65/"},{"content":"题目入口\n难度：困难\n解题思路：\n单调队列，维护一个递减的单调队列，先将第一个窗口放进队列，每添加一个元素都需要与队尾的元素循环比较，如果大于队尾元素，那就删除队尾元素（双端队列），然后取第一个窗口的最大值，后面的窗口每滑动一次都需要判断队首元素是不是左边窗口抛弃的元素，若是，则需要删除队首元素，然后接下来的操作与第一个窗口一样\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  func maxSlidingWindow(nums []int, k int) []int { if len(nums) == 0 || len(nums) \u0026lt; k{ return []int{} } //单调队列（非严格递减，队首存放窗口最大的元素）  deque := make([]int,0) //返回结果  res := make([]int,0) //先形成第一个窗口  for i:=0;i\u0026lt;k;i++{ //为了保持递减，需要移除比nums[i]小的值  for len(deque) \u0026gt; 0 \u0026amp;\u0026amp; deque[len(deque)-1] \u0026lt; nums[i]{ deque = deque[:len(deque)-1] } deque = append(deque,nums[i]) } //先加入第一个窗口的最大值  res = append(res,deque[0]) for i:=k;i\u0026lt;len(nums);i++{ //如果队首存放的是窗口左边界，那么需要移除队首  if len(deque) \u0026gt; 0 \u0026amp;\u0026amp; deque[0] == nums[i-k]{ deque = deque[1:] } for len(deque) \u0026gt; 0 \u0026amp;\u0026amp; deque[len(deque)-1] \u0026lt; nums[i]{ deque = deque[:len(deque)-1] } deque = append(deque,nums[i]) res = append(res,deque[0]) } return res }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":325,"section":"interview","tags":["算法"],"title":"剑指 Offer 59 - I. 滑动窗口的最大值","uri":"https://www.zhugeqing.top/interview/algorithm/offer/66/"},{"content":"题目入口\n难度：中等\n解题思路：\n单调队列来实现快速寻找maxValue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  type MaxQueue struct { dequeue []int //单调队列  queue []int } func Constructor() MaxQueue { return MaxQueue{} } func (this *MaxQueue) Max_value() int { if len(this.dequeue) == 0{ return -1 } return this.dequeue[0] } func (this *MaxQueue) Push_back(value int) { //在放进队列之前要先对单调队列进行操作  for len(this.dequeue) \u0026gt; 0 \u0026amp;\u0026amp; this.dequeue[len(this.dequeue)-1] \u0026lt; value{ this.dequeue = this.dequeue[:len(this.dequeue)-1] } this.dequeue = append(this.dequeue,value) this.queue = append(this.queue,value) } func (this *MaxQueue) Pop_front() int { if len(this.queue) == 0{ return -1 } val := this.queue[0] if len(this.dequeue) \u0026gt; 0 \u0026amp;\u0026amp; this.dequeue[0] == val{ this.dequeue = this.dequeue[1:] } this.queue = this.queue[1:] return val ;   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":326,"section":"interview","tags":["算法"],"title":"剑指 Offer 59 - II. 队列的最大值","uri":"https://www.zhugeqing.top/interview/algorithm/offer/67/"},{"content":"题目入口\n难度：中等\n解题思路：\n动态规划\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  func dicesProbability(n int) []float64 { dp := make([][]float64,n) for i:=1;i\u0026lt;=n;i++{ //骰子数为i点数和范围为[i,6*i]，大小为6*i - i + 1 = 5*i + 1  dp[i-1] = make([]float64,i*5+1) } //base case  for i:=0;i\u0026lt;6;i++{ dp[0][i] = 1.0/6.0 } //骰子数从2开始  for i:=1;i\u0026lt;n;i++{1 for j:=0;j\u0026lt;len(dp[i-1]);j++{ //新加骰子的点数位1-6，索引对应0-5  for k:=0;k\u0026lt;6;k++{ dp[i][j+k] += dp[i-1][j] / 6.0 } } } return dp[n-1] }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":327,"section":"interview","tags":["算法"],"title":"剑指 Offer 60. n个骰子的点数","uri":"https://www.zhugeqing.top/interview/algorithm/offer/68/"},{"content":"题目入口\n难度：简单\n解题思路：排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  func isStraight(nums []int) bool { n := len(nums) //进行排序  sort.Ints(nums) joker := 0 for i:=0;i\u0026lt;n;i++{ if nums[i] == 0{ joker ++ continue } if i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1]{ return false } } //差值  sub := nums[4] - nums[joker] //如果差值小于5就能构成顺子  return sub \u0026lt; 5 }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":328,"section":"interview","tags":["算法"],"title":"剑指 Offer 61. 扑克牌中的顺子","uri":"https://www.zhugeqing.top/interview/algorithm/offer/69/"},{"content":"题目入口\n难度：简单\n解题思路：动态规划\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  //分析：约瑟环问题:动态规划 //状态方程:dp[n] = num;n表示含有多少个元素的圆环，，num为n个元素组成的环游戏最后剩下的那个数 //状态转移方程:dp[n] = (dp[n-1] + m)%n,dp[n-1] = (dp[n-2]+m)%n-1 //......dp[2] = (dp[1]+m)%2,dp[1] = start（start为开始游戏的第一个数字） //将问题划分为子问题,想要知道n个环游戏最后剩下的数字可变为先求 //n-1个环游戏最后剩下的数字,应为dp[n] = (dp[n-1]+m)%n //递归解法 /* func lastRemaining(n int, m int) int { if n == 1 { return 0 } return (lastRemaining(n-1, m) + m) % n } */ //迭代解法 func lastRemaining(n int, m int) int { dp := 0 //题目从数字零开始 \tfor i := 2; i \u0026lt;= n; i++ { dp = (dp + m) % i } return dp }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":329,"section":"interview","tags":["算法"],"title":"剑指 Offer 62. 圆圈中最后剩下的数字","uri":"https://www.zhugeqing.top/interview/algorithm/offer/70/"},{"content":"题目入口\n难度：中等\n解题思路：\n动态规划\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  func maxProfit(prices []int) int { //动态规划 \t//dp[k][status],k表示当前是第几天(从0开始)，status表示持有状态，1表示持有，0表示不持有 \t//第k天状态为0的最大利润 \tn := len(prices) if n == 0{ return 0 } dp_i_0 := 0 dp_i_1 := -prices[0] for i := 1; i \u0026lt; n; i++ { dp_i_0 = max(dp_i_0, dp_i_1+prices[i]) dp_i_1 = max(dp_i_1, -prices[i]) } return dp_i_0 } func max(a, b int) int { if a \u0026gt; b { return a } return b }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":330,"section":"interview","tags":["算法"],"title":"剑指 Offer 63. 股票的最大利润","uri":"https://www.zhugeqing.top/interview/algorithm/offer/71/"},{"content":"题目入口\n难度：中等\n解题思路：递归加短路特性\n1 2 3 4 5 6 7 8 9 10 11  func sumNums(n int) int { res := 0 var dfs func(n int)bool dfs = func(n int)bool{ res += n return n \u0026gt; 0 \u0026amp;\u0026amp; dfs(n-1) } dfs(n) return res }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":331,"section":"interview","tags":["算法"],"title":"剑指 Offer 64. 求1+2+…+n","uri":"https://www.zhugeqing.top/interview/algorithm/offer/72/"},{"content":"题目入口\n难度：简单\n解题思路：位运算\n1 2 3 4 5 6 7 8 9 10 11 12 13  func add(a int, b int) int { //a+b可化作无进位和加上进位  //无进位和：a ^ b  //进位：a\u0026amp;b \u0026lt;\u0026lt; 1  for b != 0{ c := a\u0026amp;b \u0026lt;\u0026lt; 1 a = a ^ b b = c } return a }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":332,"section":"interview","tags":["算法"],"title":"剑指 Offer 65. 不用加减乘除做加法","uri":"https://www.zhugeqing.top/interview/algorithm/offer/73/"},{"content":"题目入口\n难度：中等\n解题思路：k神题解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  func constructArr(a []int) []int { n := len(a) if n == 0{ return []int{} } dp := make([]int,n) //base case  dp[0] = 1 //下三角  for i:=1;i\u0026lt;n;i++{ dp[i] = dp[i-1]*a[i-1] } //计算上三角需要重新开始  temp := 1 for i:=n-2;i\u0026gt;=0;i--{ temp *= a[i+1] dp[i] *= temp } return dp }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":333,"section":"interview","tags":["算法"],"title":"剑指 Offer 66. 构建乘积数组","uri":"https://www.zhugeqing.top/interview/algorithm/offer/74/"},{"content":"题目入口\n难度：中等\n直接来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  func strToInt(str string) int { n := len(str) if n == 0{ return 0 } res := 0 //符号位  sign := 1 bntry := math.MaxInt32 / 10 //先删除前导空格  i := 0 for i \u0026lt; n \u0026amp;\u0026amp; str[i] == \u0026#39; \u0026#39;{ i++ } //全部都是空格的情况  if i == n{ return 0 } if str[i] == \u0026#39;+\u0026#39;{ sign = 1 i++ }else if str[i] == \u0026#39;-\u0026#39;{ sign = -1 i++ } for i \u0026lt; n{ if str[i] \u0026lt; \u0026#39;0\u0026#39; || str[i] \u0026gt; \u0026#39;9\u0026#39;{ break } if res \u0026gt; bntry || (res == bntry \u0026amp;\u0026amp; str[i] \u0026gt; \u0026#39;7\u0026#39;){ if sign == 1{ return math.MaxInt32 }else{ return math.MinInt32 } } res = res * 10 + int(str[i]-\u0026#39;0\u0026#39;) i++ } return sign * res }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":334,"section":"interview","tags":["算法"],"title":"剑指 Offer 67. 把字符串转换成整数","uri":"https://www.zhugeqing.top/interview/algorithm/offer/75/"},{"content":"题目入口\n难度：简单\n解题思路：利用二叉搜索树的性质\n1.递归\n2.迭代\n1. 1 2 3 4 5 6 7 8 9  func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if p.Val \u0026lt; root.Val \u0026amp;\u0026amp; q.Val \u0026lt; root.Val{ return lowestCommonAncestor(root.Left,p,q) }else if p.Val \u0026gt; root.Val \u0026amp;\u0026amp; q.Val \u0026gt; root.Val{ return lowestCommonAncestor(root.Right,p,q) }else{ return root } }   2. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { //利用二叉搜索树的性质，直接递推  node := root for{ //第一种情况：p,q节点均在当前根节点的右子树  if node.Val \u0026lt; p.Val \u0026amp;\u0026amp; node.Val \u0026lt; q.Val{ node = node.Right //第二种情况：p,q节点均在当前根节点的左子树  }else if node.Val \u0026gt; p.Val \u0026amp;\u0026amp; node.Val \u0026gt; q.Val{ node = node.Left //第三种情况，p,q节点在不同子树，直接返回当前根节点  }else{ return node } } }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":335,"section":"interview","tags":["算法"],"title":"剑指 Offer 68 - I. 二叉搜索树的最近公共祖先","uri":"https://www.zhugeqing.top/interview/algorithm/offer/76/"},{"content":"题目入口\n难度：简单\n解题思路：后序遍历框架\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { //递归终止条件——查找成功或者查找失败  if root == nil || p == root || q == root{ return root } l := lowestCommonAncestor(root.Left,p,q) r := lowestCommonAncestor(root.Right,p,q) if l != nil \u0026amp;\u0026amp; r != nil{ //p,q两节点在不同子树的情况  return root }else if r == nil{ //p,q节点均在左子树的情况  return l }else{ //p,q节点均在右子树或者查找失败的情况  return r } }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":336,"section":"interview","tags":["算法"],"title":"剑指 Offer 68 - II. 二叉树的最近公共祖先","uri":"https://www.zhugeqing.top/interview/algorithm/offer/77/"},{"content":" 此文章取自于微信公众号“低并发编程”\n你是一台电脑，你的名字叫 A\r\n \n经过《如果让你来设计网络》这篇文章中的一番折腾，只要你知道另一位伙伴 B 的 IP 地址，且你们之间的网络是通的，无论多远，你都可以将一个数据包发送给你的伙伴 B\n \n这就是物理层、数据链路层、网络层这三层所做的事情。\n站在第四层的你，就可以不要脸地利用下三层所做的铺垫，随心所欲地发送数据，而不必担心找不到对方了。\n\n \n虽然你此时还什么都没干，但你还是给自己这一层起了个响亮的名字，叫做传输层。\n你本以为自己所在的第四层万事大吉，啥事没有，但很快问题就接踵而至。\n问题来了\r\n前三层协议只能把数据包从一个主机搬到另外一台主机，但是，到了目的地以后，数据包具体交给哪个程序（进程）呢？\n \n所以，你需要把通信的进程区分开来，于是就给每个进程分配一个数字编号，你给它起了一个响亮的名字：端口号。\n \n然后你在要发送的数据包上，增加了传输层的头部，源端口号与目标端口号。\n \nOK，这样你将原本主机到主机的通信，升级为了进程和进程之间的通信。\n你没有意识到，你不知不觉实现了 UDP 协议！\n（当然 UDP 协议中不光有源端口和目标端口，还有数据包长度和校验值，我们暂且略过）\n就这样，你用 UDP 协议无忧无虑地同 B 进行着通信，一直没发生什么问题。\n \n但很快，你发现事情变得非常复杂......\r\n丢包问题\r\n由于网络的不可靠，数据包可能在半路丢失，而 A 和 B 却无法察觉。\n\n \n对于丢包问题，只要解决两个事就好了。\n第一个，A 怎么知道包丢了？\n答案：让 B 告诉 A \n第二个，丢了的包怎么办？\n答案：重传 \n于是你设计了如下方案，A 每发一个包，都必须收到来自 B 的确认（ACK），再发下一个，否则在一定时间内没有收到确认，就重传这个包。\n \n你管它叫停止等待协议。只要按照这个协议来，虽然 A 无法保证 B 一定能收到包，但 A 能够确认 B 是否收到了包，收不到就重试，尽最大努力让这个通信过程变得可靠，于是你们现在的通信过程又有了一个新的特征，可靠交付。\n效率问题\r\n停止等待虽然能解决问题，但是效率太低了，A 原本可以在发完第一个数据包之后立刻开始发第二个数据包，但由于停止等待协议，A 必须等数据包到达了 B ，且 B 的 ACK 包又回到了 A，才可以继续发第二个数据包，这效率慢得可不是一点两点。\n于是你对这个过程进行了改进，采用流水线（Pipelining）的方式，不再傻傻地等。\n\n顺序问题\r\n但是网路是复杂的、不可靠的。\n有的时候 A 发出去的数据包，分别走了不同的路由到达 B，可能无法保证和发送数据包时一样的顺序。\n 在流水线中有多个数据包和ACK包在乱序流动，他们之间对应关系就乱掉了。\n难道还回到停止等待协议？A 每收到一个包的确认（ACK）再发下一个包，那就根本不存在顺序问题。应该有更好的办法！\nA 在发送的数据包中增加一个序号（seq），同时 B 要在 ACK 包上增加一个确认号（ack），这样不但解决了停止等待协议的效率问题，也通过这样标序号的方式解决了顺序问题。\n 而 B 这个确认号意味深长：比如 B 发了一个确认号为 ack = 3，它不仅仅表示 A 发送的序号为 2 的包收到了，还表示 2 之前的数据包都收到了。这种方式叫累计确认或累计应答。\n \n注意，实际上 ack 的号是收到的最后一个数据包的序号 seq + 1，也就是告诉对方下一个应该发的序号是多少。但图中为了便于理解，ack 就表示收到的那个序号，不必纠结。  \n流量问题\r\n有的时候，A 发送数据包的速度太快，而 B 的接收能力不够，但 B 却没有告知 A 这个情况。\n 怎么解决呢？\n很简单，B 告诉 A 自己的接收能力，A 根据 B 的接收能力，相应控制自己的发送速率，就好了。\nB 怎么告诉 A 呢？B 跟 A 说\u0026quot;我很强\u0026quot;这三个字么？那肯定不行，得有一个严谨的规范。\n于是 B 决定，每次发送数据包给 A 时，顺带传过来一个值，叫窗口大小（win)，这个值就表示 B 的接收能力。同理，每次 A 给 B 发包时也带上自己的窗口大小，表示 A 的接收能力。\n\n \nB 告诉了 A 自己的窗口大小值，A 怎么利用它去做 A 这边发包的流量控制呢？\n很简单，假如 B 给 A 传过来的窗口大小 win = 5，那 A 根据这个值，把自己要发送的数据分成这么几类。\n \n图片过于清晰，就不再文字解释了。\n当 A 不断发送数据包时，已发送的最后一个序号就往右移动，直到碰到了窗口的上边界，此时 A 就无法继续发包，达到了流量控制。\n\n \n但是当 A 不断发包的同时，A 也会收到来自 B 的确认包，此时整个窗口会往右移动，因此上边界也往右移动，A 就能发更多的数据包了。\n\n \n以上都是在窗口大小不变的情况下，而 B 在发给 A 的 ACK 包中，每一个都可以重新设置一个新的窗口大小，如果 A 收到了一个新的窗口大小值，A 会随之调整。\n如果 A 收到了比原窗口值更大的窗口大小，比如 win = 6，则 A 会直接将窗口上边界向右移动 1 个单位。\n 如果 A 收到了比原窗口值小的窗口大小，比如 win = 4，则 A 暂时不会改变窗口大小，更不会将窗口上边界向左移动，而是等着 ACK 的到来，不断将左边界向右移动，直到窗口大小值收缩到新大小为止。\n\n \nOK，终于将流量控制问题解决得差不多了，你看着上面一个个小动图，给这个窗口起了一个更生动的名字，滑动窗口(一种算法)。\n拥塞问题\r\n但有的时候，不是 B 的接受能力不够，而是网络不太好，造成了网络拥塞。\n \n拥塞控制与流量控制有些像，但流量控制是受 B 的接收能力影响，而拥塞控制是受网络环境的影响。\n拥塞控制的解决办法依然是通过设置一定的窗口大小，只不过，流量控制的窗口大小是 B 直接告诉 A 的，而拥塞控制的窗口大小按理说就应该是网络环境主动告诉 A。\n但网络环境怎么可能主动告诉 A 呢？只能 A 单方面通过试探，不断感知网络环境的好坏，进而确定自己的拥塞窗口的大小。\n\n \n拥塞窗口大小的计算有很多复杂的算法，就不在本文中展开了，假如拥塞窗口的大小为 cwnd，上一部分流量控制的滑动窗口的大小为 rwnd，那么窗口的右边界受这两个值共同的影响，需要取它俩的最小值。\n窗口大小 = min(cwnd, rwnd)\r\n含义很容易理解，当 B 的接受能力比较差时，即使网络非常通畅，A 也需要根据 B 的接收能力限制自己的发送窗口。当网络环境比较差时，即使 B 有很强的接收能力，A 也要根据网络的拥塞情况来限制自己的发送窗口。正所谓受其短板的影响嘛~\n连接问题\r\n有的时候，B 主机的相应进程还没有准备好或是挂掉了，A 就开始发送数据包，导致了浪费。\n\n \n这个问题在于，A 在跟 B 通信之前，没有事先确认 B 是否已经准备好，就开始发了一连串的信息。就好比你和另一个人打电话，你还没有\u0026quot;喂\u0026quot;一下确认对方有没有在听，你就巴拉巴拉说了一堆。\n这个问题该怎么解决呢？\n地球人都知道，三次握手嘛！\n* A：我准备好了(SYN)\n* B：我知道了(ACK)，我也准备好了(SYN)\n* A：我知道了(ACK)\n\n \nA 与 B 各自在内存中维护着自己的状态变量，三次握手之后，双方的状态都变成了连接已建立（ESTABLISHED）。\n虽然就只是发了三次数据包，并且在各自的内存中维护了状态变量，但这么说总觉得太 low，你看这个过程相当于双方建立连接的过程，于是你灵机一动，就叫它面向连接吧。\n注意：这个连接是虚拟的，是由 A 和 B 这两个终端共同维护的，在网络中的设备根本就不知道连接这回事儿！  \n但凡事有始就有终，有了建立连接的过程，就要考虑释放连接的过程，又是地球人都知道，四次挥手嘛！\n* A：再见，我要关闭了(FIN)\n* B：我知道了(ACK)\n给 B 一段时间把自己的事情处理完\u0026hellip;\n* B：再见，我要关闭了(FIN)\n* A：我知道了(ACK)\n \n总结\r\n以上讲述的，就是 TCP 协议的核心思想，上面过程中需要传输的信息，就体现在 TCP 协议的头部，这里放上最常见的 TCP 协议头解读的图。\n \n不知道你现在再看下面这句话，是否能理解：\nTCP 是\n面向连接的、可靠的、基于字节流的\n传输层通信协议  \n面向连接、可靠，这两个词通过上面的讲述很容易理解，那什么叫做基于字节流呢？\n很简单，TCP 在建立连接时，需要告诉对方 MSS（最大报文段大小）。\n也就是说，如果要发送的数据很大，在 TCP 层是需要按照 MSS 来切割成一个个的TCP 报文段 的。\n切割的时候我才不管你原来的数据表示什么意思，需要在哪里断句啥的，我就把它当成一串毫无意义的字节，在我想要切割的地方咔嚓就来一刀，标上序号，只要接收方再根据这个序号拼成最终想要的完整数据就行了。\n在我 TCP 传输这里，我就把它当做一个个的字节，也就是基于字节流的含义了。\n \n最后留给大家一个作业，模拟 A 与 B 建立一个 TCP 连接。\n第一题：A 给 B 发送 \"aaa\" ，然后 B 给 A 回复一个简单的字符串 \"success\"，并将此过程抓包。 第二题：A 给 B 发送 \"aaaaaa ... a\" 超过最大报文段大小，然后 B 给 A 回复一个简单的字符串 \"success\"，并将此过程抓包。 下面是我抓的包（第二题）\n三次握手阶段\rA -\u0026gt; B\t[SYN] Seq=0 Win=64240 Len=0\rMSS=1460 WS=256\rB - \u0026gt;A\t[SYN, ACK] Seq=0 Ack=1 Win=29200 Len=0\rMSS=1424 WS=512\rA -\u0026gt; B\t[ACK] Seq=1 Ack=1 Win=132352 Len=0\r数据发送阶段\rA -\u0026gt; B\t[ACK] Seq=1 Ack=1 Win=132352 Len=1424\rA -\u0026gt; B\t[ACK] Seq=1425 Ack=1 Win=132352 Len=1424\rA -\u0026gt; B\t[PSH, ACK] Seq=2849 Ack=1 Win=132352 Len=1247\rB -\u0026gt; A\t[ACK] Seq=1 Ack=1425 Win=32256 Len=0\rB -\u0026gt; A\t[ACK] Seq=1 Ack=2849 Win=35328 Len=0\rB -\u0026gt; A\t[ACK] Seq=1 Ack=4096 Win=37888 Len=0\rB -\u0026gt; A\t[PSH, ACK] Seq=1 Ack=4096 Win=37888 Len=7\r四次挥手阶段\rB -\u0026gt; A\t[FIN, ACK] Seq=8 Ack=4096 Win=37888 Len=0\rA -\u0026gt; B\t[ACK] Seq=4096 Ack=9 Win=132352 Len=0\rA -\u0026gt; B\t[FIN, ACK] Seq=4096 Ack=9 Win=132352 Len=0（下面少复制了一行ACK，抱歉）\r后记\r一提到 TCP，可能很多人都想起被三次握手和四次挥手所支配的恐惧。但其实你跟着文中的思路你就会发现，三次握手与四次挥手只占 TCP 所解决的核心问题中很小的一部分，只是因为它在面试中很适合作为知识点进行考察，所以在很多人的印象中就好像 TCP 的核心就是握手和挥手似的。\n本文希望你能从问题出发，真正理解 TCP 所想要解决的问题，你会发现很多原理就好像生活常识一样顺其自然，并不复杂，希望你有收获～\n","description":"了解tcp","id":337,"section":"article","tags":["网络"],"title":"图解 | 你管这破玩意儿叫TCP？","uri":"https://www.zhugeqing.top/article/network/interesting/2/"},{"content":" 此文章取自于微信公众号“低并发编程”\n正文开始：\n你是一台电脑，你的名字叫 A\n很久很久之前，你不与任何其他电脑相连接，孤苦伶仃。\n 直到有一天，你希望与另一台电脑 B 建立通信，于是你们各开了一个网口，用一根网线连接了起来。\n 用一根网线连接起来怎么就能\u0026quot;通信\u0026quot;了呢？我可以给你讲 IO、讲中断、讲缓冲区，但这不是研究网络时该关心的问题。\n如果你纠结，要么去研究一下操作系统是如何处理网络 IO 的，要么去研究一下包是如何被网卡转换成电信号发送出去的，要么就仅仅把它当做电脑里有个小人在开枪吧~\n 反正，你们就是连起来了，并且可以通信。\n 有一天，一个新伙伴 C 加入了，但聪明的你们很快发现，可以每个人开两个网口，用一共三根网线，彼此相连。\n 随着越来越多的人加入，你发现身上开的网口实在太多了，而且网线密密麻麻，混乱不堪。（而实际上一台电脑根本开不了这么多网口，所以这种连线只在理论上可行，所以连不上的我就用红色虚线表示了，就是这么严谨哈哈~）\n 于是你们发明了一个中间设备，你们将网线都插到这个设备上，由这个设备做转发，就可以彼此之间通信了，本质上和原来一样，只不过网口的数量和网线的数量减少了，不再那么混乱。\n 你给它取名叫集线器，它仅仅是无脑将电信号转发到所有出口（广播），不做任何处理，你觉得它是没有智商的，因此把人家定性在了物理层。\n 由于转发到了所有出口，那 BCDE 四台机器怎么知道数据包是不是发给自己的呢？\n首先，你要给所有的连接到集线器的设备，都起个名字。原来你们叫 ABCD，但现在需要一个更专业的，全局唯一的名字作为标识，你把这个更高端的名字称为MAC 地址\n你的 MAC 地址是 aa-aa-aa-aa-aa-aa，你的伙伴 b 的 MAC 地址是 bb-bb-bb-bb-bb-bb，以此类推，不重复就好。\n这样，A 在发送数据包给 B 时，只要在头部拼接一个这样结构的数据，就可以了。\n B 在收到数据包后，根据头部的目标 MAC 地址信息，判断这个数据包的确是发给自己的，于是便收下。\n其他的 CDE 收到数据包后，根据头部的目标 MAC 地址信息，判断这个数据包并不是发给自己的，于是便丢弃。\n 虽然集线器使整个布局干净不少，但原来我只要发给电脑 B 的消息，现在却要发给连接到集线器中的所有电脑，这样既不安全，又不节省网络资源。\n 如果把这个集线器弄得更智能一些，只发给目标 MAC 地址指向的那台电脑，就好了\n 虽然只比集线器多了这一点点区别，但看起来似乎有智能了，你把这东西叫做交换机。也正因为这一点点智能，你把它放在了另一个层级，数据链路层。\n 如上图所示，你是这样设计的。\n交换机内部维护一张 MAC 地址表，记录着每一个 MAC 地址的设备，连接在其哪一个端口上。\n 假如你仍然要发给 B 一个数据包，构造了如下的数据结构从网口出去。\n 到达交换机时，交换机内部通过自己维护的 MAC 地址表，发现目标机器 B 的 MAC 地址 bb-bb-bb-bb-bb-bb 映射到了端口 1 上，于是把数据从 1 号端口发给了 B，完事~\n你给这个通过这样传输方式而组成的小范围的网络，叫做以太网。\n当然最开始的时候，MAC 地址表是空的，是怎么逐步建立起来的呢？\n假如在 MAC 地址表为空是，你给 B 发送了如下数据：\n 由于这个包从端口 4 进入的交换机，所以此时交换机就可以在 MAC地址表记录第一条数据：\n 交换机看目标 MAC 地址（bb-bb-bb-bb-bb-bb）在地址表中并没有映射关系，于是将此包发给了所有端口，也即发给了所有机器。\n之后，只有机器 B 收到了确实是发给自己的包，于是做出了响应，响应数据从端口 1 进入交换机，于是交换机此时在地址表中更新了第二条数据：\n 过程如下：\n 经过该网络中的机器不断地通信，交换机最终将 MAC 地址表建立完毕~\n 随着机器数量越多，交换机的端口也不够了，但聪明的你发现，只要将多个交换机连接起来，这个问题就轻而易举搞定~\n 你完全不需要设计额外的东西，只需要按照之前的设计和规矩来，按照上述的接线方式即可完成所有电脑的互联，所以交换机设计的这种规则，真的很巧妙。你想想看为什么（比如 A 要发数据给 F）。\n但是你要注意，上面那根红色的线，最终在 MAC 地址表中可不是一条记录呀，而是要把 EFGH 这四台机器与该端口（端口6）的映射全部记录在表中。\n最终，两个交换机将分别记录 A ~ H 所有机器的映射记录。\n左边的交换机\n 右边的交换机\n 这在只有 8 台电脑的时候还好，甚至在只有几百台电脑的时候，都还好，所以这种交换机的设计方式，已经足足支撑一阵子了。\n但很遗憾，人是贪婪的动物，很快，电脑的数量就发展到几千、几万、几十万。\n 交换机已经无法记录如此庞大的映射关系了。\n此时你动了歪脑筋，你发现了问题的根本在于，连出去的那根红色的网线，后面不知道有多少个设备不断地连接进来，从而使得地址表越来越大。\n那我可不可以让那根红色的网线，接入一个新的设备，这个设备就跟电脑一样有自己独立的 MAC 地址，而且同时还能帮我把数据包做一次转发呢？\n这个设备就是路由器，它的功能就是，作为一台独立的拥有 MAC 地址的设备，并且可以帮我把数据包做一次转发，你把它定在了网络层。\n 注意，路由器的每一个端口，都有独立的 MAC 地址。\n好了，现在交换机的 MAC 地址表中，只需要多出一条 MAC 地址 ABAB 与其端口的映射关系，就可以成功把数据包转交给路由器了，这条搞定。\n那如何做到，把发送给 C 和 D，甚至是把发送给 DEFGH\u0026hellip;. 的数据包，统统先发送给路由器呢？\n不难想到这样一个点子，假如电脑 C 和 D 的 MAC 地址拥有共同的前缀，比如分别是：\n 那我们就可以说，将目标 MAC 地址为 FFFF-FFFF-？开头的，统统先发送给路由器。\n这样是否可行呢？答案是否定的。\n我们先从现实中 MAC 地址的结构入手，MAC地址也叫物理地址、硬件地址，长度为 48 位，一般这样来表示：  它是由网络设备制造商生产时烧录在网卡的EPROM（一种闪存芯片，通常可以通过程序擦写）。其中前 24 位（00-16-EA）代表网络硬件制造商的编号，后 24 位（AE-3C-40）是该厂家自己分配的，一般表示系列号。只要不更改自己的 MAC 地址，MAC 地址在世界是唯一的。形象地说，MAC地址就如同身份证上的身份证号码，具有唯一性。\n那如果你希望向上面那样将目标 MAC 地址表示为 FFFF-FFFF-？开头的，统一从路由器出去发给某一群设备（后面会提到这其实是子网的概念），那你就需要要求某一子网下统统买一个厂商制造的设备，要么你就需要要求厂商在生产网络设备烧录 MAC 地址时，提前按照你规划好的子网结构来定 MAC 地址，并且日后这个网络的结构都不能轻易改变。\n这显然是不现实的。\n于是你发明了一个新的地址，给每一台机器一个 32 位的编号，如：\n11000000101010000000000000000001\n你觉得有些不清晰，于是把它分成四个部分，中间用点相连。\n11000000.10101000.00000000.00000001\n你还觉得不清晰，于是把它转换成 10 进制。\n192.168.0.1\n最后你给了这个地址一个响亮的名字，IP 地址。现在每一台电脑，同时有自己的 MAC 地址，又有自己的 IP 地址，只不过 IP 地址是软件层面上的，可以随时修改，MAC 地址一般是无法修改的。\n这样一个可以随时修改的 IP 地址，就可以根据你规划的网络拓扑结构，来调整了。\n 如上图所示，假如我想要发送数据包给 ABCD 其中一台设备，不论哪一台，我都可以这样描述，\u0026ldquo;将 IP 地址为 192.168.0 开头的全部发送给到路由器，之后再怎么转发，交给它！\u0026quot;，巧妙吧。\n那交给路由器之后，路由器又是怎么把数据包准确转发给指定设备的呢？\n别急我们慢慢来。\n我们先给上面的组网方式中的每一台设备，加上自己的 IP 地址。\n 现在两个设备之间传输，除了加上数据链路层的头部之外，还要再增加一个网络层的头部。\n假如 A 给 B 发送数据，由于它们直接连着交换机，所以 A 直接发出如下数据包即可，其实网络层没有体现出作用。\n 但假如 A 给 C 发送数据，A 就需要先转交给路由器，然后再由路由器转交给 C。由于最底层的传输仍然需要依赖以太网，所以数据包是分成两段的。\nA ~ 路由器这段的包如下：  路由器到 C 这段的包如下：\n 好了，上面说的两种情况（A-\u0026gt;B，A-\u0026gt;C），相信细心的读者应该会有不少疑问，下面我们一个个来展开。\nA 给 C 发数据包，怎么知道是否要通过路由器转发呢？\n答案：子网 \n如果源 IP 与目的 IP 处于一个子网，直接将包通过交换机发出去。\n如果源 IP 与目的 IP 不处于一个子网，就交给路由器去处理。\n好，那现在只需要解决，什么叫处于一个子网就好了。\n 192.168.0.1 和 192.168.0.2 处于同一个子网 192.168.0.1 和 192.168.1.1 处于不同子网  这两个是我们人为规定的，即我们想表示，对于 192.168.0.1 来说：\n192.168.0.xxx 开头的，就算是在一个子网，否则就是在不同的子网。 \n那对于计算机来说，怎么表达这个意思呢？于是人们发明了子网掩码的概念。\n假如某台机器的子网掩码定为 255.255.255.0。\n这表示，将源 IP 与目的 IP 分别同这个子网掩码进行与运算，相等则是在一个子网，不相等就是在不同子网，就这么简单。\n比如：\n  A电脑：192.168.0.1 \u0026amp; 255.255.255.0 = 192.168.0.0\n  B电脑：192.168.0.2 \u0026amp; 255.255.255.0 = 192.168.0.0\n  C电脑：192.168.1.1 \u0026amp; 255.255.255.0 = 192.168.1.0\n  D电脑：192.168.1.2 \u0026amp; 255.255.255.0 = 192.168.1.0\n那么 A 与 B 在同一个子网，C 与 D 在同一个子网，但是 A 与 C 就不在同一个子网，与 D 也不在同一个子网，以此类推。\n   所以如果 A 给 C 发消息，A 和 C 的 IP 地址分别 \u0026amp; A 机器配置的子网掩码，发现不相等，则 A 认为 C 和自己不在同一个子网，于是把包发给路由器，就不管了，之后怎么转发，A 不关心。\nA 如何知道，哪个设备是路由器？\n答案：在 A 上要设置默认网关 \n上一步 A 通过是否与 C 在同一个子网内，判断出自己应该把包发给路由器，那路由器的 IP 是多少呢？\n其实说发给路由器不准确，应该说 A 会把包发给默认网关。\n对 A 来说，A 只能直接把包发给同处于一个子网下的某个 IP 上，所以发给路由器还是发给某个电脑，对 A 来说也不关心，只要这个设备有个 IP 地址就行。\n所以默认网关，就是 A 在自己电脑里配置的一个 IP 地址，以便在发给不同子网的机器时，发给这个 IP 地址。\n 路由器如何知道C在哪里？\n答案：路由表 \n现在 A 要给 C 发数据包，已经可以成功发到路由器这里了，最后一个问题就是，路由器怎么知道，收到的这个数据包，该从自己的哪个端口出去，才能直接（或间接）地最终到达目的地 C 呢。\n路由器收到的数据包有目的 IP 也就是 C 的 IP 地址，需要转化成从自己的哪个端口出去，很容易想到，应该有个表，就像 MAC 地址表一样。\n这个表就叫路由表。\n至于这个路由表是怎么出来的，有很多路由算法，本文不展开，因为我也不会哈哈~\n不同于 MAC 地址表的是，路由表并不是一对一这种明确关系，我们下面看一个路由表的结构。\n 我们学习一种新的表示方法，由于子网掩码其实就表示前多少位表示子网的网段，所以如 192.168.0.0（255.255.255.0） 也可以简写为 192.168.0.0/24。\n 这就很好理解了，路由表就表示，这个子网下的，都转发到 0 号端口，192.168.1.xxx 这个子网下的，都转发到 1 号端口192.168.0.xxx 。下一跳列还没有值，我们先不管。\n配合着结构图来看（这里把子网掩码和默认网关都补齐了）结果应该是 0\n 刚才说的都是 IP 层，但发送数据包的数据链路层需要知道 MAC 地址，可是我只知道 IP 地址该怎么办呢？\n答案：arp 假如你（A）此时不知道你同伴 B 的 MAC 地址（现实中就是不知道的，刚刚我们只是假设已知），你只知道它的 IP 地址，你该怎么把数据包准确传给 B 呢？\n答案很简单，在网络层，我需要把 IP 地址对应的 MAC 地址找到，也就是通过某种方式，找到192.168.0.2  对应的 MAC 地址 BBBB。\n这种方式就是 arp 协议，同时电脑 A 和 B 里面也会有一张 arp 缓存表，表中记录着 IP 与 MAC 地址的对应关系。\n 一开始的时候这个表是空的，电脑 A 为了知道电脑 B（192.168.0.2）的 MAC 地址，将会广播一条 arp 请求，B 收到请求后，带上自己的 MAC 地址给 A 一个响应。此时 A 便更新了自己的 arp 表。\n这样通过大家不断广播 arp 请求，最终所有电脑里面都将 arp 缓存表更新完整\n总结一下 好了，总结一下，到目前为止就几条规则：\n从各个节点的视角来看\n电脑视角：\n  首先我要知道我的 IP 以及对方的 IP\n  通过子网掩码判断我们是否在同一个子网\n  在同一个子网就通过 arp 获取对方 mac 地址直接扔出去\n  不在同一个子网就通过 arp 获取默认网关的 mac 地址直接扔出去\n  交换机视角：\n  我收到的数据包必须有目标 MAC 地址\n  通过 MAC 地址表查映射关系\n  查到了就按照映射关系从我的指定端口发出去\n  查不到就所有端口都发出去\n  路由器视角：\n  我收到的数据包必须有目标 IP 地址\n  通过路由表查映射关系\n  查到了就按照映射关系从我的指定端口发出去（不在任何一个子网范围，走其路由器的默认网关也是查到了）\n  查不到则返回一个路由不可达的数据包\n  如果你嗅觉足够敏锐，你应该可以感受到下面这句话：\n网络层（IP协议）本身没有传输包的功能，包的实际传输是委托给数据链路层（以太网中的交换机）来实现的。 涉及到的三张表分别是\n  交换机中有 MAC地址表用于映射 MAC 地址和它的端口\n  路由器中有路由表用于映射 IP 地址(段)和它的端口\n  电脑和路由器中都有 arp 缓存表用于缓存 IP 和 MAC 地址的映射关系\n  这三张表是怎么来的\n  MAC 地址表是通过以太网内各节点之间不断通过交换机通信，不断完善起来的。\n  路由表是各种路由算法 + 人工配置逐步完善起来的。\n  arp 缓存表是不断通过 arp 协议的请求逐步完善起来的。\n知道了以上这些，目前网络上两个节点是如何发送数据包的这个过程，就完全可以解释通了！\n  那接下来我们就放上本文 最后一个网络拓扑图吧，请做好 战斗准备！\n 这时路由器 1 连接了路由器 2，所以其路由表有了下一条地址这一个概念，所以它的路由表就变成了这个样子。如果匹配到了有下一跳地址的一项，则需要再次匹配，找到其端口，并找到下一跳 IP 的 MAC 地址。\n也就是说找来找去，最终必须能映射到一个端口号，然后从这个端口号把数据包发出去。\n 这时如果 A 给 F 发送一个数据包，能不能通呢？如果通的话整个过程是怎样的呢？\n 思考一分钟\u0026hellip;\n详细过程文字描述：\n1. 首先A（192.168.0.1） 通过子网掩码（255.255.255.0）计算出自己与F（192.168.2.2） 并不在同一个子网内，于是决定发送给默认网关（192.168.0.254） 。\n2. A 通过 ARP 找到默认网关 192.168.0.254 的 MAC 地址。\n3. A 将源 MAC 地址（AAAA）与网关 MAC 地址（ABAB）封装在数据链路层头部，又将源 IP 地址（192.168.0.1）和目的 IP 地址（192.168.2.2）（注意这里千万不要以为填写的是默认网关的 IP 地址，从始至终这个数据包的两个 IP 地址都是不变的，只有 MAC 地址在不断变化）封装在网络层头部，然后发包。\n 4. 交换机 1 收到数据包后，发现目标 MAC 地址是 ABAB，转发给路由器 1。\n5. 数据包来到了路由器 1，发现其目标 IP 地址是 192.168.2.2，查看其路由表，发现了下一跳的地址是 192.168.100.5。\n6. 所以此时路由器 1 需要做两件事，第一件是再次匹配路由表，发现匹配到了端口为 2，于是将其封装到数据链路层，最后把包从2 号口发出去。\n7. 此时路由器 2 收到了数据包，看到其目的地址是 192.168.2.2，查询其路由表，匹配到端口号为 1，准备从1 号口 把数据包送出去。\n8. 但此时路由器 2 需要知道192.168.2.2 的 MAC 地址了，于是查看其 arp 缓存，找到其 MAC 地址为FFFF ，将其封装在数据链路层头部，并从 1 号端口把包发出去。\n9.交换机 3 收到了数据包，发现目的 MAC 地址为FFFF ，查询其 MAC 地址表，发现应该从其6 号端口 出去，于是从 6 号端口把数据包发出去。\n10. F 最终收到了数据包！并且发现目的 MAC 地址就是自己，于是收下了这个包。\n 至此，经过物理层、数据链路层、网络层这前三层的协议，以及根据这些协议设计的各种网络设备（网线、集线器、交换机、路由器），理论上只要拥有对方的 IP 地址，就已经将地球上任意位置的两个节点连通了。\n - 完 -\n","description":"了解网络","id":338,"section":"article","tags":["网络"],"title":"如果让你来设计网络，你会把它弄成啥样？","uri":"https://www.zhugeqing.top/article/network/interesting/1/"},{"content":"如果递归函数中，只进行一次递归调用，递归深度为depth；在每个递归函数中，时间复杂度为T;则总体的时间复杂度为O(T*depth)\n力扣 50. Pow(x, n)\n实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，x^n）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  func myPow(x float64, n int) float64 { if x == 0{ return 0 }else if x \u0026gt; 0{ return pre(x,n) }else{ return 1/pre(x,n) } } func pre(x float64, n int) float64{ if n == 0{ return 1 } if n == 1{ return x } y := pre(x,n/2) if n % 2 == 0{ //说明n是偶数幂,递归整除2不丢数  return y * y }else { //说明n是奇数幂,递归整除2丢一个x  return x * y * y } }   递归深度：logn\n时间复杂度：O(logn)\n","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":339,"section":"interview","tags":["算法"],"title":"第二章第三节","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter2/3/"},{"content":"``二叉树的问题都能用前、中、后序遍历的框架解决`\n104. 二叉树的最大深度\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func max(i,j int)int{ if i \u0026gt;= j{ return i }else{ return j } } func maxDepth(root *TreeNode) int { if root == nil{ return 0 } //加1是当前节点，  return max(maxDepth(root.Left),maxDepth(root.Right)) + 1 }   111. 二叉树的最小深度\n递归写法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func minDepth(root *TreeNode) int { //无法写成二叉树最大深度的写法，因为需要考虑该分支是否有叶子节点  if root == nil{ return 0 } //如果左右节点都为不为空，则进行递归比较  if root.Left != nil \u0026amp;\u0026amp; root.Right != nil{ return 1 + min(minDepth(root.Left),minDepth(root.Right)) } if root.Left != nil{ return 1 + minDepth(root.Left) }else if root.Right != nil{ return 1 + minDepth(root.Right) }else { return 1 } } // 判断大小函数 func min(a,b int)int{ if a \u0026gt; b{ return b }else { return a } }   队列写法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func minDepth(root *TreeNode) int { if root == nil{ return 0 } //采用队列（广度优先编列）  //记录每一条路径  queue := make([]*TreeNode,0) //记录每一条路径的深度  count := make([]int,0) //入队列  queue = append(queue,root) count = append(count,1) //记录的索引  index := 0 //广度优先遍历，一层一层遍历，遇到没有左右孩子节点就退出循环  for len(queue) \u0026gt; 0{ temp := queue[index] if temp.Left == nil \u0026amp;\u0026amp; temp.Right == nil{ return count[index] } if temp.Left != nil{ queue = append(queue,temp.Left) count = append(count,count[index]+1) } if temp.Right != nil{ queue = append(queue,temp.Right) count = append(count,count[index]+1) } index++ } return 0 }   100. 相同的树\n递归写法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  func isSameTree(p *TreeNode, q *TreeNode) bool { if p == nil \u0026amp;\u0026amp; q == nil{ return true } if p == nil || q== nil{ return false } if p.Val != q.Val{ return false } return isSameTree(p.Left,q.Left) \u0026amp;\u0026amp; isSameTree(p.Right,q.Right) }   迭代写法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  func isSameTree(p *TreeNode, q *TreeNode) bool { //迭代写法  //构建队列  queue := make([]*TreeNode,0) //将两个根节点加入队列  queue = append(queue,p) queue = append(queue,q) for len(queue) \u0026gt; 0 { //取队首两个元素  u := queue[0] v := queue[1] //出队列  queue = queue[2:] //若两个节点都为空，则跳到下一轮比较  if u == nil \u0026amp;\u0026amp; v == nil{ continue } //若其中一个节点为空，而另外一个节点不为空，则返回false  if u == nil || v == nil{ return false } //若两个节点都不为空，但是不相等，则返回false  if u.Val != v.Val{ return false } queue = append(queue,u.Left) queue = append(queue,v.Left) queue = append(queue,u.Right) queue = append(queue,v.Right) } return true }   101. 对称二叉树\n递归写法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  func compare(p,q *TreeNode)bool{ if p == nil \u0026amp;\u0026amp; q == nil{ return true } if p == nil || q == nil{ return false } // //等价于  // if p != nil \u0026amp;\u0026amp; q == nil{  // return false  // }else if p == nil \u0026amp;\u0026amp; q != nil{  // return false  // }  if p.Val != q.Val{ return false } //进行递归(镜像处理p的左节点应与q的右节点进行比较，同时q的左节点也应该与)  return compare(p.Left,q.Right) \u0026amp;\u0026amp; compare(p.Right,q.Left) } func isSymmetric(root *TreeNode) bool { // 设立两指针来递归比较  //左右分开  return compare(root,root) }   迭代写法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  func isSymmetric(root *TreeNode) bool { //构建队列来进行层序遍历，不断遍历将左右节点存入队列中  queue := make([]*TreeNode,0) //根节点入队，比较两边的镜像  queue = append(queue,root) queue = append(queue,root) //迭代过程  for len(queue) \u0026gt; 0{ p := queue[0] q := queue[1] //出队列  queue = queue[2:] //进行比较  if p == nil \u0026amp;\u0026amp; q == nil{ //每次只比较两个  continue } if p == nil || q == nil{ return false } if p.Val != q.Val{ return false } queue = append(queue,p.Left) queue = append(queue,q.Right) queue = append(queue,p.Right) queue = append(queue,q.Left) } return true }   222. 完全二叉树的节点个数　1 2 3 4 5 6 7  func countNodes(root *TreeNode) int { if root == nil{ return 0 } return countNodes(root.Left) + countNodes(root.Right) + 1 }   110. 平衡二叉树\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  func isBalanced(root *TreeNode) bool { //因为-1是不平衡的信号，使用要查看是否大于0  return height(root) \u0026gt;= 0 } func height(root *TreeNode)int{ //后序遍历  if root == nil{ return 0 } //求左右子树的高度  leftHeight := height(root.Left) rightHeight := height(root.Right) //-1传递一个不平衡的信号，abs（）来检验是否两边节点数之差已经大于了1  if leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) \u0026gt; 1{ return -1 } //加1算上它自身，  return max(leftHeight,rightHeight) + 1 } func max(x, y int) int { if x \u0026gt; y { return x } return y } func abs(x int)int{ if x \u0026lt; 0{ return -x }else{ return x } }   404. 左叶子之和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  func sumOfLeftLeaves(root *TreeNode) int { if root == nil{ return 0 } res := 0 var sum func(root *TreeNode) sum = func (root *TreeNode){ if root == nil{ return } //递归终止条件  if root.Left != nil \u0026amp;\u0026amp; root.Left.Left == nil \u0026amp;\u0026amp; root.Left.Right == nil{ res += root.Left.Val } sum(root.Left) sum(root.Right) } sum(root) return res }   总结  遍历完某条路径用前序遍历递归框架  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":340,"section":"interview","tags":["算法"],"title":"第七章第一节","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter7/1/"},{"content":"257. 二叉树的所有路径\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  func binaryTreePaths(root *TreeNode) []string { if root == nil { return []string{} }else if root.Left == nil \u0026amp;\u0026amp; root.Right == nil{ return []string{strconv.Itoa(root.Val)} } res := make([]string, 0) var tarversal func(root *TreeNode, subStr string) tarversal = func(root *TreeNode, subStr string) { if root == nil{ return } if root.Right == nil \u0026amp;\u0026amp; root.Left == nil{ res = append(res, subStr+ \u0026#34;-\u0026gt;\u0026#34;+strconv.Itoa(root.Val)) return } tarversal(root.Left,subStr + \u0026#34;-\u0026gt;\u0026#34;+ strconv.Itoa(root.Val)) tarversal(root.Right,subStr + \u0026#34;-\u0026gt;\u0026#34;+ strconv.Itoa(root.Val)) } tarversal(root.Left,strconv.Itoa(root.Val)) tarversal(root.Right,strconv.Itoa(root.Val)) return res }   113. 路径总和 II\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  func pathSum(root *TreeNode, targetSum int) [][]int { if root == nil{ return [][]int{} } //返回数组  res := make([][]int,0) var tarverSal func(root *TreeNode,nums []int,target int) tarverSal = func(root *TreeNode,nums []int,target int){ if root == nil{ return } target = target+root.Val nums1 := make([]int,len(nums)) copy(nums1,nums) nums1 = append(nums1,root.Val) if root.Left == nil \u0026amp;\u0026amp; root.Right == nil \u0026amp;\u0026amp; target == targetSum{ res = append(res,nums1) return } tarverSal(root.Left,nums1,target) tarverSal(root.Right,nums1,target) } tarverSal(root,[]int{},0) return res }   129. 求根节点到叶节点数字之和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  func sumNumbers(root *TreeNode) int { res := 0 var dfs func(root *TreeNode,sum int) dfs = func(root *TreeNode,sum int){ if root == nil{ return } //前序遍历  sum = sum * 10 + root.Val if root.Left == nil \u0026amp;\u0026amp; root.Right == nil{ res += sum return } dfs(root.Left,sum) dfs(root.Right,sum) } dfs(root,0) return res }   437. 路径总和 III\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  func findPath(root *TreeNode,sum int)int{ if root == nil{ return 0 } res := 0 if root.Val == sum{ res += 1 } //存在负数，会导致路径之和还是可能等于targetSum  res += findPath(root.Left,sum-root.Val) res += findPath(root.Right,sum-root.Val) //返回所有的路径之和  return res } func pathSum(root *TreeNode, targetSum int) int { //跟随bobo老师的解法  if root == nil{ return 0 } //需要有两步  //1.包含root节点的路径之和等于targetSum  //2.不包含root节点的路径之和等于targetSum(递归调用即可)  res := findPath(root,targetSum) //递归调用，不包含root节点的路径之和也等于targetSum  res += pathSum(root.Left,targetSum) res += pathSum(root.Right,targetSum) return res }   二分搜索树 235. 二叉搜索树的最近公共祖先\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { //利用二叉搜索树的性质，直接递推  node := root for{ //第一种情况：p,q节点均在当前根节点的右子树  if node.Val \u0026lt; p.Val \u0026amp;\u0026amp; node.Val \u0026lt; q.Val{ node = node.Right //第二种情况：p,q节点均在当前根节点的左子树  }else if node.Val \u0026gt; p.Val \u0026amp;\u0026amp; node.Val \u0026gt; q.Val{ node = node.Left //第三种情况，p,q节点在不同子树，直接返回当前根节点  }else{ return node } } }   98. 验证二叉搜索树\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  func search(root *TreeNode,low,high int)bool{ if root == nil{ return true } //超出边界，直接返回false  if root.Val \u0026lt;= low || root.Val \u0026gt;= high{ return false } //对于左子树，下界不变，上界变为根节点的值  left := search(root.Left,low,root.Val) //对于右子树，上界不变，下界变为根节点的值  right := search(root.Right,root.Val,high) return left \u0026amp;\u0026amp; right } func isValidBST(root *TreeNode) bool { if root == nil{ return true } //根节点的上下界一个在最大值和最小值中  return search(root,math.MinInt64,math.MaxInt64) }   450. 删除二叉搜索树中的节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  func delete(root *TreeNode,key int)*TreeNode{ if root == nil{ return nil } if key \u0026lt; root.Val{ root.Left = delete(root.Left,key) }else if key \u0026gt; root.Val{ root.Right = delete(root.Right,key) }else{ if root.Left == nil{ return root.Right } if root.Right == nil{ return root.Left } //如果左右子树都存在，尝试将左子树作为右子树最小节点的子树  node := root.Right for node.Left != nil{ node = node.Left } node.Left = root.Left return root.Right } return root } func deleteNode(root *TreeNode, key int) *TreeNode { if root == nil{ return nil } return delete(root,key) }   108. 将有序数组转换为二叉搜索树\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buileTree(nums []int,low,high int)*TreeNode{ if low \u0026gt; high{ return nil } middle := (low+high+1)/2 val := nums[middle] root := \u0026amp;TreeNode{ Val : val, } root.Left = buileTree(nums,low,middle-1) root.Right = buileTree(nums,middle+1,high) return root } func sortedArrayToBST(nums []int) *TreeNode { // 前序遍历，选取中间节点  return buileTree(nums,0,len(nums)-1) }   230. 二叉搜索树中第K小的元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  //求一棵树的节点数 func count(root *TreeNode)int{ if root == nil{ return 0 } return count(root.Left) + count(root.Right) + 1 } func kthSmallest(root *TreeNode, k int) int { if root == nil{ return 0 } //求左子树的节点数和当前节点之和，即可知道当前是第几小的  nodeCount := count(root.Left) + 1 if nodeCount == k{ //如果相等，找到返回  return root.Val }else if nodeCount \u0026gt; k{ //如果nodeCount大于k，说明第k小的数在左子树中，向左递归  return kthSmallest(root.Left,k) }else{ //如果nodeCount小于k，说明第k小的数在右子树中，向左递归，同时k减去nodeCount  return kthSmallest(root.Right,k-nodeCount) } return -1 }   236. 二叉树的最近公共祖先\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil{ return nil } //如果root节点的值与p,q任意节点的值相等，直接返回root  if root.Val == p.Val || root.Val == q.Val{ return root } //向两边搜索  left := lowestCommonAncestor(root.Left,p,q) right := lowestCommonAncestor(root.Right,p,q) if left != nil \u0026amp;\u0026amp; right != nil{ return root } if left != nil{ return left }else{ return right } }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":341,"section":"interview","tags":["算法"],"title":"第七章第二节","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter7/2/"},{"content":"如何写出正确的程序】  ``正确地处理边界  例：二分查找法（边界处理）\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  int binarySearch(int arr[],int n,int target) { //n为数组的长度，target为需要查找的目标  int l = 0 , r = n;//在[l...r)的 范围内查找target  while(l\u0026lt;r){ //int mid = (l+r)/2;//可能含有Bug，整形溢出  //要明确l,r的取值意义，搜索区间的访问，进行循环搜索，缩小区间时也要保证不越界，也不丢界  int mid = l + (r - l) / 2; if(arr[mid] == taget){ return mid; } if arr[mid] \u0026gt; target{ l = mid + 1; }else { r = mid;//target在[l..mid)中  } } return -1; }     1 2 3 4 5 6 7 8 9 10 11 12 13 14  func binarySearch(arr []int,target int)int{ l,r := 0,len(arr) //在[l...r)的 范围内查找target  for l \u0026lt; r{ //mid := (l + r ) / 2可能含有Bug，整形溢出  mid := l + (r - l)/2 if target \u0026gt; arr[mid]{ l = mid+1 }else{ r = mid //target在[l...mid)中  } } return -1 }       'use strict'; var containerId = JSON.parse(\"\\\"990423c61028c0a0\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \n 明确变量的含义 循环不变量（不改变含义） 小数据调试（要有耐心调试的习惯，技术员的核心竞争力） 大数据调试（扩展程序的正确性，测试程序的性能）  小练习(力扣官网)  283题 27题 26题 80题  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":342,"section":"interview","tags":["算法"],"title":"第三章第一节","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter3/1/"},{"content":"509. 斐波那契数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func fib(n int)int{ if n == 0 || n == 1{ return n } dp := make([]int,n+1) dp[0] = 0 dp[1] = 1 for i:=2;i\u0026lt;=n;i++{ dp[i] = dp[i-1] + dp[i-2] } return dp[n]   70. 爬楼梯\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  func climbStairs(n int) int { if n == 0 || n == 1{ return 1 } dp := make([]int,n+1) dp[0] = 1 dp[1] = 1 for i:=2;i\u0026lt;=n;i++{ dp[i] = dp[i-1] + dp[i-2] } return dp[n] }   120. 三角形最小路径和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  func minimumTotal(triangle [][]int) int { m:=len(triangle) var min func(a,b int)int min = func(a,b int)int{ if a \u0026lt; b{ return a } return b } //动态规划  //自低向上，求出每一行从下一行的最短路径和，从倒数第二行开始  for i:=m-2;i\u0026gt;=0;i--{ for j:=0;j\u0026lt;len(triangle[i]);j++{ triangle[i][j] += min(triangle[i+1][j],triangle[i+1][j+1]) } } return triangle[0][0] }   64. 最小路径和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  func minPathSum(grid [][]int) int { //动态规划(直接省略dp数组，用原数组当dp数组)  m,n := len(grid),len(grid[0]) //向求出上边的路径  for i:=1;i\u0026lt;n;i++{ grid[0][i] += grid[0][i-1] } //求出左边的路径  for j:=1;j\u0026lt;m;j++{ grid[j][0] += grid[j-1][0] } //再求[1-len(grid)]行[1-len(grid[0])]列的路径  for i:=1;i\u0026lt;m;i++{ for j:=1;j\u0026lt;n;j++{ grid[i][j] += min(grid[i-1][j],grid[i][j-1]) } } return grid[m-1][n-1] } func min(x,y int)int{ if x \u0026lt; y{ return x } return y }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":343,"section":"interview","tags":["算法"],"title":"第九章第一节","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter9/1/"},{"content":"206. 反转链表\n1 2 3 4 5 6 7 8 9 10 11 12 13  func reverseList(head *ListNode) *ListNode { var pre *ListNode curr := head next := head for curr != nil{ next = curr.Next //next后移  curr.Next = pre //翻转一个节点  pre = curr //pre后移  curr = next //curr后移  } return pre }   92. 反转链表 II\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func reverseBetween(head *ListNode, left int, right int) *ListNode { //反转位置left -- 位置right的节点 \tdummy := \u0026amp;ListNode{Next: head} //哑巴节点 \tpre := dummy //前驱节点 \tfor i:=0;i\u0026lt;left-1;i++{//使得pre指向left位置的前驱节点 \tpre = pre.Next //一共移动left-1步 \t} curr := pre.Next //指向需要反转的节点 \tfor i:=0;i\u0026lt;right-left;i++{ //一个需要反转right-left次 \tnext := curr.Next curr.Next = next.Next next.Next = pre.Next pre.Next = next } return dummy.Next }   83. 删除排序链表中的重复元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func deleteDuplicates(head *ListNode) *ListNode { dummy := \u0026amp;ListNode{Next: head,Val: math.MaxInt64} curr := head pre := dummy.Next //前驱节点 \tfor curr != nil{ if pre.Val == curr.Val{//相同则删除节点 \tpre.Next = curr.Next curr = curr.Next }else { //不相同，直接后移 \tpre = curr curr = curr.Next } } return dummy.Next }   86. 分隔链表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  func partition(head *ListNode, x int) *ListNode { //维护两个链表，一个smallList存放小于x的元素，一个largeList存放大于等于x的元素  smallList := \u0026amp;ListNode{} smallHead := smallList largeList := \u0026amp;ListNode{} largeHead := largeList for head != nil{ if head.Val \u0026lt; x{ //小于x放入smallList  smallList.Next = head smallList = smallList.Next }else{ //大于等于x放入largeList  largeList.Next = head largeList = largeList.Next } head = head.Next //遍历指针后移  } largeList.Next = nil //将largeList的下一个节点指针清空  smallList.Next = largeHead.Next return smallHead.Next }   328. 奇偶链表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  func oddEvenList(head *ListNode) *ListNode { //类似于86题，维护两个链表，一个装奇数编号，一个装偶数编号  odd := \u0026amp;ListNode{} oddHead := odd //奇数链表的头结点  even := \u0026amp;ListNode{} evenHead := even //偶数链表的头结点  id := 1 for head != nil{ if id % 2 == 0{ //装入偶数链表  even.Next = head even = even.Next } else{ //装入奇数链表  odd.Next = head odd = odd.Next } id++ head = head.Next } //奇数编号在前，偶数编号在后，连接两个链表  even.Next = nil //断开偶数链表后的连接  odd.Next = evenHead.Next return oddHead.Next }   2. 两数相加\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { //采用加法器原理，因为有int64也装不下的示例  carry := 0 //这是进位  sum := 0//和  dummy := \u0026amp;ListNode{} //创建哑巴节点  head := dummy //用来遍历的节点  for l1 != nil || l2 != nil{ sum = 0 //重新置零  if l1 != nil{ sum += l1.Val l1 = l1.Next } if l2 != nil{ sum += l2.Val l2 = l2.Next } //sum存储当前位结果，carry存储  sum ,carry= (sum%10 + carry)%10 , (sum + carry) / 10 head.Next = \u0026amp;ListNode{Val:sum} head = head.Next } if carry != 0{ head.Next = \u0026amp;ListNode{Val:carry} } return dummy.Next }   445. 两数相加 II\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { //类似于第二题，自制加法器，不过需要额外的空间来存储  //辅助空间，采用两个切片来记录链表中的数字  nums1 := make([]int, 0) nums2 := make([]int, 0) for l1 != nil || l2 != nil{ if l1 != nil{ nums1 = append(nums1, l1.Val) l1 = l1.Next } if l2 != nil{ nums2 = append(nums2, l2.Val) l2 = l2.Next } } res := make([]int, 0) carry := 0 //进位  dummy := \u0026amp;ListNode{} //哑节点  head := dummy for len(nums1) !=0 || len(nums2) != 0{//直到两个数组为空  sum := 0 if len(nums1) != 0{ sum += nums1[len(nums1)-1] nums1 = nums1[:len(nums1)-1] } if len(nums2) != 0{ sum += nums2[len(nums2)-1] nums2 = nums2[:len(nums2)-1] } sum += carry sum,carry = sum % 10,sum / 10 res = append(res, sum) } if carry \u0026gt; 0{ //可能还有进位  res = append(res, carry) } for len(res) != 0 { head.Next = \u0026amp;ListNode{Val:res[len(res)-1]} head = head.Next res = res[:len(res)-1] } return dummy.Next }   203. 移除链表元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func removeElements(head *ListNode, val int) *ListNode { dummy := \u0026amp;ListNode{Next:head} //哑节点(虚拟节点)  pre := dummy //通过pre来删除目标节点  //用head来遍历链表  for head != nil{ if head.Val == val{//找到节点  pre.Next = head.Next }else{ pre = pre.Next } head = head.Next } return dummy.Next }   82. 删除排序链表中的重复元素 II\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  func deleteDuplicates(head *ListNode) *ListNode { //一次遍历解法，也不算难理解  dummy := \u0026amp;ListNode{Next:head} //哑节点  pre := dummy //通过pre来进行删除操作  // 一次遍历两个节点  for pre.Next != nil \u0026amp;\u0026amp; pre.Next.Next != nil{ val := pre.Next.Val //存储值，用来判断有没有重复的元素，有则删除，无则跳过  if pre.Next.Next.Val == val{ for pre.Next != nil \u0026amp;\u0026amp; pre.Next.Val == val{ pre.Next = pre.Next.Next //跳跃  } //for  }else{ pre = pre.Next //没有重复元素，往后移动  } } return dummy.Next }   21. 合并两个有序链表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { //类似归并排序写法  dummy := \u0026amp;ListNode{} //哑节点  prehead := dummy for l1 != nil \u0026amp;\u0026amp; l2 != nil { if l1.Val \u0026lt;= l2.Val { prehead.Next = l1 l1 = l1.Next }else{ prehead.Next = l2 l2 = l2.Next } prehead = prehead.Next } if l1 != nil { //把剩下的节点接上  prehead.Next = l1 } if l2 != nil { prehead.Next = l2 } return dummy.Next }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":344,"section":"interview","tags":["算法"],"title":"第五章第一节","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter5/1/"},{"content":"24. 两两交换链表中的节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func swapPairs(head *ListNode) *ListNode { dummy := \u0026amp;ListNode{Next:head} //虚拟节点  pre := dummy //遍历链表  for pre.Next != nil \u0026amp;\u0026amp; pre.Next.Next != nil{ node1 := pre.Next node2 := pre.Next.Next node1.Next = node2.Next node2.Next = node1 pre.Next = node2 pre = pre.Next.Next //前进两步  } return dummy.Next }   25. K 个一组翻转链表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  func reverse(head *ListNode,k int){ curr := head.Next for i:=0;i\u0026lt;k-1;i++{ //只需要移动k-1个节点  node := curr.Next curr.Next = node.Next node.Next = head.Next head.Next = node } } func reverseKGroup(head *ListNode, k int) *ListNode { if k == 1 || head == nil{ //k=1时，不需要交换  return head } //穿针引线  dummy := \u0026amp;ListNode{Next:head} //虚拟节点  pre := dummy //用于遍历的节点  for pre.Next != nil{ i := 0 curr := pre.Next for i!=k \u0026amp;\u0026amp; curr != nil{ //判断是否满足反转条件  i++ curr = curr.Next } if i != k{ return dummy.Next //节点不够用，直接返回  }else{ reverse(pre,k) //翻转操作  for i:=0;i\u0026lt;k;i++{ //pre前进k步  pre = pre.Next } } } return dummy.Next //返回头结点 }   147. 对链表进行插入排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  func insertionSortList(head *ListNode) *ListNode { if head == nil{ return nil } dummy := \u0026amp;ListNode{Next:head} //虚拟节点  lastSort,curr := head,head.Next//已排序完成区间的最后一个节点和当前扫描节点  for curr != nil{ if lastSort.Val \u0026lt;= curr.Val{//是有序的，直接前进  lastSort = lastSort.Next }else{ //不是有序的，从区间最开始的地方遍历  pre := dummy for pre.Next.Val \u0026lt;= curr.Val{ pre = pre.Next } //找到比curr节点值大的节点，进行交换  lastSort.Next = curr.Next curr.Next = pre.Next pre.Next = curr } curr = lastSort.Next //curr前进  } return dummy.Next }   148. 排序链表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76  func merge(l1,l2 *ListNode)*ListNode{ //合并两个有序列表  dummy := \u0026amp;ListNode{} head := dummy for l1 != nil \u0026amp;\u0026amp; l2 != nil{ if l1.Val \u0026lt;= l2.Val{ head.Next = l1 l1 = l1.Next //l1指针往后移  }else{ head.Next = l2 l2 = l2.Next //l2指针往后移  } head = head.Next //遍历节点往后移  } //连接剩余节点（可能是l1，也可能是l2）  if l1 != nil{ head.Next = l1 } if l2 != nil{ head.Next = l2 } return dummy.Next } func sortList(head *ListNode) *ListNode { if head == nil{ return head } //归并排序  //1.先得出链表的长度  length := 0 for curr := head;curr != nil;curr = curr.Next{ length ++ //计算链表的长度  } //2.以链表的长度为最大值，从长度为1的链表合并链表，不断迭代  dummy := \u0026amp;ListNode{Next:head} for subLength:=1;subLength\u0026lt;length;subLength *= 2 { curr := dummy.Next //每一轮合并的起始遍历节点  pre := dummy for curr != nil{ head1 := curr //记录需要合并的链表的起始节点  for i:=1;i\u0026lt;subLength \u0026amp;\u0026amp; curr.Next!=nil;i++{ curr = curr.Next //节点后移  } head2 := curr.Next //第二个链表的起始位置  curr.Next = nil //断开第一个链表与后面节点的连接  curr = head2 //找寻第二个链表的末尾  //因为进行第一个链表的搜寻可能搜索到curr为nil,所以多一个条件判断  for i:=1;i\u0026lt;subLength \u0026amp;\u0026amp; curr != nil \u0026amp;\u0026amp; curr.Next!=nil;i++{ curr = curr.Next //节点后移  } if curr != nil{ temp := curr.Next //保存下一次合并的头节点  curr.Next = nil //断开第二链表与后面节点  curr = temp //curr继续进行找寻合并的链表  } //下面两段代码非常重要，使用pre来连接合并之后的链表  pre.Next = merge(head1, head2) for pre.Next != nil{ pre = pre.Next } } } return dummy.Next }   61. 旋转链表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  func rotateRight(head *ListNode, k int) *ListNode { if k== 0 || head == nil || head.Next == nil{ return head } //解法，把这个链表当成一个圆盘餐桌，一个一个传递菜，从链表倒数第一个节点开始传递...倒数第二个...第一个。一共传递k次，只需要求最后的菜传到了哪里，再断开链表中这个人的前一个节点  //由于是圆盘餐桌，当k \u0026gt;= length(圆盘长度)，可以采取取模减少运算  //假如k为3,length为5,可以用length - k得到最终送到了二号节点  dummy := \u0026amp;ListNode{Next:head} //虚拟节点  curr := head length := 1 //链表的长度  //先弄一个环形链表  for curr.Next != nil{ curr = curr.Next length++ //统计链表的长度  } curr.Next = head //首尾相连  m := length - k%length //虽然链表方向和送菜方向是相反的，但可以通过length - k 来计算  curr = dummy for i:=0;i\u0026lt;m;i++{ curr = curr.Next } temp := curr.Next curr.Next = nil //断开连接  return temp }   *\n143. 重排链表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  func reverseList(head *ListNode) *ListNode { var prev, cur *ListNode = nil, head for cur != nil { nextTmp := cur.Next cur.Next = prev prev = cur cur = nextTmp } return prev } func mergeList(l1, l2 *ListNode) { var l1Tmp, l2Tmp *ListNode for l1 != nil \u0026amp;\u0026amp; l2 != nil { l1Tmp = l1.Next l2Tmp = l2.Next l1.Next = l2 l1 = l1Tmp l2.Next = l1 l2 = l2Tmp } } func reorderList(head *ListNode) { if head == nil { return } slow, fast := head, head for fast.Next != nil \u0026amp;\u0026amp; fast.Next.Next != nil { slow = slow.Next fast = fast.Next.Next } mid := slow l1 := head l2 := mid.Next mid.Next = nil l2 = reverseList(l2) mergeList(l1, l2) }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":345,"section":"interview","tags":["算法"],"title":"第五章第二节","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter5/2/"},{"content":"树型问题 17. 电话号码的字母组合\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  func letterCombinations(digits string) []string { if digits == \u0026#34;\u0026#34;{ return []string{} } hash := map[byte][]byte{ \u0026#39;0\u0026#39; : []byte{\u0026#39; \u0026#39;}, \u0026#39;1\u0026#39; : []byte{\u0026#39; \u0026#39;}, \u0026#39;2\u0026#39; : []byte{\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;}, \u0026#39;3\u0026#39; : []byte{\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;}, \u0026#39;4\u0026#39; : []byte{\u0026#39;g\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;i\u0026#39;}, \u0026#39;5\u0026#39; : []byte{\u0026#39;j\u0026#39;,\u0026#39;k\u0026#39;,\u0026#39;l\u0026#39;}, \u0026#39;6\u0026#39; : []byte{\u0026#39;m\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;o\u0026#39;}, \u0026#39;7\u0026#39; : []byte{\u0026#39;p\u0026#39;,\u0026#39;q\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;s\u0026#39;}, \u0026#39;8\u0026#39; : []byte{\u0026#39;t\u0026#39;,\u0026#39;u\u0026#39;,\u0026#39;v\u0026#39;}, \u0026#39;9\u0026#39; : []byte{\u0026#39;w\u0026#39;,\u0026#39;x\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;z\u0026#39;}, } //返回数组  res := make([]string,0) var findCombinations func(digits []byte,index int,s []byte) findCombinations = func(digits []byte,index int,s []byte){ if index == len(digits){ res = append(res,string(s)) return //递归终止条件  } //递归  for i:=0;i\u0026lt;len(hash[digits[index]]);i++{ findCombinations(digits,index+1,append(s,hash[digits[index]][i])) } } findCombinations([]byte(digits),0,[]byte{}) return res }   递归调用一个重要的特征：回溯 93. 复原 IP 地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  func restoreIpAddresses(s string) []string { //回溯是暴力解法的一个主要手段  //一个ip地址一共有4个段  //返回答案  ans := make([]string,0) //每一段的数字segment[i]  segmentIp := make([]int,4) //dfs函数的含义：将s拆分为一个合法的ip地址  //segment表示当前dfs函数需要确定的是第几段ip地址,startIp则表示在s字符串中的下标  var dfs func(segment ,startIp int) dfs = func(segment,startIp int){ //递归终止条件  //已经包含4段，加入结果集  if segment == 4{ //只有长度符合要求才能加入结果集  if startIp == len(s){ subStr := \u0026#34;\u0026#34; for i:=0;i\u0026lt;segment;i++{ subStr += strconv.Itoa(segmentIp[i]) if i!= 3{ subStr += \u0026#34;.\u0026#34; } } ans = append(ans,subStr) } return } if startIp == len(s){ //提前回溯  return } //不能含有前导0  if s[startIp] == \u0026#39;0\u0026#39;{ //直接把这一段的值置为0  segmentIp[segment] = 0 //段号加一，下标也加一，继续递归  dfs(segment+1,startIp+1) } val := 0 for endIp:=startIp;endIp\u0026lt;len(s);endIp++{ //选取数字进行递归  val = val*10 + int(s[endIp]-\u0026#39;0\u0026#39;) if val \u0026gt; 0 \u0026amp;\u0026amp; val \u0026lt;= 0xff{ segmentIp[segment] = val dfs(segment+1,endIp+1) }else{ break } } return } dfs(0,0) return ans }   131. 分割回文串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  //判断是否是回文子串 func isVaild(s []byte)bool{ length := len(s) for i:=0;i\u0026lt;length/2;i++{ if s[i] != s[length-i-1]{ return false } } return true } func partition(s string) [][]string { //回溯解法 \t//返回数组 \tans := make([][]string,0) res := []string{} var dfs func(index int) //dfs函数的意义是为了拆分字符串，使得是回文子串 \tdfs = func(index int){ //递归终止条件（进行回溯） \tif index == len(s){ // append([]string(nil), res...)是为了隔离ans[i]与res的关系 \tans = append(ans,append([]string(nil), res...)) return } //子串（0...len(s)-1） \tfor i:=index;i\u0026lt;len(s);i++{ //如果是回文串就向下递归 \tif isVaild([]byte(s[index:i+1])) { res = append(res, s[index:i+1]) //如果是回文串就向下递归 \tdfs(i + 1) //删除一个字符串，重新递归 \tres = res[:len(res)-1] } } return } dfs(0) return ans }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":346,"section":"interview","tags":["算法"],"title":"第八章第一节","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter8/1/"},{"content":"组合问题 77. 组合\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  func combine(n int, k int) [][]int { if k \u0026gt; n || n \u0026lt; 1 || k == 0{ return [][]int{} } //返回数组  res := make([][]int,0) //暂存组合数组  temp := make([]int,0) //回溯加剪枝  //start为开始组合的地方  var dfs func(start int) dfs = func(start int){ if len(temp) == k { //满足组合条件，加入结果集  res = append(res,append([]int(nil),temp...)) return } //需要剪枝，当组合数组已经有len(temp)个元素时，还需要添加k-len(temp)个元素，此时还有n-i+1个可以添加，所以应该有(n-i+1) \u0026gt;= (k-len(temp)) 换成i的条件，即i\u0026lt;n-(k-len(temp)+1  //剪枝在树规模大的情况下效率提升明显  for i:=start;i\u0026lt;=n-(k-len(temp))+1;i++{ //加入暂存组合，进行递归  temp = append(temp,i) dfs(i+1) //进行回溯之后，需要删除上一次添加的元素，进行下一次同层递归  temp = temp[:len(temp)-1] } return } dfs(1) return res }   39. 组合总和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  func combinationSum(candidates []int, target int) [][]int { //返回结果数组res \tres := make([][]int,0) //暂存数组 \ttemp := make([]int,0) n := len(candidates) var dfs func(start int,sum int) dfs = func(start int,sum int) { for i:=start;i\u0026lt;n;i++{ if sum+candidates[i] == target{ //如果满足条件，直接加入结果集 \tres = append(res,append([]int(nil),append(temp,candidates[i])...)) } //进行剪枝 \tif sum + candidates[i] \u0026gt; target{ continue } temp = append(temp,candidates[i]) dfs(i,sum+candidates[i]) //回溯之后，删除暂存数组加入的元素 \ttemp = temp[:len(temp)-1] } return } //start表示数组中的下标 \t//sum表示当前暂存组合的和 \tdfs(0,0) return res }   40. 组合总和 II\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  func combinationSum2(candidates []int, target int) [][]int { //返回结果数组res \tres := make([][]int,0) //暂存数组 \ttemp := make([]int,0) //增加一个used用来记录数组的该元素是否被使用 \tused := make(map[int]bool) //先进行排序 \tsort.Ints(candidates) n := len(candidates) var dfs func(start int,sum int) dfs = func(start int,sum int) { if sum == target{ //如果满足条件，直接加入结果集 \tres = append(res,append([]int(nil),temp...)) } for i:=start;i\u0026lt;n;i++{ if i \u0026gt; 0 \u0026amp;\u0026amp; !used[i-1] \u0026amp;\u0026amp; candidates[i-1] == candidates[i]{ continue } //进行剪枝 \tif sum + candidates[i] \u0026gt; target{ //因为已经升序排序，所以可以直接退出for循环 \tbreak } temp = append(temp,candidates[i]) used[i] = true dfs(i+1,sum+candidates[i]) delete(used,i) //回溯之后，删除暂存数组加入的元素 \ttemp = temp[:len(temp)-1] } return } //start表示数组中的下标 \t//sum表示当前暂存组合的和 \tdfs(0,0) return res }   216. 组合总和 III\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  func combinationSum3(k int, n int) [][]int { if k \u0026lt; 1 || n \u0026lt; 1{ return [][]int{} } //回溯+剪枝 \t//返回结果数组 \tres := make([][]int,0) //递归函数 \tvar dfs func(start ,sum int) //暂存数组 \ttemp := make([]int,0) dfs = func(start ,sum int) { if sum == n \u0026amp;\u0026amp; len(temp) == k{ //满足，加入结果集 \tres = append(res,append([]int(nil),temp...)) return } //递归细节 \tfor i:=start;i\u0026lt;=9;i++{ //进行剪枝 \tif sum + i \u0026gt; n{ //因为是升序，所以直接退出即可 \tbreak } if len(temp)+1 \u0026gt; k{ break } temp = append(temp,i) //进行递归 \tdfs(i+1,sum+i) //进行回溯 \ttemp = temp[:len(temp)-1] } return } //从数字1开始 \tdfs(1,0) return res }   78. 子集\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  func subsets(nums []int) [][]int { //返回结果数组 \tres := make([][]int,0) //先加入一个空集 \tres = append(res,[]int{}) //暂存数组 \ttemp := make([]int,0) //回溯 \t//数组的长度 \tn := len(nums) var dfs func(start int) dfs = func(start int){ if start \u0026gt;= n{ return } for i:=start;i\u0026lt;n;i++{ temp = append(temp,nums[i]) //递归 \tres = append(res,append([]int(nil),temp...)) dfs(i+1) //回溯 \ttemp = temp[:len(temp)-1] } return } dfs(0) return res }   90. 子集 II\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  func subsetsWithDup(nums []int) [][]int { //返回结果数组 \tres := make([][]int,0) //先加入一个空集 \tres = append(res,[]int{}) //暂存结果数组 \ttemp := make([]int,0) //帮助记录重复元素 \tused := make(map[int]bool) //数组长度 \tn := len(nums) //为了避免重复结果，先对数组进行排序 \tsort.Ints(nums) //回溯+剪枝 \tvar dfs func(start int) dfs = func(start int){ if start \u0026gt;= n{ return } //递归细节 \tfor i:=start;i\u0026lt;n;i++{ if i\u0026gt;0 \u0026amp;\u0026amp; !used[i-1] \u0026amp;\u0026amp; nums[i-1] == nums[i]{ continue } used[i] = true temp = append(temp,nums[i]) res = append(res,append([]int(nil),temp...)) dfs(i+1) used[i] = false temp = temp[:len(temp)-1] } } dfs(0) return res }   401. 二进制手表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  func readBinaryWatch(turnedOn int) []string { //组合问题，从下面数组中选取turnedOn个数来进行组合合成一个时间  temp := []int{1,2,4,8,1,2,4,8,16,32} //返回数组  ans := make([]string,0) //暂存组合数结果  res := make([]int,0) //start开始遍历的地方，  var dfs func(start int) dfs = func(start int){ //递归终止条件  if len(res) == turnedOn{ //时钟数  hour := 0 //分钟数  minute := 0 //%02d不足2个数，自动往前面补0  for i:=0;i\u0026lt;turnedOn;i++{ //大于等于3说明是分钟数灯泡，否则就是时钟数  if res[i] \u0026gt;= 4{ minute += temp[res[i]] }else{ hour += temp[res[i]] } } //时间合理性  if minute \u0026lt; 60 \u0026amp;\u0026amp; hour \u0026lt; 12{ ans = append(ans,fmt.Sprintf(\u0026#34;%d:%02d\u0026#34;,hour,minute)) } return } //递归细节  for i:=start;i\u0026lt;10;i++{ res = append(res,i) //递归  dfs(i+1) //回溯  res = res[:len(res)-1] } return } dfs(0) return ans }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":347,"section":"interview","tags":["算法"],"title":"第八章第三节——组合","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter8/3/"},{"content":"排列问题 46. 全排列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  func permuteUnique(nums []int) [][]int { //怎么这么多的大佬，通过率也太高了  //元素数组为空，返回空结果 \tif len(nums) == 0{ return [][]int{} } //返回结果数组 \tans := [][]int{} //used用于判断递归的路径使用的哪些元素 \tused := make(map[int]bool,len(nums)) //暂存一次排列结果 \ttemp := []int{} //dfs函数进行回溯，index表示当前结果一维数组的大小， \tvar dfs func(index int) dfs = func(index int) { //满足条件，组合结束，加入结果集 \tif len(temp) == len(nums){ ans = append(ans,append([]int(nil),temp...)) return } for i:=0;i\u0026lt;len(nums);i++{ _,ok:=used[nums[i]] //如果不在used里面就进行递归 \tif !ok{ used[nums[i]] = true temp = append(temp,nums[i]) dfs(index+1) //回溯回来之后，重新选取，删除temp添加的元素 \ttemp = temp[:len(temp)-1] //删除used标记的元素 \tdelete(used,nums[i]) } } return } dfs(0) return ans }   47. 全排列 II\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  func permuteUnique(nums []int) [][]int { if len(nums) == 0{ return [][]int{} } //返回结果数组 \tres := make([][]int,0) //结果暂存数组 \ttemp := make([]int,0) //标记元素是否使用 \tused := make(map[int]bool) //先对数组进行排序，方便剪枝 \tsort.Ints(nums) //回溯递归函数 \tvar dfs func(index int) dfs = func(index int){ //递归终止 \tif index == len(nums){ res = append(res,append([]int(nil),temp...)) return } //选取路径 \tfor i:=0;i\u0026lt;len(nums);i++{ //需要剪枝的情况， \tif used[i]{ continue } if i \u0026gt; 0 \u0026amp;\u0026amp; !used[i-1] \u0026amp;\u0026amp; nums[i-1] == nums[i]{ continue } //标记已使用 \tused[i] = true //加入暂存组合结果 \ttemp = append(temp,nums[i]) //递归 \tdfs(index+1) //释放标记 \tused[i] = false temp = temp[:len(temp)-1] } } dfs(0) fmt.Println(res) return res }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":348,"section":"interview","tags":["算法"],"title":"第八章第二节——排列","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter8/2/"},{"content":"记忆化搜索 51. N 皇后\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  //将放置的皇后的坐标转换成字符串数组 func generateBoard(res []int,n int)[]string { ans := make([]string, 0) for i := 0; i \u0026lt; len(res); i++{ temp := []byte{} for j := 0; j \u0026lt; n; j++ { if j == res[i]{ temp = append(temp,\u0026#39;Q\u0026#39;) }else{ temp = append(temp,\u0026#39;.\u0026#39;) } } ans = append(ans,string(temp)) } return ans } func solveNQueens(n int) [][]string { //结果返回数组 \tres := make([][]string,0) //用来记录i列是否已经有皇后占领 \tcol := make([]bool,n) //用来记录第一种对角线 是否有皇后占领（从右上到左下，一共2*n-1条对角线，对角线的关系是，同一对角线行列下标相加得到的值相同，把想加的值来作为对角线数组下标） \tdia1 := make([]bool,2*n-1) //用来记录第二种对角线 是否有皇后占领（从左上到右下，一共2*n-1条对角线，对角线的关系是，同一对角线行列下标之差得到的值相同，把行-列+n-1的值作为对角线数组的下标） \tdia2 := make([]bool,2*n-1) //用来暂时记录皇后在每一行的下标 \tboard := make([]int,0) //递归回溯函数 \t//index 表示当前已经准备放第几行的皇后（从0开始计数） \tvar dfs func(index int) dfs = func(index int) { //找到一种放置N皇后的方法，加入结果数组中 \tif index == n{ res = append(res,generateBoard(board,n)) return } //递归细节 \t//把皇后放置在index行0-（n-1）之间的一列 \tfor i:=0;i\u0026lt;n;i++{ //继续递归条件： \t//1.同列没有其他皇后 \t//2.第一种对角线上没有其他皇后 \t//3.第二种对角线上没有其他皇后 \tif !col[i] \u0026amp;\u0026amp; !dia1[index+i] \u0026amp;\u0026amp; !dia2[index-i+n-1]{ //加入放置数组中 \tboard = append(board,i) //进行标记 \tcol[i] = true dia1[index+i] = true dia2[index-i+n-1] = true //继续下一行的放置 \tdfs(index+1) //回溯，取消标记，弹出board的一个元素 \tdia2[index-i+n-1] = false dia1[index+i] = false col[i] = false board = board[:len(board)-1] } } } dfs(0) return res }   52. N皇后 II\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  func totalNQueens(n int) int { //返回结果 \tres := 0 //用来记录i列是否已经有皇后占领 \tcol := make([]bool,n) //用来记录第一种对角线 是否有皇后占领（从右上到左下，一共2*n-1条对角线，对角线的关系是，同一对角线行列下标相加得到的值相同，把想加的值来作为对角线数组下标） \tdia1 := make([]bool,2*n-1) //用来记录第二种对角线 是否有皇后占领（从左上到右下，一共2*n-1条对角线，对角线的关系是，同一对角线行列下标之差得到的值相同，把行-列+n-1的值作为对角线数组的下标） \tdia2 := make([]bool,2*n-1) //用来暂时记录皇后在每一行的下标 \tboard := make([]int,0) //递归回溯函数 \t//index 表示当前已经准备放第几行的皇后（从0开始计数） \tvar dfs func(index int) dfs = func(index int) { //找到一种放置N皇后的方法，加入结果数组中 \tif index == n{ res ++ return } //递归细节 \t//把皇后放置在index行0-（n-1）之间的一列 \tfor i:=0;i\u0026lt;n;i++{ //继续递归条件： \t//1.同列没有其他皇后 \t//2.第一种对角线上没有其他皇后 \t//3.第二种对角线上没有其他皇后 \tif !col[i] \u0026amp;\u0026amp; !dia1[index+i] \u0026amp;\u0026amp; !dia2[index-i+n-1]{ //加入放置数组中 \tboard = append(board,i) //进行标记 \tcol[i] = true dia1[index+i] = true dia2[index-i+n-1] = true //继续下一行的放置 \tdfs(index+1) //回溯，取消标记，弹出board的一个元素 \tdia2[index-i+n-1] = false dia1[index+i] = false col[i] = false board = board[:len(board)-1] } } } dfs(0) return res }   37. 解数独\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  func solveSudoku(board [][]byte) { hash := []byte{\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;3\u0026#39;,\u0026#39;4\u0026#39;,\u0026#39;5\u0026#39;,\u0026#39;6\u0026#39;,\u0026#39;7\u0026#39;,\u0026#39;8\u0026#39;,\u0026#39;9\u0026#39;} //用来记录i行的数字j是否被占领  row := make([][]bool,9) //用来记录i列的数字j是否被占领  col := make([][]bool,9) //用来记录第i个九宫格的数字j是否被占领  //index = i/3*3 + j/3  dia := make([][]bool,9) //用来记录空白格的地方  spaces := make([][2]int,0) //进行初始化  for i:=0;i\u0026lt;9;i++{ row[i] = make([]bool,9) col[i] = make([]bool,9) dia[i] = make([]bool,9) } for i:=0;i\u0026lt;9;i++{ for j:=0;j\u0026lt;9;j++{ if board[i][j] != \u0026#39;.\u0026#39;{ x := board[i][j] - \u0026#39;1\u0026#39; row[i][x] = true col[j][x] = true y := i/3*3+j/3 dia[y][x] = true }else{ spaces = append(spaces,[2]int{i,j}) } } } var dfs func(startx int)bool dfs = func(startx int)bool{ //数独解答完成  if startx == len(spaces){ return true } x := spaces[startx][0] y := spaces[startx][1] for j:=0;j\u0026lt;9;j++{ //继续递归条件： \t//1.同行没有该数字 \t//2.同列没有该数字 \t//3.同九宫格没有该数字  if !row[x][j] \u0026amp;\u0026amp; !col[y][j] \u0026amp;\u0026amp; !dia[x/3*3+y/3][j]{ board[x][y] = hash[j] row[x][j] = true col[y][j] = true dia[x/3*3+y/3][j] = true if dfs(startx+1){ return true } //回溯细节  row[x][j] = false col[y][j] = false dia[x/3*3+y/3][j] = false } } return false } dfs(0) return }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":349,"section":"interview","tags":["算法"],"title":"第八章第五节——AI算法的基础是回溯算法","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter8/5/"},{"content":"floodfill算法 79. 单词搜索\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  func exist(board [][]byte, word string) bool { m,n := len(board), len(board[0]) for i := 0; i \u0026lt; m; i++ {//行范围  for j := 0; j \u0026lt; n; j++ {//列范围  //如果在数组中找得到第一个数，就执行下一步，否则返回false  if search(board, i, j, 0,word) { //dsf深度优先搜索，从一个起点开始搜索，若搜索到，则返回true，否则，下一个矩阵单元  return true } } } return false } func search(board [][]byte, i,j,k int, word string) bool { //如果找到最后一个数，则返回true,搜索成功  if k == len(word) { //k表示word当前遍历下标  return true } //i,j的约束条件  if i \u0026lt; 0 || j \u0026lt; 0 || i == len(board) || j == len(board[0]) { return false } //进入DFS深度优先搜索  //先把正在遍历的该值重新赋值，如果在该值的周围都搜索不到目标字符，则再把该值还原  //如果在数组中找到第一个字符，则进入下一个字符的查找  if board[i][j] == word[k] { temp := board[i][j] board[i][j] = \u0026#39; \u0026#39; //下面这个if语句，如果成功进入，说明找到该字符，然后进行下一个字符的搜索,直到所有的搜索都成功，  //即k == len(word) - 1 的大小时，会返回true，进入该条件语句，然后返回函数true值。  if search(board, i, j + 1, k + 1, word) || //向下搜索  search(board, i, j - 1, k + 1, word) || //向上搜索  search(board, i + 1, j, k + 1, word) || //向右搜索  search(board, i - 1, j, k + 1, word) { //向左搜索  return true }else { //没有找到目标字符，还原之前重新赋值的board[i][j]  board[i][j] = temp } } return false }   200. 岛屿数量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  func numIslands(grid [][]byte) int { //初始化一个二维数组，用来标记该地区是否已经被访问过 \tused := make([][]bool,len(grid)) for i:=0;i\u0026lt;len(grid);i++{ used[i] = make([]bool,len(grid[i])) } //二维数组的行数和列数 \tm,n:=len(grid),len(grid[0]) var notInArea func(x,y int)bool notInArea = func(x,y int)bool{ return x \u0026lt; 0 || x \u0026gt;= m || y \u0026lt; 0 || y \u0026gt;= n } var dfs func(startx,starty int)bool dfs = func(startx, starty int) bool { //越界，直接返回false \tif notInArea(startx,starty){ return false } //说明是海洋，直接返回 \tif grid[startx][starty] == \u0026#39;0\u0026#39; || used[startx][starty]{ return false } used[startx][starty] = true //向上右下左四个方向标记陆地 \tdfs(startx+1,starty) dfs(startx,starty+1) dfs(startx-1,starty) dfs(startx,starty-1) return true } //返回数，岛屿的数量 \tans := 0 //从不同的地方开始出发 \tfor i:=0;i\u0026lt;m;i++{ for j:=0;j\u0026lt;n;j++{ //如果该位置已经被使用过，直接跳过本次循环 \tif used[i][j]{ continue } if grid[i][j] != \u0026#39;0\u0026#39; \u0026amp;\u0026amp; dfs(i,j){ //找到一个新岛屿，ans加一 \tans++ } } } //返回找到的岛屿数量 \treturn ans }   130. 被围绕的区域\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71  func solve(board [][]byte) { //采用floodfill算法  //准备进行洪水攻击吧  //我们的目的是把被X包围的O变成O，但是周围有一些捣蛋鬼O没有被X包围，我就从他们开始进行floodfill，把他们全部变成\u0026#39;Y\u0026#39;字符，最后再扫描区域，把被X包围的好孩子\u0026#39;O\u0026#39;加入X的一边，把捣蛋鬼Y再变成O  //表示矩阵的行列数  m,n := len(board),len(board[0]) var notInArea func(x,y int)bool notInArea = func(x,y int)bool{ return x \u0026lt; 0 || x \u0026gt;= m || y \u0026lt; 0 || y \u0026gt;= n } //进行洪水攻击的函数  var dfs func(startx,starty int) dfs = func(startx,starty int){ //如果越界或者该字符不是\u0026#39;O\u0026#39;，就不用攻击了，直接返回  if notInArea(startx,starty) || board[startx][starty] != \u0026#39;O\u0026#39;{ return } //如果是\u0026#39;O\u0026#39;这个捣蛋鬼就把他变成\u0026#39;Y\u0026#39;  board[startx][starty] = \u0026#39;Y\u0026#39; //向四处进行洪水攻击  //上面  dfs(startx-1,starty) //下面  dfs(startx+1,starty) //左面  dfs(startx,starty-1) //右面  dfs(startx,starty+1) } //先从上边开始进行“洪水攻击”（floodfill）  for i:=0;i\u0026lt;n;i++{ dfs(0,i) } //从下边开始进行“洪水攻击”（floodfill）  for i:=0;i\u0026lt;n;i++{ dfs(m-1,i) } //先从左边开始进行“洪水攻击”（floodfill）  //下面从1开始，m-2结尾只是因为进行上下洪水攻击的时候已经从包含在左边的两个坐标开始了，省去这两个坐标  for i:=1;i\u0026lt;m-1;i++{ dfs(i,0) } //先从右边开始进行“洪水攻击”（floodfill）  for i:=1;i\u0026lt;m-1;i++{ dfs(i,n-1) } for i:=0;i\u0026lt;m;i++{ for j:=0;j\u0026lt;n;j++{ //把好孩子\u0026#39;O\u0026#39;变成\u0026#39;X\u0026#39;  if board[i][j] == \u0026#39;O\u0026#39;{ board[i][j] = \u0026#39;X\u0026#39; //把已经变成了\u0026#39;Y\u0026#39;的坏孩子\u0026#39;O\u0026#39;再变成\u0026#39;O\u0026#39;  }else if board[i][j] == \u0026#39;Y\u0026#39;{ board[i][j] = \u0026#39;O\u0026#39; } } } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  func pacificAtlantic(heights [][]int) [][]int { //结果返回数组 \tres := make([][]int,0) //floodfill \tm,n := len(heights),len(heights[0]) P := make([][]bool,m) A := make([][]bool,m) for i:=0;i\u0026lt;m;i++{ P[i] = make([]bool,n) A[i] = make([]bool,n) } var notInArea func(x,y int)bool notInArea = func(x, y int)bool{ return x \u0026lt; 0 || y \u0026lt; 0 || x \u0026gt;= m || y \u0026gt;= n } var dfs func(visited [][]bool,startx,starty int,numsSize int) dfs = func(visited [][]bool,startx, starty int,numsSize int) { if notInArea(startx,starty) || visited[startx][starty] || heights[startx][starty] \u0026lt; numsSize{ return } visited[startx][starty] = true if P[startx][starty] \u0026amp;\u0026amp; A[startx][starty]{ res = append(res,[]int{startx,starty}) } dfs(visited,startx+1,starty,heights[startx][starty]) dfs(visited,startx-1,starty,heights[startx][starty]) dfs(visited,startx,starty+1,heights[startx][starty]) dfs(visited,startx,starty-1,heights[startx][starty]) } //上下 \tfor i:=0;i\u0026lt;n;i++{ dfs(P,0,i,math.MinInt64) dfs(A,m-1,i,math.MinInt64) } //左右 \tfor i:=0;i\u0026lt;m;i++{ dfs(P,i,0,math.MinInt64) dfs(A,i,n-1,math.MinInt64) } return res }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":350,"section":"interview","tags":["算法"],"title":"第八章第四节——floodfill","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter8/4/"},{"content":"栈的应用 20. 有效的括号\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  func isValid(s string) bool { //用栈解决的经典问题  stack := make([]byte,0) for i:=0;i\u0026lt;len(s);i++{ if s[i] == \u0026#39;(\u0026#39; || s[i] == \u0026#39;{\u0026#39; || s[i] == \u0026#39;[\u0026#39;{ //左括号，入栈  stack = append(stack, s[i]) //push  }else{ //右括号，进行匹配出栈  if len(stack) == 0{ //栈为空，无法匹配，返回false  return false } var match byte if s[i] == \u0026#39;}\u0026#39;{ match = \u0026#39;{\u0026#39; }else if s[i] == \u0026#39;)\u0026#39;{ match = \u0026#39;(\u0026#39; }else{ match = \u0026#39;[\u0026#39; } if match != stack[len(stack)-1]{ //匹配不成功，出栈  return false } stack = stack[:len(stack)-1] //pop  } } if len(stack) != 0{ //栈为空，匹配未完成，返回false  return false } return true }   150. 逆波兰表达式求值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  func evalRPN(tokens []string) int { stack := make([]string,0) for i:=0;i\u0026lt;len(tokens);i++{ ch := tokens[i] if ch == \u0026#34;+\u0026#34; || ch == \u0026#34;/\u0026#34; || ch == \u0026#34;-\u0026#34; || ch == \u0026#34;*\u0026#34;{ //匹配到运算符，出栈两个元素进行运算  nums1,_:= strconv.Atoi(stack[len(stack)-2]) nums2,_:= strconv.Atoi(stack[len(stack)-1]) stack = stack[:len(stack)-2] //出栈两个元素 \tvar res int switch ch { case \u0026#34;+\u0026#34;: res = nums1 + nums2 case \u0026#34;-\u0026#34;: res = nums1 - nums2 case \u0026#34;*\u0026#34;: res = nums1 * nums2 case \u0026#34;/\u0026#34;: res = nums1 / nums2 } stack = append(stack,strconv.Itoa(res)) //结果入栈 \t}else{ //匹配到数字，直接入栈 \tstack = append(stack,tokens[i]) } } res,_:= strconv.Atoi(stack[0]) return res }   71. 简化路径\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func simplifyPath(path string) string { parts := strings.Split(path, \u0026#34;/\u0026#34;) var stack []string for _, part := range parts { switch part { case \u0026#34;\u0026#34;, \u0026#34;.\u0026#34;: //空字符串和\u0026#34;.\u0026#34;直接跳过 \tcontinue case \u0026#34;..\u0026#34;: //遇到..就出栈一个目录名 \tif len(stack) \u0026gt; 0 { stack = stack[:len(stack)-1] } default: //为字母字符串，直接入栈 \tstack = append(stack, part) } } return \u0026#34;/\u0026#34; + strings.Join(stack, \u0026#34;/\u0026#34;) }   栈和递归的关系紧密 二叉树中的算法 三种二叉树遍历用栈解决\n144. 二叉树的前序遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  type Command struct{ s string node *TreeNode } func inorderTraversal(root *TreeNode)(res []int){ if root == nil{ return } stack := make([]Command, 0) stack = append(stack, Command{s:\u0026#34;go\u0026#34;,node:root}) for len(stack) != 0{ command := stack[len(stack)-1] //取栈顶元素  stack = stack[:len(stack)-1] //出栈  if command.s == \u0026#34;print\u0026#34; { //判断是否是需要打印的节点  res = append(res, command.node.Val) }else{ if command.node.Right != nil{ stack = append(stack, Command{s:\u0026#34;go\u0026#34;,node:command.node.Right}) } if command.node.Left != nil{ stack = append(stack, Command{s:\u0026#34;go\u0026#34;,node:command.node.Left}) } stack = append(stack, Command{s:\u0026#34;print\u0026#34;,node:command.node}) //把根节点设第一个打印的  } } return res }   94.二叉树的中序遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  type Command struct{ s string node *TreeNode } func inorderTraversal(root *TreeNode)(res []int){ if root == nil{ return } stack := make([]Command, 0) stack = append(stack, Command{s:\u0026#34;go\u0026#34;,node:root}) for len(stack) != 0{ command := stack[len(stack)-1] //取栈顶元素  stack = stack[:len(stack)-1] //出栈  if command.s == \u0026#34;print\u0026#34; { //判断是否是需要打印的节点  res = append(res, command.node.Val) }else{ if command.node.Right != nil{ stack = append(stack, Command{s:\u0026#34;go\u0026#34;,node:command.node.Right}) } stack = append(stack, Command{s:\u0026#34;print\u0026#34;,node:command.node}) //把根节点设第二个打印的  if command.node.Left != nil{ stack = append(stack, Command{s:\u0026#34;go\u0026#34;,node:command.node.Left}) } } } return res }   145. 二叉树的后序遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  type Command struct{ s string node *TreeNode } func postorderTraversal(root *TreeNode)(res []int){ if root == nil{ return } stack := make([]Command, 0) stack = append(stack, Command{s:\u0026#34;go\u0026#34;,node:root}) for len(stack) != 0{ command := stack[len(stack)-1] //取栈顶元素  stack = stack[:len(stack)-1] //出栈  if command.s == \u0026#34;print\u0026#34; { //判断是否是需要打印的节点  res = append(res, command.node.Val) }else{ stack = append(stack, Command{s:\u0026#34;print\u0026#34;,node:command.node}) //把根节点设为最后一个打印的  if command.node.Right != nil{ stack = append(stack, Command{s:\u0026#34;go\u0026#34;,node:command.node.Right}) } if command.node.Left != nil{ stack = append(stack, Command{s:\u0026#34;go\u0026#34;,node:command.node.Left}) } } } return res }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":351,"section":"interview","tags":["算法"],"title":"第六章第一节","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter6/1/"},{"content":"队列的应用    广度优先遍历    树：层序遍历    图：无权图的最短路径    102. 二叉树的层序遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  type queue struct{ node *TreeNode level int //当前节点的层级 } func levelOrder(root *TreeNode) [][]int { //用队列解决  if root == nil{ return [][]int{} } res := make([][]int, 0) //结果数组  q := make([]queue, 0)//初始化队列  q = append(q, queue{node:root,level:0}) //根节点先入队  for len(q) != 0{ node := q[0].node //获取队列中的元素  level := q[0].level //获取队列中的层级  q = q[1:] //出队  if level == len(res){//说明此时res[level]还不存在  res =append(res, []int{}) } res[level] = append(res[level] ,node.Val) //如果存在添加左右节点到队列中，层级+1  if node.Left != nil{ q = append(q, queue{node:node.Left,level:level+1}) } if node.Right != nil{ q = append(q, queue{node:node.Right,level:level+1}) } } return res }   107. 二叉树的层序遍历 II\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  type queue struct{ node *TreeNode level int } func levelOrderBottom(root *TreeNode) [][]int { res := make([][]int, 0) //需要倒置切片  if root == nil{ return res } q := make([]queue, 0) q = append(q ,queue{node:root,level:0} ) for len(q) != 0{ level := q[0].level node := q[0].node q = q[1:] //出队  //判断是否存在存放该层的切片  if level == len(res){ res = append(res,[]int{}) } res[level] = append(res[level], node.Val) //层序遍历需要先对左子树进行判断是否需要入队  if node.Left != nil{ q = append(q, queue{node:node.Left,level:level+1})//入队  } if node.Right != nil{ q = append(q, queue{node:node.Right,level:level+1})//入队  } } for i:=0;i\u0026lt;len(res)/2;i++{ res[i],res[len(res)-i-1] = res[len(res)-i-1],res[i] } return res }   103. 二叉树的锯齿形层序遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  type queue struct{ node *TreeNode //队列元素存储的节点  level int //队列元素存储的节点的层级 } func zigzagLevelOrder(root *TreeNode) [][]int { res := make([][]int,0) //构造返回数组  if root == nil{ return res } q := make([]queue, 0) //构造队列  q = append(q, queue{node:root,level:0})//初始化队列  for len(q) != 0{ node := q[0].node level := q[0].level q = q[1:] //出队  if level == len(res){//想等说明还需要添加一个切片数组来存放本层因为下标0开始嘛...  res = append(res, []int{}) } res[level] = append(res[level], node.Val) //捋一下，偶数层从右到左，奇数层从左到右//多加一个判断  if node.Left != nil{ q = append(q,queue{node:node.Left,level:level+1}) } if node.Right != nil{ q = append(q,queue{node:node.Right,level:level+1}) } } //只需要把奇数层的节点值倒置一一下就行了  for i:=1;i\u0026lt;len(res);i+=2{ length := len(res[i]) for j:=0;j\u0026lt;length/2;j++{ res[i][j],res[i][length-1-j] = res[i][length-1-j],res[i][j] } } return res }   199. 二叉树的右视图\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  type queue struct{ node *TreeNode level int //层级 } func rightSideView(root *TreeNode) []int { if root == nil{ return []int{} } res := make([][]int, 0) //队列实现  q := make([]queue, 0) q = append(q, queue{node:root,level:0}) //将root节点先加入队列q  for len(q) != 0{ node := q[0].node level := q[0].level q = q[1:] //出队  if level == len(res){//说明此时需要加入一个空切片来存储该层节点的值  res = append(res ,[]int{}) } res[level] = append(res[level], node.Val) //咱们先入队右边的节点再入队左边的节点  if node.Right != nil{ q = append(q, queue{node:node.Right,level:level+1}) } if node.Left != nil{ q = append(q, queue{node:node.Left,level:level+1}) } } resEnd := make([]int, 0) //再重新构建返回数组，只取每一层第一个  for _,v := range res{ resEnd = append(resEnd, v[0]) } return resEnd }   BFS和图的最短路径 279. 完全平方数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  func numSquares(n int) int { //队列，图的最短路径  vivsted := make([]bool,n+1) //查看节点是否被访问过  queue := make([][]int, 0)//构造队列  queue = append(queue, []int{}) queue[0] = append(queue[0], n) queue[0] = append(queue[0], 0) vivsted[queue[0][0]] = true for len(queue) != 0{ nums := queue[0][0] step := queue[0][1] queue = queue[1:] if nums == 0{ return step //已经到达零  } for i:=1; ;i++{ a := nums-i*i if a \u0026lt; 0{ break }else if a == 0{//直接返回  return step+1 } if !vivsted[a]{//判断是否遍历过  queue = append(queue, []int{a,step+1}) vivsted[a] = true } } } return 0 }   127. 单词接龙\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  func ladderLength(beginWord string, endWord string, wordList []string) int { //BFS+队列 \thash := make(map[string]int) //为wordList建立映射 \tvisited := make([]bool,len(wordList)) //用来保存图的该节点是否已经被访问过了 \tqueue := make([]string,0) //队列用于BFS  for i:=0;i\u0026lt;len(wordList);i++{ hash[wordList[i]] = i //创建映射 \tif beginWord == wordList[i]{ visited[i] = true //如果图的起始位置也在wordList中，则标记为ture，防止重复遍历 \t} } _,ok:=hash[endWord] if !ok{ //wordList里面不存在endWord，直接返0没有路径 \treturn 0 } queue = append(queue,beginWord) //入队 \twordlength := 0 //路径长度 \tfor len(queue) != 0{ n := len(queue) wordlength++ for n !=0{ n-- str := queue[0] //取队首元素 \tqueue = queue[1:]//出队 \tfor i:=0;i\u0026lt;len(beginWord);i++{ word := []byte(str) //先转换成字节切片 \t//把单词的每一个都变化25次，即26个英文单词，找到路径，还需还原 \tfor j:=0;j\u0026lt;=25;j++{ word[i] = \u0026#39;a\u0026#39; + byte(j) v,ok := hash[string(word)] if ok \u0026amp;\u0026amp; !visited[v]{ //找到 \tqueue = append(queue,string(word))//入队 \tvisited[v] = true if string(word) == endWord{ //如果是最终节点，直接返回 \treturn wordlength + 1 } } } } } } return 0 //没有此路径 }   优先队列  优先队列的底层实现：堆 熟练自己熟悉的编程语言的优先队列  347. 前 K 个高频元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71  type Item struct{ //值，代表freq里面的key \tval int //优先级，代表freq里面的value(频率) \tpriority int } type PQ []Item //实现接口  func (pq PQ)Len()int{ return len(pq) } func (pq PQ)Swap(i,j int){ pq[i],pq[j] = pq[j],pq[i] } //小顶堆 func (pq PQ)Less(i,j int)bool{ return pq[i].priority \u0026lt; pq[j].priority } func (pq *PQ)Pop()interface{}{ item := (*pq)[len(*pq)-1] *pq = (*pq)[:len(*pq)-1] return item } func (pq *PQ)Push(x interface{}){ *pq = append(*pq,x.(Item)) } func topKFrequent(nums []int, k int) []int { //2.优先队列 \tpq := make(PQ,0) res := make([]int,0) //记录元素出现的频率的查找表 \tfreq := make(map[int]int,0) for i:=0;i\u0026lt;len(nums);i++{ freq[nums[i]]++ } for i,v:=range freq{ item := Item{ val: i, priority: v, } //出队列,入队优先级大的 \tif k == 0{ //优先队列的最小元素小于它，直接出队列 \tif pq[0].priority \u0026lt; item.priority { heap.Pop(\u0026amp;pq) heap.Push(\u0026amp;pq,item) } }else{ heap.Push(\u0026amp;pq,item) k-- } } for _,v:=range pq{ res = append(res,v.val) } return res }   23. 合并K个升序链表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  type PQ []*ListNode //实现所有方法来实现接口  func (pq PQ)Len()int{ return len(pq) } func (pq PQ)Less(i,j int)bool{ return pq[i].Val \u0026lt; pq[j].Val } func (pq PQ)Swap(i,j int){ pq[i],pq[j] = pq[j],pq[i] } func (pq *PQ)Push(x interface{}){ *pq = append(*pq,x.(*ListNode)) } func (pq *PQ)Pop()interface{}{ item := (*pq)[len(*pq)-1] *pq = (*pq)[0:len(*pq)-1] return item } func mergeKLists(lists []*ListNode) *ListNode { //采用优先队列来解决  if len(lists) == 0{ return nil } dummy := \u0026amp;ListNode{ Val: -1, Next: nil, } //做遍历节点 \tnode := dummy var pq PQ //优先队列pq  for i:=0;i\u0026lt;len(lists);i++{ if lists[i] != nil{ pq.Push(lists[i]) } } heap.Init(\u0026amp;pq) for len(pq) \u0026gt; 0{ item := heap.Pop(\u0026amp;pq).(*ListNode) next := item.Next node.Next = item// \tnode = node.Next if next != nil{ //将链表元素重新入堆 \theap.Push(\u0026amp;pq,next) } } return dummy.Next }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":352,"section":"interview","tags":["算法"],"title":"第六章第二节","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter6/2/"},{"content":"455. 分发饼干\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  func findContentChildren(g []int, s []int) int { //贪心算法 \t//先对g和s进行排序(从大到小) \tsort.Slice(g, func(i, j int) bool { return g[i] \u0026gt; g[j] }) sort.Slice(s, func(i, j int) bool { return s[i] \u0026gt; s[j] }) //gi表示当前g数组最大值的下标 \t//si表示当前s数组 最大值的下标 \tgi, si := 0, 0 //res表示结果返回值 \tres := 0 for gi \u0026lt; len(g) \u0026amp;\u0026amp; si \u0026lt; len(s) { if g[gi] \u0026lt;= s[si] { gi++ si++ res++ } else { gi++ } } return res }   392. 判断子序列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  func isSubsequence(s string, t string) bool { //t字符串当前的下标  tStart := 0 sStart := 0 for sStart \u0026lt; len(s){ if tStart \u0026gt;= len(t){ return false } if s[sStart] == t[tStart]{ sStart++ tStart++ }else{ tStart++ } } return true }   435. 无重叠区间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  func eraseOverlapIntervals(intervals [][]int) int { if len(intervals) == 0 { return 0 } n := len(intervals) //先进行排序 \t//选择先结尾的，若结尾相同选择先开始的 \tsort.Slice(intervals, func(i, j int) bool { if intervals[i][1] != intervals[j][1] { return intervals[i][1] \u0026lt; intervals[j][1] } return intervals[i][0] \u0026lt; intervals[j][0] }) //res表示当前intervals数组不重叠的去区间的个数 \tres := 1 //pre表示上一个不重叠的区间 \tpre := 0 for i := 1; i \u0026lt; n; i++ { if intervals[i][0] \u0026gt;= intervals[pre][1]{ res++ pre=i } } return n - res }   不是所有能用动态规划解决的问题都能用贪心算法解决 练习 1.最小生成树\n2.最短路径\n","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":353,"section":"interview","tags":["算法"],"title":"第十章第一节","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter10/1/"},{"content":"两类查找问题\n  1.查找有无\n-元素\u0026rsquo;a\u0026rsquo;是否存在？set（集合）\n  2.查找对应关系（键值对应）\n-元素\u0026rsquo;a\u0026rsquo;出现了几次？map（字典）\n  练习\n349. 两个数组的交集\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func intersection(nums1 []int, nums2 []int) []int { hash := make(map[int]bool) res := make([]int, 0) for _, v := range nums1 { hash[v] = true } for _, v := range nums2 { if hash[v] == true { res = append(res, v) hash[v] = false } } return res }   242. 有效的字母异位词\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  func isAnagram(s string, t string) bool { if len(s) != len(t){ //长度不等，直接返回false  return false } //建立一个与两个字符串有关的映射，初始值为0，map[s[i]]就加1，map[t[i]]就减1，如果map里面出现了值不为0的key就说明  //不是异位词  hash := make(map[byte]int) for i:=0;i\u0026lt;len(s);i++{ hash[s[i]-\u0026#39;a\u0026#39;]++ hash[t[i]-\u0026#39;a\u0026#39;]-- } for _,v := range hash{ if v != 0{ return false } } return true }   202.快乐数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  func isHappy(n int) bool { hash := make(map[int]bool) res := n for{ if res == 1{ return true }else if hash[res] == true{ return false } hash[res] = true res = getSquareSUm(res) } return false } func getSquareSUm(n int)int{ res := 0 for n \u0026gt; 0{ res += (n%10) * (n%10) n = n / 10 } return res }   290. 单词规律\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  func wordPattern(pattern string, s string) bool { //双映射，字符-\u0026gt;字符串，字符串-\u0026gt;字符  word2ch := make(map[string]byte) ch2word := make(map[byte]string) stringSlice := strings.Split(s, \u0026#34; \u0026#34;) if len(stringSlice) != len(pattern){ return false } //双映射，对应的字符有着对应的字符串，对应的字符串有着对应的字符  for i:=0;i\u0026lt;len(pattern);i++{ if word2ch[stringSlice[i]] != 0 \u0026amp;\u0026amp; word2ch[stringSlice[i]] != pattern[i]{ return false } if ch2word[pattern[i]] != \u0026#34;\u0026#34; \u0026amp;\u0026amp; ch2word[pattern[i]] != stringSlice[i]{ return false } word2ch[stringSlice[i]] = pattern[i] ch2word[pattern[i]] = stringSlice[i] } return true }   451. 根据字符出现频率排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  //第一种写法 func frequencySort(s string) string { if len(s) == 1 || s == \u0026#34;\u0026#34;{ return s } freq := make(map[byte]int) //记录字符的出现频率 \tret := make([]byte,0) //记录不同的字符 \tres := make([]byte,0) //返回结果 \tfor i:=0;i\u0026lt;len(s);i++{ if freq[s[i]] == 0{ ret = append(ret,s[i]) } freq[s[i]]++ } //sort.Slice(ret, func(i, j int) bool { \t//\treturn freq[ret[i]] \u0026gt; freq[ret[j]] \t//}) \tquickSort(ret,freq) for i:=0;i\u0026lt;len(ret);i++{ for j:=0;j\u0026lt;freq[ret[i]];j++{ res = append(res,ret[i]) } } return string(res) } func quickSort(ret []byte,freq map[byte]int){ partition(ret,freq,0,len(ret)-1) } func partition(ret []byte,freq map[byte]int,low,high int){ if low \u0026gt;= high{ return } pivot := ret[low] l := low r := high for l \u0026lt; r{ for l \u0026lt; r \u0026amp;\u0026amp; freq[ret[r]] \u0026lt; freq[pivot]{ r-- } if l \u0026lt; r{ ret[l] = ret[r] l++ } for l \u0026lt; r \u0026amp;\u0026amp; freq[ret[l]] \u0026gt;= freq[pivot]{ l++ } if l \u0026lt; r { ret[r] = ret[l] r-- } } ret[l] = pivot partition(ret,freq,low,l-1) partition(ret,freq,l+1,high) }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  //第二种写法 func frequencySort(s string) string { if len(s) == 1 || s == \u0026#34;\u0026#34;{ return s } freq := make(map[byte]int) //记录字符的出现频率 \tret := make([]byte,0) //记录不同的字符 \tres := make([]byte,0) //返回结果 \tfor i:=0;i\u0026lt;len(s);i++{ if freq[s[i]] == 0{ ret = append(ret,s[i]) } freq[s[i]]++ } //sort.Slice(ret, func(i, j int) bool { \t//\treturn freq[ret[i]] \u0026gt; freq[ret[j]] \t//}) \tsort.Slice(ret,func(i,j int)bool{ return freq[ret[i]] \u0026gt; freq[ret[j]] }) for i:=0;i\u0026lt;len(ret);i++{ for j:=0;j\u0026lt;freq[ret[i]];j++{ res = append(res,ret[i]) } } return string(res) }   1. 两数之和\n1 2 3 4 5 6 7 8 9 10 11 12  func twoSum(nums []int, target int) []int { hashMap := map[int]int{} //实例化一个map  for i:=0;i\u0026lt;len(nums);i++{ if v,ok := hashMap[target-nums[i]];ok{//如果存在就放回hashMap的值  return []int{i,v} } hashMap[nums[i]] = i //添加  } return []int{} //没找到 }   15. 三数之和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  func threeSum(nums []int) [][]int { res := make([][]int, 0) // 先对原始数组进行排序，排序后一来可以过滤很多重复结果，二来可以让twoSum以O(n)处理 \tsort.Ints(nums) for i := 0; i \u0026lt; len(nums); i++ { //if nums[i] == nums[i+1] \u0026amp;\u0026amp; nums[i+1] == nums[i+2] { \t//\tcontinue \t//} \t// 从向后判断改为向前判断相等，那么第一次的结果就一定要加入结果列表里面，然后后面如果有和前面相同的枚举就跳过 \tif i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] { continue } twoSumTarget := nums[i] * -1 l, r := i+1, len(nums)-1 for l \u0026lt; r { // 这里需要确保前指针后移不能越过后指针，然后是向前判断相等 \tif l \u0026gt; i+1 \u0026amp;\u0026amp; nums[l] == nums[l-1] { l++ continue } twoSum := nums[l] + nums[r] if twoSum == twoSumTarget { // 这样的情况就是twoSum符合目标值，记录这个三元组 \tres = append(res, []int{nums[i], nums[l], nums[r]}) // 然后找到三元组后前后指针一起移动 \tr-- l++ } // twoSum比目标值大，后指针要向前移 \tif twoSum \u0026gt; twoSumTarget { //去重 \tr-- continue } if twoSum \u0026lt; twoSumTarget { //去重 \t// twoSum小于目标值，前指针后移 \tl++ continue } } } return res }   16. 最接近的三数之和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  func abs(a int)int{ if a \u0026gt;= 0{ return a }else{ return -a } } func threeSumClosest(nums []int, target int) int { sub := math.MaxInt64 //记录与目标值的差值 \tres := math.MaxInt64 //记录最接近目标的和 \tsort.Ints(nums) for i:=0;i\u0026lt;len(nums);i++{ //去重 \tif i \u0026gt; 0 \u0026amp;\u0026amp; nums[i-1] == nums[i]{ continue //有相同元素可以直接跳过考虑，因为在第一次已经考虑 \t} l := i+1 r := len(nums)-1 // \tfor l \u0026lt; r{ //寻找最接近的三数之和 \tcurr := nums[i] + nums[l] + nums[r] //临时记录和 \tcurrSub := abs(curr - target) //临时的差值 \tif curr \u0026lt; target { //当前的差值小于最少的差值 \tl++ if currSub \u0026lt; sub{ sub = currSub //当前最接近的差值 \tres = curr //当前最接近的结果 \t} }else if curr \u0026gt; target { //差值大于sub，说明和太大了或者太小了 \tr-- if currSub \u0026lt; sub{ sub = currSub //当前最接近的差值 \tres = curr //当前最接近的结果 \t} }else{ //目标值想等，一定是最接近的数，直接返回 \treturn curr } } } return res }   454. 四数相加 II\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  func fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int { //建立一个查找表（采用map，键为nums3和nums4和的可能性，值为出现的频率）  hash1 := make(map[int]int) //nums1 + nums2  hash2 := make(map[int]int) //nums3 + nums4  res := 0 //返回结果  for i:=0;i\u0026lt;len(nums1);i++{ for j:=0;j\u0026lt;len(nums2);j++{ hash1[nums1[i]+nums2[j]]++ //统计频率  } } for i:=0;i\u0026lt;len(nums3);i++{ for j:=0;j\u0026lt;len(nums4);j++{ hash2[nums3[i]+nums4[j]]++ //统计频率  } } for i,v := range hash1{ if hash2[0-i] != 0{ res += v * hash2[0-i] } } return res }   49. 字母异位词分组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  func groupAnagrams(strs []string) [][]string { hash := make(map[string][]string) //构建一个字典  res := make([][]string, 0) //返回结果  for _,v := range strs{ s := []byte(v) //将每个字符串转换成byte切片排序后再转换成string进行映射  sort.Slice(s,func(i,j int)bool{ return s[i] \u0026lt; s[j] //从小到大排列  }) hash[string(s)] = append(hash[string(s)], v) //添加到value切片中  } for _,v := range hash{ res = append(res, v) //把每一个value(一维切片)添加到二维切片中  } return res }   447. 回旋镖的数量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  func numberOfBoomerangs(points [][]int) int { res := 0 //最终返回结果  for i:=0;i\u0026lt;len(points);i++{ //i当做枢纽，寻找到i距离想等的点  hash := make(map[int]int) //本轮的哈希表，不同的i点有不同的哈希表  for j := 0;j\u0026lt;len(points);j++{ //j为另外一个点  if i != j{ //两点不能相同  hash[distance(points[i],points[j])]++ //频率加一  } } //二层循环for  for _,v := range hash{ res += v * (v-1) //第一次有v种选择，第二次有v-1种选择  } } return res } func distance(a,b []int)int{ //如果距离太大需要改用int64  return (a[0]-b[0]) * (a[0]-b[0]) + (a[1]-b[1]) * (a[1]-b[1]) //计算的是a,b两点的平方 }   149. 直线上最多的点数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  func maxPoints(points [][]int) int { //以i点为枢纽，找到与i点组成的直线的斜率相同的点  resMax := 0 //返回值  for i:=0;i\u0026lt;len(points);i++{ //建立一个key为两点斜率，可能为浮点数，所以才要float64，value为相同斜率点的个数  hash := make(map[float64]int) for j:=0;j\u0026lt;len(points);j++{ if i != j{ //不能是同一个点组成直线  hash[lineSlope(points[i],points[j])]++ } } for _,v := range hash{ if v \u0026gt; resMax{ //遍历hash表，同一直线最多的点数  resMax = v } } } return resMax + 1 //因为hash表没有统计点i它自身，所以需要加一 } func lineSlope(a,b []int)float64{ return float64(a[1]-b[1]) / float64(a[0]-b[0]) //相当于(ay-by) / (ax-bx) }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":354,"section":"interview","tags":["算法"],"title":"第四章第一节","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter4/1/"},{"content":"滑动窗口+查找表\n219. 存在重复元素 II\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  func containsNearbyDuplicate(nums []int, k int) bool { //滑动窗口加查找表  hash := make(map[int]int) //key为数组元素，value为出现的频率  for i:=0;i\u0026lt;len(nums);i++{ if hash[nums[i]] \u0026gt; 0{ return true }else{ hash[nums[i]]++ //添加到查找表  } if len(hash) == k+1{ //维护窗口大小  delete(hash,nums[i-k]) } } return false }   217. 存在重复元素\n1 2 3 4 5 6 7 8 9 10 11 12 13  func containsDuplicate(nums []int) bool { //查找表  hash := make(map[int]int) for i:=0;i\u0026lt;len(nums);i++{ if hash[nums[i]] \u0026gt; 0{ return true }else{ hash[nums[i]]++ } } return false }   220. 存在重复元素 III\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  func getId(x ,t int)int{ if x \u0026gt;= 0{ return x / t } return (x+1) / t -1 //0 —— t为一个桶，-1 —— -(t+1)，使用x先减一，除以t，再减1 } func containsNearbyAlmostDuplicate(nums []int, k int, t int) bool { //桶排序 \thash := make(map[int]int) for i:=0;i\u0026lt;len(nums);i++{ id := getId(nums[i], t+1) if _,has := hash[id];has{ return true } if y,has := hash[id+1];has \u0026amp;\u0026amp; math.Abs(float64(y-nums[i])) \u0026lt;= float64(t){ return true } if z,has := hash[id-1];has \u0026amp;\u0026amp; math.Abs(float64(z-nums[i])) \u0026lt;= float64(t){ return true } hash[id] = nums[i] //添加到查找表中  if len(hash) \u0026gt;= k+1{ delete(hash, getId(nums[i-k], t+1)) } } return false }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":355,"section":"interview","tags":["算法"],"title":"第四章第二节","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter4/2/"},{"content":"基础算法思路的应用（对撞指针，双指针） 力扣75. 颜色分类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  func sortColors(nums []int) { n := len(nums) //划分三个区间，扫描一次数组，放入三个区间  //0在区间[0,zero]从0开始不断扩大区间  //2在区间[two,n-1]从n-1开始不断缩小区间  //1在区间[zero+1,two-1]从zero+1开始不断扩大区间  //设置初始值zero,two  zero := -1 //最开始0元素的个数为0，从-1开始  two := n //最开始2元素的个数为0，从n开始  for i:=0;i\u0026lt;two;{//扫描到two就行，因为two到n-1的区间已经确定为2元素  if nums[i] == 1{ i++ //1的范围是由two和zero决定的，所以继续扫描就行  }else if nums[i] == 2{ two-- //先减一扩大two范围,再交换到two  nums[two],nums[i] = nums[i],nums[two] //i++ two所在元素未确定，i不能继续前进  }else {//为0的情况  zero++ nums[zero],nums[i] = nums[i],nums[zero] i++ //zero找到正确的位置，i继续前进  } } }   力扣88. 合并两个有序数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  func merge(nums1 []int, m int, nums2 []int, n int) { //双指针,一个指针指向nums1,一个指针指向nums2  if m == 0{ //  for i:=0;i\u0026lt;len(nums2);i++{ nums1[i] = nums2[i] } return } if n == 0{ return } for m \u0026gt; 0 \u0026amp;\u0026amp; n \u0026gt; 0{ if nums2[n-1] \u0026gt;= nums1[m-1]{ nums1[n+m-1] = nums2[n-1] n-- }else{ nums1[n+m-1] = nums1[m-1] m-- } } for n \u0026gt; 0{//将nums2数组的数补到nums1数组里  nums1[n+m-1] = nums2[n-1] n-- } }   力扣215. 数组中的第K个最大元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  func findKthLargest(nums []int, k int) int { //快排 \tif len(nums) == 1 { return nums[0] } return quickSort(nums, 0, len(nums)-1, len(nums)-k) } func quickSort(nums []int, start, end, k int) int { middle := partition(nums, start, end, k) if middle == k { return nums[middle] } else if middle \u0026lt; k { return quickSort(nums, middle+1, end, k) } else { return quickSort(nums, start, middle-1, k) } } func partition(nums []int, start, end, k int) int { //为基数寻找最佳位置 \tif start \u0026gt;= end { return start } selectMedium(nums,start,end) pivot := nums[start] low := start high := end //挖坑法  for low \u0026lt; high{ for low \u0026lt; high \u0026amp;\u0026amp; nums[high] \u0026gt;= pivot{ high-- } if low \u0026lt; high{ nums[low],nums[high] = nums[high],nums[low] low++ } for low \u0026lt; high \u0026amp;\u0026amp; nums[low] \u0026lt;= pivot{ low++ } if low \u0026lt; high{ nums[high],nums[low] = nums[low],nums[high] high-- } } nums[high] = pivot return high } func selectMedium(nums []int, i, j int){ medium := (i + j) / 2 //直接按照中，小，大排序 \tif nums[i] \u0026lt; nums[medium] { nums[i], nums[medium] = nums[medium], nums[i] } if nums[i] \u0026gt; nums[j] { nums[i], nums[j] = nums[j], nums[i] } if nums[medium] \u0026gt; nums[j] { nums[j], nums[medium] = nums[medium], nums[j] } }   力扣167. 两数之和 II - 输入有序数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func twoSum(numbers []int, target int) []int { //对撞指针O(n)  i,j := 0,len(numbers)-1 // 两个指针的索引  for i != j{ if numbers[i] + numbers[j] == target{ //相等找到，直接返回  return []int{i+1,j+1} }else if numbers[i] + numbers[j] \u0026gt; target{ //如果大于，就缩小j  j-- }else{ //小于，i++  i++ } } return []int{} //不存在 }   力扣125. 验证回文串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  func isalnum(ch byte) bool { return (ch \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;Z\u0026#39;) || (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) } func isPalindrome(s string) bool { temp := []byte(strings.ToUpper(s)) //对撞指针 \tl, r := 0, len(temp)-1 for l \u0026lt; r { if !isalnum(temp[l]) { l++ //跳过该字符 \tcontinue } if !isalnum(temp[r]) { r-- //跳过该字符 \tcontinue } if temp[r] == temp[l] { //进行比较，不相等返回false \tl++ r-- } else { return false } } return true }   力扣344. 反转字符串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  func reverseString(s []byte) { //对撞指针  if len(s) == 0 || len(s) == 1{ return } l,r := 0,len(s)-1 //左右指针  for l \u0026lt; r{ //交换  if s[l] != s[r]{ s[l],s[r] = s[r],s[l] } l++ r-- } }   力扣345. 反转字符串中的元音字母\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  func judege(v byte) bool { //判断是不是元音字母 \tif v == \u0026#39;a\u0026#39; || v == \u0026#39;e\u0026#39; || v == \u0026#39;i\u0026#39; || v == \u0026#39;o\u0026#39; || v == \u0026#39;u\u0026#39; { return true } if v == \u0026#39;A\u0026#39; || v == \u0026#39;E\u0026#39; || v == \u0026#39;I\u0026#39; || v == \u0026#39;O\u0026#39; || v == \u0026#39;U\u0026#39; { return true } return false } func reverseVowels(s string) string { res := []byte(s) //先转换成byte切片，方便交换数据 \tl, r := 0, len(s)-1 //对撞指针 \tfor l \u0026lt; r { for !judege(res[l]) \u0026amp;\u0026amp; l \u0026lt; r { //若不是元音字母，就后移指针 \tl++ } for !judege(res[r]) \u0026amp;\u0026amp; l \u0026lt; r{ // 若不是元音字母，就前移指针 \tr-- } //交换只有两种情况  //1.l,r分别指向两个元音字母  //2.l,r两个指针相遇  //所以不需要考虑交换错字母  res[l],res[r] = res[r],res[l]//交换两个元音字母  l++ r-- } return string(res) }   力扣11. 盛最多水的容器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  func maxArea(height []int) int { //采用对撞指针  l,r := 0,len(height)-1 res := 0 //记录最大的容器容量  curr := 0 //记录遍历的容器容量  for l \u0026lt; r{ if height[l] \u0026lt;= height[r]{//如果某一边直线要短一点就从那边开始移动指针，  curr = height[l] * (r-l) l++ }else{ curr = height[r] * (r-l) r-- } if res \u0026lt; curr{ //如果当前容量大于最大记录容量，则更新最大容量  res = curr } } return res }   总结：涉及知识点——对撞指针 ","description":"对撞指针","id":356,"section":"interview","tags":["算法"],"title":"第三章第二节","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter3/2/"},{"content":"343. 整数拆分\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  func integerBreak(n int) int { //动态规划  dp := make([]int,n+1) dp[1] = 1 var max func(a,b int)int max = func(a,b int)int{ if a \u0026gt; b{ return a } return b } var max3 func(a,b,c int)int max3 = func(a,b,c int)int{ return max(a,max(b,c)) } //外层循环依次求i拆分后乘积的最大值  for i:=2;i\u0026lt;=n;i++{ for j:=1;j\u0026lt;=i-1;j++{ dp[i] = max3(dp[i],j*(i-j),j*dp[i-j]) } } return dp[n] }   279. 完全平方数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  func numSquares(n int) int { f := make([]int, n+1) for i := 1; i \u0026lt;= n; i++ { minn := math.MaxInt32 for j := 1; j*j \u0026lt;= i; j++ { minn = min(minn, f[i-j*j]) } f[i] = minn + 1 } return f[n] } func min(a, b int) int { if a \u0026lt; b { return a } return b }   91. 解码方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  func numDecodings(s string) int { n := len(s) f := make([]int, n+1) f[0] = 1 for i := 1; i \u0026lt;= n; i++ { //只要当前字符不等于\u0026#39;0\u0026#39;就都可以解码成功，加入前一个字符解码的方法  if s[i-1] != \u0026#39;0\u0026#39; { f[i] += f[i-1] } //如果当前字符和前面的字符也能构成一种解码方法，那就再加上前前一个字符的解法方法  if i \u0026gt; 1 \u0026amp;\u0026amp; s[i-2] != \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ((s[i-2]-\u0026#39;0\u0026#39;)*10+(s[i-1]-\u0026#39;0\u0026#39;) \u0026lt;= 26) { f[i] += f[i-2] } } return f[n] }   62. 不同路径\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  func uniquePaths(m int, n int) int { dp := make([][]int,m) for i:=0;i\u0026lt;m;i++{ dp[i] = make([]int,n) } //先求上面能够到达的路径数  for i:=0;i\u0026lt;n;i++{ dp[0][i] = 1 } //求左面能够到达的路径数  for i:=0;i\u0026lt;m;i++{ dp[i][0] = 1 } for i:=1;i\u0026lt;m;i++{ for j:=1;j\u0026lt;n;j++{ //能到达当前格子的路径等于上面格子的路径加入左面格子的路径  dp[i][j] = dp[i-1][j]+dp[i][j-1] } } return dp[m-1][n-1] }   63. 不同路径 II\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  func uniquePathsWithObstacles(obstacleGrid [][]int) int { m,n:=len(obstacleGrid),len(obstacleGrid[0]) dp := make([][]int,m) for i:=0;i\u0026lt;m;i++{ dp[i] = make([]int,n) } if obstacleGrid[0][0] == 0{ dp[0][0] = 1 } //先求上面能够到达的路径数  for i:=1;i\u0026lt;n;i++{ if obstacleGrid[0][i] == 1{ dp[0][i] = 0 }else{ dp[0][i] = dp[0][i-1] } } //求左面能够到达的路径数  for i:=1;i\u0026lt;m;i++{ if obstacleGrid[i][0] == 1{ dp[i][0] = 0 }else{ dp[i][0] = dp[i-1][0] } } for i:=1;i\u0026lt;m;i++{ for j:=1;j\u0026lt;n;j++{ //能到达当前格子的路径等于上面格子的路径加入左面格子的路径  if obstacleGrid[i][j] == 1{ dp[i][j] = 0 }else{ dp[i][j] = dp[i-1][j]+dp[i][j-1] } } } return dp[m-1][n-1] }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":357,"section":"interview","tags":["算法"],"title":"第九章第二节","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter9/2/"},{"content":"基础算法思路的应用（双索引技术——滑动窗口） 209. 长度最小的子数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  func minSubArrayLen(target int, nums []int) int { //滑动窗口  l,r := 0,-1 //nums[l,r]为滑动窗口  sum := 0 //窗口内数的数值之和  res := len(nums) + 1 //窗口内数的个数之和(最优解为个数最少且满足res\u0026gt;=target)  for l \u0026lt; len(nums){//滑动范围  if (r+1) \u0026lt; len(nums) \u0026amp;\u0026amp; sum \u0026lt; target{ //不满足条件，扩大窗口(r++)并考虑边界  r++ sum += nums[r] }else{ //满足条件，缩小窗口(l++)寻找最优解  sum -= nums[l] l++ } if sum \u0026gt;= target { //如果满足条件，判断res与当前区间的大小  if res \u0026gt; (r-l+1){ res = r-l+1 } } } if res == len(nums)+1{//说明不存在  return 0 } return res }   3. 无重复字符的最长子串\n先考虑如下点（通用字符串题）：\n-字符集？只有字母？数字+字母？ASCII？\n-大小写是否敏感？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  func lengthOfLongestSubstring(s string) int { //滑动窗口  var freq[128]int //字符出现频率  l,r := 0,-1 //窗口[l...r]  res := 0 for l \u0026lt; len(s){ if r+1 \u0026lt; len(s) \u0026amp;\u0026amp; freq[s[r+1]] == 0{ //注意边界，如果窗口的下一个字符符合，就加入窗口  r++//扩大窗口  freq[s[r]]++ //频率加一  }else{ //不符合要求，缩小窗口  freq[s[l]]-- l++ //缩小窗口  } if res \u0026lt; (r-l+1){ //更新结果  res = r-l+1 } } return res }   仔细咀嚼上面的代码（知道处理滑动窗口的边界问题，滑动窗口求值的更新问题，窗口扩大与缩小的情况）\n练习题：\n438. 找到字符串中所有字母异位词\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  func findAnagrams(s string, p string) []int { var freq [26]int //统计字符出现的频率  var need [26]int //统计p字符串各字符出现的频率  l,r := 0,-1 //[l...r]窗口  res := make([]int,0) for i:=0;i\u0026lt;len(p);i++{ need[p[i]-\u0026#39;a\u0026#39;]++ //频率++  } for l \u0026lt; len(s) { //窗口滑动范围  if r+1 \u0026lt; len(s) \u0026amp;\u0026amp; r-l+1\u0026lt;len(p){//len(p)大小为一个窗口  r++ //扩大窗口  freq[s[r]-\u0026#39;a\u0026#39;]++ //窗口内字符频率增加  }else{ freq[s[l]-\u0026#39;a\u0026#39;]-- //窗口内字符频率减少（准备缩小窗口）  l++ //缩小窗口  } if r - l + 1 == len(p) \u0026amp;\u0026amp; freq == need{ //判断窗口是否满足条件，若满足则更新结果  res = append(res, l) } } return res }   下面这题很值得多刷几遍\n76. 最小覆盖子串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  func minWindow(s string, t string) string { //优化滑动窗口  var freq [58]int var need [58]int valid := 0 //记录t字符串不同字符的个数  res := \u0026#34;\u0026#34; //返回结果  for i:=0;i\u0026lt;len(t);i++{ if need[t[i]-\u0026#39;A\u0026#39;] == 0{ valid++ //不同字符数量增加  } need[t[i]-\u0026#39;A\u0026#39;]++ } curr := 0 //记录当前窗口里面包含t中不同字符的个数  l,r := 0,-1 //窗口大小[l...r]  for l \u0026lt; len(s){ if (r+1)\u0026lt;len(s) \u0026amp;\u0026amp; valid != curr{ //保证r在扩大窗口之后不会越界  r++ //扩大窗口  freq[s[r]-\u0026#39;A\u0026#39;]++ //增大频率  if freq[s[r]-\u0026#39;A\u0026#39;] == need[s[r]-\u0026#39;A\u0026#39;]{ curr++ //若两个表的值相等，则curr加一  } }else{ freq[s[l]-\u0026#39;A\u0026#39;] -- //减少频率  if freq[s[l]-\u0026#39;A\u0026#39;] \u0026lt; need[s[l]-\u0026#39;A\u0026#39;]{ //更新匹配条件curr  curr-- } l++ //缩小窗口  } if curr == valid{ //更新结果的两种情况：  //1.结果仍然为空字符串  //2.结果比当前成功匹配的窗口大小要大  if res == \u0026#34;\u0026#34; || len(res) \u0026gt; (r-l+1){ res = s[l:r+1] //切片切取的方式来更新  } } } return res }   ","description":"滑动窗口","id":358,"section":"interview","tags":["算法"],"title":"第三章第三节","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter3/3/"},{"content":"198. 打家劫舍\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  func rob(nums []int) int { //动态规划 \tn := len(nums) if n == 1{ return nums[0] } dp := make([]int, n) //dp[i]表示从前i间房子里面能偷盗的最大值 \tdp[0] = nums[0] dp[1] = max(dp[0], nums[1]) for i:=2;i\u0026lt;n;i++{ //状态转移方程 \tdp[i] = max(nums[i]+dp[i-2], dp[i-1]) } return dp[n-1] } func max(a,b int)int{ if a \u0026gt; b{ return a } return b }   213. 打家劫舍 II\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  func MaxDp(a int, b int) int { if a \u0026gt; b { return a } return b } //区别于打家劫舍一，不能同时偷盗第一间和最后一间 func rob(nums []int) int { if len(nums) == 1{ return nums[0] } pre := 0 curr := nums[0] //类似dp[0] \tres1 := curr //1——(n-1) \tfor i := 2; i \u0026lt; len(nums); i++ { //dp[i]最高为dp[n-1] \tres1 = MaxDp(curr, pre+nums[i-1]) pre,curr = curr,res1 } pre = 0 curr = nums[1] res2 := curr //2——n  for i := 3; i \u0026lt;= len(nums); i++ { //dp[i]最高为dp[n-1] \tres2 = MaxDp(curr, pre+nums[i-1]) pre,curr = curr,res2 } return MaxDp(res1, res2) }   337. 打家劫舍 III\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  func rob(root *TreeNode) int { val := dfs(root) return max(val[0], val[1]) } //动态规划 //使用一个一维数组 //0表示选中,1表示不选中该节点 func dfs(node *TreeNode) []int { if node == nil { return []int{0, 0} } l, r := dfs(node.Left), dfs(node.Right) //选择root,则不选择l和r  selected := node.Val + l[1] + r[1] //不选择root,则可以选择l和r或者不选择l和r，取最大值  notSelected := max(l[0], l[1]) + max(r[0], r[1]) return []int{selected, notSelected} } func max(x, y int) int { if x \u0026gt; y { return x } return y }   121. 买卖股票的最佳时机\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  func maxProfit(prices []int) int { //动态规划 \t//dp[k][status],k表示当前是第几天(从0开始)，status表示持有状态，1表示持有，0表示不持有 \t//第k天状态为0的最大利润 \tn := len(prices) dp_i_0 := 0 dp_i_1 := -prices[0] for i := 1; i \u0026lt; n; i++ { dp_i_0 = max(dp_i_0, dp_i_1+prices[i]) dp_i_1 = max(dp_i_1, -prices[i]) } return dp_i_0 } func max(a, b int) int { if a \u0026gt; b { return a } return b }   122. 买卖股票的最佳时机 II\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  func maxProfit(prices []int) int { //动态规划 \t//dp[k][status],k表示当前是第几天(从0开始)，status表示持有状态，1表示持有，0表示不持有 \t//第k天状态为0的最大利润 \tn := len(prices) //不限制交易时，当 k无穷大时，k等于k-1 \tdp_0_0 := 0 //第0天不持有股票 \tdp_0_1 := -prices[0] //第  for i := 1; i \u0026lt; n; i++ { //记录之前的dp[i-1][0]  temp := dp_0_0 dp_0_0 = max(dp_0_0, dp_0_1+prices[i]) dp_0_1 = max(dp_0_1, temp-prices[i]) } return dp_0_0 } func max(a, b int) int { if a \u0026gt; b { return a } return b }   123. 买卖股票的最佳时机 III\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  func maxProfit(prices []int) int { //动态规划  //定义最优子结构  //i表示第多少天(从1开始)，k表示第几次交易(从1开始)，status表示当前股票的是否持有  //dp[i][k][status]  n := len(prices) //4 个 base case  //当k为2时  // dp[0][2][0] = 0  dp_0_2_0 := 0 // dp[0][2][1] = math.MinInt64  dp_0_2_1 := math.MinInt64 // dp[0][1][0] = 0  dp_0_1_0 := 0 // dp[0][1][1] = math.MinInt64  dp_0_1_1 := math.MinInt64 for i:=0;i\u0026lt;n;i++{ dp_0_2_0 = max(dp_0_2_0,dp_0_2_1+prices[i]) dp_0_2_1 = max(dp_0_2_1,dp_0_1_0-prices[i]) dp_0_1_0 = max(dp_0_1_0,dp_0_1_1+prices[i]) dp_0_1_1 = max(dp_0_1_1,-prices[i]) } return dp_0_2_0 } func max(a,b int)int{ if a \u0026gt; b{ return a } return b }   188. 买卖股票的最佳时机 IV\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  func maxProfit(k int, prices []int) int { //动态规划  n := len(prices) //当k大于n/2时，因为一次交易至少要两天（先买后卖），k可以看作无限趋近于无穷大  if k \u0026gt; n/2{ return maxProfitInfinite(k,prices) } //dp[i][k][status]  dp := make([][][]int,n) for i:=0;i\u0026lt;n;i++{ dp[i] = make([][]int,k+1) } for i:=0;i\u0026lt;n;i++{ for j:=0;j\u0026lt;k+1;j++{ dp[i][j] = make([]int,2) } } //base case  for i:=1;i\u0026lt;=k;i++{ dp[0][i][0] = 0 dp[0][i][1] = -prices[0] } for i:=1;i\u0026lt;n;i++{ for j:=k;j\u0026gt;=1;j--{ dp[i][j][0] = max(dp[i-1][j][0],dp[i-1][j][1]+prices[i]) dp[i][j][1] = max(dp[i-1][j][1],dp[i-1][j-1][0]-prices[i]) } } return dp[n-1][k][0] } func max(a,b int)int{ if a \u0026gt; b{ return a } return b } func maxProfitInfinite(k int,prices []int)int{ n := len(prices) //动态规划，省去k  //dp[i][status]，i表示第多少天，status表示股票持有情况  //base case  //从0天开始计算法，base case是-1天的情况  dp_i_0_0 := 0 dp_i_0_1 := math.MinInt64 for i:=0;i\u0026lt;n;i++{ dp_i_0_0 = max(dp_i_0_0,dp_i_0_1+prices[i]) dp_i_0_1 = max(dp_i_0_1,dp_i_0_0-prices[i]) } return dp_i_0_0 }   309. 最佳买卖股票时机含冷冻期\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  func maxProfit(prices []int) int { //动态规划  //dp[i][k][status]  //i表示第i天,k表示第k次交易(不限制交易可以看作无穷次，直接省去k),status表示持有股票情况,0表示不持有,1表示持有  n := len(prices) if n == 1{ return 0 } dp := make([][]int,n) for i:=0;i\u0026lt;n;i++{ dp[i] = make([]int,2) } //base case  //第-1天不持有股票，利润为0(dp[i-1][0])  dp_i_0 := 0 //第-1天持有股票，利润为math.MinInt64(不可能)dp[i-1][1]  dp_i_1 := math.MinInt64 //用来表示dp[i-2][0]  pre := 0 for i:=0;i\u0026lt;n;i++{ //状态转移方程  //temp需要记录下一次赋给pre的值  temp := dp_i_0 dp_i_0 = max(dp_i_0,dp_i_1+prices[i]) dp_i_1 = max(dp_i_1,pre-prices[i]) pre = temp } return dp_i_0 } func max(a,b int)int{ if a \u0026gt; b{ return a } return b }   714. 买卖股票的最佳时机含手续费\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  func maxProfit(prices []int, fee int) int { //动态规划 \t//与前面股票不同点：卖出股票时需要支付一笔费用 \t//dp[i][j][status] \tn := len(prices) dp_0_0 := 0 dp_0_1 := -prices[0] for i := 1; i \u0026lt; n; i++ { temp := dp_0_0 dp_0_0 = max(dp_0_0, dp_0_1+prices[i]-fee) dp_0_1 = max(dp_0_1, temp-prices[i]) } return dp_0_0 } func max(a, b int) int { if a \u0026gt; b { return a } return b }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":359,"section":"interview","tags":["算法"],"title":"第九章第三节","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter9/3/"},{"content":"代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  //0-1背包问题 //weight为各物品的重量，value为各物品的价值，packweight为背包最大载重 func knapsack01(weight []int, value []int, packWeight int) int { //自底向上的动态规划  dp := make([][]int, len(weight)) for i := 0; i \u0026lt; len(weight); i++ { dp[i] = make([]int, packWeight+1) //背包载重为0的情况下，最大价值一定为0 \t} //处理base case \tfor i := 0; i \u0026lt; len(weight); i++ { dp[i][0] = 0 } for i := 1; i \u0026lt; packWeight+1; i++ { if i \u0026gt;= weight[0] { dp[0][i] = weight[0] } } //dp[i][j]表示在背包载重为j的情况下，考虑前一件物品能得到的最大价值 \tfor i := 1; i \u0026lt; len(weight); i++ { for j := 1; j \u0026lt;= packWeight; j++ { //至少的最大价值 \tdp[i][j] = dp[i-1][j] if j \u0026gt;= weight[i] { dp[i][j] = max(dp[i][j], value[i]+dp[i-1][j-weight[i]]) } } } return dp[len(weight)-1][packWeight] } func max(a, b int) int { if a \u0026gt; b { return a } return b }   对空间的优化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  //0-1背包问题 func knapsack01(weight []int, value []int, packWeight int) int { //自底向上的动态规划 \t//对于空间的优化，通过观察状态转移方程，发现两行即可 \tn := len(weight) dp := make([][]int, 2) for i := 0; i \u0026lt; 2; i++ { dp[i] = make([]int, packWeight+1) //背包载重为0的情况下，最大价值一定为0 \t} //处理base case \tfor i := 0; i \u0026lt; 2; i++ { dp[i][0] = 0 } for i := 1; i \u0026lt; packWeight+1; i++ { if i \u0026gt;= weight[0] { dp[0][i] = weight[0] } } //dp[i][j]表示在背包载重为j的情况下，考虑前一件物品能得到的最大价值 \tfor i := 1; i \u0026lt; n; i++ { for j := 1; j \u0026lt;= packWeight; j++ { //至少的最大价值 \tdp[i%2][j] = dp[(i-1)%2][j] if j \u0026gt;= weight[i] { dp[i%2][j] = max(dp[i%2][j], value[i]+dp[(i-1)%2][j-weight[i]]) } } } return dp[(len(weight)-1)%2][packWeight] } func max(a, b int) int { if a \u0026gt; b { return a } return b }   关于0-1背包问题变种的解决 ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":360,"section":"interview","tags":["算法"],"title":"第九章第四节——0-1背包","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter9/4/"},{"content":"300. 最长递增子序列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  func lengthOfLIS(nums []int) int { //动态规划 \t//最优子结构dp[i]表示以nums[i]结尾的最长递增序列的长度 \tn := len(nums) dp := make([]int, n) max := 0 for i := 0; i \u0026lt; n; i++ { for j := 0; j \u0026lt; i; j++ { if nums[i] \u0026gt; nums[j] { if dp[i] \u0026lt; dp[j]+1 { dp[i] = dp[j] + 1 } } } if max \u0026lt; dp[i] { max = dp[i] } } return max + 1 }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":361,"section":"interview","tags":["算法"],"title":"第九章第五节——最长递增子序列","uri":"https://www.zhugeqing.top/interview/algorithm_interview/chapter9/5/"},{"content":"冒泡排序是入门级的算法，但也有一些有趣的玩法。通常来说，冒泡排序有三种写法：\n 一边比较一边向后两两交换，将最大值 / 最小值冒泡到最后一位； 经过优化的写法：使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序； 进一步优化的写法：除了使用变量记录当前轮次是否发生交换外，再使用一个变量记录上次发生交换的位置，下一轮排序时到达上次交换的位置就停止比较。  先来看看冒泡排序的动图吧！\n 冒泡排序的第一种写法 golang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  //升序排序 func swap(arr []int, i, j int) { //交换元素（异或） \tarr[i] = arr[i] ^ arr[j] arr[j] = arr[j] ^ arr[i] arr[i] = arr[i] ^ arr[j] } func bubbleSort(arr []int) { for i := 0; i \u0026lt; len(arr)-1; i++ { for j := 0; j \u0026lt; len(arr)-i-1; j++ { if arr[j] \u0026gt; arr[j+1] { swap(arr, j, j+1) } } } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public static void bubbleSort(int[] arr) { for (int i = 0; i \u0026lt; arr.length - 1; i++) { for (int j = 0; j \u0026lt; arr.length - 1 - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { // 如果左边的数大于右边的数，则交换，保证右边的数字最大  swap(arr, j, j + 1); } } } } // 交换元素 private static void swap(int[] arr, int i, int j) { arr[i] = arr[i] ^ arr[j]; arr[j] = arr[j] ^ arr[i]; arr[i] = arr[i] ^ arr[j]; }    \r  'use strict'; var containerId = JSON.parse(\"\\\"b4325ab8e97102aa\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  冒泡排序的第二种写法 golang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  func swap(arr []int, i, j int) { //交换元素（异或）  arr[i] = arr[i] ^ arr[j] arr[j] = arr[j] ^ arr[i] arr[i] = arr[i] ^ arr[j] } //经过优化的写法：使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序； func bubbleSort(arr []int) { swapped := true //记录是否发生交换  for i := 0; i \u0026lt; len(arr)-1; i++ { if !swapped { //若上一轮未发生交换，就退出排序  break } swapped = false for j := 0; j \u0026lt; len(arr)-i-1; j++ { if arr[j] \u0026gt; arr[j+1] { swap(arr, j, j+1) swapped = true //发生交换  } } } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  public static void bubbleSort(int[] arr) { // 初始时 swapped 为 true，否则排序过程无法启动  boolean swapped = true; for (int i = 0; i \u0026lt; arr.length - 1; i++) { // 如果没有发生过交换，说明剩余部分已经有序，排序完成  if (!swapped) break; // 设置 swapped 为 false，如果发生交换，则将其置为 true  swapped = false; for (int j = 0; j \u0026lt; arr.length - 1 - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { // 如果左边的数大于右边的数，则交换，保证右边的数字最大  swap(arr, j, j + 1); // 表示发生了交换  swapped = true; } } } } // 交换元素 private static void swap(int[] arr, int i, int j) { arr[i] = arr[i] ^ arr[j]; arr[j] = arr[j] ^ arr[i]; arr[i] = arr[i] ^ arr[j]; }    \r  'use strict'; var containerId = JSON.parse(\"\\\"27e8998f1d8b9c71\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  冒泡排序的第三种写法 golang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  func swap(arr []int, i, j int) { //交换元素（异或）  arr[i] = arr[i] ^ arr[j] arr[j] = arr[j] ^ arr[i] arr[i] = arr[i] ^ arr[j] } //进一步优化的写法：除了使用变量记录当前轮次是否发生交换外， //再使用一个变量记录上次发生交换的位置，下一轮排序时到达上次交换的位置就停止比较 func bubbleSort(arr []int) { swapped := true //记录是否发生交换  indexOfLastUnsortedElement := len(arr) - 1 // 上次发生交换的位置  swappedIndex := -1 for swapped { swapped = false for i := 0; i \u0026lt; indexOfLastUnsortedElement; i++ { if arr[i] \u0026gt; arr[i+1] { swap(arr, i, i+1) swapped = true //发生交换  swappedIndex = i } } indexOfLastUnsortedElement = swappedIndex } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  public static void bubbleSort(int[] arr) { boolean swapped = true; // 最后一个没有经过排序的元素的下标  int indexOfLastUnsortedElement = arr.length - 1; // 上次发生交换的位置  int swappedIndex = -1; while (swapped) { swapped = false; for (int i = 0; i \u0026lt; indexOfLastUnsortedElement; i++) { if (arr[i] \u0026gt; arr[i + 1]) { // 如果左边的数大于右边的数，则交换，保证右边的数字最大  swap(arr, i, i + 1); // 表示发生了交换  swapped = true; // 更新交换的位置  swappedIndex = i; } } // 最后一个没有经过排序的元素的下标就是最后一次发生交换的位置  indexOfLastUnsortedElement = swappedIndex; } } // 交换元素 private static void swap(int[] arr, int i, int j) { arr[i] = arr[i] ^ arr[j]; arr[j] = arr[j] ^ arr[i]; arr[i] = arr[i] ^ arr[j]; }    \r  'use strict'; var containerId = JSON.parse(\"\\\"ea5470d4fe4f6d04\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  时间复杂度 \u0026amp; 空间复杂度 冒泡排序从 1956 年就有人开始研究，之后经历过多次优化。它的空间复杂度为 O(1)，时间复杂度为 O(n^2)，第二种、第三种冒泡排序由于经过优化，最好的情况下只需要 O(n)的时间复杂度。\n最好情况：在数组已经有序的情况下，只需遍历一次，由于没有发生交换，排序结束。\n最差情况：数组顺序为逆序，每次比较都会发生交换。\n但优化后的冒泡排序平均时间复杂度仍然是 O(n^2)，所以这些优化对算法的性能并没有质的提升。正如 Donald E. Knuth（1974 年图灵奖获得者）所言：“冒泡排序法除了它迷人的名字和导致了某些有趣的理论问题这一事实外，似乎没有什么值得推荐的。”\n不管怎么说，冒泡排序法是所有排序算法的老祖宗，如同程序界经典的 「Hello, world」 一般经久不衰，总是出现在各类算法书刊的首个章节。但面试时如果你说你只会冒泡排序可就太掉价了，下一节我们就来认识一下他的继承者们。\n稳定性 冒泡排序是稳定的。\n","description":"战略上藐视技术，战术上重视技术——闪客","id":362,"section":"data_structure_and_sort","tags":["排序算法"],"title":"冒泡排序","uri":"https://www.zhugeqing.top/data_structure_and_sort/sort/bub/"},{"content":"选择排序的思想是：双重循环遍历数组，每经过一轮比较，找到最小元素的下标，将其交换至首位。\n选择排序就好比第一个数字站在擂台上，大吼一声：“还有谁比我小？”。剩余数字来挨个打擂，如果出现比第一个数字小的数，则新的擂主产生。每轮打擂结束都会找出一个最小的数，将其交换至首位。经过 n-1 轮打擂，所有的数字就按照从小到大排序完成了。\n先来看看选择排序的动图吧！\n \n图中可以看出，每一轮排序都找到了当前的最小值，这个最小值就是被选中的数字，将其交换至本轮首位。这就是「选择排序法」名称的由来。\n正是由于它比较容易理解，许多初学者在排序时非常喜欢使用选择排序法。\n现在让我们思考一下，冒泡排序和选择排序有什么异同？\n相同点：\n 都是两层循环，时间复杂度都为 O(n^2); 都只使用有限个变量，空间复杂度 O(1)。  不同点：\n 冒泡排序在比较过程中就不断交换；而选择排序增加了一个变量保存最小值 / 最大值的下标，遍历完成后才交换，减少了交换次数。  事实上，冒泡排序和选择排序还有一个非常重要的不同点，那就是：\n 冒泡排序法是稳定的，选择排序法是不稳定的。  想要理解这点不同，我们先要知道什么是排序算法的稳定性。\n排序算法的稳定性 假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i] = r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的。 理解了稳定性的定义后，我们就能分析出：冒泡排序中，只有左边的数字大于右边的数字时才会发生交换，相等的数字之间不会发生交换，所以它是稳定的。\n而选择排序中，最小值和首位交换的过程可能会破坏稳定性。比如数列：[2, 2, 1]，在选择排序中第一次进行交换时，原数列中的两个 2 的相对顺序就被改变了，因此，我们说选择排序是不稳定的。\n那么排序算法的稳定性有什么意义呢？其实它只在一种情况下有意义：当要排序的内容是一个对象的多个属性，且其原本的顺序存在意义时，如果我们需要在二次排序后保持原有排序的意义，就需要使用到稳定性的算法。\n举个例子，如果我们要对一组商品排序，商品存在两个属性：价格和销量。当我们按照价格从高到低排序后，要再按照销量对其排序，这时，如果要保证销量相同的商品仍保持价格从高到低的顺序，就必须使用稳定性算法。\n当然，算法的稳定性与具体的实现有关。在修改比较的条件后，稳定性排序算法可能会变成不稳定的。如冒泡算法中，如果将「左边的数大于右边的数，则交换」这个条件修改为「左边的数大于或等于右边的数，则交换」，冒泡算法就变得不稳定了。\n同样地，不稳定排序算法也可以经过修改，达到稳定的效果。思考一下，选择排序算法如何实现稳定排序呢？\n实现的方式有很多种，这里给出一种最简单的思路：新开一个数组，将每轮找出的最小值依次添加到新数组中，选择排序算法就变成稳定的了。\n但如果将寻找最小值的比较条件由arr[minIndex] \u0026gt; arr[j]修改为arr[minIndex] \u0026gt;= arr[j]，即使新开一个数组，选择排序算法依旧是不稳定的。所以分析算法的稳定性时，需要结合具体的实现逻辑才能得出结论，我们通常所说的算法稳定性是基于一般实现而言的。\n选择排序的一般写法 golang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  func swap(arr []int, i, j int) { //交换元素（异或）  arr[i] = arr[i] ^ arr[j] arr[j] = arr[j] ^ arr[i] arr[i] = arr[i] ^ arr[j] } func selectionSort(arr []int) { for i := 0; i \u0026lt; len(arr)-1; i++ { minIndex := i for j := i + 1; j \u0026lt; len(arr); j++ { //因为minIndex起始是i，所有j比较从i+1开始  if arr[j] \u0026lt; arr[minIndex] { minIndex = j//记录最小数的下标  } } if minIndex != i { //因为采取的异或交换，若两个值相等，会变成0，所有进行判断  swap(arr, i, minIndex) } } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public static void selectionSort(int[] arr) { int minIndex; for (int i = 0; i \u0026lt; arr.length - 1; i++) { minIndex = i; for (int j = i + 1; j \u0026lt; arr.length; j++) { if (arr[minIndex] \u0026gt; arr[j]) { // 记录最小值的下标  minIndex = j; } } // 将最小元素交换至首位  int temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; } }    \r  'use strict'; var containerId = JSON.parse(\"\\\"9bc07431fc93d4ed\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  二元选择排序 选择排序算法也是可以优化的，既然每轮遍历时找出了最小值，何不把最大值也顺便找出来呢？这就是二元选择排序的思想。\n使用二元选择排序，每轮选择时记录最小值和最大值，可以把数组需要遍历的范围缩小一倍。\n二元选择排序的一般写法 golang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  func swap(arr []int, i, j int) { //交换元素（异或）  arr[i] = arr[i] ^ arr[j] arr[j] = arr[j] ^ arr[i] arr[i] = arr[i] ^ arr[j] } func selectionSort(arr []int) { // i 只需要遍历一半  for i := 0; i \u0026lt; len(arr)/2; i++ { maxIndex := i minIndex := i for j := i + 1; j \u0026lt; len(arr)-i; j++ { if arr[j] \u0026lt; arr[minIndex] { minIndex = j } if arr[j] \u0026gt; arr[maxIndex] { maxIndex = j } } //如果 minIndex 和 maxIndex 都相等，那么他们必定都等于 i，且后面的所有数字都与 arr[i] 相等，此时已经排序完成  if minIndex == maxIndex { break } if arr[i] != arr[minIndex] { //因为采取的异或交换，若两个值相等，会变成0，所有进行判断  swap(arr, i, minIndex) // 将最小元素交换至首位  } if maxIndex == i { // 如果最大值的下标刚好是 i，由于 arr[i] 和 arr[minIndex] 已经交换了，所以这里要更新 maxIndex 的值。  maxIndex = minIndex } lastIndex := len(arr) - i - 1 //末尾下标  if arr[maxIndex] != arr[lastIndex] {//因为采取的异或交换，若两个值相等，会变成0，所有进行判断s  swap(arr, maxIndex, lastIndex) // 将最大元素交换至末尾  } } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  public static void selectionSort2(int[] arr) { int minIndex, maxIndex; // i 只需要遍历一半  for (int i = 0; i \u0026lt; arr.length / 2; i++) { minIndex = i; maxIndex = i; for (int j = i + 1; j \u0026lt; arr.length - i; j++) { if (arr[minIndex] \u0026gt; arr[j]) { // 记录最小值的下标  minIndex = j; } if (arr[maxIndex] \u0026lt; arr[j]) { // 记录最大值的下标  maxIndex = j; } } // 如果 minIndex 和 maxIndex 都相等，那么他们必定都等于 i，且后面的所有数字都与 arr[i] 相等，此时已经排序完成  if (minIndex == maxIndex) break; // 将最小元素交换至首位  int temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; // 如果最大值的下标刚好是 i，由于 arr[i] 和 arr[minIndex] 已经交换了，所以这里要更新 maxIndex 的值。  if (maxIndex == i) maxIndex = minIndex; // 将最大元素交换至末尾  int lastIndex = arr.length - 1 - i; temp = arr[lastIndex]; arr[lastIndex] = arr[maxIndex]; arr[maxIndex] = temp; } }    \r  'use strict'; var containerId = JSON.parse(\"\\\"3ea7af051d687fea\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  我们使用 minIndex 记录最小值的下标，maxIndex 记录最大值的下标。每次遍历后，将最小值交换到首位，最大值交换到末尾，就完成了排序。\n由于每一轮遍历可以排好两个数字，所以最外层的遍历只需遍历一半即可。\n二元选择排序中有一句很重要的代码，它位于交换最小值和交换最大值的代码中间：\ngolang java  1 2 3  if maxIndex == i{ maxIndex = minIndex }    \r1  if (maxIndex == i) maxIndex = minIndex;    \r  'use strict'; var containerId = JSON.parse(\"\\\"a44db8db3e55a7a5\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  这行代码的作用处理了一种特殊情况：如果最大值的下标等于 i，也就是说 arr[i] 就是最大值，由于 arr[i] 是当前遍历轮次的首位，它已经和 arr[minIndex] 交换了，所以最大值的下标需要跟踪到 arr[i] 最新的下标 minIndex。\n二元选择排序的效率 在二元选择排序算法中，数组需要遍历的范围缩小了一倍。那么这样可以使选择排序的效率提升一倍吗？\n从代码可以看出，虽然二元选择排序最外层的遍历范围缩小了，但 for 循环内做的事情翻了一倍。也就是说二元选择排序无法将选择排序的效率提升一倍。但实测会发现二元选择排序的速度确实比选择排序的速度快一点点，它的速度提升主要是因为两点：\n 在选择排序的外层 for 循环中，i 需要加到 arr.length - 1 ，二元选择排序中 i 只需要加到 arr.length / 2 在选择排序的内层 for 循环中，j 需要加到 arr.length ，二元选择排序中 j 只需要加到 arr.length - i  时间复杂度 \u0026amp; 空间复杂度 前文已经说到，选择排序使用两层循环，时间复杂度为 O(n^2)，只使用有限个变量，空间复杂度 O(1)。二元选择排序虽然比选择排序要快，但治标不治本，二元选择排序中做的优化无法改变其时间复杂度，二元选择排序的时间复杂度仍然是 O(n^2)只使用有限个变量，空间复杂度 O(1)。\n稳定性 选择排序和二元选择排序都是不稳定的。\nTips：排序算法的稳定性与效率、可靠性都无关。 ","description":"战略上藐视技术，战术上重视技术——闪客","id":363,"section":"data_structure_and_sort","tags":["排序算法"],"title":"选择排序","uri":"https://www.zhugeqing.top/data_structure_and_sort/sort/sel/"},{"content":"插入排序的思想非常简单，生活中有一个很常见的场景：在打扑克牌时，我们一边抓牌一边给扑克牌排序，每次摸一张牌，就将它插入手上已有的牌中合适的位置，逐渐完成整个排序。\n插入排序有两种写法：\n 交换法：在新数字插入过程中，不断与前面的数字交换，直到找到自己合适的位置。 移动法：在新数字插入过程中，与前面的数字不断比较，前面的数字不断向后挪出位置，当新数字找到自己的位置后，插入一次即可。  先来看看选择排序的动图吧！\n 交换法插入排序 当数字少于两个时，不存在排序问题，当然也不需要插入，所以我们直接从第二个数字开始往前插入。\n整个过程就像是已经有一些数字坐成了一排，这时一个新的数字要加入，这个新加入的数字原本坐在这一排数字的最后一位，然后它不断地与前面的数字比较，如果前面的数字比它大，它就和前面的数字交换位置。\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  func swap(arr []int, i, j int) { //交换元素（异或）  arr[i] = arr[i] ^ arr[j] arr[j] = arr[j] ^ arr[i] arr[i] = arr[i] ^ arr[j] } //交换法插入排序 func insertSort(arr []int) { // 从第二个数开始，往前插入数字  for i := 1; i \u0026lt; len(arr); i++ { // j 记录当前数字下标  j := i // 当前数字比前一个数字小，则将当前数字与前一个数字交换  for j \u0026gt;= 1 \u0026amp;\u0026amp; arr[j-1] \u0026gt; arr[j] { swap(arr, j-1, j) // 更新当前数字下标  j-- } } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public static void insertSort(int[] arr) { // 从第二个数开始，往前插入数字  for (int i = 1; i \u0026lt; arr.length; i++) { // j 记录当前数字下标  int j = i; // 当前数字比前一个数字小，则将当前数字与前一个数字交换  while (j \u0026gt;= 1 \u0026amp;\u0026amp; arr[j] \u0026lt; arr[j - 1]) { swap(arr, j, j - 1); // 更新当前数字下标  j--; } } } private static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; }    \r  'use strict'; var containerId = JSON.parse(\"\\\"dc728ddd1cc8225a\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  移动法插入排序 我们发现，在交换法插入排序中，每次交换数字时，swap 函数都会进行三次赋值操作。但实际上，新插入的这个数字并不一定适合与它交换的数字所在的位置。也就是说，它刚换到新的位置上不久，下一次比较后，如果又需要交换，它马上又会被换到前一个数字的位置。\n由此，我们可以想到一种优化方案：让新插入的数字先进行比较，前面比它大的数字不断向后移动，直到找到适合这个新数字的位置后，新数字只做一次插入操作即可。\n这种方案我们需要把新插入的数字暂存起来，代码如下：\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  func insertSort(arr []int) { // 从第二个数开始，往前插入数字  for i := 1; i \u0026lt; len(arr); i++ { currentNumber := arr[i] j := i - 1 // 寻找插入位置的过程中，不断地将比 currentNumber 大的数字向后挪  for j \u0026gt;= 0 \u0026amp;\u0026amp; currentNumber \u0026lt; arr[j] { arr[j+1] = arr[j] //更新下标  j-- } // 两种情况会跳出循环：1. 遇到一个小于或等于 currentNumber 的数字，跳出循环，currentNumber 就坐到它后面。  // 2. 已经走到数列头部，仍然没有遇到小于或等于 currentNumber 的数字，也会跳出循环，此时 j 等于 -1，currentNumber 就坐到数列头部。  arr[j+1] = currentNumber }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public static void insertSort(int[] arr) { // 从第二个数开始，往前插入数字  for (int i = 1; i \u0026lt; arr.length; i++) { int currentNumber = arr[i]; int j = i - 1; // 寻找插入位置的过程中，不断地将比 currentNumber 大的数字向后挪  while (j \u0026gt;= 0 \u0026amp;\u0026amp; currentNumber \u0026lt; arr[j]) { arr[j + 1] = arr[j]; j--; } // 两种情况会跳出循环：1. 遇到一个小于或等于 currentNumber 的数字，跳出循环，currentNumber 就坐到它后面。  // 2. 已经走到数列头部，仍然没有遇到小于或等于 currentNumber 的数字，也会跳出循环，此时 j 等于 -1，currentNumber 就坐到数列头部。  arr[j + 1] = currentNumber; } }    \r  'use strict'; var containerId = JSON.parse(\"\\\"b2714f8c627545cd\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  整个过程就像是已经有一些数字坐成了一排，这时一个新的数字要加入，所以这一排数字不断地向后腾出位置，当新的数字找到自己合适的位置后，就可以直接坐下了。重复此过程，直到排序结束。\n时间复杂度 \u0026amp; 空间复杂度 插入排序过程需要两层循环，时间复杂度为 O(n^2)，只需要常量级的临时变量，空间复杂度为 O(1)。\n稳定性 插入排序的过程不会破坏原有数组中相同关键字的相对次序，所以插入排序是一种稳定的排序算法。\n","description":"战略上藐视技术，战术上重视技术——闪客","id":364,"section":"data_structure_and_sort","tags":["排序算法"],"title":"插入排序","uri":"https://www.zhugeqing.top/data_structure_and_sort/sort/ins/"},{"content":"冒泡排序 冒泡排序有两种优化方式：\n 记录当前轮次是否发生过交换，没有发生过交换表示数组已经有序； 记录上次发生交换的位置，下一轮排序时只比较到此位置。  选择排序 选择排序可以演变为二元选择排序：\n 二元选择排序：一次遍历选出两个值——最大值和最小值； 二元选择排序剪枝优化：当某一轮遍历出现最大值和最小值相等，表示数组中剩余元素已经全部相等。  插入排序 插入排序有两种写法：\n 交换法：新数字通过不断交换找到自己合适的位置； 移动法：旧数字不断向后移动，直到新数字找到合适的位置。  相同点  时间复杂度都是 O(n^2),空间复杂度都是 O(1)。 都需要采用两重循环。  不同点  选择排序是不稳定的，冒泡排序、插入排序是稳定的； 在这三个排序算法中，选择排序交换的次数是最少的； 在数组几乎有序的情况下，插入排序的时间复杂度接近线性级别。  ","description":"战略上藐视技术，战术上重视技术——闪客","id":365,"section":"data_structure_and_sort","tags":["排序算法"],"title":"O(n^2)排序算法的小结","uri":"https://www.zhugeqing.top/data_structure_and_sort/sort/conclusion1/"},{"content":"1959 年 77 月，美国辛辛那提大学的数学系博士 Donald Shell 在 《ACM 通讯》上发表了希尔排序算法，成为首批将时间复杂度降到 O(n^2)以下的算法之一。虽然原始的希尔排序最坏时间复杂度仍然是 O(n^2) ，但经过优化的希尔排序可以达到 O(n^(1.3))甚至 O(n^(7/6))。\n略为遗憾的是，所谓「一将功成万骨枯」，希尔排序和冒泡、选择、插入等排序算法一样，逐渐被快速排序所淘汰，但作为承上启下的算法，不可否认的是，希尔排序身上始终闪耀着算法之美。\n希尔排序本质上是对插入排序的一种优化，它利用了插入排序的简单，又克服了插入排序每次只交换相邻两个元素的缺点。它的基本思想是：\n 将待排序数组按照一定的间隔分为多个子数组，每组分别进行插入排序。这里按照间隔分组指的不是取连续的一段数组，而是每跳跃一定间隔取一个值组成一组 逐渐缩小间隔进行下一轮排序 最后一轮时，取间隔为 1，也就相当于直接使用插入排序。但这时经过前面的「宏观调控」，数组已经基本有序了，所以此时的插入排序只需进行少量交换便可完成  举个例子，对数组 [84, 83, 88, 87, 61, 50, 70, 60, 80, 99]进行希尔排序的过程如下：\n 第一遍（5间隔排序）：按照间隔 5分割子数组，共分成五组，分别[84, 50], [83, 70], [88, 60], [87, 80], [61, 99] 。对它们进行插入排序，排序后它们分别变成：[50, 84], [70, 83], [60, 88], [80, 87], [61, 99]。此时整个数组变成 [50, 70, 60, 80, 61, 84, 83, 88, 87, 99]。 第二遍（2间隔排序）：按照间隔 2分割子数组，共分成两组，分别是 [50, 60, 61, 83, 87], [70, 80, 84, 88, 99]。对他们进行插入排序，排序后它们分别变成： [50, 60, 61, 83, 87], [70, 80, 84, 88, 99]，此时整个数组变成[50, 70, 60, 80, 61, 84, 83, 88, 87, 99]。这里有一个非常重要的性质：当我们完成2间隔排序后，这个数组仍然是保持 5间隔有序的。也就是说，更小间隔的排序没有把上一步的结果变坏。 第三遍（1间隔排序，等于直接插入排序）：按照间隔 1分割子数组，分成一组，也就是整个数组。对其进行插入排序，经过前两遍排序，数组已经基本有序了，所以这一步只需经过少量交换即可完成排序。排序后数组变成 [50, 60, 61, 70, 80, 83, 84, 87, 88, 99]，整个排序完成。  先来看看希尔排序的动图吧！\n \n其中，每一遍排序的间隔在希尔排序中被称之为增量，所有的增量组成的序列称之为增量序列，也就是本例中的 [5, 2, 1][5,2,1]。增量依次递减，最后一个增量必须为 11，所以希尔排序又被称之为「缩小增量排序」。要是以专业术语来描述希尔排序，可以分为以下两个步骤：\n  定义增量序列 D_m \u0026gt; D_{m-1} \u0026gt; D_{m-2} \u0026gt; \u0026hellip; \u0026gt; D_1 = 1\n  对每个 D_k进行[D_k间隔排序]\n  有一条非常重要的性质保证了希尔排序的效率：\n [D_{k+1}间隔]有序的序列，在经过[D_k间隔]排序后，仍然是 [D_{k+1}间隔]有序的\n  增量序列的选择会极大地影响希尔排序的效率，我们采用的增量序列为 D_m = N/2, D_k = D_{k+1} / 2,这个序列正是当年希尔发表此算法的论文时选用的序列，所以也被称之为希尔增量序列\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  func shellSort(arr []int){ //生成间隔序列，在希尔排序中我们称之为增量序列  for gap:=len(arr)/2;gap\u0026gt;0;gap/=2{ //将一个数组转换成gap个数组（每一个数组各个元素之间的距离相差gap）  for groupStartIndex:=0;groupStartIndex\u0026lt;gap;groupStartIndex++{\t//插入排序(i:=groupStartIndex+gap就相当于插入排序的i:=1)  for i:=groupStartIndex+gap;i\u0026lt;len(arr);i+=gap{ currentNumber:=arr[i] j:=i-gap for j \u0026gt;=0 \u0026amp;\u0026amp; currentNumber \u0026lt; arr[j]{ arr[j+gap] = arr[j] j -= gap } arr[j+gap] = currentNumber }\t} } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public static void shellSort(int[] arr) { // 间隔序列，在希尔排序中我们称之为增量序列  for (int gap = arr.length / 2; gap \u0026gt; 0; gap /= 2) { // 分组  for (int groupStartIndex = 0; groupStartIndex \u0026lt; gap; groupStartIndex++) { // 插入排序  for (int currentIndex = groupStartIndex + gap; currentIndex \u0026lt; arr.length; currentIndex += gap) { // currentNumber 站起来，开始找位置  int currentNumber = arr[currentIndex]; int preIndex = currentIndex - gap; while (preIndex \u0026gt;= groupStartIndex \u0026amp;\u0026amp; currentNumber \u0026lt; arr[preIndex]) { // 向后挪位置  arr[preIndex + gap] = arr[preIndex]; preIndex -= gap; } // currentNumber 找到了自己的位置，坐下  arr[preIndex + gap] = currentNumber; } } } }    \r  'use strict'; var containerId = JSON.parse(\"\\\"9f1071fdbe5a7596\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  这段代码可以优化一下。我们现在的处理方式是：处理完一组间隔序列后，再回来处理下一组间隔序列，这非常符合人类思维。但对于计算机来说，它更喜欢从第 gap 个元素开始，按照顺序将每个元素依次向前插入自己所在的组这种方式。虽然这个过程看起来是在不同的间隔序列中不断跳跃，但站在计算机的角度，它是在访问一段连续数组。\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func shellSort(arr []int){ //创建 间隔序列（增量序列）  for gap:=len(arr)/2;gap\u0026gt;0;gap/=2{ for i:=gap;i\u0026lt;len(arr);i++{ currentNumber := arr[i]//记录当前需要插入的数  j := i-gap//记录当前下标的前一个下标  for j\u0026gt;=0 \u0026amp;\u0026amp; arr[j] \u0026gt; currentNumber{ arr[j+gap] = arr[j] //后移元素  j -= gap //更新下标  } arr[j+gap] = currentNumber } } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public static void shellSort(int[] arr) { // 间隔序列，在希尔排序中我们称之为增量序列  for (int gap = arr.length / 2; gap \u0026gt; 0; gap /= 2) { // 从 gap 开始，按照顺序将每个元素依次向前插入自己所在的组  for (int i = gap; i \u0026lt; arr.length; i++) { // currentNumber 站起来，开始找位置  int currentNumber = arr[i]; // 该组前一个数字的索引  int preIndex = i - gap; while (preIndex \u0026gt;= 0 \u0026amp;\u0026amp; currentNumber \u0026lt; arr[preIndex]) { // 向后挪位置  arr[preIndex + gap] = arr[preIndex]; preIndex -= gap; } // currentNumber 找到了自己的位置，坐下  arr[preIndex + gap] = currentNumber; } } }    \r  'use strict'; var containerId = JSON.parse(\"\\\"f680c6db40481e9c\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  经过优化之后，这段代码看起来就和插入排序非常相似了，区别仅在于希尔排序最外层嵌套了一个缩小增量的 for 循环；并且插入时不再是相邻数字挪动，而是以增量为步长挪动。\n增量序列 增量序列的选择会极大地影响希尔排序的效率。增量序列如果选得不好，希尔排序的效率可能比插入排序效率还要低，举个例子：\n \n在这个例子中，我们发现，原数组 8 间隔、4 间隔、2 间隔都已经有序了，使用希尔排序时，真正起作用的只有最后一轮 1 间隔排序，也就是直接插入排序。希尔排序反而比直接使用插入排序多执行了许多无用的逻辑。\n于是人们发现：增量元素不互质，则小增量可能根本不起作用。\n事实上，希尔排序的增量序列如何选择是一个数学界的难题，但它也是希尔排序算法的核心优化点。数学界有不少的大牛做过这方面的研究。比较著名的有 Hibbard 增量序列、Knuth 增量序列、Sedgewick 增量序列。\n  Hibbard 增量序列：D_k = 2^k - 1,也就是1, 3, 7, 15,\u0026hellip;。数学界猜想它最坏的时间复杂度为 O(n^(3/2))，平均时间复杂度为 O(n^(5/4));\n  Knuth 增量序列：D_1 = 1; D_{k+1} = 3 * D_{k + 1},也就是1, 4, 13, 40, \u0026hellip;,数学界猜想它的平均时间复杂度为 O(n^(3/2))\n  Sedgewick 增量序列：1,5,19,41,109,\u0026hellip;,这个序列的元素有的是通过 9 * 4^k - 9 * 2^k + 1 计算出来的，有的是通过 4^k - 3 * 2^k + 1 计算出来的。数学界猜想它最坏的时间复杂度为 O(n^(4/3)),平均时间复杂度为 O(n^(7/6)).\n  使用 Knuth 序列进行希尔排序的代码如下：\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  func shellSort(arr []int){ // 找到当前数组需要用到的 Knuth 序列中的最大值  maxKnuthNumber := 1; for maxKnuthNumber \u0026lt;= len(arr) / 3 { maxKnuthNumber = maxKnuthNumber * 3 + 1 } //创建 间隔序列（增量序列）  for gap:=maxKnuthNumber;gap\u0026gt;0;gap = (gap-1)/3{ // 从 gap 开始，按照顺序将每个元素依次向前插入自己所在的组  for i:=gap;i\u0026lt;len(arr);i++{ currentNumber := arr[i] j := i - gap //记录当前元素下标的上一个下标  for j\u0026gt;=0 \u0026amp;\u0026amp; arr[j] \u0026gt; currentNumber{ arr[j+gap] = arr[j] //后移元素  j -= gap //更新下标  } arr[j+gap] = currentNumber } } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  public static void shellSortByKnuth(int[] arr) { // 找到当前数组需要用到的 Knuth 序列中的最大值  int maxKnuthNumber = 1; while (maxKnuthNumber \u0026lt;= arr.length / 3) { maxKnuthNumber = maxKnuthNumber * 3 + 1; } // 增量按照 Knuth 序列规则依次递减  for (int gap = maxKnuthNumber; gap \u0026gt; 0; gap = (gap - 1) / 3) { // 从 gap 开始，按照顺序将每个元素依次向前插入自己所在的组  for (int i = gap; i \u0026lt; arr.length; i++) { // currentNumber 站起来，开始找位置  int currentNumber = arr[i]; // 该组前一个数字的索引  int preIndex = i - gap; while (preIndex \u0026gt;= 0 \u0026amp;\u0026amp; currentNumber \u0026lt; arr[preIndex]) { // 向后挪位置  arr[preIndex + gap] = arr[preIndex]; preIndex -= gap; } // currentNumber 找到了自己的位置，坐下  arr[preIndex + gap] = currentNumber; } } }    \r  'use strict'; var containerId = JSON.parse(\"\\\"ebda174a0fa88671\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  先根据数组的长度，计算出需要用到的 Knuth 序列中的最大增量值，然后根据 Knuth 序列的规则依次缩小增量，从高增量到低增量分别进行排序。\n使用 Knuth 序列的希尔排序，时间复杂度已经降到了 O(n^2)以下。但具体时间复杂度是多少，尚未有明确的证明，数学界仅仅是猜想它的平均时间复杂度为 O(n^(3/2))\n时间复杂度 \u0026amp; 空间复杂度 事实上，希尔排序时间复杂度非常难以分析，它的平均复杂度界于 O(n) 到 O(n^2)之间，普遍认为它最好的时间复杂度为 O(n^(1.3))，希尔排序的空间复杂度为O(1)只需要常数级的临时变量。\n稳定性 虽然插入排序是稳定的排序算法，但希尔排序是不稳定的。在增量较大时，排序过程可能会破坏原有数组中相同关键字的相对次序。\n希尔排序与 O(n^2)级排序算法的本质区别 相对于前面介绍的冒泡排序、选择排序、插入排序来说，希尔排序的排序过程显得较为复杂，希望读者还没有被绕晕。接下来我们来分析一个有趣的问题：希尔排序凭什么可以打破时间复杂度O(n^2)的魔咒呢？它和之前介绍的O(n^2)级排序算法的本质区别是什么？\n只要理解了这一点，我们就能知道为什么希尔排序能够承上启下，启发出之后的一系列 O(n^2)级以下的排序算法。\n这个问题我们可以用逆序对来理解。\n当我们从小到大排序时，在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。 排序算法本质上就是一个消除逆序对的过程。\n对于随机数组，逆序对的数量是 O(n^2)级的，如果采用「交换相邻元素」的办法来消除逆序对，每次最多只能消除一组逆序对，因此必须执行 O(n^2)级的交换次数，这就是为什么冒泡、插入、选择算法只能到 O(n^2)级的原因。反过来说，基于交换元素的排序算法要想突破 O(n^2)级，必须通过一些比较，交换间隔比较远的元素，使得一次交换能消除一个以上的逆序对。\n希尔排序算法就是通过这种方式，打破了在空间复杂度为 O(1)的情况下，时间复杂度为 O(n^2)的魔咒，此后的快排、堆排等等算法也都是基于这样的思路实现的。\n注：\n1.虽然约翰·冯·诺伊曼在 1945 年提出的归并排序已经达到了O(nlogn) 的时间复杂度，但归并排序的空间复杂度为 O(n)，采用的是空间换时间的方式突破 O(n^2)。\n2.希尔排序在面试或是实际应用中都很少遇到，读者仅需了解即可。\n ","description":"战略上藐视技术，战术上重视技术——闪客","id":366,"section":"data_structure_and_sort","tags":["排序算法"],"title":"希尔排序","uri":"https://www.zhugeqing.top/data_structure_and_sort/sort/she/"},{"content":"数组、链表都是一维的数据结构，相对来说比较容易理解，而堆是二维的数据结构，对抽象思维的要求更高，所以许多程序员「谈堆色变」。但堆又是数据结构进阶必经的一步，我们不妨静下心来，将其梳理清楚。\n堆：符合以下两个条件之一的完全二叉树：\n 根节点的值 ≥ 子节点的值，这样的堆被称之为最大堆，或大顶堆（用于升序排序）； 根节点的值 ≤ 子节点的值，这样的堆被称之为最小堆，或小顶堆（用于降序排序）。    堆排序是由罗伯特·弗洛伊德(Robert W．Floyd）和威廉姆斯(J．Williams） 在1964年发明的。\n堆排序过程如下：\n 用数列构建出一个大顶堆，取出堆顶的数字； 调整剩余的数字，构建出新的大顶堆，再次取出堆顶的数字； 循环往复，完成整个排序。  整体的思路就是这么简单，我们需要解决的问题有两个：\n 如何用数列构建出一个大顶堆； 取出堆顶的数字后，如何将剩余的数字调整成新的大顶堆。  构建大顶堆 \u0026amp; 调整堆 构建大顶堆有两种方式：\n 方案一：从 0 开始，将每个数字依次插入堆中，一边插入，一边调整堆的结构，使其满足大顶堆的要求； 方案二：将整个数列的初始状态视作一棵完全二叉树，自底向上调整树的结构，使其满足大顶堆的要求。  方案二更为常用，动图演示如下：\n  \n在介绍堆排序具体实现之前，我们先要了解完全二叉树的几个性质。将根节点的下标视为 0，则完全二叉树有如下性质：\n 对于完全二叉树中的第 i 个数，它的左子节点下标：left = 2i + 1 对于完全二叉树中的第 i 个数，它的右子节点下标：right = left + 1 对于有 n 个元素的完全二叉树(n≥2)(n≥2)，它的最后一个非叶子结点的下标：n/2 - 1  \n堆排序代码如下：\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  func swap(arr []int, i, j int) { //交换元素（异或）  arr[i] = arr[i] ^ arr[j] arr[j] = arr[j] ^ arr[i] arr[i] = arr[i] ^ arr[j] } func heapSort(arr []int){ //如何用数列构建出一个大顶堆；  //取出堆顶的数字后，如何将剩余的数字调整成新的大顶堆。  // 构建初始大顶堆  buildMaxHeap(arr) for i:=len(arr)-1;i\u0026gt;0;i--{ swap(arr,0,i) //交换元素，使得当前堆最大的元素交换到堆的末尾  maxHeapify(arr,0,i) //从0第一个非叶子节点开始调整堆,用i是因为初建堆已经把堆的大小-1了  } } func buildMaxHeap(arr []int){ // 从最后一个非叶子结点开始调整大顶堆，最后一个非叶子结点的下标就是 arr.length / 2-1  for i := len(arr) / 2 - 1; i \u0026gt;= 0; i--{ //i--是为了不断从前面的非叶子节点调整堆  maxHeapify(arr,i,len(arr)) } } func maxHeapify(arr []int,index ,heapSize int){ // 左子结点下标  l := index*2+1 //当前调整堆节点的左子节点  // 右子结点下标  r := l+1 //当前调整堆节点的右子节点  // 记录根结点、左子树结点、右子树结点三者中的最大值下标  largest := index // 记录最大数的下标  // 与左子树结点比较  if l\u0026lt;heapSize \u0026amp;\u0026amp; arr[l]\u0026gt;arr[largest]{ largest = l } // 与右子树结点比较  if r\u0026lt;heapSize \u0026amp;\u0026amp; arr[r]\u0026gt;arr[largest]{ largest = r } //递归向下调整  if largest != index {//若不相等就说明  swap(arr,largest,index)//交换元素，使其符合大顶堆的性质  maxHeapify(arr,largest,heapSize) //递归，把最大元素和他的子树节点相比较，找出最大元素，  } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  public static void heapSort(int[] arr) { // 构建初始大顶堆  buildMaxHeap(arr); for (int i = arr.length - 1; i \u0026gt; 0; i--) { // 将最大值交换到数组最后  swap(arr, 0, i); // 调整剩余数组，使其满足大顶堆  maxHeapify(arr, 0, i); } } // 构建初始大顶堆 private static void buildMaxHeap(int[] arr) { // 从最后一个非叶子结点开始调整大顶堆，最后一个非叶子结点的下标就是 arr.length / 2-1  for (int i = arr.length / 2 - 1; i \u0026gt;= 0; i--) { maxHeapify(arr, i, arr.length); } } // 调整大顶堆，第三个参数表示剩余未排序的数字的数量，也就是剩余堆的大小 private static void maxHeapify(int[] arr, int i, int heapSize) { // 左子结点下标  int l = 2 * i + 1; // 右子结点下标  int r = l + 1; // 记录根结点、左子树结点、右子树结点三者中的最大值下标  int largest = i; // 与左子树结点比较  if (l \u0026lt; heapSize \u0026amp;\u0026amp; arr[l] \u0026gt; arr[largest]) { largest = l; } // 与右子树结点比较  if (r \u0026lt; heapSize \u0026amp;\u0026amp; arr[r] \u0026gt; arr[largest]) { largest = r; } if (largest != i) { // 将最大值交换为根结点  swap(arr, i, largest); // 再次调整交换数字后的大顶堆  maxHeapify(arr, largest, heapSize); } } private static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; }    \r  'use strict'; var containerId = JSON.parse(\"\\\"a2f1a4cbf47519e9\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  堆排序的第一步就是构建大顶堆，对应代码中的buildMaxHeap 函数。我们将数组视作一颗完全二叉树，从它的最后一个非叶子结点开始，调整此结点和其左右子树，使这三个数字构成一个大顶堆。\n需要注意的是，如果根结点和左右子树结点任何一个数字发生了交换，则还需要保证调整后的子树仍然是大顶堆，所以子树会执行一个递归的调整过程。\n注：在有的文章中，作者将堆的根节点下标视为 1，这样做的好处是使得第 i 个结点的左子结点下标为 2i，右子结点下标为 2i + 1，与 2i + 1 和 2i + 2 相比，计算量会少一点，本文未采取这种实现，但两种实现思路的核心思想都是一致的。 时间复杂度 \u0026amp; 空间复杂度 堆排序分为两个阶段：初始化建堆（buildMaxHeap）和重建堆（maxHeapify，直译为大顶堆化）。所以时间复杂度要从这两个方面分析。\n根据数学运算可以推导出初始化建堆的时间复杂度为O(n)，重建堆的时间复杂度为O(nlogn)，所以堆排序总的时间复杂度为O(nlogn)。\n堆排序的空间复杂度为 O(1)，只需要常数级的临时变量。\n稳定性 堆排序在进行层层比较的时候可能会破坏原有数组中相同关键字的相对次序，所以堆排序是不稳定的排序算法。\n","description":"战略上藐视技术，战术上重视技术——闪客","id":367,"section":"data_structure_and_sort","tags":["排序算法"],"title":"堆排序","uri":"https://www.zhugeqing.top/data_structure_and_sort/sort/heap/"},{"content":"快速排序算法由 C. A. R. Hoare 在 1960 年提出。它的时间复杂度也是 O(nlogn)，但它在时间复杂度为O(nlogn)级的几种排序算法中，大多数情况下效率更高，所以快速排序的应用非常广泛。再加上快速排序所采用的分治思想非常实用，使得快速排序深受面试官的青睐，所以掌握快速排序的思想尤为重要。\n快速排序算法的基本思想是：\n 从数组中取出一个数，称之为基数（pivot） 遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域 将左右两个区域视为两个数组，重复前两个步骤，直到排序完成  \n事实上，快速排序的每一次遍历，都将基数摆到了最终位置上。第一轮遍历排好 1 个基数，第二轮遍历排好 2 个基数（每个区域一个基数，但如果某个区域为空，则此轮只能排好一个基数），第三轮遍历排好 4 个基数（同理，最差的情况下，只能排好一个基数），以此类推。总遍历次数为 logn～n 次，每轮遍历的时间复杂度为O(n)，所以很容易分析出快速排序的时间复杂度为 O(nlogn)～ O(n^2)平均时间复杂度为O(nlogn)。\n让我们来看一下快速排序的动图吧 快速排序递归框架 根据我们分析出的思路，先搭出快速排序的架子：\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14  func quickSort(arr []int) { quickSortRecursion(arr, 0, len(arr) - 1); } func quickSortRecursion(arr []int, start, end int) { // 将数组分区，并获得中间值的下标  middle := partition(arr, start, end); // 对左边区域快速排序  quickSort(arr, start, middle - 1); // 对右边区域快速排序  quickSort(arr, middle + 1, end); } partition(arr []int,start,end int)int{ // TODO: 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标 }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14  public static void quickSort(int[] arr) { quickSort(arr, 0, arr.length - 1); } public static void quickSort(int[] arr, int start, int end) { // 将数组分区，并获得中间值的下标  int middle = partition(arr, start, end); // 对左边区域快速排序  quickSort(arr, start, middle - 1); // 对右边区域快速排序  quickSort(arr, middle + 1, end); } public static int partition(int[] arr, int start, int end) { // TODO: 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标 }    \r  'use strict'; var containerId = JSON.parse(\"\\\"9a9b9545df1744f9\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  partition 意为“划分”，我们期望 partition 函数做的事情是：将 arr 从 start 到 end 这一区间的值分成两个区域，左边区域的每个数都比基数小，右边区域的每个数都比基数大，然后返回中间值的下标。\n只要有了这个函数，我们就能写出快速排序的递归函数框架。首先调用 partition 函数得到中间值的下标 middle，然后对左边区域执行快速排序，也就是递归调用 quickSort(arr, start, middle - 1)，再对右边区域执行快速排序，也就是递归调用 quickSort(arr, middle + 1, end)。\n现在还有一个问题，何时退出这个递归函数呢？\n退出递归的边界条件 很容易想到，当某个区域只剩下一个数字的时候，自然不需要排序了，此时退出递归函数。实际上还有一种情况，就是某个区域只剩下 0 个数字时，也需要退出递归函数。当 middle 等于 start 或者 end 时，就会出现某个区域剩余数字为 0。\n所以我们可以通过这种方式退出递归函数：\ngolang java  1 2 3 4 5 6 7 8 9  func quickSortRecurison(arr []int,start,end int){ middle := partition(arr,start,end) if start != middle \u0026amp;\u0026amp; start != middle-1{ quickSortRecurison(arr,start,middle-1) } if end != middle \u0026amp;\u0026amp; end != middle+1{ quickSortRecurison(arr,middle+1,end) } }    \r1 2 3 4 5 6 7 8  public static void quickSort(int[] arr, int start, int end) { // 将数组分区，并获得中间值的下标  int middle = partition(arr, start, end); // 当左边区域中至少有 2 个数字时，对左边区域快速排序  if (start != middle \u0026amp;\u0026amp; start != middle - 1) quickSort(arr, start, middle - 1); // 当右边区域中至少有 2 个数字时，对右边区域快速排序  if (middle != end \u0026amp;\u0026amp; middle != end - 1) quickSort(arr, middle + 1, end); }    \r  'use strict'; var containerId = JSON.parse(\"\\\"7907a8459278a099\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \n在递归之前，先判断此区域剩余数字是否为 0 个或者 1 个，当数字至少为 2 个时，才执行这个区域的快速排序。因为我们知道 middle \u0026gt;= start \u0026amp;\u0026amp; middle \u0026lt;= end 必然成立，所以判断剩余区域的数字为 0 个或者 1 个也就是指 start 或 end 与 middle 相等或相差 1。\n我们来分析一下这四个判断条件：\n当 start == middle 时，相当于 quickSort(arr, start, middle - 1) 中的 start == end + 1\n当 start == middle - 1 时，相当于 quickSort(arr, start, middle - 1) 中的 start == end\n当 middle == end时，相当于 quickSort(arr, middle + 1, end) 中的 start == end + 1\n当 middle == end -1时，相当于 quickSort(arr, middle + 1, end) 中的 start == end\n综上，我们可以将此边界条件统一移到 quickSort 函数之前：\ngolang java  1 2 3 4 5 6 7 8  func quickSortRecurison(arr []int,start,end int){ if start == end || start = end + 1{ return } middle = partition(arr,start,end) quickSortRecurison(arr,start,middle-1) qucikSortRecurison(arr,midlle+1,end) }    \r1 2 3 4 5 6 7 8 9 10  public static void quickSort(int[] arr, int start, int end) { // 如果区域内的数字少于 2 个，退出递归  if (start == end || start == end + 1) return; // 将数组分区，并获得中间值的下标  int middle = partition(arr, start, end); // 对左边区域快速排序  quickSort(arr, start, middle - 1); // 对右边区域快速排序  quickSort(arr, middle + 1, end); }    \r  'use strict'; var containerId = JSON.parse(\"\\\"d75c4839e7a1c768\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  更进一步，由上文所说的 middle \u0026gt;= start \u0026amp;\u0026amp; middle \u0026lt;= end 可以推出，除了start == end || start == end + 1这两个条件之外，其他的情况下 start 都小于 end。所以我们可以将这个判断条件再次简写为：\ngolang java  1 2 3 4 5 6 7 8  func quickSortRecurison(arr []int,start,end int){ if start \u0026gt;= end{ return } middle := partition(arr,start,end) quickSortRecurison(arr,start,middle-1) quickSortRecursion(arr,midlle+1,end) }    \r1 2 3 4 5 6 7 8 9 10  public static void quickSort(int[] arr, int start, int end) { // 如果区域内的数字少于 2 个，退出递归  if (start \u0026gt;= end) return; // 将数组分区，并获得中间值的下标  int middle = partition(arr, start, end); // 对左边区域快速排序  quickSort(arr, start, middle - 1); // 对右边区域快速排序  quickSort(arr, middle + 1, end); }    \r  'use strict'; var containerId = JSON.parse(\"\\\"022889adce5e2be4\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \n这样我们就写出了最简洁版的边界条件，我们需要知道，这里的 start \u0026gt;= end 实际上只有两种情况：\n start == end: 表明区域内只有一个数字 start == end + 1: 表明区域内一个数字也没有  不会存在 start 比 end 大 2 或者大 3 之类的。\n分区算法实现 快速排序中最重要的便是分区算法，也就是 partition 函数。大多数人都能说出快速排序的整体思路，但实现起来却很难一次写对。主要问题就在于分区时存在的各种边界条件，需要读者亲自动手实践才能加深体会。\n上文已经说到，partition 函数需要做的事情就是将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标。那么首先我们要做的事情就是选择一个基数，基数我们一般称之为 pivot，意为“轴”。整个数组就像围绕这个轴进行旋转，小于轴的数字旋转到左边，大于轴的数字旋转到右边。\n基数的选择 基数的选择没有固定标准，随意选择区间内任何一个数字做基数都可以。通常来讲有三种选择方式：\n 选择第一个元素作为基数 选择最后一个元素作为基数 选择区间内一个随机元素作为基数  选择的基数不同，算法的实现也不同。实际上第三种选择方式的平均时间复杂度是最优的，待会分析时间复杂度时我们会详细说明。\n本文通过第一种方式来讲解快速排序：\ngolang java  1 2 3 4 5 6 7 8  func partition(arr []int,start,end int){ //取第一个数为基数  pivot := arr[start] //从第二个数开始分区  left = start + 1 //右边界  right = end }    \r1 2 3 4 5 6 7 8 9 10  // 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标 public static int partition(int[] arr, int start, int end) { // 取第一个数为基数  int pivot = arr[start]; // 从第二个数开始分区  int left = start + 1; // 右边界  int right = end; // TODO }    \r  'use strict'; var containerId = JSON.parse(\"\\\"fe1247936141d1ed\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  最简单的分区算法 分区的方式也有很多种，最简单的思路是：从 left 开始，遇到比基数大的数，就交换到数组最后，并将 right 减一，直到 left 和 right 相遇，此时数组就被分成了左右两个区域。再将基数和中间的数交换，返回中间值的下标即可。\n按照这个思路，我们敲出了如下代码：\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  func swap(arr []int,i,j int){ arr[i] = arr[i] ^ arr[j] arr[j] = arr[j] ^ arr[i] arr[i] = arr[i] ^ arr[j] } func quickSort(arr []int){ quickSortRecursion(arr,0,len(arr)-1) } func quickSortRecursion(arr []int,start,end int){ if start \u0026gt;= end { return } middle := partition(arr,start,end) quickSortRecursion(arr,start,middle-1) quickSortRecursion(arr,middle+1,end) } func partition(arr []int,start,end int)int{ pivot := start left = start + 1 right = end for left \u0026lt; right{ for arr[left] \u0026lt;= pivot \u0026amp;\u0026amp; left \u0026lt; right{ left ++ } //left找到大于基数的数，停下来  if left != right{ swap(arr,left,right) right-- } } if left == right \u0026amp;\u0026amp; arr[right] \u0026gt; pivot{ right-- } if left != start{ swap(arr,left,start) } return right }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  public static void quickSort(int[] arr) { quickSort(arr, 0, arr.length - 1); } public static void quickSort(int[] arr, int start, int end) { // 如果区域内的数字少于 2 个，退出递归  if (start \u0026gt;= end) return; // 将数组分区，并获得中间值的下标  int middle = partition(arr, start, end); // 对左边区域快速排序  quickSort(arr, start, middle - 1); // 对右边区域快速排序  quickSort(arr, middle + 1, end); } // 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标 public static int partition(int[] arr, int start, int end) { // 取第一个数为基数  int pivot = arr[start]; // 从第二个数开始分区  int left = start + 1; // 右边界  int right = end; // left、right 相遇时退出循环  while (left \u0026lt; right) { // 找到第一个大于基数的位置  while (left \u0026lt; right \u0026amp;\u0026amp; arr[left] \u0026lt;= pivot) left++; // 交换这两个数，使得左边分区都小于或等于基数，右边分区大于或等于基数  if (left != right) { exchange(arr, left, right); right--; } } // 如果 left 和 right 相等，单独比较 arr[right] 和 pivot  if (left == right \u0026amp;\u0026amp; arr[right] \u0026gt; pivot) right--; // 将基数和中间数交换  if (right != start) exchange(arr, start, right); // 返回中间值的下标  return right; } private static void exchange(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; }    \r  'use strict'; var containerId = JSON.parse(\"\\\"9bac0136a33dd6dc\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  因为我们选择了数组的第一个元素作为基数，并且分完区后，会执行将基数和中间值交换的操作，这就意味着交换后的中间值会被分到左边区域。所以我们需要保证中间值的下标是分区完成后，最后一个比基数小的值，这里我们用 right 来记录这个值。\n这段代码有一个细节。首先，在交换 left 和 right 之前，我们判断了 left != right，这是因为如果剩余的数组都比基数小，则 left 会加到 right 才停止，这时不应该发生交换。因为 right 已经指向了最后一个比基数小的值。\n但这里的拦截可能会拦截到一种错误情况，如果剩余的数组只有最后一个数比基数大，left 仍然加到 right 停止了，但我们并没有发生交换。所以我们在退出循环后，单独比较了 arr[right] 和 pivot。\n实际上，这行单独比较的代码非常巧妙，一共处理了三种情况：\n 一是刚才提到的剩余数组中只有最后一个数比基数大的情况 二是 left 和 right 区间内只有一个值，则初始状态下， left == right，所以 while (left \u0026lt; right) 根本不会进入，所以此时我们单独比较这个值和基数的大小关系 三是剩余数组中每个数都比基数大，此时 right 会持续减小，直到和 left 相等退出循环，此时 left 所在位置的值还没有和 pivot 进行比较，所以我们单独比较 left 所在位置的值和基数的大小关系  双指针分区算法 除了上述的分区算法外，还有一种双指针的分区算法更为常用：从 left 开始，遇到比基数大的数，记录其下标；再从 right 往前遍历，找到第一个比基数小的数，记录其下标；然后交换这两个数。继续遍历，直到 left 和 right 相遇。然后就和刚才的算法一样了，交换基数和中间值，并返回中间值的下标。\n代码如下：\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  func quickSort(arr []int){ quickSortRescursion(arr,0,len(arr)-1) } func quickSortRescursion(arr []int,start,end int){ if start \u0026gt;= end { return } //求分区中轴，把数组分区  middle := partition(arr,start,end) //向左分区递归，对左分区进行排序  quickSortRescursion(arr,start,middle-1) //向右分区递归，对右分区进行排序  quickSortRescursion(arr,middle+1,end) } func partition(arr []int,start,end int)int{ //基数  pivot := arr[start] left := start+1 right := end for left \u0026lt; right{ for left \u0026lt; right \u0026amp;\u0026amp; arr[left] \u0026lt;= pivot{ left++ } for left \u0026lt; right \u0026amp;\u0026amp; arr[right] \u0026gt;= pivot{ right-- } if left \u0026lt; right{ swap(arr,left,right) left++ right-- } } // 如果 left 和 right 相等，单独比较 arr[right] 和 pivot  if left == right \u0026amp;\u0026amp; arr[right] \u0026gt; pivot{ right-- } // 将基数和轴交换  if right != start{ swap(arr,right,start) } return right }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  public static void quickSort(int[] arr) { quickSort(arr, 0, arr.length - 1); } public static void quickSort(int[] arr, int start, int end) { // 如果区域内的数字少于 2 个，退出递归  if (start \u0026gt;= end) return; // 将数组分区，并获得中间值的下标  int middle = partition(arr, start, end); // 对左边区域快速排序  quickSort(arr, start, middle - 1); // 对右边区域快速排序  quickSort(arr, middle + 1, end); } // 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标 public static int partition(int[] arr, int start, int end) { // 取第一个数为基数  int pivot = arr[start]; // 从第二个数开始分区  int left = start + 1; // 右边界  int right = end; while (left \u0026lt; right) { // 找到第一个大于基数的位置  while (left \u0026lt; right \u0026amp;\u0026amp; arr[left] \u0026lt;= pivot) left++; // 找到第一个小于基数的位置  while (left \u0026lt; right \u0026amp;\u0026amp; arr[right] \u0026gt;= pivot) right--; // 交换这两个数，使得左边分区都小于或等于基数，右边分区大于或等于基数  if (left \u0026lt; right) { exchange(arr, left, right); left++; right--; } } // 如果 left 和 right 相等，单独比较 arr[right] 和 pivot  if (left == right \u0026amp;\u0026amp; arr[right] \u0026gt; pivot) right--; // 将基数和轴交换  exchange(arr, start, right); return right; } private static void exchange(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; }    \r  'use strict'; var containerId = JSON.parse(\"\\\"c4631d55525703d2\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  同样地，我们需要在退出循环后，单独比较 left 和 right 的值。\n时间复杂度 \u0026amp; 空间复杂度 平均时间复杂度为O(nlogn)，最坏的时间复杂度为O(n^2)，空间复杂度与递归的层数有关，每层递归会生成一些临时变量，所以空间复杂度为 O(logn)~ O(n)，平均空间复杂度为O(logn)\n为什么说随机选择剩余数组中的一个元素作为基数的方案平均复杂度是最优的呢？什么情况下快速排序算法的时间复杂度最高，一共有两种情况。\n 数组为正序 数组为逆序  理想中的快速排序在第 k 轮遍历中，可以排好 2^(k-1)个基数。但从图中我们发现，当数组原本为正序或逆序时，我们将第一个数作为基数的话，每轮分区后，都有一个区域是空的，也就是说数组中剩下的数字都被分到了同一个区域！这就导致了每一轮遍历只能排好一个基数。所以总的比较次数为 (n - 1) + (n - 2) + (n - 3) + \u0026hellip; + 1 次，由等差数列求和公式可以计算出总的比较次数为 n(n - 1)/2 次，此时快速排序的时间复杂度达到了 O(n^2)级。\n稳定性 从代码实现中可以分析出，快速排序是一种不稳定的排序算法，在分区过程中，相同数字的相对顺序可能会被修改。\n快速排序的优化思路  1.每轮选择基数时，从剩余的数组中随机选择一个数字作为基数。这样每轮都选到最大或最小值的概率就会变得很低了。所以我们才说用这种方式选择基数，其平均时间复杂度是最优的 2.三数取中，待排序序列中low、mid、high三个位置上数据进行排序，取他们中间的那个数据作为枢轴，并用0下标元素存储枢轴。  ","description":"战略上藐视技术，战术上重视技术——闪客","id":368,"section":"data_structure_and_sort","tags":["排序算法"],"title":"快速排序","uri":"https://www.zhugeqing.top/data_structure_and_sort/sort/qui/"},{"content":"约翰·冯·诺伊曼在 1945 年提出了归并排序。在讲解归并排序之前，我们先一起思考一个问题：如何将两个有序的列表合并成一个有序的列表？\n将两个有序的列表合并成一个有序的列表 这太简单了，首先想到的思路就是，将两个列表拼接成一个列表，然后之前学的冒泡、选择、插入、希尔、堆、快排都可以派上用场了。\n觉得太暴力了一点？那我们换个思路。\n既然列表已经有序了，通过前几章的学习，我们已经知道，插入排序的过程中，被插入的数组也是有序的。这就好办了，我们将其中一个列表中的元素逐个插入另一个列表中即可。\n但是按照这个思路，我们只需要一个列表有序就行了，另一个列表不管是不是有序的，都会被逐个取出来，插入第一个列表中。那么，在两个列表都已经有序的情况下，还可以有更优的合并方案吗？\n深入思考之后，我们发现，在第二个列表向第一个列表逐个插入的过程中，由于第二个列表已经有序，所以后续插入的元素一定不会在前面插入的元素之前。在逐个插入的过程中，每次插入时，只需要从上次插入的位置开始，继续向后寻找插入位置即可。这样一来，我们最多只需要将两个有序数组遍历一次就可以完成合并。\n思路很接近了，如何实现它呢？我们发现，在向数组中不断插入新数字时，原数组需要不断腾出位置，这是一个比较复杂的过程，而且这个过程必然导致增加一轮遍历。\n但好在我们有一个替代方案：只要开辟一个长度等同于两个数组长度之和的新数组，并使用两个指针来遍历原有的两个数组，不断将较小的数字添加到新数组中，并移动对应的指针即可。\n根据这个思路，我们可以写出合并两个有序列表的代码：\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // 将两个有序数组合并为一个有序数组 func merge(arr1,arr2 []int)[]int{ //返回的有序的结果数组  res := make([]int,len(arr1)+len(arr2)) //遍历两个数组的指针  index1,index2 := 0,0 //遍历\t for index1 \u0026lt; len(arr1) \u0026amp;\u0026amp; index2 \u0026lt; len(arr2){ if arr1[index1]\u0026lt;=arr2[index2]{ res[index1+index2] = arr1[index1] index1++ }else{ res[index1+index2] = arr2[index2] index2++ } } // 将剩余数字补到结果数组之后  for index1 \u0026lt; len(arr1){ res[index1+index2] = arr1[index1] index1++ } for index2 \u0026lt; len(arr2){ res[index1+index2] = arr2[index2] index2++ } return res }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // 将两个有序数组合并为一个有序数组 private static int[] merge(int[] arr1, int[] arr2) { int[] result = new int[arr1.length + arr2.length]; int index1 = 0, index2 = 0; while (index1 \u0026lt; arr1.length \u0026amp;\u0026amp; index2 \u0026lt; arr2.length) { if (arr1[index1] \u0026lt;= arr2[index2]) { result[index1 + index2] = arr1[index1]; index1++; } else { result[index1 + index2] = arr2[index2]; index2++; } } // 将剩余数字补到结果数组之后  while (index1 \u0026lt; arr1.length) { result[index1 + index2] = arr1[index1]; index1++; } while (index2 \u0026lt; arr2.length) { result[index1 + index2] = arr2[index2]; index2++; } return result; }    \r  'use strict'; var containerId = JSON.parse(\"\\\"970494e66cabaf4f\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \n合并有序数组的问题解决了，但我们排序时用的都是无序数组，那么上哪里去找这两个有序的数组呢？\n答案是 —— 自己拆分，我们可以把数组不断地拆成两份，直到只剩下一个数字时，这一个数字组成的数组我们就可以认为它是有序的。\n然后通过上述合并有序列表的思路，将 1 个数字组成的有序数组````合并成一个包含 2 个数字的有序数组，再将 2 个数字组成的有序数组合并成包含 4 个数字的有序数组...直到整个数组排序完成，这就是归并排序（Merge Sort）的思想。\n将数组拆分成有序数组 拆分过程使用了二分的思想，这是一个递归的过程，归并排序使用的递归框架如下：\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  //归并排序 func mergeSort(arr []int){ if len(arr) \u0026lt;= 1{ return } //把结果存入res中  res := mergeRescurison(arr,0,len(arr)-1) for i:=0;i\u0026lt;len(arr);i++{ arr[i] = res[i] } } //拆分数组 func mergeRescurison(arr []int,start,end int)[]int{ if start \u0026gt;= end{//递归终止条件  return []int{arr[start]} } //左区间递归  left := mergeRescurison(arr,start,(start+end)/2) //右区间递归  right := mergeRescurison(arr,(start+end)/2+1,end) //将两个有序数组合并  return merge(left,right) }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public static void mergeSort(int[] arr) { if (arr.length == 0) return; int[] result = mergeSort(arr, 0, arr.length - 1); // 将结果拷贝到 arr 数组中  for (int i = 0; i \u0026lt; result.length; i++) { arr[i] = result[i]; } } // 对 arr 的 [start, end] 区间归并排序 private static int[] mergeSort(int[] arr, int start, int end) { // 只剩下一个数字，停止拆分，返回单个数字组成的数组  if (start == end) return new int[]{arr[start]}; int middle = (start + end) / 2; // 拆分左边区域  int[] left = mergeSort(arr, start, middle); // 拆分右边区域  int[] right = mergeSort(arr, middle + 1, end); // 合并左右区域  return merge(left, right); }    \r  'use strict'; var containerId = JSON.parse(\"\\\"5efc6da314203a7f\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  可以看到，我们在这个函数中，将原有数组不断地二分，直到只剩下最后一个数字。此时嵌套的递归开始返回，一层层地调用merge函数，也就是我们刚才写的将两个有序数组合并为一个有序数组的函数。\n这就是最经典的归并排序，只需要一个二分拆数组的递归函数和一个合并两个有序列表的函数即可。\n归并排序分成两步:\n 一是拆分数组 二是合并数组  但这份代码还有一个缺点，那就是在递归过程中，开辟了很多临时空间，接下来我们就来看下它的优化过程。\n归并排序的优化：减少临时空间的开辟 为了减少在递归过程中不断开辟空间的问题，我们可以在归并排序之前，先开辟出一个临时空间，在递归过程中统一使用此空间进行归并即可。\n代码如下：\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  func mergeSort(arr []int){ if len(arr) \u0026lt;= 1{ return } //辅助数组  res := make([]int,len(arr)) mergeRescurison(arr,0,len(arr)-1,res) } func mergeRescurison(arr []int,start,end int,res []int){ if start \u0026gt;= end{ return } middle := (start+end)/2 // 拆分左边区域，并将归并排序的结果保存到 result 的 [start, middle] 区间  mergeRescurison(arr,start,middle,res) // 拆分右边区域，并将归并排序的结果保存到 result 的 [middle + 1, end] 区间  mergeRescurison(arr,middle+1,end,res) // 合并左右区域到 result 的 [start, end] 区间  merge(arr,start,end,res) } // 将 result 的 [start, middle] 和 [middle + 1, end] 区间合并 func merge(arr []int,start,end int,res []int){ middle := (start+end)/2 // 数组 1 的首尾位置  start1,end1 := start,middle // 数组 2 的首尾位置  start2,end2 := middle+1,end // 用来遍历数组的指针  index1 := start1 index2 := start2 // 结果数组的指针  resIndex := start for index1 \u0026lt;= end1 \u0026amp;\u0026amp; index2 \u0026lt;= end2{ if arr[index1] \u0026lt;= arr[index2]{ res[resIndex] = arr[index1] index1++ resIndex++ }else{ res[resIndex] = arr[index2] index2++ resIndex++ } } //把剩余的数字移到数组里面去  for index1 \u0026lt;= end1{ res[resIndex] = arr[index1] index1++ resIndex++ } for index2 \u0026lt;= end2{ res[index1+index2-start2] = arr[index2] index2++ resIndex++ } // 将 result 操作区间的数字拷贝到 arr 数组中，以便下次比较  for i := start; i \u0026lt;= end; i++{ arr[i] = res[i] } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  public static void mergeSort(int[] arr) { if (arr.length == 0) return; int[] result = new int[arr.length]; mergeSort(arr, 0, arr.length - 1, result); } // 对 arr 的 [start, end] 区间归并排序 private static void mergeSort(int[] arr, int start, int end, int[] result) { // 只剩下一个数字，停止拆分  if (start == end) return; int middle = (start + end) / 2; // 拆分左边区域，并将归并排序的结果保存到 result 的 [start, middle] 区间  mergeSort(arr, start, middle, result); // 拆分右边区域，并将归并排序的结果保存到 result 的 [middle + 1, end] 区间  mergeSort(arr, middle + 1, end, result); // 合并左右区域到 result 的 [start, end] 区间  merge(arr, start, end, result); } // 将 result 的 [start, middle] 和 [middle + 1, end] 区间合并 private static void merge(int[] arr, int start, int end, int[] result) { int middle = (start + end) / 2; // 数组 1 的首尾位置  int start1 = start; int end1 = middle; // 数组 2 的首尾位置  int start2 = middle + 1; int end2 = end; // 用来遍历数组的指针  int index1 = start1; int index2 = start2; // 结果数组的指针  int resultIndex = start1; while (index1 \u0026lt;= end1 \u0026amp;\u0026amp; index2 \u0026lt;= end2) { if (arr[index1] \u0026lt;= arr[index2]) { result[resultIndex++] = arr[index1++]; } else { result[resultIndex++] = arr[index2++]; } } // 将剩余数字补到结果数组之后  while (index1 \u0026lt;= end1) { result[resultIndex++] = arr[index1++]; } while (index2 \u0026lt;= end2) { result[resultIndex++] = arr[index2++]; } // 将 result 操作区间的数字拷贝到 arr 数组中，以便下次比较  for (int i = start; i \u0026lt;= end; i++) { arr[i] = result[i]; } }    \r  'use strict'; var containerId = JSON.parse(\"\\\"301e309323317965\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  在这份代码中，我们统一使用result 数组作为递归过程中的临时数组，所以merge 函数接收的参数不再是两个数组，而是 result 数组中需要合并的两个数组的首尾下标。根据首尾下标可以分别计算出两个有序数组的首尾下标 start1、end1、start2、end2，之后的过程就和之前合并两个有序数组的代码类似了。\n这份代码还可以再精简一下，我们可以去掉一些不会改变的临时变量。比如 start1 始终等于 start，end2 始终等于 end，end1 始终等于 middle。并且分析可知，resultIndex 的值始终等于 start 加上 index1 和 index2 移动的距离。即：\ngolang java  1  resultIndex = start + (index1 - start1) + (index2 - start2)    \r1  resultIndex = start + (index1 - start1) + (index2 - start2)    \r  'use strict'; var containerId = JSON.parse(\"\\\"08b06e28a9920422\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  将 start1 == start 代入，化简得：\ngolang java  1  resultIndex = index1 + index2 - start2    \r1  resultIndex = index1 + index2 - start2    \r  'use strict'; var containerId = JSON.parse(\"\\\"10048c9b3b2784de\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  所以最终的归并排序代码如下：\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  func mergeSort(arr []int){ if len(arr) \u0026lt;= 1{ return } //辅助数组  res := make([]int,len(arr)) mergeRescurison(arr,0,len(arr)-1,res) } func mergeRescurison(arr []int,start,end int,res []int){ if start \u0026gt;= end{ return } middle := (start+end)/2 // 拆分左边区域，并将归并排序的结果保存到 result 的 [start, middle] 区间  mergeRescurison(arr,start,middle,res) // 拆分右边区域，并将归并排序的结果保存到 result 的 [middle + 1, end] 区间  mergeRescurison(arr,middle+1,end,res) // 合并左右区域到 result 的 [start, end] 区间  merge(arr,start,end,res) } func merge(arr []int,start,end int,res []int){ end1 := (start+end)/2 start2 := end1 + 1 index1,index2:= start,start2 //数组指针为start + (index1-start1) + (index2 -(middlex+1))  for index1 \u0026lt;= end1 \u0026amp;\u0026amp; index2 \u0026lt;= end{ if arr[index1] \u0026lt;= arr[index2]{ res[index1+index2-start2] = arr[index1] index1++ }else{ res[index1+index2-start2] = arr[index2] index2++ } } //把剩余的数字移到数组里面去  for index1 \u0026lt;= end1{ res[index1+index2-start2] = arr[index1] index1++ } for index2 \u0026lt;= end{ res[index1+index2-start2] = arr[index2] index2++ } //将合并排序后的数组给arr  for start \u0026lt;= end{ arr[start] = res[start] start++ } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  public static void mergeSort(int[] arr) { if (arr.length == 0) return; int[] result = new int[arr.length]; mergeSort(arr, 0, arr.length - 1, result); } // 对 arr 的 [start, end] 区间归并排序 private static void mergeSort(int[] arr, int start, int end, int[] result) { // 只剩下一个数字，停止拆分  if (start == end) return; int middle = (start + end) / 2; // 拆分左边区域，并将归并排序的结果保存到 result 的 [start, middle] 区间  mergeSort(arr, start, middle, result); // 拆分右边区域，并将归并排序的结果保存到 result 的 [middle + 1, end] 区间  mergeSort(arr, middle + 1, end, result); // 合并左右区域到 result 的 [start, end] 区间  merge(arr, start, end, result); } // 将 result 的 [start, middle] 和 [middle + 1, end] 区间合并 private static void merge(int[] arr, int start, int end, int[] result) { int end1 = (start + end) / 2; int start2 = end1 + 1; // 用来遍历数组的指针  int index1 = start; int index2 = start2; while (index1 \u0026lt;= end1 \u0026amp;\u0026amp; index2 \u0026lt;= end) { if (arr[index1] \u0026lt;= arr[index2]) { result[index1 + index2 - start2] = arr[index1++]; } else { result[index1 + index2 - start2] = arr[index2++]; } } // 将剩余数字补到结果数组之后  while (index1 \u0026lt;= end1) { result[index1 + index2 - start2] = arr[index1++]; } while (index2 \u0026lt;= end) { result[index1 + index2 - start2] = arr[index2++]; } // 将 result 操作区间的数字拷贝到 arr 数组中，以便下次比较  while (start \u0026lt;= end) { arr[start] = result[start++]; } }    \r  'use strict'; var containerId = JSON.parse(\"\\\"3d9109ddb126cd60\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \n牺牲了一些可读性，代码变得精简了不少。动图演示如下：\n 时间复杂度 \u0026amp; 空间复杂度 归并排序的复杂度比较容易分析，拆分数组的过程中，会将数组拆分logn次，每层执行的比较次数都约等于n次，所以时间复杂度是 O(nlogn)。\n空间复杂度是 O(n)，主要占用空间的就是我们在排序前创建的长度为 n 的 result 数组。\n稳定性 分析归并的过程可知，归并排序是一种稳定的排序算法。其中，对算法稳定性非常重要的一行代码是：\n golang java  1 2 3 4  if arr[index1] \u0026lt;= arr[index2]{ res[index1 + index2 - start2] = arr[index1] index1++ }    \r1 2 3  if (arr[index1] \u0026lt;= arr[index2]) { result[index1 + index2 - start2] = arr[index1++]; }    \r  'use strict'; var containerId = JSON.parse(\"\\\"f6809c3864c7ae98\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \n在这里我们通过arr[index1] \u0026lt;= arr[index2]来合并两个有序数组，保证了原数组中，相同的元素相对顺序不会变化，如果这里的比较条件写成了arr[index1] \u0026lt; arr[index2]，则归并排序将变得不稳定。\n","description":"战略上藐视技术，战术上重视技术——闪客","id":369,"section":"data_structure_and_sort","tags":["排序算法"],"title":"归并排序","uri":"https://www.zhugeqing.top/data_structure_and_sort/sort/mer/"},{"content":"希尔排序 希尔排序是一个承上启下的算法，通过交换间隔较远的元素，使得一次交换能消除一个以上的逆序对，打破了在空间复杂度为 O(1)的情况下，时间复杂度 O(n^2)的魔咒。它启发出了后续一系列时间复杂度为O(nlogn)，空间复杂度为O(1) 的排序算法\n希尔排序本质上是插入排序的优化，先对间隔较大的元素进行插入排序，完成宏观调控，然后逐步缩小间隔，最后一轮一定是间隔为 1 的排序，也就是插入排序。间隔在希尔排序中被称为「增量」，增量序列不同，希尔排序的效率也不同。\n堆排序 堆排序分为两步：初始化建堆、重建堆。排序过程是：\n 用数列构建出一个大顶堆，取出堆顶的数字； 调整剩余的数字，构建出新的大顶堆，再次取出堆顶的数字； 循环往复，完成整个排序。  快速排序 快速排序算法是面试中考察的重点，也是应用最广泛的排序算法。排序过程是：\n 从数组中取出一个数，称之为基数（pivot）； 遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域； 将左右两个区域视为两个数组，重复前两个步骤，直到排序完成。  快速排序中最重要的是分区算法，最常用的分区算法是双指针分区算法，优点是一次交换可以完成两个数的分区。\n归并排序 归并排序分为两步：二分拆数组、不断合并两个有序列表。\n归并的优化主要在于减少临时空间的开辟。\n不存在空间复杂度为O(1) 的归并排序。\n相同点 平均时间复杂度都在 O(n)到O(n^2)\n不同点  希尔排序、堆排序、快速排序是不稳定的，归并排序是稳定的。 希尔排序的平均复杂度界于 O(n)到 O(n^2)之间，普遍认为它最好的时间复杂度为 O(n^1.3)，希尔排序的空间复杂度为 O(1)；堆排序和快速排序的时间复杂度为 O(nlogn)，空间复杂度为 O(1)；归并排序的时间复杂度是O(nlogn)，空间复杂度是 O(n)。  ","description":"战略上藐视技术，战术上重视技术——闪客","id":370,"section":"data_structure_and_sort","tags":["排序算法"],"title":"O(nlogn)排序算法的小结","uri":"https://www.zhugeqing.top/data_structure_and_sort/sort/conclusion2/"},{"content":"想一下我们是怎么对日期进行排序的。比如对这样三个日期进行排序：2014 年 1 月 7 日，2020 年 1 月 9 日，2020 年 7 月 10日。\n我们大脑中对日期排序的思维过程是：\n 先看年份，2014比2020 要小，所以 2014 年这个日期应该放在其他两个日期前面。 另外两个日期年份相等，所以我们比较一下月份，1 比 7 要小，所以 1 月这个日期应该放在 7 月这个日期前面  这种利用多关键字进行排序的思想就是基数排序，和计数排序一样，这也是一种线性时间复杂度的排序算法。其中的每个关键字都被称作一个基数。\n比如我们对 999, 997, 866, 666 这四个数字进行基数排序，过程如下：\n先看第一位基数：6 比 8 小，8 比 9 小，所以 666 是最小的数字，866 是第二小的数字，暂时无法确定两个以 9 开头的数字的大小关系\n再比较 9 开头的两个数字，看他们第二位基数：9 和 9 相等，暂时无法确定他们的大小关系\n再比较 99 开头的两个数字，看他们的第三位基数：7 比 9 小，所以 997 小于 999\n基数排序有两种实现方式。本例属于「最高位优先法」，简称 MSD (Most significant digital)，思路是从最高位开始，依次对基数进行排序。\n与之对应的是「最低位优先法」，简称 LSD (Least significant digital)。思路是从最低位开始，依次对基数进行排序。使用 LSD 必须保证对基数进行排序的过程是稳定的。\n通常来讲，LSD 比 MSD 更常用。以上述排序过程为例，因为使用的是 MSD，所以在第二步比较两个以 9 开头的数字时，其他基数开头的数字不得不放到一边。体现在计算机中，这里会产生很多临时变量。\n但在采用 LSD 进行基数排序时，每一轮遍历都可以将所有数字一视同仁，统一处理。所以 LSD 的基数排序更符合计算机的操作习惯。\n基数排序最早是用在卡片排序机上的，一张卡片有 80 列，类似一个 80 位的整数。机器通过在卡片不同位置上穿孔表示当前基数的大小。卡片排序机的排序过程就是采用的 LSD 的基数排序。\n动图演示\n简单起见，我们先只考虑对非负整数排序的情况。\n 基数排序可以分为以下三个步骤：\n 找出数组中最大的数字的位数 maxDigitLength 获取数组中每个数字的基数 遍历 maxDigitLength 轮数组，每轮按照基数对其进行排序  找出数组中最大的数字的位数 首先找到数组中的最大值：\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12  func radixSort(arr []int){ if len(arr) == 0{ return } max := 0 for _,v:=range arr{ if v \u0026gt; max{ max = v } } //... }     1 2 3 4 5 6 7 8 9 10  public static void radixSort(int[] arr) { if (arr == null) return; int max = 0; for (int value : arr) { if (value \u0026gt; max) { max = value; } } // ... }       'use strict'; var containerId = JSON.parse(\"\\\"cc96bbddbd8d7cae\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  通过遍历一次数组，找到了数组中的最大值 max，然后我们计算这个最大值的位数：\ngolang java  1 2 3 4 5 6  maxDigitLength = 0 for max != 0{ maxDigitLength++//记录最大遍历次数  max /= 10 }     1 2 3 4 5  int maxDigitLength = 0; while (max != 0) { maxDigitLength++; max /= 10; }       'use strict'; var containerId = JSON.parse(\"\\\"3a4ec4f518e14a8c\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  将 maxDigitLength 初始化为 0，然后不断地除以10，每除一次，maxDigitLength 就加一，直到 max 为0。\n读者可能会有疑惑，如果 max 初始值就是 0 呢？严格来讲，0 在数学上属于 1 位数。\n但实际上，基数排序时我们无需考虑 max 为 0 的场景，因为 max 为 0 只有一种可能，那就是数组中所有的数字都为 0，此时数组已经有序，我们无需再进行后续的排序过程。\n获取基数 获取基数有两种做法：\n第一种：\ngolang java  1 2 3 4 5 6 7 8 9 10  mod := 10 dev := 1 for i:=0;i\u0026lt;maxDigitLength;i++{ for _,v := range arr{ radix := v % mod / dev //对基数进行排序  } mod *= 10 dev *= 10 }     1 2 3 4 5 6 7 8 9 10  int mod = 10; int dev = 1; for (int i = 0; i \u0026lt; maxDigitLength; i++) { for (int value : arr) { int radix = value % mod / dev; // 对基数进行排序  } mod *= 10; dev *= 10; }       'use strict'; var containerId = JSON.parse(\"\\\"764625c5c9307c00\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  第二种：\ngolang java  1 2 3 4 5 6 7 8  dev := 1 for i:=0;i\u0026lt;maxDigitLength;i++{ for _,v := range arr{ radix := v / dev % 10 //对基数进行排序  } dev *= 10 }     1 2 3 4 5 6 7 8  int dev = 1; for (int i = 0; i \u0026lt; maxDigitLength; i++) { for (int value : arr) { int radix = value / dev % 10; // 对基数进行排序  } dev *= 10; }       'use strict'; var containerId = JSON.parse(\"\\\"ef2e60bdb006efd5\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  两者的区别是先做除法运算还是先做模运算，推荐使用第二种写法，因为它可以节省一个变量\n对基数进行排序 golang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  func radixSort(arr []int) { //第一步，先确定基数个数  if len(arr) == 0 { return } max := 0 for _, v := range arr { if v \u0026gt; max { max = v } } maxLength := 0 for max != 0 { maxLength++ max /= 10 } //结果暂存  res := make([]int, len(arr)) dev := 1 //从1开始  for i := 0; i \u0026lt; maxLength; i++ { //记录各基数个数  count := make([]int, 10) for _, v := range arr { radix := v / dev % 10 //求当前数的基数  count[radix]++ //记录基数个数  } //counting[i] 更新为数字 i 在最终排序结果中的起始下标位置。  //这个位置等于前面比自己小的数字的总数  fmt.Println(count) for i := 1; i \u0026lt; len(count); i++ { count[i] += count[i-1] } fmt.Println(count) for i := len(arr) - 1; i \u0026gt;= 0; i-- { radix := arr[i] / dev % 10 count[radix]-- res[count[radix]] = arr[i] } for i, v := range res { arr[i] = v } dev *= 10 fmt.Println(arr) } }     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  public class RadixSort { public static void radixSort(int[] arr) { if (arr == null) return; // 找出最大值  int max = 0; for (int value : arr) { if (value \u0026gt; max) { max = value; } } // 计算最大数字的长度  int maxDigitLength = 0; while (max != 0) { maxDigitLength++; max /= 10; } // 使用计数排序算法对基数进行排序  int[] counting = new int[10]; int[] result = new int[arr.length]; int dev = 1; for (int i = 0; i \u0026lt; maxDigitLength; i++) { for (int value : arr) { int radix = value / dev % 10; counting[radix]++; } for (int j = 1; j \u0026lt; counting.length; j++) { counting[j] += counting[j - 1]; } // 使用倒序遍历的方式完成计数排序  for (int j = arr.length - 1; j \u0026gt;= 0; j--) { int radix = arr[j] / dev % 10; result[--counting[radix]] = arr[j]; } // 计数排序完成后，将结果拷贝回 arr 数组  System.arraycopy(result, 0, arr, 0, arr.length); // 将计数数组重置为 0  Arrays.fill(counting, 0); dev *= 10; } } }       'use strict'; var containerId = JSON.parse(\"\\\"fa9ed3231486f962\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  首先我们将每位元素出现的次数记录到 counting 数组中\n然后将 counting[i] 更新为数字 i 在最终排序结果中的起始下标位置。这个位置等于前面比自己小的数字的总数。\n我们将 result 数组的值拷贝回 arr 数组，并且将 counting 数组中的元素都置为 0，以便在下一轮中复用。\n对包含负数的数组进行基数排序 如果数组中包含负数，如何进行基数排序呢？\n我们很容易想到一种思路：将数组中的每个元素都加上一个合适的正整数，使其全部变成非负整数，等到排序完成后，再减去之前加的这个数就可以了。\n但这种方案有一个缺点：加法运算可能导致数字越界，所以必须单独处理数字越界的情况。\n事实上，有一种更好的方案解决负数的基数排序。那就是在对基数进行计数排序时，申请长度为 19 的计数数组，用来存储 [-9, 9] 这个区间内的所有整数。在把每一位基数计算出来后，加上 9，就能对应上 counting 数组的下标了。也就是说，counting 数组的 下标 [0, 18] 对应基数 [−9,9]。\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  func radixSort(arr []int) { //第一步，先确定基数个数  if len(arr) == 0 { return } max := 0 for _, v := range arr { if v \u0026lt; 0 { v = -v } if v \u0026gt; max { max = v } } maxLength := 0 for max != 0 { maxLength++ max /= 10 } //结果暂存  res := make([]int, len(arr)) dev := 1 //从1开始  for i := 0; i \u0026lt; maxLength; i++ { //记录各基数个数  count := make([]int, 19) for _, v := range arr { radix := v/dev%10 + 9 //求当前数的基数  count[radix]++ //记录基数个数  } //counting[i] 更新为数字 i 在最终排序结果中的起始下标位置。  //这个位置等于前面比自己小的数字的总数  fmt.Println(count) for i := 1; i \u0026lt; len(count); i++ { count[i] += count[i-1] } fmt.Println(count) for i := len(arr) - 1; i \u0026gt;= 0; i-- { radix := arr[i]/dev%10 + 9 count[radix]-- res[count[radix]] = arr[i] } for i, v := range res { arr[i] = v } dev *= 10 fmt.Println(arr) } }     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  public class RadixSort { public static void radixSort(int[] arr) { if (arr == null) return; // 找出最长的数  int max = 0; for (int value : arr) { if (Math.abs(value) \u0026gt; max) { max = Math.abs(value); } } // 计算最长数字的长度  int maxDigitLength = 0; while (max != 0) { maxDigitLength++; max /= 10; } // 使用计数排序算法对基数进行排序，下标 [0, 18] 对应基数 [-9, 9]  int[] counting = new int[19]; int[] result = new int[arr.length]; int dev = 1; for (int i = 0; i \u0026lt; maxDigitLength; i++) { for (int value : arr) { // 下标调整  int radix = value / dev % 10 + 9; counting[radix]++; } for (int j = 1; j \u0026lt; counting.length; j++) { counting[j] += counting[j - 1]; } // 使用倒序遍历的方式完成计数排序  for (int j = arr.length - 1; j \u0026gt;= 0; j--) { // 下标调整  int radix = arr[j] / dev % 10 + 9; result[--counting[radix]] = arr[j]; } // 计数排序完成后，将结果拷贝回 arr 数组  System.arraycopy(result, 0, arr, 0, arr.length); // 将计数数组重置为 0  Arrays.fill(counting, 0); dev *= 10; } } }       'use strict'; var containerId = JSON.parse(\"\\\"896e9a2b2f66492b\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  代码中主要做了两处修改：\n 当数组中存在负数时，我们就不能简单的计算数组的最大值了，而是要计算数组中绝对值最大的数，也就是数组中最长的数 在获取基数的步骤，将计算出的基数加上 99，使其与 counting 数组下标一一对应  时间复杂度 \u0026amp; 空间复杂度 无论 LSD 还是 MSD，基数排序时都需要经历 maxDigitLength 轮遍历，每轮遍历的时间复杂度为 O(n + k) ，其中 k 表示每个基数可能的取值范围大小。如果是对非负整数排序，则 k = 10，如果是对包含负数的数组排序，则 k = 19。\n所以基数排序的时间复杂度为 O(d(n + k))表示最长数字的位数，k 表示每个基数可能的取值范围大小)。\n稳定性 基数排序是一种稳定的排序算法\n","description":"战略上藐视技术，战术上重视技术——闪客","id":371,"section":"data_structure_and_sort","tags":["排序算法"],"title":"基数排序","uri":"https://www.zhugeqing.top/data_structure_and_sort/sort/rad/"},{"content":"《上部分》 这似乎是一个很凝重的话题，但是它真的很有趣。\n1. 指针是指向某一类型的东西，任何一个整体，只要能称为整体就能拥有它自己的独一无二的指针类型，所以指针的类型其实是近似无穷无尽的\n2. 函数名在表达式中总是以函数指针的身份呈现，除了取地址运算符以及sizeof\n3. C语言最晦涩难明的就是它复杂的声明: void (signal(int sig, void (func)(int)))(int),\n试试着把它改写成容易理解的形式\n4. 对于指针，尽最大的限度使用const保护它，无论是传递给函数，还是自己使用\n先来看看一个特殊的指针，姑且称它为指针，因为它依赖于环境: NULL，是一个神奇的东西。先附上定义，在编译器中会有两种NULL(每种环境都有唯一确定的NULL):\n1 2  #define NULL 0 #define NULL ((void*)0)   有什么区别吗？看起来没什么区别都是0，只不过一个是常量，一个是地址为0的指针。\n当它们都作为指针的值时并不会报错或者警告，即编译器或者说C标准认为这是合法的:\n1 2 3  int* temp_int_1 = 0; //无警告 int* temp_int_2 = (void*)0; //无警告 int* temp_int_3 = 10; //出现警告   为什么？为什么0可以赋值给指针，但是10却不行？他们都是常量。\n因为C语言规定当处理上下文的编译器发现常量0出现在指针赋值的语句中，它就作为指针使用，似乎很扯淡，可是却是如此。\n回到最开始，对于NULL的两种情况，会有什么区别？拿字符串来说，实际上我是将字符数组看作是C风格字符串。\n在C语言中，字符数组是用来存储一连串有意义的字符，默认在这些字符的结尾添加'\\0'，好这里又出现了一个0值。\n对于某些人，在使用字符数组的时候总是分不清楚NULL与'\\0\u0026rsquo;的区别而误用，在字符数组的末尾使用NULL是绝对错误的！虽然它们的本质都是常量0，但由于位置不同所以含义也不同。\n开胃菜已过\n对于一个函数，我们进行参数传递，参数有两种形式: 形参与实参\n1 2 3 4 5 6  int function(int value) { /*...*/ } //... function(11);   其中，value是形参，11是实参，我们知道场面上，C语言拥有两种传递方式:按值传递和按址传递，但是你是否有认真研究过？这里给出一个实质，其实C语言只有按值传递，所谓按址传递只不过是按值传递的一种假象。至于原因稍微一想便能明白。\n对于形参和实参而言两个关系紧密，可以这么理解总是实参将自己的一份拷贝传递给形参，这样形参便能安全的使用实参的值，但也带给我们一些麻烦，最经典的交换两数\n1 2 3 4 5 6 7  void swap_v1(int* val_1, int* val_2) { int temp = *val_1; *val_1 = *val_2; *val_2 = *val_1; }   这就是所谓的按址传递，实际上只是将外部指针(实参)的值做一个拷贝，传递给形参val_1与val_2，实际上我们使用:\n1 2  #define SWAP_V2(a, b) (a += b, b = a - b, a -= b) #define SWAP_V3(x, y) {x ^= y; y ^= x; x ^= y}   试一试是不是很神奇，而且省去了函数调用的时间，空间开销。上述两种写法的原理实质是一样的。\n但是，动动脑筋想一想，这种写法真的没有瑕疵吗？如果输入的两个参数本就指向同一块内存，会发生什么？\n1 2 3 4 5 6 7 8  ... int test_1 = 10, test_2 = 100; SWAP_V2(test_1, test_2); printf(\u0026#34;Now the test_1 is %d, test_2 is %d\\n\u0026#34;, test_1, test_2); .../*恢复原值*/ SWAP_V2(test_1, test_1); printf(\u0026#34;Now the test_1 is %d\\n\u0026#34;, test_1);   会输出什么？:\n1 2  $: Now the test_1 is 100, test_2 is 10 $: Now the test_1 is 0   对，输出了0，为什么？稍微动动脑筋就能相通，那么对于后面的SWAP_V3亦是如此，所以在斟酌之下，解决方案应该尽可能短小精悍:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  static inline void swap_final(int* val_1, int* val_2) { if(val_1 == val_2) return; *val_1 ^= *val_2; *val_2 ^= *val_1; *val_1 ^= *val_2; } #define SWAP(x, y) do{ if(\u0026amp;x == \u0026amp;y) break; x ^= y; y ^= x; x ^= y; }while(0)   这便是目前能找到最好的交换函数，我们在此基础上可以考虑的更深远一些，如何让这个交换函数更加通用？即适用范围更大？暂不考虑浮点类型。\n提示：可用void*\n与上面的情况类似，偶尔的不经意就会造成严重的后果:\n1 2 3 4 5 6 7 8 9 10 11  int combine_1(int* dest, int* add) { *dest += *add; *dest += *add; return *dest; } int combine_2(int* dest, int* add) { *dest += 2 * (*add);//在不确定优先级时用括号是一个明智的选择  return *dest; }   上述两个函数的功能一样吗？恩看起来是一样的\n1 2 3 4 5 6  int test_3 = 10, test_4 = 100; combine_1(\u0026amp;test_3, \u0026amp;test_4); printf(\u0026#34;After combine_1, test_3 = %d\\n\u0026#34;,test_3); .../*恢复原值*/ combine_2(\u0026amp;test_3, \u0026amp;test_4); printf(\u0026#34;After combine_2, test_3 = %d\\n\u0026#34;,test_3);   输出\n1 2 3 4  $: After combine_1, test_3 = 210 $: After combine_2, test_3 = 210   如果传入两个同一对象呢？\n1 2 3 4 5 6  ... /*恢复test_3原值*/ combine_1(\u0026amp;test_3, \u0026amp;test_3); printf(\u0026#34;After second times combine_1, test_3 = %d\\n\u0026#34;,test_3); ... combine_2(\u0026amp;test_3, \u0026amp;test_3); printf(\u0026#34;After second times combine_2, test_3 = %d\\n\u0026#34;,test_3);   输出\n1 2 3  $: After second times combine_1, test_3 = 40 $: After second times combine_2, test_3 = 30   知道真相总是令人吃惊，指针也是那么令人又爱又恨。\n C99 标准之后出现了一个新的关键字， restrict，被用于修饰指针，它并没有太多的显式作用，甚至加与不加，在 你自己 看来，效果毫无区别。但是反观标准库的代码中，许多地方都使用了该关键字，这是为何\n首先这个关键字是写给编译器看的\n其次这个关键字的作用在于辅助编译器更好的优化该程序(后方文章会有介绍)\n最后，如果不熟悉，绝对不要乱用这个关键字  关于数组的那些事\n数组和指针一样吗？\n不一样!\n要时刻记住，数组与指针是不同的东西。但是为什么下面代码是正确的？\n1 2  int arr[10] = {10, 9, 8, 7}; int* parr = arr;   我们还是那句话，结合上下文，编译器推出 arr处于赋值操作符的右侧，默默的将他转换为对应类型的指针，而我们在使用arr时也总是将其当成是指向该数组内存块首位的指针。\n1 2 3 4 5 6 7 8 9 10  //int function2(const int test_arr[10] //int function2(const int test_arr[]) 考虑这三种写法是否一样 int function2(const int* test_arr) { return sizeof(test_arr); } int size_out = sizeof(arr); int size_in = function2(arr); printf(\u0026#34;size_out = %d, size_in = %d\\n\u0026#34;, size_out, size_in);   1  输出: size_out = 40, size_in = 8   这就是为什么数组与指针不同的原因所在，在外部即定义数组的代码块中，编译器通过上下文发觉此处arr是一个数组，而arr代表的是一个指向10个int类型的数组的指针，只所谓最开始的代码是正确的，只是因为这种用法比较多，就成了标准的一部分。就像世上本没有路，走的多了就成了路。”正确”的该怎么写\n1  int (*p)[10] = \u0026amp;arr;   此时p的类型就是一个指向含有10个元素的数组的指针,此时(*p)[0]产生的效果是arr[0]，也就是parr[0]，但是(*p)呢？这里不记录，结果是会溢出，为什么？\n这就是数组与指针的区别与联系，但是既然我们可以使用像parr这样的指针，又为什么要写成int (*p)[10]这样丑陋不堪的模式呢？原因如下:\n回到最开始说过的传递方式，按值传递在传递arr时只是纯粹的将其值进行传递，而丢失了上下文的它只是一个普通指针，只不过我们程序员知道它指向了一块有意义的内存的起始位置，我想要将数组的信息一起传递，除了额外增加一个参数用来记录数组的长度以外，也可以使用这个方法，传递一个指向数组的指针\n这样我们就能只传递一个参数而保留所有信息。但这么做的也有限制:对于不同大小，或者不同存储类型的数组而言，它们的类型也有所不同\n1 2 3 4  int arr_2[5]; int (*p_2)[5] = \u0026amp;arr_2; float arr_3[5]; float (*p_3)[5] = \u0026amp;arr_3;   如上所示，指向数组的指针必须明确指定数组的大小，数组存储类型，这就让指向数组的指针有了比较大的限制。\n这种用法在多维数组中使用的比较多，但总体来说平常用的并不多，就我而言，更倾向于使用一维数组来表示多维数组，实际上诚如前面所述，C语言是一个非常简洁的语言，它没有太多的废话，就本质而言C语言并没有多维数组，因为内存是一种线性存在，即便是多维数组也是实现成一维数组的形式。\n就多维数组在这里解释一下。所谓多维数组就是将若干个降一维的数组组合在一起，降一维的数组又由若干个更降一维的数组组合在一起，直到最低的一维数组，举个例子:\n1  int dou_arr[5][3];   就这个二维数组而言，将5个每个为3个int类型的数组组合在一起，要想指向这个数组该怎么做？\n1 2 3  int (*p)[3] = \u0026amp;dou_arr[0]; int (*dou_p)[5][3] = \u0026amp;dou_arr; int (*what_p)[3] = dou_arr;   实际上多维数组只是将多个降一维的数组组合在一起，令索引时比较直观而已。当真正理解了内存的使用，反而会觉得多维数组带给自己更多限制\n对于第三句的解释，当数组名出现在赋值号右侧时，它将是一个指针，类型则是 指向该数组元素的类型，而对于一个多维数组来说，其元素类型则是其降一维数组，即指向该降一维数组的指针类型。这个解释有点绕，自己动手写一写就好很多。\n对于某种形式下的操作，我们总是自然的将相似的行为结合在一起考虑。考虑如下代码:\n1 2 3  int* arr_3[5] = {1, 2, 3, 4, 5}; int* p_4 = arr_3; printf(\u0026#34;%d == %d == %d ?\\n\u0026#34;, arr_3[2], *(p_4 + 2), *(arr_3 + 2));     输出: 3 == 3 == 3 ?\n  实际上对于数组与指针而言， []操作在大多数情况下都能有相同的结果，对于指针而言*(p_4 + 2)相当于p_4[2]，也就是说[]便是指针运算的语法糖，有意思的是2[p_4]也相当于p_4[2]，\u0026ldquo;Iamastring\u0026rdquo;[2] == \u0026rsquo;m'，但这只是娱乐而已，实际中请不要这么做，除非是代码混乱大赛或者某些特殊用途。\n在此处，应该声明的是这几种写法的执行效率完全一致，并不存在一个指针运算便快于[]运算，这些说法都是上个世纪的说法了，随着时代的发展，我们应该更加注重代码整洁之道\n  在此处还有一种奇异又实用的技巧，在char数组中使用指针运算进行操作，提取不同类型的数据，或者是在不同类型数组中，使用char*指针抽取其中内容，才是显示指针运算的用途。但在使用不同类型指针操作内存块的时候需要注意，不要操作无意义的区域或者越界操作。\n  实际上，最简单的安全研究之一，便是利用溢出进行攻击。\n Advance:对于一个函数中的某个数组的增长方向，总是向着返回地址的，中间可能隔着许多其他自动变量，我们只需要一直进行溢出试验，直到某一次，该函数无法正常返回了！那就证明我们找到了该函数的返回地址存储地区，这时候我们可以进行一些操作，例如将我们想要的返回地址覆盖掉原先的返回地址，这就是所谓的溢出攻击中的一种。  《下部分》 内存的使用的那些事儿\n你一直以为你操作的是真实物理内存，实际上并不是，你操作的只是操作系统为你分配的资格虚拟地址，但这并不意味着我们可以无限使用内存，那内存卖那么贵干嘛，实际上存储数据的还是物理内存，只不过在操作系统这个中介的介入情况下，不同程序窗口(可以是相同程序)可以共享使用同一块内存区域，一旦某个傻大个程序的使用让物理内存不足了，我们就会把某些没用到的数据写到你的硬盘上去，之后再使用时，从硬盘读回。这个特性会导致什么呢？假设你在Windows上使用了多窗口，打开了两个相同的程序:\n1 2 3 4 5 6 7 8 9 10 11 12 13  ... int stay_here; char tran_to_int[100]; printf(\u0026#34;Address: %p\\n\u0026#34;,\u0026amp;stay_here); fgets(tran_to_int,sizeof(tran_to_int), stdin); sscanf(tran_to_int,\u0026#34;%d\u0026#34;,\u0026amp;stay_here); for(;;) { printf(\u0026#34;%d\\n\u0026#34;, stay_here); getchar(); ++stay_here; } ...   对此程序(引用前桥和弥的例子)，每敲击一次回车，值加1。当你同时打开两个该程序时，你会发现，两个程序的stay_here都是在同一个地址，但对它进行分别操作时，产生的结果是独立的！这在某一方面验证了虚拟地址的合理性。虚拟地址的意义就在于，即使一个程序出现了错误，导致所在内存完蛋了，也不会影响到其他进程。对于程序中部的两个读取语句，是一种理解C语言输入流本质的好例子，建议查询用法，这里稍微解释一下:\n通俗地说，fgets将输入流中由调用起，stdin输入的东西存入起始地址为tran_to_int的地方，并且最多读取sizeof(tran_to_int)个，并在后方sscanf函数中将刚才读入的数据按照%d的格式存入stay_here，这就是C语言一直在强调的流概念的意义所在，这两个语句组合看起来也就是读取一个数据这么简单，但是我们要知道一个问题，一个关于scanf的问题\nscanf(\u0026quot;%d\u0026quot;,\u0026amp;stay_here);\n这个语句将会读取键盘输入，直到回车之前的所有数据，什么意思？就是回车会留在输入流中，被下一个输入读取或者丢弃。这就有可能会影响我们的程序，产生意料之外的结果。而使用上当两句组合则不会。\n函数与函数指针的那些事\n事实上，函数名出现在赋值符号右边就代表着函数的地址\n1 2 3 4 5  intfunction(int argc){/*...*/ } ... int(*p_fun)(int)=function; int(*p_fuc)(int)=\u0026amp;function;//和上一句意义一致   上述代码即声明并初始化了函数指针，p_fun的类型是指向一个返回值是int类型，参数是int类型的函数的指针\n1 2 3  p_fun(11); (*p_fun)(11); function(11);   上述三个代码的意义也相同，同样我们也能使用函数指针数组这个概念\nint(*p_func_arr[])(int)={func1, func2,};\r其中func1,func2都是返回值为int参数为int的函数，接着我们能像数组索引一样使用这个函数了。\nTips: 我们总是忽略函数声明，这并不是什么好事。\n在C语言中，因为编译器并不会对有没有函数声明过分深究，甚至还会放纵，当然这并不包含内联函数(inline)，因为它本身就只在本文件可用。\n比如，当我们在某个地方调用了一个函数，但是并没有声明它：\n1  CallWithoutDeclare(100);//参数100为 int 型   那么，C编译器就会推测，这个使用了int型参数的函数，一定是有一个int型的参数列表，一旦函数定义中的参数列表与之不符合，将会导致参数信息传递错误(编译器永远坚信自己是对的！)，我们知道C语言是强类型语言，一旦类型不正确，会导致许多意想不到的结果(往往是Bug)发生。\n对函数指针的调用同样如此\nC语言中malloc的那些事儿\n我们常常见到这种写法:\n1  int* pointer =(int*)malloc(sizeof(int));   这有什么奇怪的吗？看下面这个例子:\nint* pointer_2 = malloc(sizeof(int));\n哪个写法是正确的？两个都正确，这是为什么呢，这又要追求到远古C语言时期，在那个时候， void* 这个类型还没有出现的时候，malloc 返回的是 char* 的类型，于是那时的程序员在调用这个函数时总要加上强制类型转换，才能正确使用这个函数，但是在标准C出现之后，这个问题不再拥有，由于任何类型的指针都能与 void* 互相转换，并且C标准中并不赞同在不必要的地方使用强制类型转换，故而C语言中比较正统的写法是第二种。\n题外话: C++中的指针转换需要使用强制类型转换，而不能像第二种例子，但是C++中有一种更好的内存分配方法，所以这个问题也不再是问题。\nTips:\nC语言的三个函数malloc, calloc, realloc都是拥有很大风险的函数，在使用的时候务必记得对他们的结果进行校验，最好的办法还是对他们进行再包装，可以选择宏包装，也可以选择函数包装。\nrealloc函数是最为人诟病的一个函数，因为它的职能过于宽广，既能分配空间，也能释放空间，虽然看起来是一个好函数，但是有可能在不经意间会帮我们做一些意料之外的事情，例如多次释放空间。正确的做法就是，应该使用再包装阉割它的功能，使他只能进行扩展或者缩小堆内存块大小。\n指针与结构体\n1 2 3 4 5 6 7 8 9 10 11  typedefstruct tag{ int value; long vari_store[1]; }vari_struct; ```c 乍一看，似乎是一个很中规中矩的结构体 ```c ... vari_struct vari_1; vari_struct* vari_p_1 =\u0026amp;vari_1; vari_struct* vari_p_2 = malloc(sizeof(vari_struct))(   似乎都是这么用的，但总有那么一些人想出了一些奇怪的用法\n1 2  int what_spa_want =10; vari_struct* vari_p_3 = malloc(sizeof(vari_struct)+sizeof(long)*what_spa_want);    这么做是什么意思呢？这叫做可变长结构体，即便我们超出了结构体范围，只要在分配空间内，就不算越界。what_spa_want解释为你需要多大的空间，即在一个结构体大小之外还需要多少的空间，空间用来存储long类型，由于分配的内存是连续的，故可以直接使用数组vari_store直接索引。\n而且由于C语言中，编译器并不对数组做越界检查，故对于一个有N个数的数组arr，表达式\u0026amp;arr[N]是被标准允许的行为，但是要记住arr[N]却是非法的。\n这种用法并非是娱乐，而是成为了标准(C99)的一部分，运用到了实际中  对于内存的理解\n在内存分配的过程中，我们使用 malloc 进行分配，用 free 进行释放，但这是我们理解中的分配与释放吗？\n在调用 malloc 时，该函数或使用 brk() 或使用 mmap() 向操作系统申请一片内存，在使用时分配给需要的地方，与之对应的是 free，与我们硬盘删除东西一样，实际上:\n1 2 3 4  int* value = malloc(sizeof(int)*5); ... free(value); printf(\u0026#34;%d\\n\u0026#34;, value[0]);   代码中，为什么在 free 之后，我又继续使用这个内存呢？因为 free 只是将该内存标记上释放的标记，示意分配内存的函数，我可以使用，但并没有破坏当前内存中的内容，直到有操作对它进行写入。\n这便引申出几个问题:\nBug更加难以发现，让我们假设，如果我们有两个指针p1,p2指向同一个内存，如果我们对其中某一个指针使用了 free(p1); 操作，却忘记了还有另一个指针指向它，那这就会导致很严重的安全隐患，而且这个隐患十分难以发现，原因在于这个Bug并不会在当时显露出来，而是有可能在未来的某个时刻，不经意的让你的程序崩溃。\n有可能会让某些问题更加简化，例如释放一个条条相连的链表域。\n某些大哥提到说，free并不是什么都不做，而是将该段地址空间的前面一小部分置零\n但是如果地址空间很长的话，依旧有误用的风险，希望大家还是警惕\n实际上之所以库作者不让free操作将地址空间清空，有一部分原因是为了性能考虑，因为置零操作是一个消耗性能的行为，具体可以自行尝试，所谓双刃剑就在于此。\n 总的来说，还是那句话C语言是一把双刃剑。     所以，指针其实就是一个存放了另外一个存储空间的地址的存储空间，从而可以由本指针存储空间访问到另外一个存储空间！      \u0026mdash;\u0026ndash;摘抄自《c语言进阶》一书\n","description":"都2020年了，还搞不懂c语言指针是什么？","id":372,"section":"article","tags":null,"title":"c语言指针！","uri":"https://www.zhugeqing.top/article/program/c/c_pointer/"},{"content":"历史上，有多种辅助存储设备，比如软盘、光盘、硬盘、U 盘等，相对于内存，它们就是人们常说的“外存”，即外存储器（设备）。\n从软盘（Floppy Disk）启动计算机，这已经是过去的事了。软盘的尺寸比烟盒稍大一点，但是比较薄，采用塑料作为基片，上面是一层磁性物质，可以用来记录二进制位。这种塑料介质比较柔软，所以称为软盘。\n在数据记录原理上和软盘很相似的设备是硬盘（Hard Disk，HDD），而且它们几乎是同一个时代的产物。但是，与软盘不同，硬盘是多盘片、密封、高转速的，采用铝合金作为基片，并在表面涂上磁性物质来记录二进制位。这就使得它的盘片具有较高的硬度，故称为硬盘。\n  图1-1 一块被拆开密封盖的硬盘\r 如图1-1 所示，这是一块被拆开的硬盘，中间是用于记录数据的铝合金盘片，固定在中心的轴上，由一个高速旋转的马达驱动。附着在盘片表面的扁平锥状物，就是用于在盘片上读写数据的磁头。\n为了进一步搞清楚硬盘的内部构造，图1-2 给出了更为详细的图示。\n硬盘可以只有一个盘片（这称为单碟），也可能有好几个盘片。但无论如何，它们都串在同一个轴上，由电动机带动着一起高速旋转。一般来说，转速可以达到每分钟3600 转或者7200转，有的能达到一万多转，这个参数就是我们常说的“转/分钟”（Round Per Minute，RPM）。\n  图1-2 硬盘的结构示意图\r 每个盘片都有两个磁头（Head），上面一个，下面一个，所以经常用磁头来指代盘面。磁头都有编号，第1 个盘片，上面的磁头编号为0，下面的磁头编号为1；第2 个盘片，上面的磁头编号为2，下面的磁头编号为3，以此类推。\n每个磁头不是单独移动的。相反，它们都通过磁头臂固定在同一个支架上，由步进电动机带动着一起在盘片的中心和边缘之间来回移动。也就是说，它们是同进退的。步进电动机由脉冲驱动，每次可以旋转一个固定的角度，即可以步进一次。\n可以想象，当盘片高速旋转时，磁头每步进一次，都会从它所在的位置开始，绕着圆心“画”出一个看不见的圆圈，这就是磁道（Track）。磁道是数据记录的轨迹。因为所有磁头都是联动的，故每个盘面上的同一条磁道又可以形成一个虚拟的圆柱，称为柱面（Cylinder）。\n磁道，或者柱面，也要编号。编号是从盘面最边缘的那条磁道开始，向着圆心的方向，从0开始编号。\n柱面是一个用来优化数据读写的概念。初看起来，用硬盘来记录数据时，应该先将一个盘面填满后，再填写另一个盘面。实际上，移动磁头是一个机械动作，看似很快，但对处理器来说，却很后，再填写另一个盘面。实际上，移动磁头是一个机械动作，看似很快，但对处理器来说，却很漫长，这就是寻道时间。为了加速数据在硬盘上的读写，最好的办法就是尽量不移动磁头。这样，当0 面的磁道不足以容纳要写入的数据时，应当把剩余的部分写在1 面的同一磁道上。如果还写不下，那就继续把剩余的部分写在2 面的同一磁道上。换句话说，在硬盘上，数据的访问是以柱面来组织的。\n实际上，磁道还不是硬盘数据读写的最小单位，磁道还要进一步划分为扇区（Sector）。磁道很窄，也看不见，但在想象中，它仍呈带状，占有一定的宽度。将它划分许多分段之后，每一部分都呈扇形，这就是扇区的由来。\n每条磁道能够划分为几个扇区，取决于磁盘的制造者，但通常为63 个。而且，每个扇区都有一个编号，与磁头和磁道不同，扇区的编号是从1 开始的。\n扇区与扇区之间以间隙（空白）间隔开来，每个扇区以扇区头开始，然后是512 个字节的数据区。扇区头包含了每个扇区自己的信息，主要有本扇区的磁道号、磁头号和扇区号，用来供硬盘定位机构使用。现代的硬盘还会在扇区头部包括一个指示扇区是否健康的标志，以及用来替换该扇区的扇区地址。用于替换扇区的，是一些保留和隐藏的磁道。\n","description":"硬盘的构造及其工作原理","id":373,"section":"article","tags":null,"title":"硬盘到底是什么！","uri":"https://www.zhugeqing.top/article/computer/hard_disk/"},{"content":" 国内网站   1.一个几乎全能编程的网站(适合小白和容易忘记基础的大佬 )\n菜鸟教程\t(https://www.runoob.com/)\n 2.垂直的互联网IT技能免费学习网站。以独家视频教程、\n在线编程工具、学习计划、问答社区为核心特色。在这里，\n你可以找到最好的互联网技术牛人，也可以通过免费的在线公开视频课程学习国内领先的互联网IT技术。\n慕课网 (https://www.imooc.com/)\n 3.全国最大中文IT社区\u0026mdash;国内的程序员入门级网站，内容很多很杂，包括论坛、资源下载、博客、各种资讯等等\nCSDN (https://www.csdn.net/)\n 4.国内最好的开源社区\n开源中国社区 (https://www.oschina.net/)\n 当然国内好的自学编程的网站还有很多，网站只是一条比较好的学习路径，关键看个人，学习基础知识的话以上我“强烈”建议菜鸟教程\n 国外网站   考虑到国内网络环境的问题，以下推荐网站可能需要读者自行解决网络问题，翻墙，买服务器等方法等等\u0026hellip;\n1.Codecademy\u0026mdash;是最受欢迎的免费编程学习网站之一。事实上，已经有超过2400万人通过这家公司的教育模式学会了编程。\nCodecademy开设的课程有HTML\u0026amp;CSS，JavaScript，jQuery的，PHP，Python和Ruby等等\nCodecademy (http://www.codecademy.com/)\n 2.edX\u0026mdash;是另一个领先的在线学习平台，重点是它不是以营利为目的，而是开源的。\n由美国哈佛大学和麻省理工学院于2012年联合创办的，所以你将会在这里学习到先进的技术和理论\nedX(https://www.edx.org/)\n 3.MIT Open Courseware\u0026mdash;如果你已经学过基础知识，并向更深入的层次探索，比如探究背后的编码理论等，麻省理工学院提供了包括如计算机科学导论,\nJava编程介绍和C语言编程等免费课件的网站\nMIT Open Courseware(https://ocw.mit.edu/)\n 4.Github\u0026mdash;作为开源代码库以及版本控制系统，Github拥有140多万开发者用户,是这个星球上最流行的开源托管服务\n[Github]\u0026mdash;(https://github.com/)(https://github.com/)\n 文章到此为止，最后给上大家几点自学编程的建议\n1.你为什么学编程？\n（发自内心的问自己，直到找到一个令你自己满意的答案）\n2.学好英语\n（本人英语不好，但是学好英语是非常有必要的，一个英语好的人和一个英语差的人学起编程来，无论是体验还是难度都截然不同，\n。“学编程前先学好英语”这话非常实在）\n3.学会看说明文档\n(你要的答案往往就安静地躺在说明文档里面。)\n4.求人与求己\n（是要自力更生，还是要求助于人？\n是要脚踏实地，还是要抄捷径？记住”我想学习和探究“， 不要依赖复制粘贴）\n5.何为好代码\n（高可读性， 简洁高效，容易维护，可重复利用，放哪都能快速适用，没有或者少bugs）\n6.切忌急于求成\n（一定要相信自己，并且坚持下去，出现很难解决的问题，先查后问，还是解决不了，心中暗念“next”，等以后有能力了再来解决）\n7.潮流\n(打好基础，理解透彻，即使面对汹涌的更新潮流也能淡然自若)\n 最后送上我最喜欢的一句话\n 相信奇迹的人本身和奇迹一样了不起   ","description":"下面的网站将会为你提供优秀的学习资源","id":374,"section":"tips","tags":["tips"],"title":"推荐网站","uri":"https://www.zhugeqing.top/tips/site/"},{"content":"第1关：2ASK信号调制仿真实验 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  %%%%%%%%%%%%%%%%%% close all warning(\u0026#39;off\u0026#39;,\u0026#39;all\u0026#39;); pkg load signal pkg load control graphics_toolkit(\u0026#39;gnuplot\u0026#39;) %%%%%%%%%%%%%%%%%% M=50;%序列长度为50 noise=[0.00170025278399322,0.00579925361297162,-0.00714310096629334,0.00272643143019335,0.00100802419684427,-0.00413527348586984,-0.00137113836576452,0.00108347369636230,0.0113158847017096,0.00875772885084802,-0.00426871731460998,0.00959727067790200,0.00229392957513885,-0.000199397016852454,0.00226021551753314,-0.000648159587254171,-0.000392578899000573,0.00471083746550627,0.00445575828950284,0.00448155590914867,0.00212346038447597,-0.00381840892055235,0.00226810776410646,0.00515525663574379,0.00154601784805246,0.00327198659039563,0.00229861261880637,-0.000959564457631679,0.000929303175360663,-0.00248960682256061,0.00280935365969837,-0.00362735417391552,-0.00338006517147871,-0.00255985963731520,-0.00931064403066404,0.00454855786679564,0.00102834277822039,-0.00238729295873880,0.00433326446110449,-0.00541229013635247,-0.000323319003177169,-0.000763522585788712,0.00100942034023821,0.000989345750938120,-0.00273499044128340,-9.50305426206111e-05,-0.000521393239075185,0.00198498473247699,0.00345720960183260,0.00350783016806733,-0.00273111002511628,0.000244630925692657,-0.00383937520385469,-0.00352119851938448,-2.16594772483810e-05,0.00484660258518588,-0.00243389732485633,0.00117440292305099,-0.000713360515784856,0.00353339035622491,-0.00344392369073065,0.000102955741600630,0.00174724385550262,0.00348043510455776,0.00488322677971841,0.000271738102753605,-0.00471682271745288,-0.00234736451706880,-0.00335701619972062,0.00743279837064303,-0.00194670407732034,0.00236562650119770,-0.000608480757436136,0.00281003289690063,-0.00241866565419543,-0.00443436383528728,-0.00449794761227818,0.00154380469498033,-0.000560909495244566,-0.000619975564691178,0.00448825278222720,0.000922070751904369,0.000625533475304696,0.00502074536329467,-0.00254394472213016,0.00220291982776910,0.00264078064868034,-0.000770694943862005,0.000682008696201164,-0.00368672221976851,-0.00363014542763929,0.000331642971575452,0.00228396779107165,0.00817604122870907,-0.00210889346973370,0.000592392714082402,-0.000260870278439018,-0.00611275518971366,-0.00138813286215800,-0.00567527280751046,0.00265750076389293,-0.00280820401546184,0.000316521330179453,-0.00172195167062450,0.000959817028316207,-0.00189839927624125,0.00154940638940559,0.00233807148852672,0.00541346449283775,-0.000613872520441205,-0.00676207309805321,-0.00265501273943131,0.00428360338203992,-0.00339045271668892,0.00303880295473295,0.000392279911298421,0.00454323363446341,-0.00620091026181624,-0.000625176683452966,-0.00381954279497232,0.00919592883116571,0.00260957127396760,0.00436069227976388,-0.00334625979026459,-0.00148189258332133,-0.000861623925951127,0.00347352363052822,-0.000878708205442169,0.00221846888083166,-0.00648841284797830,-0.00111897194301269,-0.00260440926971922,-0.00498709219200955,0.00160635689049171,0.000891711905068898,0.000105872683686670,-0.00421745996636203,0.00356544364381195,0.00110736452720184,-0.000945729826637209,7.23838802643151e-05,-0.000828502311059354,-0.00553465747328963,-0.000903307686081267,-0.00262901174694241,-0.00309652222352663,-0.00365686312188795,-0.00168725572721395,-0.00633289024903783,0.00304916116246501,0.00164457444077748,-6.33336278303420e-05,-0.000109955828567654,-0.00252401487262710,0.00322136571041752,-0.000421270659391237,-0.00225954277446061,0.00427345702576509,-0.000710788489207581,-0.00186267334503898,-0.000928930439712761,-0.00268137821772674,-0.00354215670354541,0.00798791239597796,0.00523514305445018,0.000972511563775425,-0.00397535730396648,-0.00273685021861336,-0.000558249885691753,0.00250267733158671,-0.00421216782477074,-0.00736768685796241,-0.00458244799655438,0.00105465385682813,0.00123756876052454,0.00142833573603463,-0.000411996248105506,0.000580875924260760,-0.00150572804727633,0.00272595168480883,-0.00430605600520939,0.00143892980106025,-0.00268385471213961,-0.00105900548576821,0.00174805442579358,0.00328589316046846,-0.00353428384022958,0.00398655287294975,0.00208755590744625,-0.000214609723862891,-0.000617343632906553,-0.000688131699768613,-0.000958510459627360,7.28766632841493e-05,0.000162194346482667,0.00261223990738246,0.00482872426405490,0.00147651308917585,-0.000663171805026064,0.00197702549957079,0.000579415480523204,-0.00325641089818718,0.00300170299112978,0.000971015047206092,0.000427460699615663,0.00162935197631386,0.000826639378787020,-0.00297723942085876,-0.000513356796111308,-0.000461865307310738,-0.00168236769183794,0.00531927861949227,-0.00276929934771564,-0.00152995752461649,-0.00225155607932768,-0.00371318542406007,-0.000607914731715953,-0.000866686165433062,0.00483851413080094,-0.000787485380080333,-0.00336533830123142,0.00507057719287896,0.00390439828368849,-0.000726142596064627,-0.00476289518454089,-0.00140603661103977,-0.000493128853575997,0.000873004472089378,-0.000825871962687130,0.00140222320920569,0.00123927830363757,-0.00395499396710097,-0.00299771564740126,-0.00234358324468242,-0.00160586009468610,-0.00101374876291904,3.94305709415788e-05,-0.00957909983541055,-0.00144520718919805,0.00392896683944133,-0.00337320600407983,0.00295270770948532,0.00110781227647625,-9.17242785922280e-05,0.000576964413353471,-0.00494914167046101,-0.000267337308429845,0.00507212371262009,0.000311002970671688,0.000130834853658650,-0.00232164658386654,-9.74415700444193e-05,0.000734745767429243,0.00134835584736807,-0.00117892475546772,-0.000747735047859763,0.00639947248179118,-0.00714154230965267,0.00705012626986774,0.00106747014933259,0.00316246998859637,-0.00526255014209742,-0.00186585312111336,-0.000879316093168440,0.00133674438694915,-0.00528163835481018,0.00149143869419484,-0.00383535960472832,0.000209311311458612,0.00206293045319315,0.00103425442773951,0.00342358774459770,0.00318149517194983,-0.00205835099427384,0.000812882944062166,-0.00298638483995088,-0.00417986231266670,0.00292455638903151,1.57636617045699e-07,-0.000173668856790022,0.00288123739774750,0.00188023874341696,0.00110743334870819,0.00395364152886696,0.00294025243345712,0.000758197991525556,-0.00218311349381783,-0.00206039352570827,0.00376975711382597,-0.00509705523009636,-7.73554357482194e-05,-0.00616279589058961,0.00322709807334982,0.00272498621246161,3.67483063916651e-06,-0.000224006936685972,-0.00786232009927583,0.00183782825270624,-0.00693308796878123,-0.00733420830136658,0.000252772586371131,-0.00299936022543956,0.00130124759949590,0.00214079179134441,0.00271238846610226,-0.00218563706182018,0.00142105681872007,0.000318230595569291,0.00261226270189674,0.00169547755619082,0.00283937251081634,-0.000417224172268138,-0.000465491876331381,0.00318685932610918,-0.00671558822669188,-0.00159564231778164,-0.00401797244376390,-0.00120983937472230,0.00205130393899089,0.00261117851744164,-0.00320953360757736,-0.00148965386125544,0.000433310698348843,-0.000922953032966856,0.000954434074726176,0.00126469268651919,-0.00294079666265168,-0.000559186399589629,-0.00674227512029413,0.00362195174998481,-0.00198935965971014,-0.00380690787898152,-0.000803043599306497,-0.00451777806429565,-6.59575785021031e-05,-0.00177297839335944,0.00688674096084341,0.00360014366122730,-0.00789584840899626,0.00139559829703284,-0.00442130017051268,-0.000806555297447276,0.000519891328296551,0.00236454261504759,-0.000863450268273938,0.00498469873914276,-0.00152085681101521,0.00103568426313411,0.00210207385961236,0.000269389983663326,0.00278581731287364,0.00102208968528839,-0.00247968795890718,-0.00570909181735158,0.00587738696056419,-0.00191169199463104,0.000326852140824174,0.00178089028120315,0.000359225245034178,-0.00286099549129992,-0.00147904337542249,-0.000394936690083239,0.00467687739799952,-0.00272213822603144,0.00248133956474284,0.000975952060870254,-0.000739530386831056,-0.00334244130195655,-0.000898532593153235,-0.000274138743574747,-0.00464663521800966,0.000607733619635894,-0.00260031965771909,-0.000298014905986167,0.00106319993715017,-0.00286076732173691,-0.000911546651442201,0.00110699563780727,-0.00580549635355724,0.00327604347111733,0.00766681931658800,0.00303389079805500,-0.000998558725525054,0.00135542392516087,-0.00327607152136739,0.00593833199452786,0.00297476851954247,0.00248980597071708,-0.00276975761170205,0.00101176800004746,-0.00176548154478369,-0.000984826292990073,-0.00180252962547202,-0.00324365449798642,-0.00287370586814928,-0.000663753650412894,-0.00537227994104146,0.00192140172730351,-0.000372510898558130,0.00221093910395882,0.000852703875795145,0.00156307291293672,-0.00469004047682811,-0.00322635927431066,-0.00141352233668414,0.000346770913600812,0.00356937806646676,-0.000916943646196421,0.00398937365314713,0.00150342526115166,0.00371288317367804,0.000401441877298297,-0.00207703433895526,-0.00468459518984775,0.000491699378148897,0.00258848670637421,-0.000925244909768027,-0.00171011680378418,-0.000976011117454117,-0.00346773249970429,-0.00155903392521895,-0.000571548029104483,0.000144962304515867,-0.000201699935542461,0.00193321162706720,0.000345692900885400,0.00573642053362192,0.000986705981765876,0.00570631034223638,-0.00228671090043344,0.00166508793450327,-0.000822985486012823,0.00189781724852294,0.00187817408676608,-0.00691280731063900,-0.00419647890580750,-0.00455688510781241,0.00127074387585061,0.00464918466637821,-0.00103347733471483,0.00256879089041644,0.00172514928210658,-0.00332555335910906,0.00125690100145774,-0.00237769993493189,0.00479485693411633,-0.000102984344495375,0.00517348516825427,-0.00134415296912099,0.00186395196773087,-0.000198563290343649,-0.00639399555428073,-0.00310577258331817,0.00193693079479408,-0.000173565182716292,-0.00353774121907169,-0.00198078286026846,0.000789044376797417,-0.00314020182053440,0.00308306331569695,-0.00202610135977731,0.00572012585518167,-0.00341483692068118,0.000629892329140568,-0.00480990831680469,-0.00228832254170414,-0.00187602221804652,0.00126913694162274,0.00297928714832327,0.000950220062522057,-0.00117975300945313,0.00257880109126495,0.00252630248829629,0.000380122477764824,0.00180644361787023,0.00130537560161435,-0.00312104751516023,0.00240196594841181,-0.00207825298637235,-0.00190975792221867,0.000559554983290081,-0.000972411353171237,-0.000416852557181442,0.00188268627193351,0.00331037592774030,-0.000626000161545908,0.00103620933744873,-0.000753575524348625,0.000726049126274663,0.00139139554494149,-0.00195070134624542,0.000869110231443219,0.00190085152875630,0.000291903372058882,0.00547023878820387,-0.00192442761242514,-0.00233078765024878,-0.00553360423858053,0.00287919872159054,0.00274195578670709,-0.000252643340160658,0.00284123054940502,0.000580921230937917,0.000919559147342457,0.000357162555469710,0.00139125097841350,0.000321484874591714,0.00881432792231477,-0.00368931876188418,-0.00586380856446034,-0.00360715050116407,-0.00345745558655779,-0.00137119299148366,-0.000532748532481737,-0.000691063794869121,0.00171184979275524,0.00123096782027210,0.00237559463595089,0.00562333890439058,0.00386766338433635,-0.00405801211186635,-0.00736480083839107,0.00285215772894430,-0.00580479920171669,0.000211103889698640,0.000112195985458430,0.00704292385903040,-0.000218874689259143,-0.00160429639371859,0.000745695659639477,0.000777303191904898,0.000221502400940587,-0.00192450055143970,-0.00386617973363393,0.00100086202038585,-0.00424652538749690,-0.00326405349243498,0.00420967425420224,-0.00132468821541605,-0.000443736246895203,0.00284548804879237,-0.000949034328629139,0.00325514019552697,-0.00109119441317163,0.00320276070953571,0.00199013069869991,-0.000673612837114757,-0.00273757525869639,-0.00329859807845612,-0.000854032572945362,-0.00138552462081654,-0.00129234165596503,0.00311024312505559,-0.000941401027996780,0.00361663026993670,-0.00168113042128870,0.00307552287472712,-0.00165150104170719,0.000558388015279188,0.00306974253330750,-0.00130909527708012,-0.00138593306882978,0.00633527737332085,0.00300730549858941,-0.00136611610412723,0.00205213079653810,-0.00113866124309525,0.00223220442733618,0.00447730787928724,-0.00507392405419460,0.00325351907570082,0.00461049894203269,0.000150117505090641,0.00552214858332656,0.000491378464827492,-0.00391211594176322,-0.00693643795566579,-0.00105432572055036,0.00225642204526111,0.00100373138397214,0.00130795089723745,-0.00182490484914349,0.000455373679605353,-0.00518191603025342,-0.00240361562240172,-0.00258925111657227,0.00164352705228910,-4.47780385497421e-05,-0.00365410470700323,-3.01204293922108e-05,-0.00218137245290151,-0.00210828783948613,0.00273268040959795,0.000358663749409072,0.00125973392907182,0.00279535823615062,0.000570024878768671,0.00174195494910506,0.00215972267304188,0.00370178961443024,0.00150480330450491,0.00446587187530303,7.14943048625096e-05,-0.000151376366544793,0.00538009256968400,-0.00161184996241059,-9.02817668505804e-06,0.00290887511679609,0.000473736808502718,0.00444278964928769,0.00327017944248023,0.000922026210548762,-0.00245929871404839,0.00179205040935314,-0.00437223200510082,0.000773096805094814,0.00255650796687045,0.000673697003588410,0.00278178344461583,0.00644749282169447,0.00292173094199369,0.000844067078479173,0.00202911184714758,0.00134550283482267,-0.00415752076437488,-0.00131680789749899,0.00387280294899888,-0.000137825359535354,0.00184178411903576,-0.00318283270092653,0.000204019852917246,0.00189828982048914,-0.00430548832575338,0.00109918441488644,-0.000575038747387069,-0.00297106980128831,-0.000118690364517748,-0.00599664133705918,-0.00672925339538138,-0.00372175835645087,-0.00313233791251409,-0.00370945392317304,-0.00545628175306029,0.000911457248980671,-0.00504125156480384,0.000348542604628565,0.00248892336770982,-7.04171661421270e-06,0.000294435751899932,-0.00119583761208882,-0.00468863354326722,-0.000138566533578717,0.00303839610222891,0.00549681311830406,-0.00136043158968904,-0.00514604633542246,0.000526036959231493,0.00118985728290122,-0.000717680384505351,-0.00363317966695440,0.00640150175628816,-0.00746146848734610,-0.00161267320774351,-0.00417934708092562,-0.00201161415290196,0.00100513444174530,0.000436546025633231,-0.00224754164937364,0.00245710089441803,0.00196818240223369,0.00204719810872514,-0.00134596555837443,0.00331590351392676,0.00208933925913386,0.00793343514639864,0.00336295465903016,0.00365850749888228,0.000167533762113704,-0.00407423427477172,-0.00117390465794160,-0.00239634844860040,-0.00178342630734519,0.00175550226659188,-0.00176068683330204,-0.00283059627165938,-0.00129440790981104,-0.000508768628273699,0.00129442912496703,-0.00301249953196473,0.00100344595391322,0.000246721159121502,0.00418807451933144,-0.000674104267018208,-0.000425258813447349,-0.00370415233511761,-0.00438058523653321,0.000981913519206803,-0.000788953695042245,0.00159297857390077,-0.00282284321430999,0.00603524590644770,0.000386527413593335,0.00331100990936445,-0.000717584676963042,-0.000513876259492794,0.00218213570095253,0.00175745722272380,-0.00354255736489870,-0.00484680087784543,-0.00347176272143734,-0.00447706834665668,0.000188378741425488,-0.00130048961453411,-0.00116375211979760,-0.00430374330039453,0.00246520866448351,0.00138953994169606,-0.000283411178183631,0.00322925507420436,-0.00276376573770681,0.00131139747236979,0.00110186782249136,0.00110443943953080,-0.00230608234316361,0.00103355961710708,-0.00162819868543441,-0.00283481163527795,-0.00380506810509153,0.00328186121211753,-0.00267511048441924,-0.000546801586834600,-0.00382209339162154,-0.000939597441862785,-0.0102206009189209,-0.00343726688883940,-0.00451078720077911,-0.00320797500005520,-0.000674410065231281,-0.00102884001761935,0.00614872570001571,-0.00180810567506906,-0.000790671487151228,-0.00496261125361502,-0.00150961653275142,-0.00423105368138678,9.58139260502817e-05,0.00269769722710926,0.00127836170176099,-0.00221555564915479,-0.00515622936368095,0.00461696707892787,0.00648280433675995,0.000381056354466270,-0.00313034372879350,0.00378768597521288,-0.00187414351887651,-0.00148566765386262,0.00280297137799562,-0.00438044963147569,-0.00618779931591374,0.00133031866714338,0.00126724481912074,0.000300865920354074,0.00157065395582652,0.00342234526016628,0.00306882536147347,-0.00179797485069458,0.00256135659281548,0.000547856293627496,-0.00159866597068033,-0.00377356424428165,0.00204590174680202,-0.00111825284589498,0.000146838866405395,-0.00250752017189909,-0.00490315728536312,0.000542603698055696,-0.000196501166191248,0.00379165907027950,0.00253521087166201,0.00333084153999763,-0.00236815622478670,-0.00296092436445372,-0.00401320475065725,0.00157475299945741,0.00881984894234567,0.00230078479850182,-0.00244464334011413,0.00264566823152279,-0.00356809373286815,-0.00450456994766402,0.00226875180678837,-0.00245995324820392,0.000999235091493467,0.00444785464538208,0.00126846747451803,0.00293984394896607,-0.00507799243832130,0.00209196128618316,0.00676253790350168,0.00171123307808563,-0.00487268148925241,-0.000642393921889251,-0.00158102885169398,0.00121122796269710,0.00130297027140180,0.00128228003386288,-0.00115037574171029,-0.00189506458458821,-0.00186444409624253,0.00269913311160364,-0.00585972602836188,-0.000655550150636008,0.000855010950162827,-0.00206424318863945,0.00150912518220259,-0.000225532536012873,-0.00296716920239970,0.000510276300791479,-0.000848068736314267,-0.00129613111751525,-0.00224939991666723,0.000194307680056238,-0.00583797324109825,-0.00125963992503088,-0.00171885008220130,-0.00288367626845298,0.00206401417312763,-0.00232196959754571,0.00170963194226803,0.00308587982919206,-0.000496067808032685,0.000878478589095733,0.00202233128091867,-0.000256074967990944,0.00171038157267678,-0.00399258060268093,0.00351146850466960,-0.00312927195335422,-0.00578328701884601,0.00437816871299201,-0.000198359539490656,0.00141961322901440,-0.00114872415235145,-0.00322736806443707,-0.00971764300774092,0.00198046808345664,-0.000906576094889644,-0.000624053065727326,0.00128263680874552,-0.00448837392874357,-0.00230670838038916,0.00362816920233389,0.00189061397236590,-0.00405176710202071,-0.00696733329246169,-0.00180643947552883,0.000676716283999734,0.00298005752364017,0.000296386025324225,-0.00354906128473320,0.000968156030144163,-0.00370724836190017,-0.00303884309604396,-0.00206729163789880,-0.00388768407178286,-0.000856866977167581,-0.00284589199322521,-0.000903418890758068,-0.00146230531929037,-0.00129585463004012,-0.00159233008054410,0.00390002790766475,0.00192995455541833,0.000186802556261012,-0.00463889287429031,-0.00514124134915361,-0.00621309267095249,0.00823835232335413,0.00307491914277946,0.000812645179584237,-0.00308081884022504,-0.00362512248790448,0.00173178817084430,0.00494923012231346,-0.00535482283118249,-0.00142111923162469,-0.000266554938597452,-0.00629924817385330,0.00266025237742018,-0.00131126663125913,0.00604684674736006,-0.00123613032833103,0.00129394735858068,-0.00361267507439753,-0.00197599275834448,-0.00369582615921316,0.00124143204198152,0.00411677798172949,-0.00187726008161093,0.00137994015218412,-0.00159493420479390,0.000322892940710307,0.00378287636120689,0.000380367663082582,-0.00327878671166892,-0.00271039842479270,-0.000537189716715181,-0.000606108320153287,-0.00273794808926997,0.000571310153633320,0.00400511470427051,-0.000794267026586804,-0.000646907301151578,-0.00696182354182981,-0.00244922548869253,-0.00440591476708263,-0.00122138120838849,0.00166204997346719,0.00481700039998856,0.00568733882720629,-0.000369620506263713,-0.00101254924865957,0.00258521347930496,0.00155001945274433,0.00241993664773543,0.00246113443836515,-0.00468113598013342,0.00170878087783410,-0.000289471803887720,-0.00240412910774601,-0.00219334137504729,0.00405232522369692,-0.00256061515712269,-0.00391116304681795,0.000678898158868013,0.00635861864016885,8.08102138979971e-05,0.000974928419886001,-0.00296699819388357,0.00529433570260873,0.000395247309935343,0.00167632736121748,-0.00301070407381876,0.00270072052488586,0.00123058686281530,-0.00365559640607316,0.000125669315790333,-0.00142491789820753,0.000345472325348761,-0.000792317656359121,-0.000600521760124539,-0.00326635933115960,-0.00102233882081748,0.00242397074665680,0.00551714102036238,-0.00366988623670694,0.00751803638981397,0.00482588224851144,0.000532867503508561,-0.000952498678777185,-0.00220933879243231,0.00263345178782841,-0.00219653467806435,-0.00146060227079975,0.00279424273159422,0.00137857654833672,0.00283576415300203,0.00159610281634161,-0.00126774805566724,-0.00162493008938327,0.00251833545885246,-0.00212248966136505,0.00375254538149315,0.00250041917780707,0.000909855254956797,1.02018700119934e-05,0.00115618306411921,0.0111523344795443,-0.000355555946045665,-0.00492238222640890,0.00605608520586014,0.00192850255029737,-0.00204887645146614,0.00827673972155679,0.00174225820738359,0.000930353738865019,-0.00245975806631721,-0.00336760465250650,-0.00559221618830554,-0.00133738900042038,-0.00333020228569715,0.00204838194043099,-0.00100442852477603,0.00559404252026491,0.00477688096216171,0.000518646161193544,-0.000894177377486050,0.00364346819528503,-0.00362557547225520,0.00213042233775862,-0.00211592107739555,-0.00126593153307527,-0.00212442580764172,0.00182029877968559,-0.00246054774133712,-0.00336327583210399,0.00174867092871773,-0.00133899955456138,0.00114343901360263,-0.00111277148865976,0.000852362559329186,-0.00810950090949490,0.00147319172489749,0.00586147436020894,0.00328652146184998,0.00288050790394540,-0.000758096892062805,0.000572366184261010,0.000772384885394098,0.000304821065379139,-0.00262617197749499,-0.00111391921746526,-0.000552687203105348,-0.00151995957070835,0.00264631003772490,0.00802696541597762,-0.00418475034039212,0.000405847547670668,-0.00456120337416651,0.00411889261342656,0.00445853163932465,-0.00525742249423334,0.00614647000443551,-0.00343011768353023,0.000717264577612525,0.00347511926712415,0.000465451703771071,0.00725953271570279,0.00870435228464071,0.000437399051189540,-0.00603067286720033,-0.00115420918906293,-0.00268195934296820,-0.00241836248016380,-0.00356608411949787,0.000247254996195312,0.00666174789848659,-0.00226370821939686,-0.000887068410452435,0.00368871784792581,0.00383527807833193,0.00153541541646950,0.00324454901326202,0.00275347744460022,-0.00120722441080199,0.00135627883820980,-0.000945933760942991,-0.00284563411788330,0.00200724139202651,0.000213306983375309,-0.000591727118710457,0.000922523213811848,0.00312336485929921,0.00124256821223166,0.000615225463837640,0.000884757717535303,0.000161972847892563,-0.00244907730176413,0.00248802222623614,0.00445535497638268,-0.00168896801985261,0.00609610741679478,-0.000557343681352226,-0.000770806325948875,-0.00283846251079093,-0.00250558916785587,-0.00301357057590773,0.00111914731174359,0.00505024066680508,0.00166800739158957,0.00270122485419688,0.00424329128004053,-0.00790421876425806,-0.000529869101250211,0.00111633244282650,0.00226815543279002,-0.00412630318699508,-0.00318083691515725,0.00250036067264636,-0.000368630908434087,0.00174902379650255,-0.00303782560532018,-0.00516653681734514,0.00240712664626136,0.00377356854754973,0.00516101807402325,-0.00484520895260088,-0.00422749849438919,-0.00466071185516981,-0.000131750209101611,-0.00194640509554633,0.00415572239379469,-0.00460132454784112,-0.00550979201650762,0.000649230413502844,0.00377237714939360,-0.00253874954884004,-0.00400229378393857,-0.000472227202135134,-0.00517489877269906,5.48476380241025e-05,0.00261959054521155,0.000688549114848724,-0.00603756249905350,-0.00169757965294837,-0.000955109990026237,0.00573505025743931,0.00289301526037522,-0.000180505072762793,0.00414056644779159,-0.00330374483420282,-0.00110131635410127,0.00446691060219573,0.00475095197207572,0.00230965169104858,0.00155189494611685,-0.00185349359722320,0.00235557952360388,-0.00261885596017386,0.00181679407499857,0.000891260708050068,0.00360280276264491,-0.00134671237423545,0.00201165096732554,0.00250824932731342,-0.00284091787832730,0.000494089580575396,0.00505096036124963,0.000355565584926332,-0.000975957735888988,0.00144408448020605,-0.000869945210797862,0.00140134313430340,-0.000426164749605429,-5.79589514531076e-05,0.00145714410474218,0.00430801975899159,0.00142895284962630,0.00521264681406375,-0.00641424371554000,-0.00142067477851071,0.000746276029725324,-0.00264104880574845,-0.00403492450862230,0.00195123625307381,0.00193753227752513,0.000915103562662722,0.00125009934247022,-0.00275296142720960,-0.00157382884012069,-0.000337325904046226,-0.00217510670897647,0.00104949948311539,0.00747949736479805,-0.00152494742806386,0.00204741100016592,-0.00327113817443558,0.00423604357952800,-0.00306469089680506,0.000660016683231679,-0.00195616394838527,0.00161913563184457,3.59050416218754e-05,-0.000139104250144684,0.00932584946117143,-0.00199238100266563,-0.000148245677881742,0.00848447163437527,-0.00362615434002711,0.00174873557888910,-0.00340406037917362,0.00325916853244290,0.00103574020903263,0.00206219972232042,-0.000881836278642800,0.000775363899294557,0.00465649647837430,-0.00719450278197986,-0.00516491877197867,0.00131382813790182,-0.00207056091280472,-0.000937135657438803,-0.00473367312207440,-0.00286133775893519,-0.00127813427050449,-0.00229517532628776,-0.00274006623856515,-0.00133399664980560,-0.00298097265826558,0.00424340890162851,-0.00312570500922501,0.00574883954860142,-0.00118407251590939,-0.00459080724695150,-0.00195644365882319,0.00295515151647312,0.00333914149852512,0.000506683137811862,0.000908839612230166,0.00200142316727349,-0.00461389550785343,-0.00183952766954754,-0.00578744031606003,-0.00142018863652064,0.00300187018856139,0.00226874894156697,0.00723474929000679,0.000527239165142831,-0.00681942252845980,0.00534234968897928,0.00405492776059484,-0.00184244088267767,0.000703968798937615,0.00246484197981810,0.00121655085014018,0.00220210556351409,-0.000356437894728676,-0.000122771322129836,0.000278560703958632,-0.00249711144332058,0.00449979657612787,2.00225432743274e-05,0.00217084304923870,-0.00270353753061283,-0.00340019262388500,-0.000287663706256545,-0.000799334720422774,0.00377836466950379,0.00191654172876137,0.00170925670433795,-0.00456929964567994,-0.00306011650999594,0.000638942433052363,-0.00110008674275168,0.00407961643091986,0.00424110076029348,-0.00183664355826843,0.00276742176379632,0.00441280000333200,0.00101504439662646,0.00513358608217026,0.00335970911881327,0.000677060211161813,0.00277269517794113,0.000614768948785874,-0.00131200420821233,0.00113354604787010,0.000114546133947624,-0.00115306499704931,0.00560045561250300,0.000699726878833684,0.00863421204045267,-0.000936557175473918,0.00178445921761641,0.00500468596727510,0.00863058344808676,0.000959954543728714,-0.00249901673262876,0.00254051136187661,-0.00417389882926478,-0.000865976327998896,0.000859718692722611,0.00471038178129735,0.00454464053834318,-8.71567886262525e-05,0.00292172735735463,-0.00101597789470737,0.00209066045805484,0.00605669123449837,0.000495717412141494,-0.000950379727022499,-0.00158124880610011,0.00226568144093109,0.00422887826672074,0.00672199020861364,0.000170907776753326,0.000515564841398142,-0.00200079439082623,0.00509756468579514,-0.000238589814985035,-0.00149650724631867,0.00690717584470713,0.00256106892975938,0.00226527484698837,-0.00317989513422445,0.00137238617183644,0.00164483846303753,-0.00345398043663081,-0.000714024750725129,-0.00128047508809714,0.00166923740463654,-0.00318429616981064,0.00344380502800745,0.00564426942675979,-0.000960556133149382,-2.75011634913724e-05,0.00160212062627096,0.00380501688337254,0.00165076500483807,0.00125556998772813,-0.00152678193442807,-0.000732058406515135,0.00193969435403973,0.00532164065644523,0.00179741830073599,-0.00381379936822079,0.00136945719352227,-0.000291311385018700,-0.000771769478181805,-0.000693135412514566,-0.00278206663339548,-0.00101447235051460,-0.00248053895973785,-0.00115411284890030,0.000370842111275275,0.000551310503082757,-0.000681965457238477,-0.000482599872702174,0.000106531505085299,0.00144921558050469,0.00405287377836568,0.00196089691733535,-0.000906542351012915,0.00189109173360627,-0.000776442494110514,-0.00563118538753561,-0.00742262217676353,-0.00541886413203556,-0.000749862239973189,-0.00195942887190661,-0.00227734708032863,0.000128569271902637,-0.00208388225007565,-0.00199386360271383,0.00192780380692061,0.00247396039997701,0.00770515628265882,0.000956296217586426,0.000184423571096324,-0.00181557100322159,-0.000617315814831745,-0.000159793930058844,-0.00555224818757724,-0.000813836263727241,0.00237025955946960,-0.00180491522357136,0.00156290316368614,0.00313520995108463,0.00340621611758413,0.00245658946395501,-0.00714624265919352,-0.00178471580228150,0.00285076622602748,0.00124807361649349,1.53510356793083e-05,0.00138165801672489,0.00357360371681119,0.000486265779338827,-0.00239898971016650,-0.000569725737219686,-0.000657088366164899,0.00283575759089445,0.00130383143527813,0.00173140927542811,0.000467495455604896,-0.00114558933241891,0.000193345751357412,0.000685283121245090,-0.00442125127318298,0.000565637784560438,0.00293327885115633,-0.000348413224736227,0.00497235868494002,0.00177242694737404,-0.00132924635594809,-0.000486818066626068,-0.000870254364086758,0.000762489827557533,0.00238652792337171,-0.000923100154871849,0.00144973158350931,0.00555071002731297,0.00294563188828891,0.00260971530686494,-0.00257664639702728,-0.00168930194117186,0.000767015692889537,-0.000318276760892335,-0.00513885440847626,-0.00478902650256677,0.00324509579116956,-0.00239740958078470,0.00657230329673892,-0.00702653860284990,0.00141911522877579,1.97995076457207e-06,-0.00239143867295451,0.00127858736513716,-0.00251038321296399,0.00271887319245452,0.000211459010887323,-0.00518419813145241,-0.00766773248255215,-0.000897549035234594,0.00362335766210876,0.000572907597039570,0.000171554285785675,0.00217486801661226,-0.00440634078258119,0.00450740222511364,-0.00282660554801274,0.000119422467008095,-0.00114970703796389,0.000472939123418396,-0.00614910616691024,0.00481897878143749,0.00172600330115985,0.00635594881448419,0.00447990598264744,3.63050522069860e-05,-0.00296953468984925,-0.00549891114849753,5.36669242641970e-05,0.000693041905661998,0.00330717515197698,-0.00300727120185669,0.00251337013467490,0.000225880892077025,-0.00244661280702085,0.00244811470335875,0.000840073979982800,-0.000743468968220641,0.00593651926459628,0.00192658415203416,-0.000348716624071801,0.000877397564018041,0.000275263350744856,0.000548949428521039,0.00143438117115540,-0.00190849158690309,-0.00252041096212091,0.00114047195170867,0.00596118329862635,-0.000970255820725316,-0.00320251435758637,-0.000754347130822026,-0.00153058922490565,-0.00103515426811343,0.00150371989776125,-0.000411111562972092,-0.00187951010483383,-0.00140331418614706,-0.00418220595996748,-0.00271804458238584,-0.00446830204151279,-0.00163169068567635,-0.00343138147035432,-0.00223623181375940,-0.000953915431128678,-0.00379612618752941,-6.12288619896560e-05,0.00107634623131494,-0.00304600381659007,0.00352253250880335,-0.00501570575538787,-0.00123896349760940,-0.00469499007528971,-0.00108980679499702,-0.00418658969263144,-0.00181778772330951,-0.00234232033745517,-0.00374730495495291,-0.00652966076473737,0.00178687602094601,0.00632500552303339,0.00703077958092867,-0.00155640218467506,-0.000145474052056987,-0.00147282135184249,0.000240166867958138,-0.00290540472056683,-0.00606988612670097,-0.000115243337007821,-0.00387418768714384,-0.00601602554309850,0.00750803315199269,-0.000737903937712463,0.00127718303923652,0.00377091681213931,-0.00532767526951228,0.00130649036659208,0.00158665769805388,0.000262672523069329,0.000499001254573470,-0.00166950081882244,0.00228651869801433,-0.00268775149880018,-0.00251838749286426,0.00229371879725881,0.00533332192243929,-0.00122188565022047,-0.00159719818412651,0.00129044296067127,0.00339108787115264,0.00306103067210184,0.000854275183218123,-0.00200616961495731,0.00199148603634902,-0.000250559130052341,0.00435429558560330,-0.00445315889768599,0.000446613797032147,0.00407845083050584,-0.00156512600045674,-0.00197586998832155,-0.00295241087077847,-0.000881405568261662,-0.000634115599393637,0.000432413525853992,-0.00279339436173376,0.000261007829147619,-0.00190962009965401,-0.00116602115242292,-0.00265052760271708,-0.000893264513000425,0.0112889131205647,0.0107755634785245,0.00362687272617324,0.00248952690944981,-0.00404182524921881,-0.00184864570447019,-0.00195873269458713,0.00169277053873873,0.00152733916751477,0.000343028333174900,-0.00107607478607519,-0.00292778977492603,1.68286607525880e-05,0.00360230698682584,0.00135143492592349,0.000572473921535810,0.00207913348973066,0.00184754682767008,-0.00511166782044554,5.93697141065830e-05,-0.00134700619006845,-0.00643215898080274,-0.00420125205503186,-0.00101156714633377,0.00261024031808432,-0.000725087528388568,0.000829309888243590,-0.00283966065356511,-0.00682199015359385,0.000296990860960578,-0.00300789989706629,0.00370805494156673,0.00548685489647172,-0.00117540610058597,0.00377216758575349,0.00301569984895994,-0.00447476372117628,-0.000105481939387531,0.000825726870314248,0.00165385393232387,0.00214018791356607,0.00213262632212358,0.00214528587398688,-0.000988463863882627,0.00119927408783005,-0.00712428975880758,-0.00369464930723695,0.00380094903376149,-0.00208943888599350,0.00103583263471863,0.00476911657107704,-0.00281097693936805,-0.00303352435678439,-0.00155811524857841,0.00139474336719403,-0.000647521408011720,-0.00309209700666735,-0.00497409385415770,-0.00117086987705693,-0.000699323367461480,-0.00169249155087925,-0.000828428750438925,-0.00346400612589326,0.00173682879509784,-0.00687675403614174,0.000457311681632655,0.00211566948636222,-0.00268423348920199,-0.000180534808540188,0.000922709185310011,-0.00194359447898684,-4.31435504190669e-05,0.00130321730232463,-0.00296352722964777,0.00264099843896370,0.00346123452312969,0.00101566265674402,4.77909917095953e-05,-0.00368244874852185,0.00156482384091472,-0.00384485208284813,0.00503051328096815,0.00166486028480972,0.000837429916731303,-0.00124466581646865,-0.00688209661583095,-0.00378099129967580,0.00115526981401248,0.00762881478611897,0.00234086724863991,0.000979504085010907,-0.00171391396125681,0.000386693381415393,0.00304299443686051,-0.000803138973285877,0.00598225770333810,-0.00385878239788295,-0.00118976631536094,0.000165795525919857,-0.00617888089088448,0.00178801684077956,0.000246007690533234,0.000255199562779751,0.00251308675214545,0.00330043420799153,0.00253673059178750,-0.00148255281546228,-0.000147338024467203,0.00111771663581118,-0.00397435234424470,-0.00327621907123854,-0.00135017456924008,0.000245609929862667,0.00566341874883070,0.00252116740237307,-0.00139931020731793,-0.00198936070490829,0.00485028968406409,0.00864421368099502,0.000529488854170146,-0.00151430461541824,-0.00446720381633592,0.00308318294547560,0.000916171871520932,0.00368534447740465,-0.00287357947015476,0.000760765065824898,-0.00206827611449145,0.00403176025421762,-0.00174301775545727,-0.000276411111468144,-0.00109990442218544,0.00314318551680459,0.00135483413876125,-0.00317551267812610,-0.00200073473823104,-0.00330682534426552,0.00159918597860198,0.00104972983738272,-0.00517162848565622,-0.00602995818278229,-0.000127751973052093,0.00220471889115925,0.000533800613446767,-0.00488191263270987,-0.00490723004399013,0.00274194076801348,-0.000459709760007754,-0.00122140338491480,0.00416220286074664,-0.00251864103088117,0.000428303224576376,0.00132121994052337,0.00259268708845772,-0.00270170260468061,0.00112994058898069,0.00869141438936416,-0.00478445334698296,0.00137236220032144,-0.000726589370560804,-0.00261547677080021,-0.00263096003830710,0.00157449646770358,0.00732265269590915,-0.00251029728240326,0.00171066436099471,-0.00176790724025744,0.00625045069009356,0.00172236733715670,-0.000436095664574254,0.00196021887501696,-1.76543113694083e-05,0.00350127143916024,-0.000586887453859042,-0.00354623449622127,0.000779341800068223,0.00493643315970571,-0.00378405011563410,-0.000766363058642041,0.00317754565356221,-0.00607197093826717,0.00197783321603551,0.00238106990814491,0.000675094683214361,-0.00243569400173282,-2.25617523046950e-05,0.000294681665532370,0.00295752399977722,0.00209822790132943,-0.00110753293787791,0.00512250223868294,-0.000160748365400976,-0.00256997379136947,-0.00138640556526459,0.00271516320483312,0.000617326990913047,0.00281082893219242,0.000218898618268626,0.00786401950600673,-0.00526722602148988,-0.00131527964824529,-0.000266341591479369,0.000282239439729493,0.00460474176197989,0.000693972959434519,-0.000363273767406025,0.000216940056678827,0.00237643539792798,-0.00218015978358607,0.00142559772724205,-0.00494904251315298,-0.000249174589110057,-0.00297820770428769,-0.00206452935502655,0.000893435903733808,-0.00355781232355623,-0.00312741066225830,-0.00479356629603567,-0.00704716889646715,-0.000479153618329731,0.00367692053184365,-0.000575333053283056,-0.000739826054105830,-0.00331006376532927,0.00500689391614884,-0.000788714491033404,0.00409204740195446,0.00114468170357007,-0.000831845071724813,0.00342204122537093,0.00310672934438205,-0.000352416758631235,0.00409815621763088,0.00563294945266990,-0.000207492455724267,-0.000808533888691676,0.00127957820445757,0.00111235252285968,0.00255357418603554,-0.000808248103976283,0.00226138674599374,0.00331595585698113,0.000561457829123979,0.000484769844087074,-0.00396652227638217,-0.00370872195405636,-0.00462148480345648,-0.00393478410444248,-0.000490467289727193,-0.00510680587553347,0.00710268164644734,0.00233781220928703,-0.00653846873940600,-0.00365100951110930,-0.000338970481553735,-0.00541659926989985,-0.00145431423659959,0.00345004525413761,-0.000518234874884455,-0.000212633036912879,-0.00316731344815335,-0.00175715578089070,-0.00427399642841619,0.00115173732946472,-0.00143000600698185,0.00247722070630682,0.00391248581193176,0.00340639974472103,-0.000110177306827268,-0.00159374788719806,-0.00387068785966003,0.000374758625025951,0.00303412161689902,-0.00107811670963744,-0.000548080686168870,0.00194891332737057,0.00273195292263392,-0.00448067601660509,0.000632303611835240,0.000619258881933145,-0.000477922621538986,0.00282323141411587,-0.00115167049582937,-0.00261263803291824,0.000872824384605364,0.00145400673307163,-0.000687816484696880,0.00251756187465529,-0.00480040885405673,-0.00339918611804860,-0.00971504106887448,0.00164883430444231,-0.00313389187470270,-0.000800453864920431,0.00319157699234173,0.000161314275908632,-0.00139277077581904,-0.00268309586470392,-0.000760119335128295,0.00190663028663153,-0.00479481504778935,-0.000216136941870522,0.00247414347912787,-0.00449272984776169,0.00211671839969733,0.00216058395608449,-0.00278955967193586,-0.00475767442698184,0.00136970704470935,0.00255592898630691,0.00183076265918755,0.00241234074861903,-0.00373821391092663,0.00184628850735746,-0.00183415165970304,-0.00177519892153448,-0.00492017668611660,0.00347916462287074,0.000553582957329112,0.00317369762615859,0.00477822739385418,-0.00359626557983912,0.00203340269977158,-4.03508022611553e-05,0.00289114310398886,0.00350283781208210,0.00259455857340052,-0.00258551563182918,-0.000399981389042468,0.000835293210067478,0.00998814276404236,0.00387890425930021,0.00733849323411373,0.00131075732488639,0.000669870231347791,0.00193900396358571,-0.00166897729274063,0.00392628789998917,-0.000498471986815131,-0.00434371023738778,0.00275383204228674,-0.00496013782059118,-0.00583203973245461,0.000912031898199439,-0.00300704501534055,-0.00287998775546955,-0.000512128243330690,-0.00154604313174989,-0.000704498566781928,0.000860349803766369,-0.00369521914077664,-0.00387136879961403,-0.00663913458982557,-0.00123405555108258,0.00210064336261873,-0.00222075378144621,0.00158533686217099,0.00170862208750189,0.00313302971149985,0.00312868831590618,-0.00217830708414601,-0.00270955842174508,0.000153022671820602,-0.00210245106317508,0.00459397344922741,0.00436345539648458,0.000300847772376267,-0.00135069437248969,0.00161531612570169,-0.00207531942133610,-0.000395337757728709,-0.00167748299584491,0.000333893511619499,0.00356815728371973,0.00234792172252230,0.00361639070763320,-0.00289258042257656,0.000568582810387519,-0.00310961884399642,0.00121693479228346,0.00102994634640130,0.00409929331914088,0.00347606883904517,0.00206567265416657,-0.00159718228931395,-0.00150522458220207,-0.00648760685272024,-0.00141766342527800,-0.00490531414872144,0.00294036728710268,0.00285218462382256,0.000437303310824263,-0.00119663040114385,0.000452408905100417,0.00507557791852691,0.00426627955946004,-0.00141809847060386,0.000532563357870031,-0.00354332166693127,0.00126722239672576,0.00233712129080922,0.00284619126260312,-0.00484213733489028,0.00159575104116445,-0.00273288666844307,-0.00119077131249458,0.00249190769985963,0.000943009038242000,-0.000517797152562924,0.00191865677444074,0.00516873865789156,-0.00197166027566182,-0.00426939159375187,-0.00367532868376641,-0.00298607302364863,-0.00212255536042400,0.00182362598049380,-0.00659578415277735,0.000746183317645404,-0.00246158444530397,0.00347712017589510,-0.00270553185892755,2.38993041577117e-05,-0.00296490653117472,-0.00215528095807024,-0.000822633109254589,-0.000723514469303841,-0.00165960440666038,0.00356805643276518,0.00173969305874569,0.00586649105505950,-0.000876895783135817,0.00337298265837838,-0.00663837612184438,0.00201906296041176,0.00117467691511100,-0.00118325884101587,0.00219888447782356,0.00277530576117898,0.00326854805194946,0.00132749671433753,0.00190074779154355,-0.00213143305601191,-0.00346325836816003,-0.000846278393123678,0.000589924073559622,0.00300715109178440,-0.00249983974163248,-0.00154786528740931,0.00940611227175925,-0.00196878776558274,0.00607253124638774,0.00303941977916056,-0.00176392848626206,-0.000336956975371838,-0.000680399603150084,0.00149730587564290,0.00431853589453546,-0.00517919010306618,0.00639959257992306,0.00245958568213445,-0.00173578028945309,-0.000398482909023667,0.000947356429428670,0.000936575518778016,0.00379720899487512,0.00344742917570595,-0.00113431919614193,-0.000410867243337982,0.00232028177986354,0.000380521836625958,0.00359339503612005,-0.00217176729092994,0.00149159218174932,0.000911818936989217,0.00440143145106586,-0.00425485094844413,2.36350590321344e-06,0.000169165434925531,-0.00740575447693914,0.00394682339338826,0.00888357113276228,-0.000734233001422391,0.000907675345871217,-0.00146920839920373,0.00121531951970277,-0.00120112009181728,-0.000321851015258612,0.00511704320618376,-0.00267917613093072,-0.00182110250458578,-0.000240058389953335,-0.000418911956550527,0.00455149680328892,0.00642341733811125,-0.00309334509860260,-0.00202709482493146,0.00164588858237180,-0.00120387909306396,0.00630195117381716,0.00517307594065708,0.00176777295166336,0.00178237854160157,-0.00107010407589025,0.00241486502341067,0.00356528574400157,0.000447687339559917,0.00609729539963131,0.00212074327944253,-0.000348202304896717,0.00117308566127669,0.00346773690103464,-0.00125910229885974,-0.000270256316720628,0.00750499376144803,-0.00149866985402548,0.00299259255548059,0.00258725407377233,0.00502476713051892,0.00166339598776424,-0.00779563914868503,-0.00269593006744110,0.00161824946368951,0.000815155843591173,0.00620580355646940,0.00444715821965601,0.00157112621128319,0.000261933236663077,-0.00489671695968025,0.00589182808517527,0.000423829392045768,-0.00488888940177345,0.00137015924202102,0.000325569829886421,-0.00180359273020407,0.00155919944318709,-0.00223735322935022,-0.00426282945659830,-0.00554758854047873,-0.00115046492985060,-0.00198304536481699,0.00139187731127511,-0.00475176847319960,-0.000658498293723150,-0.00475962461659071,0.00572290297423944,-0.000369899737854280,0.00387761328050105,0.00156514764879226,0.00287322921007934,-0.00364996043613426,0.00397673971919463,0.00459331081212492,-0.00656745456391239,-0.000558104072547380,-0.00206206494669739,0.000495003350478419,-0.00268865003543704,0.000882420674891987,0.00188817616500605,0.000773862178165975,-0.000374244528131606,-0.00407746573992020,0.000182032218277028,-0.00164733443186871,-0.00404463816662937,-0.000177806118065837,-0.000663067275253226,0.000607478466989403,0.00313803022893988,0.00182224414078813,0.00412925084980875,-0.00230626753953878,-0.00273402522007582,-0.000300166530606050,0.00437410646443504,0.00412260248348983,-0.000397853047949481,-0.00188748063610658,-0.00480870590450266,0.00212454968494991,7.22399881068481e-05,-0.00372449453471213,-0.00105802905391283,-0.00578524533645941,0.00135974649654674,-0.000550215638889906,0.00515844146083810,-0.00429888886277662,0.00306901159943540,0.000454228963814751,0.000261215490969469,0.00226629060308325,0.00377412735459048,-0.00338699517830776,0.00417073499245579,-0.00382636590213337,-0.00339664955833174,-0.00212682172193295,0.00232889790435498,-0.00338351279610061,0.00105846214499811,0.00130248712958758,0.000487370826020905,0.00175370652822693,-0.00370886371942969,0.00318626886770135,0.000358982645768613,0.00230862354890566,-0.00311013733204713,0.000164538229433298,0.00277521289053412,0.00320699555803117,-0.000266733095101834,-0.00586138149629634,-0.00346845162799819,0.000691361262418422,0.00251162591041432,0.00146452729551532,-0.00193730623954058,0.00709741538167086,0.000228783225681428,0.00273699683998230,-0.00131454764972649,-0.00352574386484100,0.00216695844442845,0.00328141082723340,0.00576233880845881,-0.00167280849414276,-0.00514808283124925,0.00511435934952561,0.000835273718188256,-0.00356434920265400,-0.00176826932713254,-0.00255779296905350,0.00367141791570173,0.00187240126509009,0.000767635516457487,0.000760456577575064,-0.00259781235909335,0.00314049629076631,0.00109539629894380,-0.000825776719912217,-0.000584113493304514,-0.000321714316425139,-0.00280507671733294,0.00234444023256919,0.00440254784841947,0.00782315961857866,0.00159353256369029,-0.00260091188130133,0.000635560479643780,-0.00318457971035806,-0.00193901872677880,-0.00208382520975224,-0.00263490248818818,0.00119590794208440,-0.00352702297479085,0.00211000242056888,0.00251506315743240,0.00328083731361023,-6.46091039380434e-05,0.00195730151613654,0.00570178745980347,0.000167579564438818,-0.000562537847561146,0.00560508200870961,-0.00793353361939540,-0.00144386178073599,0.00768552859083212,-0.00149086872363261,-0.00177191426991420,-0.00387843037697814,0.00250752922042903,-0.00667221749190716,-0.00252790934861611,0.00179293267014713,-4.56284683895695e-06,0.00197302303372540,0.000399841015314079,0.00215309301508738,-0.00407116658374706,0.000689644857160062,-0.00495392006030359,0.00247695495149900,-0.000982108284270754,0.00207231774687983,-0.00169962102455649,0.00103926169226933,0.00333326824745948,-0.00626035893081182,-0.00590519993898245,-0.00579441740396630,0.00268348388830268,0.00128131462067789,-0.00222136103166413,0.00474039974467273,0.000435745625585033,-0.00501796986359180,-0.00322282109403188,-0.00438049371335776,0.00301961602655822,-0.00190090935702007,-0.00370584411010537,-0.00182498303158492,-0.00264502556176085,0.00269732648979899,0.00150945372283079,0.000956020019224999,0.00131479975922089,0.000135898342659776,-0.00300053737218842,0.00171271603716993,-0.00259663554867971,-0.00338966138853227,-0.00339657598669267,0.00274976741690344,0.00310235697162982,-0.00556189417296570,-0.000468320538175491,0.000796709755594252,-0.00193020566657115,0.00240642945369277,0.000804576731054169,-0.000483302522300475,-0.00176268795820890,0.00214091781178822,0.00268571432268486,0.00148407961926077,-0.000758256327423478,0.00291241172592309,-0.00286781072335944,0.000456761302446095,0.00441583307427674,-0.000599880149660183,-0.00266844338640735,0.00614569072895336,-0.000780834471574306,0.00139652239089718,-0.00254124264400480,0.000909500883895066,0.00147684088477237,1.44250760120608e-05,0.00103118825620740,0.00380923766342944,-0.00444020412804641,0.000650049039158014,-0.00629671396191076,8.98369370789442e-05,0.00610482574970833,0.00297613584088800,-2.18970376608339e-05,-0.00106961400490778,0.00167052308636693,0.00334220997622292,4.66139225790090e-05,0.00510632348086192,-0.00257995991981532,-0.00631746904938180,-0.00236598897604365,-0.000630254652046778,-0.00117877086716855,-0.00267962288966008,0.00422871799011149,-0.00511124395655311,-0.00155526379332984,-0.00306520069131380,-0.00149926088559111,-0.00210659498242358,0.00151275357360470,-0.00329211487696093,-0.00259515190900054,0.000319799893876887,0.00342785376033952,-0.00586453005294996,0.00569131802832349,-0.00277766344379691,0.00204831073055970,0.00331901605438595,0.00418398862791593,-0.00163603269932479,7.68906222793901e-05,-0.000513449136989749,-0.00191526852210420,0.000859221716775333,0.00113413005030040,-0.00111411824210885,0.000418558844047465,0.00845460792667098,-2.39260313534216e-05,0.00224617510855632,-0.00146267789397174,-0.00166929649236431,-0.00109347471684725,0.00178528843575458,-0.00253468932882825,-0.00585953222421830,0.000168283823155344,-0.00138006609145021,0.000885461374227506,0.000267547306951038,0.00230567691367531,0.00284843139168831,-0.00419203636426180,-0.00482114157048383,0.00158883370486862,0.000968894760598553,-0.00296988615879054,0.00391300910105490,0.000104392839916764,0.000390757332215576,0.000866272380193773,0.00238488168759429,0.00482088440536440,-0.000828440100486797,-0.00547290179345223,0.00320485551523682,-0.00293375913864850,0.00393286238551665,-0.00186412693929761,0.00471647937046465,-0.00254872652350000,-0.00351834712924595,0.00302610861833183,-0.00431034758935341,0.00215219862346910,0.00138451986073360,-0.000453051762268127,-0.00108002060951969,0.00650736859695811,-0.00118438377547737,-0.000601475322197716,-0.00296853253095338,-0.00257239386227665,-0.00184556454001424,0.00540599388869870,-0.00123461586782436,-0.00218217828235568,-0.00141739831253536,0.00225905637287263,-0.00416070753323113,0.00198313419204865,-0.00420992394194062,-0.000413778187183913,-0.00577715294810858,0.00169473563900021,0.00219103061114420,-0.00217422323074607,0.00100426272000263,0.000514952694304521,0.00366544633455407,0.000405998689744294,0.00328705523362037,-0.000369262771499679,-0.00205009483597885,-0.000120107115722460,-0.000630320421520169,0.00278808493991874,-0.000177543141179905,-0.00266023088352908,-0.000489659209994221,0.00375866637340437,-0.00131205202016877,-0.00208272907470221,0.00311165170754257,0.000320109444637340,-0.00114697652482809,-0.00233637874729120,-0.00467967259443988,0.000485004057057536,-0.00100249726914903,0.00100850806499408,-0.00460600473605888,0.00418000771575011,0.00154067412766390,-0.00495410718950962,0.00334271605009295,-0.00185808413973365,0.000955708670807528,0.000694001008150869,-0.00277711572444772,-0.00904854053555337,0.00169357455017638,-0.00108161694404729,-0.00189059570026562,0.00132471829936653,-0.00218096193595152,0.00212249243557949,0.000477179668375428,-0.00313482556361722,0.00264628864912442,0.00150052911612453,0.00395969610936453,-0.00282272068295586,-0.00283110569525602,0.000990823580967359,0.00210934406447205,0.00261873447336514,2.05841451220666e-05,-0.000745956625213484,0.00206440156465604,0.00621239727398426,0.00279730077032092,0.000267329330820632,-0.00181677298137028,0.00158035025525494,-0.00153087279055086,0.000754031306775982,0.00246103686996763,0.00292280764443276,0.00185985538746858,0.00435741078198437,0.00585402400337742,-0.00600094290057895,-0.00562469324408754,-0.00291764777087161,-0.00631800018320083,-0.00112924953498128,-0.00106379260786009,0.000791916560463957,0.000904923387261780,-0.00216985553405169,-0.00257192623528568,0.00250895918737770,-0.00120781694397765,-0.00433612831483610,3.25950328631253e-05,0.000645522207993299,-0.00129977677640949,0.00209836469359548,0.000713985815598561,-0.000673069021776662,-0.000139249540187403,0.00144889814271509,-0.00139588431581594,-0.00333603445252551,-0.000492000628109168,0.000408401402820280,0.00161095381981865,-9.52589643653523e-05,-0.00144631496291725,0.00188577882732383,-0.000359008467594846,0.00255203528015979,-0.000283981197200078,-1.98974469930446e-05,-0.000290488949148737,-0.00291321123943955,-0.00293127812559965,-0.00303964665993617,0.00564412752665056,-0.000633053158923536,0.00297384276571144,0.00110412928489279,0.00587956055885197,0.00293165899009745,-0.00388000035313274,-0.00103482102351760,0.00281963349372846,0.000911322815704829,0.00716317691550117,-0.000151442522163647,-0.00490742507553754,0.00140431473689118,-0.00288342446425460,0.000156326081549973,0.00340908038657795,0.000974546808026666,0.000947540269712292,-0.000623659516132746,-0.000463028388642650,-0.000325938708916007,-0.00885115807852044,0.00124364530350707,0.00313143644887637,-0.00410347556451740,-0.00481288655075396,0.00196381018493741,-0.00476720499313608,-0.00531073586456843,0.00249496181397424,-0.00206902249216101,0.00393672897860153,-0.00408649889964496,-0.00194275310280589,0.000764307367438100,0.00173719453832699,0.00147878955555669,0.000605440203498274,-0.000726707077816746,-0.00183164447328221,0.00151941489268603,-0.00122327222159913,0.00133326540765222,0.00343962792695074,-0.00711301201275361,0.00570626723357748,-0.00199875041775510,0.00416300637916313,0.00490656490425967,-0.00464509528055979,0.000559528210680726,0.0109612762916180,-0.000678709295987678,0.00153776048683163,0.00104635062281455,0.00400945842580547,0.00344850871029001,-0.00299293962151764,-0.00138665604584309,0.00108535906441321,-0.000184687710007736,0.00801629382411695,0.00138711866856389,0.00138355250555455,-0.00264896408603937,-0.00413468631326674,0.00251129976796338,-0.000623802874524003,0.00205280144887698,-0.00262935251585528,0.00283325550847879,-0.00573474759433901,0.00495428808697507,0.00267687014085161,0.000348340177850404,-0.00367172542449801,-0.00125711827133090,0.000804149218911259,0.00381936555188500,-0.00326834555269528,0.00409561364771782,0.00875357362893559,-0.00156642522455153,0.00148236674573632,-0.00207855526235168,-0.00542949553070837,0.00465018971176645,0.00219505476809838,-0.00161496567207653,0.000358562389220496,-0.000726714009204932,-0.00462240510512757,-0.00911474718442717,-0.000150105754871767,-0.00146244574341795,-0.00182351443079929,-0.00267518684446497,-0.00574660326950409,-0.00164985706665513,0.000510505070698752,-0.00335774080891863,0.00142458628758464,-0.000862663252692618,-0.000320826826855729,-0.00451922981314858,-0.00241727489119560,0.00129696879081186,-0.00249798668538939,0.000511141483258375,0.00625468162482031,0.00251485325696358,0.00328044164570331,0.00746401871876665,0.00371692566562910,0.00125776566411748,0.00617039022648818,-0.00286077461065518,-0.00215715463622579,0.00638239836473572,0.00143675928298150,-0.000133145107241409,0.00144885223082276,-0.000835297100436910,-0.000923338108571106,-0.00122316312847354,-0.00175187947589382,-0.00298432974534984,-0.000189256570992238,-0.00181731281014565,0.00455954680258821,0.000744800915929583,0.00322987624798368,-0.000442182970533332,-0.000257887231366349,0.00397892559469733,0.00464391226770968,0.000104168133159688,0.00535208582919125,0.00150438579249531,0.00116539487679925,0.00693171492131512,0.00485626270015435,0.00286900871087519,0.00127205649087077,-0.00170251337429493,-0.000364343364775323,0.00576167007171021,-0.00639256534466560,-0.00201429959407585,-0.000597048217929272,0.000468886852702177,-0.00564112401144796,0.00167305848760860,0.00230761476345209,-0.00297296766580912,-0.000819937328280340,-0.00383756571681770,0.00513727711925937,0.00118114994453089,-0.000793389517475873,-0.00292654852281299,0.000311991355995134,0.00532616051166834,0.000870446650568568,0.00111719911204194,-0.00379592082713998,0.000525345000486177,0.00245443900672120,-0.00436848231402998,0.00356793154028268,0.00779640452224495,-0.00492656681618775,-0.00653531423331255,-0.000229577138000758,0.00240052114894218,-0.000258244712247779,-0.000501136546735892,2.05485956629698e-05,-0.00336658546795099,-0.00519851591198395,0.00500129968953739,0.000925327159093436,-0.00375554807625322,0.00340241070579583,-0.00410264923162573,-0.000385071277467453,0.00234252528868451,-0.00265858256601539,-0.00110512371550431,9.37044747716387e-05,0.00617394697832885,0.00145155986054812,-0.00126273519715858,-0.000712728822600317,-0.000886332488774289,0.00413222589223417,-0.000899273136098056,-0.00250360839533116,0.000760903734917773,-0.000299296880305833,0.00250842830090231,0.00303401418714144,0.00343772095728490,0.00204652716868270,0.00200029927199841,0.00601868819628104,-0.00366832284161001,-0.00109828832330440,-0.00536026509868592,0.00290735399556064,6.80876860576496e-05,-0.000946597250181980,-0.00544232995446115,0.000580062508211995,-0.000821345639507819,-0.00428421881969322,-0.00366015298115334,-0.00240961244290061,-0.000791516792870989,-0.00521384667174699,-0.000575504863351627,0.00194697397219508,-0.00119114863192417,-0.00220738133902148,0.000961719566440613,0.00348192043017277,-0.00141229840966605,-0.00147587371800649,-0.00454046355889962,-0.00309180980805826,0.00191600695646258,-0.000359407164580768,0.00241775591251869,0.00211840175792574,0.00118833236407034,0.00242436906736496,0.00481764098009760,0.00182407826190954,0.00134704495271324,-0.000135759649092143,-0.00392838056850159,-0.00159679739017050,0.00103043232072752,-0.00351462930236096,0.00148052882897144,0.00102019149126247,0.000316295557727557,0.000953219840932371,7.53369569096519e-05,-6.97431932500447e-05,-2.76950024419697e-05,0.00293919519736422,-0.000285972080105493,-0.00835203632103234,-0.00153734126014004,0.000619710357954776,0.00303490809595354,0.00436496894980746,-0.00297716943016982,0.00240607620886922,0.000752370517330569,-0.000658934735762414,7.82322170900923e-05,-8.88318693824446e-05,0.000443854535571105,0.000751313477833919,-0.00212362353253655,-0.00330458021302289,0.00305402227651014,-0.000694931135743456,0.00447315514229789,-0.00292253481586334,-0.00187883824178735,0.00449446760906469,0.00445124621547216,-0.00325398610136163,0.000653049015911233,0.00424096632245466,0.00421441984969495,-0.00406319381786324,0.00511775392568498,0.00209230130690574,0.000718932575509701,-0.000713334358844908,-0.00305473946666290,0.000300472859195100,-0.000811859452219732,0.00730527693557913,0.000601021613146346,-0.000548351576489803,-4.43630338109458e-05,-0.00193764868066804,0.00655160667977839,0.00201444703404008,0.000236835410564407,0.00355208275142682,-0.000104759737716509,-0.000309105385164049,-0.00176018665519939,-0.00194637875678827,0.00507404276926221,0.00243019594332550,0.000274907780472677,0.00538965683046555,7.47368127594350e-05,0.000917195929319825,-0.00449011553975409,0.00150294695159112,-0.00457682465994902,-0.00312521574439861,0.00300220165544041,0.00111066772842383,-0.00275839653071852,-0.00125898866041796,0.000810921464896086,0.000695781573853305,-0.00541205032091119,-0.00381293286247722,-0.00560644523036447,-0.000229238700591550,-0.00544264303241676,0.00221954333190444,-0.00317956897782312,-0.00349882882115926,0.00566224758184758,0.00683805910914570,-0.00259078299164484,-0.000117161089925501,0.00620756367196318,-0.00170847227516313,0.00543122387505723,0.00259246141424963,0.000175572292216986,-0.00111668035878965,0.00535420816575621,0.00224853881092268,-0.00200097526107212,0.00124190988130654,-0.00277635824705169,0.000471006803373863,0.00484422387937383,0.00168185029385270,-0.00240227834949458,0.00110042247424358,-0.00220664588949454,0.00638563399660019,-0.00567217596563052,-0.00208554599969912,0.00243954965648596,-0.00259414632203381,5.65673977522829e-05,0.00206982211506046,0.00397719271235975,-0.00293168434328939,-0.000537200348789790,-0.00149155937046341,-0.000361238011037601,0.00116842014514833,-0.00195623327556504,0.00253018618197309,0.00134933139397897,-0.00149364099537808,0.000872636150582085,0.00311239936816254,0.00314048146188872,0.00211306278049273,-0.000205543065030955,-0.00196092405771185,0.000708679917471700,-0.00147405207599283,-0.00105015092308369,0.00292452120308551,0.00457589647715362,0.00188418656272227,0.00649301161034721,-0.00483591419227447,7.17444122234623e-05,0.000301317026364087,0.00510558056134414,0.00158516495329175,-0.00102407266499627,0.00175258680500168,0.00203158458661690,0.000577511319694302,-0.00641144324760762,0.00323526600744695,-0.0110412246885689,0.000346236627312686,-0.00490574086814510,-0.00112295930654471,0.00442262707772734,-0.00162375038503737,0.00606265435597853,0.00246155033552631,-0.000779359489042009,-0.00285721796435379,-0.00156818063260455,0.00118425649609579,-0.00749628069995256,0.00194499684648886,0.000883745868828501,0.00258947877529092,0.00647478419697667,-0.00102376952931216,-0.00310074698779816,0.00373033078448026,0.00282891905557581,-0.000451986316240993,-0.00187671859685090,0.000787145295503056,-0.00357268546795198,0.000209009522946002,-0.00201729469357126,-0.00259087826755722,0.00306093779765437,9.59719958587568e-05,0.00427254235401264,-0.00343541706155792,0.000759784765574256,-0.00330831568641987,0.00195655698574254,0.00412688052136645,0.00323656298199282,-0.00668942666629924,0.00215581596741687,2.75411471111209e-05,0.00105706507855974,-0.00173107115192016,-0.00522087090515311,0.00282326023968582,-0.00160345043801724,-0.00104289118434442,0.000532381455207176,0.00802187632696305,0.00725308435212901,-0.00416997196061841,-0.00149934567736532,0.00312237601857032,-0.00655548517592508,0.00393395600788948,-0.000996875084438464,0.00442495615283767,-0.00278242928037908,-0.00291711403768058,0.00731878458265456,0.00185946101918966,-0.000979571271268909,-0.00326651944691938,0.00348910137711156,0.00108184342912288,-0.00715937519021898,-0.00285644055884937,0.00939205619934835,-3.72082948214558e-05,-0.00632309772790990,-0.00280815098096832,-0.00132784797095176,0.00219644961931159,-0.000514669211644336,0.000321213544725030,-5.64734136596634e-05,-0.00303682090900104,0.00370873709171060,-0.00115509364622979,-0.00146543312872199,0.000616611167429948,-0.000211703429762400,-0.00164922310029062,0.000401924734956816,0.00668195111564851,0.00171168111817666,-0.00207156152562482,-0.00274969126871627,-0.000755461465909546,-0.00498370949665189,0.00577353232141020,0.000645950484956970,-0.00367898052428889,0.000381401735098152,-0.00456480590662944,0.00184153989190072,-0.000573844191832817,0.000132846593975611,0.00114424470251273,0.00269968267827364,-0.00256072396289453,-0.00463922155586549,-0.000328548750511009,-0.00260228063544410,0.00134390923644145,-0.00586502695758923,0.00271505282286533,0.000968901796661870,-0.00351506689799452,-0.00100320324773451,0.00264955435255188,0.00767315704479277,-0.00111024229852566,0.00437014705051098,-0.00272163154121796,0.000654245123070496,-0.000656163879975580,0.00107598722106173,-0.00157516890878895,-0.00449484459845484,-0.000856263056794426,0.00139033683015344,-0.00160056714328187,-0.000582960297337398,0.00127123248862226,0.00170518942111503,-0.00231982544444531,-0.000848666746506965]; a=[1,1,1,1,0,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,0,0,0,0,1,1,1,0,1,0,1,1,1,1]; figure (1) subplot(311);%输出图形排队6行1列，第1列  %%%%%%%%% begin %%%%%%%%% t=0.001:0.001:3; for i=1:M m(1,60*(i-1)+1:(60*i))=a(i)*ones(1,60); end plot(t,m); %%%%%%%%% end %%%%%%%%% axis([0 3 -1.2 1.2]);%x、y轴范围  title(\u0026#39;information source\u0026#39;); st=zeros(1,3000); subplot(312);%输出图形排队6行1列，第2列  %%%%%%%%% begin %%%%%%%%% f=150; carry=cos(2*pi*f*t); st=m.*carry; plot(t,st); %%%%%%%%% end %%%%%%%%% axis([0 3 -1.2 1.2]) title(\u0026#39;2ASK signal\u0026#39;) subplot(313) %%%%%%%%% begin %%%%%%%%% anst=noise+st; plot(t,anst); %%%%%%%%% end %%%%%%%%% axis([0 3 -1.2 1.2]) title(\u0026#39;2ASK signal and noise\u0026#39;) %%%%%%%%% test %%%%%%%%% sa=pwd; print(1,\u0026#39;-djpeg\u0026#39;,\u0026#39;./picture/step1/student1.jpg\u0026#39;) run(\u0026#39;./step1/test1plot.m\u0026#39;) system(\u0026#39;python3 ./step1/test.py\u0026#39;);   第2关：2ASK信号解调仿真实验 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102  %%%%%%%%%%%%%%%%%% close all warning(\u0026#39;off\u0026#39;,\u0026#39;all\u0026#39;); pkg load signal pkg load control graphics_toolkit(\u0026#39;gnuplot\u0026#39;) %%%%%%%%%%%%%%%%%% M=50; noise=[0.00170025278399322,0.00579925361297162,-0.00714310096629334,0.00272643143019335,0.00100802419684427,-0.00413527348586984,-0.00137113836576452,0.00108347369636230,0.0113158847017096,0.00875772885084802,-0.00426871731460998,0.00959727067790200,0.00229392957513885,-0.000199397016852454,0.00226021551753314,-0.000648159587254171,-0.000392578899000573,0.00471083746550627,0.00445575828950284,0.00448155590914867,0.00212346038447597,-0.00381840892055235,0.00226810776410646,0.00515525663574379,0.00154601784805246,0.00327198659039563,0.00229861261880637,-0.000959564457631679,0.000929303175360663,-0.00248960682256061,0.00280935365969837,-0.00362735417391552,-0.00338006517147871,-0.00255985963731520,-0.00931064403066404,0.00454855786679564,0.00102834277822039,-0.00238729295873880,0.00433326446110449,-0.00541229013635247,-0.000323319003177169,-0.000763522585788712,0.00100942034023821,0.000989345750938120,-0.00273499044128340,-9.50305426206111e-05,-0.000521393239075185,0.00198498473247699,0.00345720960183260,0.00350783016806733,-0.00273111002511628,0.000244630925692657,-0.00383937520385469,-0.00352119851938448,-2.16594772483810e-05,0.00484660258518588,-0.00243389732485633,0.00117440292305099,-0.000713360515784856,0.00353339035622491,-0.00344392369073065,0.000102955741600630,0.00174724385550262,0.00348043510455776,0.00488322677971841,0.000271738102753605,-0.00471682271745288,-0.00234736451706880,-0.00335701619972062,0.00743279837064303,-0.00194670407732034,0.00236562650119770,-0.000608480757436136,0.00281003289690063,-0.00241866565419543,-0.00443436383528728,-0.00449794761227818,0.00154380469498033,-0.000560909495244566,-0.000619975564691178,0.00448825278222720,0.000922070751904369,0.000625533475304696,0.00502074536329467,-0.00254394472213016,0.00220291982776910,0.00264078064868034,-0.000770694943862005,0.000682008696201164,-0.00368672221976851,-0.00363014542763929,0.000331642971575452,0.00228396779107165,0.00817604122870907,-0.00210889346973370,0.000592392714082402,-0.000260870278439018,-0.00611275518971366,-0.00138813286215800,-0.00567527280751046,0.00265750076389293,-0.00280820401546184,0.000316521330179453,-0.00172195167062450,0.000959817028316207,-0.00189839927624125,0.00154940638940559,0.00233807148852672,0.00541346449283775,-0.000613872520441205,-0.00676207309805321,-0.00265501273943131,0.00428360338203992,-0.00339045271668892,0.00303880295473295,0.000392279911298421,0.00454323363446341,-0.00620091026181624,-0.000625176683452966,-0.00381954279497232,0.00919592883116571,0.00260957127396760,0.00436069227976388,-0.00334625979026459,-0.00148189258332133,-0.000861623925951127,0.00347352363052822,-0.000878708205442169,0.00221846888083166,-0.00648841284797830,-0.00111897194301269,-0.00260440926971922,-0.00498709219200955,0.00160635689049171,0.000891711905068898,0.000105872683686670,-0.00421745996636203,0.00356544364381195,0.00110736452720184,-0.000945729826637209,7.23838802643151e-05,-0.000828502311059354,-0.00553465747328963,-0.000903307686081267,-0.00262901174694241,-0.00309652222352663,-0.00365686312188795,-0.00168725572721395,-0.00633289024903783,0.00304916116246501,0.00164457444077748,-6.33336278303420e-05,-0.000109955828567654,-0.00252401487262710,0.00322136571041752,-0.000421270659391237,-0.00225954277446061,0.00427345702576509,-0.000710788489207581,-0.00186267334503898,-0.000928930439712761,-0.00268137821772674,-0.00354215670354541,0.00798791239597796,0.00523514305445018,0.000972511563775425,-0.00397535730396648,-0.00273685021861336,-0.000558249885691753,0.00250267733158671,-0.00421216782477074,-0.00736768685796241,-0.00458244799655438,0.00105465385682813,0.00123756876052454,0.00142833573603463,-0.000411996248105506,0.000580875924260760,-0.00150572804727633,0.00272595168480883,-0.00430605600520939,0.00143892980106025,-0.00268385471213961,-0.00105900548576821,0.00174805442579358,0.00328589316046846,-0.00353428384022958,0.00398655287294975,0.00208755590744625,-0.000214609723862891,-0.000617343632906553,-0.000688131699768613,-0.000958510459627360,7.28766632841493e-05,0.000162194346482667,0.00261223990738246,0.00482872426405490,0.00147651308917585,-0.000663171805026064,0.00197702549957079,0.000579415480523204,-0.00325641089818718,0.00300170299112978,0.000971015047206092,0.000427460699615663,0.00162935197631386,0.000826639378787020,-0.00297723942085876,-0.000513356796111308,-0.000461865307310738,-0.00168236769183794,0.00531927861949227,-0.00276929934771564,-0.00152995752461649,-0.00225155607932768,-0.00371318542406007,-0.000607914731715953,-0.000866686165433062,0.00483851413080094,-0.000787485380080333,-0.00336533830123142,0.00507057719287896,0.00390439828368849,-0.000726142596064627,-0.00476289518454089,-0.00140603661103977,-0.000493128853575997,0.000873004472089378,-0.000825871962687130,0.00140222320920569,0.00123927830363757,-0.00395499396710097,-0.00299771564740126,-0.00234358324468242,-0.00160586009468610,-0.00101374876291904,3.94305709415788e-05,-0.00957909983541055,-0.00144520718919805,0.00392896683944133,-0.00337320600407983,0.00295270770948532,0.00110781227647625,-9.17242785922280e-05,0.000576964413353471,-0.00494914167046101,-0.000267337308429845,0.00507212371262009,0.000311002970671688,0.000130834853658650,-0.00232164658386654,-9.74415700444193e-05,0.000734745767429243,0.00134835584736807,-0.00117892475546772,-0.000747735047859763,0.00639947248179118,-0.00714154230965267,0.00705012626986774,0.00106747014933259,0.00316246998859637,-0.00526255014209742,-0.00186585312111336,-0.000879316093168440,0.00133674438694915,-0.00528163835481018,0.00149143869419484,-0.00383535960472832,0.000209311311458612,0.00206293045319315,0.00103425442773951,0.00342358774459770,0.00318149517194983,-0.00205835099427384,0.000812882944062166,-0.00298638483995088,-0.00417986231266670,0.00292455638903151,1.57636617045699e-07,-0.000173668856790022,0.00288123739774750,0.00188023874341696,0.00110743334870819,0.00395364152886696,0.00294025243345712,0.000758197991525556,-0.00218311349381783,-0.00206039352570827,0.00376975711382597,-0.00509705523009636,-7.73554357482194e-05,-0.00616279589058961,0.00322709807334982,0.00272498621246161,3.67483063916651e-06,-0.000224006936685972,-0.00786232009927583,0.00183782825270624,-0.00693308796878123,-0.00733420830136658,0.000252772586371131,-0.00299936022543956,0.00130124759949590,0.00214079179134441,0.00271238846610226,-0.00218563706182018,0.00142105681872007,0.000318230595569291,0.00261226270189674,0.00169547755619082,0.00283937251081634,-0.000417224172268138,-0.000465491876331381,0.00318685932610918,-0.00671558822669188,-0.00159564231778164,-0.00401797244376390,-0.00120983937472230,0.00205130393899089,0.00261117851744164,-0.00320953360757736,-0.00148965386125544,0.000433310698348843,-0.000922953032966856,0.000954434074726176,0.00126469268651919,-0.00294079666265168,-0.000559186399589629,-0.00674227512029413,0.00362195174998481,-0.00198935965971014,-0.00380690787898152,-0.000803043599306497,-0.00451777806429565,-6.59575785021031e-05,-0.00177297839335944,0.00688674096084341,0.00360014366122730,-0.00789584840899626,0.00139559829703284,-0.00442130017051268,-0.000806555297447276,0.000519891328296551,0.00236454261504759,-0.000863450268273938,0.00498469873914276,-0.00152085681101521,0.00103568426313411,0.00210207385961236,0.000269389983663326,0.00278581731287364,0.00102208968528839,-0.00247968795890718,-0.00570909181735158,0.00587738696056419,-0.00191169199463104,0.000326852140824174,0.00178089028120315,0.000359225245034178,-0.00286099549129992,-0.00147904337542249,-0.000394936690083239,0.00467687739799952,-0.00272213822603144,0.00248133956474284,0.000975952060870254,-0.000739530386831056,-0.00334244130195655,-0.000898532593153235,-0.000274138743574747,-0.00464663521800966,0.000607733619635894,-0.00260031965771909,-0.000298014905986167,0.00106319993715017,-0.00286076732173691,-0.000911546651442201,0.00110699563780727,-0.00580549635355724,0.00327604347111733,0.00766681931658800,0.00303389079805500,-0.000998558725525054,0.00135542392516087,-0.00327607152136739,0.00593833199452786,0.00297476851954247,0.00248980597071708,-0.00276975761170205,0.00101176800004746,-0.00176548154478369,-0.000984826292990073,-0.00180252962547202,-0.00324365449798642,-0.00287370586814928,-0.000663753650412894,-0.00537227994104146,0.00192140172730351,-0.000372510898558130,0.00221093910395882,0.000852703875795145,0.00156307291293672,-0.00469004047682811,-0.00322635927431066,-0.00141352233668414,0.000346770913600812,0.00356937806646676,-0.000916943646196421,0.00398937365314713,0.00150342526115166,0.00371288317367804,0.000401441877298297,-0.00207703433895526,-0.00468459518984775,0.000491699378148897,0.00258848670637421,-0.000925244909768027,-0.00171011680378418,-0.000976011117454117,-0.00346773249970429,-0.00155903392521895,-0.000571548029104483,0.000144962304515867,-0.000201699935542461,0.00193321162706720,0.000345692900885400,0.00573642053362192,0.000986705981765876,0.00570631034223638,-0.00228671090043344,0.00166508793450327,-0.000822985486012823,0.00189781724852294,0.00187817408676608,-0.00691280731063900,-0.00419647890580750,-0.00455688510781241,0.00127074387585061,0.00464918466637821,-0.00103347733471483,0.00256879089041644,0.00172514928210658,-0.00332555335910906,0.00125690100145774,-0.00237769993493189,0.00479485693411633,-0.000102984344495375,0.00517348516825427,-0.00134415296912099,0.00186395196773087,-0.000198563290343649,-0.00639399555428073,-0.00310577258331817,0.00193693079479408,-0.000173565182716292,-0.00353774121907169,-0.00198078286026846,0.000789044376797417,-0.00314020182053440,0.00308306331569695,-0.00202610135977731,0.00572012585518167,-0.00341483692068118,0.000629892329140568,-0.00480990831680469,-0.00228832254170414,-0.00187602221804652,0.00126913694162274,0.00297928714832327,0.000950220062522057,-0.00117975300945313,0.00257880109126495,0.00252630248829629,0.000380122477764824,0.00180644361787023,0.00130537560161435,-0.00312104751516023,0.00240196594841181,-0.00207825298637235,-0.00190975792221867,0.000559554983290081,-0.000972411353171237,-0.000416852557181442,0.00188268627193351,0.00331037592774030,-0.000626000161545908,0.00103620933744873,-0.000753575524348625,0.000726049126274663,0.00139139554494149,-0.00195070134624542,0.000869110231443219,0.00190085152875630,0.000291903372058882,0.00547023878820387,-0.00192442761242514,-0.00233078765024878,-0.00553360423858053,0.00287919872159054,0.00274195578670709,-0.000252643340160658,0.00284123054940502,0.000580921230937917,0.000919559147342457,0.000357162555469710,0.00139125097841350,0.000321484874591714,0.00881432792231477,-0.00368931876188418,-0.00586380856446034,-0.00360715050116407,-0.00345745558655779,-0.00137119299148366,-0.000532748532481737,-0.000691063794869121,0.00171184979275524,0.00123096782027210,0.00237559463595089,0.00562333890439058,0.00386766338433635,-0.00405801211186635,-0.00736480083839107,0.00285215772894430,-0.00580479920171669,0.000211103889698640,0.000112195985458430,0.00704292385903040,-0.000218874689259143,-0.00160429639371859,0.000745695659639477,0.000777303191904898,0.000221502400940587,-0.00192450055143970,-0.00386617973363393,0.00100086202038585,-0.00424652538749690,-0.00326405349243498,0.00420967425420224,-0.00132468821541605,-0.000443736246895203,0.00284548804879237,-0.000949034328629139,0.00325514019552697,-0.00109119441317163,0.00320276070953571,0.00199013069869991,-0.000673612837114757,-0.00273757525869639,-0.00329859807845612,-0.000854032572945362,-0.00138552462081654,-0.00129234165596503,0.00311024312505559,-0.000941401027996780,0.00361663026993670,-0.00168113042128870,0.00307552287472712,-0.00165150104170719,0.000558388015279188,0.00306974253330750,-0.00130909527708012,-0.00138593306882978,0.00633527737332085,0.00300730549858941,-0.00136611610412723,0.00205213079653810,-0.00113866124309525,0.00223220442733618,0.00447730787928724,-0.00507392405419460,0.00325351907570082,0.00461049894203269,0.000150117505090641,0.00552214858332656,0.000491378464827492,-0.00391211594176322,-0.00693643795566579,-0.00105432572055036,0.00225642204526111,0.00100373138397214,0.00130795089723745,-0.00182490484914349,0.000455373679605353,-0.00518191603025342,-0.00240361562240172,-0.00258925111657227,0.00164352705228910,-4.47780385497421e-05,-0.00365410470700323,-3.01204293922108e-05,-0.00218137245290151,-0.00210828783948613,0.00273268040959795,0.000358663749409072,0.00125973392907182,0.00279535823615062,0.000570024878768671,0.00174195494910506,0.00215972267304188,0.00370178961443024,0.00150480330450491,0.00446587187530303,7.14943048625096e-05,-0.000151376366544793,0.00538009256968400,-0.00161184996241059,-9.02817668505804e-06,0.00290887511679609,0.000473736808502718,0.00444278964928769,0.00327017944248023,0.000922026210548762,-0.00245929871404839,0.00179205040935314,-0.00437223200510082,0.000773096805094814,0.00255650796687045,0.000673697003588410,0.00278178344461583,0.00644749282169447,0.00292173094199369,0.000844067078479173,0.00202911184714758,0.00134550283482267,-0.00415752076437488,-0.00131680789749899,0.00387280294899888,-0.000137825359535354,0.00184178411903576,-0.00318283270092653,0.000204019852917246,0.00189828982048914,-0.00430548832575338,0.00109918441488644,-0.000575038747387069,-0.00297106980128831,-0.000118690364517748,-0.00599664133705918,-0.00672925339538138,-0.00372175835645087,-0.00313233791251409,-0.00370945392317304,-0.00545628175306029,0.000911457248980671,-0.00504125156480384,0.000348542604628565,0.00248892336770982,-7.04171661421270e-06,0.000294435751899932,-0.00119583761208882,-0.00468863354326722,-0.000138566533578717,0.00303839610222891,0.00549681311830406,-0.00136043158968904,-0.00514604633542246,0.000526036959231493,0.00118985728290122,-0.000717680384505351,-0.00363317966695440,0.00640150175628816,-0.00746146848734610,-0.00161267320774351,-0.00417934708092562,-0.00201161415290196,0.00100513444174530,0.000436546025633231,-0.00224754164937364,0.00245710089441803,0.00196818240223369,0.00204719810872514,-0.00134596555837443,0.00331590351392676,0.00208933925913386,0.00793343514639864,0.00336295465903016,0.00365850749888228,0.000167533762113704,-0.00407423427477172,-0.00117390465794160,-0.00239634844860040,-0.00178342630734519,0.00175550226659188,-0.00176068683330204,-0.00283059627165938,-0.00129440790981104,-0.000508768628273699,0.00129442912496703,-0.00301249953196473,0.00100344595391322,0.000246721159121502,0.00418807451933144,-0.000674104267018208,-0.000425258813447349,-0.00370415233511761,-0.00438058523653321,0.000981913519206803,-0.000788953695042245,0.00159297857390077,-0.00282284321430999,0.00603524590644770,0.000386527413593335,0.00331100990936445,-0.000717584676963042,-0.000513876259492794,0.00218213570095253,0.00175745722272380,-0.00354255736489870,-0.00484680087784543,-0.00347176272143734,-0.00447706834665668,0.000188378741425488,-0.00130048961453411,-0.00116375211979760,-0.00430374330039453,0.00246520866448351,0.00138953994169606,-0.000283411178183631,0.00322925507420436,-0.00276376573770681,0.00131139747236979,0.00110186782249136,0.00110443943953080,-0.00230608234316361,0.00103355961710708,-0.00162819868543441,-0.00283481163527795,-0.00380506810509153,0.00328186121211753,-0.00267511048441924,-0.000546801586834600,-0.00382209339162154,-0.000939597441862785,-0.0102206009189209,-0.00343726688883940,-0.00451078720077911,-0.00320797500005520,-0.000674410065231281,-0.00102884001761935,0.00614872570001571,-0.00180810567506906,-0.000790671487151228,-0.00496261125361502,-0.00150961653275142,-0.00423105368138678,9.58139260502817e-05,0.00269769722710926,0.00127836170176099,-0.00221555564915479,-0.00515622936368095,0.00461696707892787,0.00648280433675995,0.000381056354466270,-0.00313034372879350,0.00378768597521288,-0.00187414351887651,-0.00148566765386262,0.00280297137799562,-0.00438044963147569,-0.00618779931591374,0.00133031866714338,0.00126724481912074,0.000300865920354074,0.00157065395582652,0.00342234526016628,0.00306882536147347,-0.00179797485069458,0.00256135659281548,0.000547856293627496,-0.00159866597068033,-0.00377356424428165,0.00204590174680202,-0.00111825284589498,0.000146838866405395,-0.00250752017189909,-0.00490315728536312,0.000542603698055696,-0.000196501166191248,0.00379165907027950,0.00253521087166201,0.00333084153999763,-0.00236815622478670,-0.00296092436445372,-0.00401320475065725,0.00157475299945741,0.00881984894234567,0.00230078479850182,-0.00244464334011413,0.00264566823152279,-0.00356809373286815,-0.00450456994766402,0.00226875180678837,-0.00245995324820392,0.000999235091493467,0.00444785464538208,0.00126846747451803,0.00293984394896607,-0.00507799243832130,0.00209196128618316,0.00676253790350168,0.00171123307808563,-0.00487268148925241,-0.000642393921889251,-0.00158102885169398,0.00121122796269710,0.00130297027140180,0.00128228003386288,-0.00115037574171029,-0.00189506458458821,-0.00186444409624253,0.00269913311160364,-0.00585972602836188,-0.000655550150636008,0.000855010950162827,-0.00206424318863945,0.00150912518220259,-0.000225532536012873,-0.00296716920239970,0.000510276300791479,-0.000848068736314267,-0.00129613111751525,-0.00224939991666723,0.000194307680056238,-0.00583797324109825,-0.00125963992503088,-0.00171885008220130,-0.00288367626845298,0.00206401417312763,-0.00232196959754571,0.00170963194226803,0.00308587982919206,-0.000496067808032685,0.000878478589095733,0.00202233128091867,-0.000256074967990944,0.00171038157267678,-0.00399258060268093,0.00351146850466960,-0.00312927195335422,-0.00578328701884601,0.00437816871299201,-0.000198359539490656,0.00141961322901440,-0.00114872415235145,-0.00322736806443707,-0.00971764300774092,0.00198046808345664,-0.000906576094889644,-0.000624053065727326,0.00128263680874552,-0.00448837392874357,-0.00230670838038916,0.00362816920233389,0.00189061397236590,-0.00405176710202071,-0.00696733329246169,-0.00180643947552883,0.000676716283999734,0.00298005752364017,0.000296386025324225,-0.00354906128473320,0.000968156030144163,-0.00370724836190017,-0.00303884309604396,-0.00206729163789880,-0.00388768407178286,-0.000856866977167581,-0.00284589199322521,-0.000903418890758068,-0.00146230531929037,-0.00129585463004012,-0.00159233008054410,0.00390002790766475,0.00192995455541833,0.000186802556261012,-0.00463889287429031,-0.00514124134915361,-0.00621309267095249,0.00823835232335413,0.00307491914277946,0.000812645179584237,-0.00308081884022504,-0.00362512248790448,0.00173178817084430,0.00494923012231346,-0.00535482283118249,-0.00142111923162469,-0.000266554938597452,-0.00629924817385330,0.00266025237742018,-0.00131126663125913,0.00604684674736006,-0.00123613032833103,0.00129394735858068,-0.00361267507439753,-0.00197599275834448,-0.00369582615921316,0.00124143204198152,0.00411677798172949,-0.00187726008161093,0.00137994015218412,-0.00159493420479390,0.000322892940710307,0.00378287636120689,0.000380367663082582,-0.00327878671166892,-0.00271039842479270,-0.000537189716715181,-0.000606108320153287,-0.00273794808926997,0.000571310153633320,0.00400511470427051,-0.000794267026586804,-0.000646907301151578,-0.00696182354182981,-0.00244922548869253,-0.00440591476708263,-0.00122138120838849,0.00166204997346719,0.00481700039998856,0.00568733882720629,-0.000369620506263713,-0.00101254924865957,0.00258521347930496,0.00155001945274433,0.00241993664773543,0.00246113443836515,-0.00468113598013342,0.00170878087783410,-0.000289471803887720,-0.00240412910774601,-0.00219334137504729,0.00405232522369692,-0.00256061515712269,-0.00391116304681795,0.000678898158868013,0.00635861864016885,8.08102138979971e-05,0.000974928419886001,-0.00296699819388357,0.00529433570260873,0.000395247309935343,0.00167632736121748,-0.00301070407381876,0.00270072052488586,0.00123058686281530,-0.00365559640607316,0.000125669315790333,-0.00142491789820753,0.000345472325348761,-0.000792317656359121,-0.000600521760124539,-0.00326635933115960,-0.00102233882081748,0.00242397074665680,0.00551714102036238,-0.00366988623670694,0.00751803638981397,0.00482588224851144,0.000532867503508561,-0.000952498678777185,-0.00220933879243231,0.00263345178782841,-0.00219653467806435,-0.00146060227079975,0.00279424273159422,0.00137857654833672,0.00283576415300203,0.00159610281634161,-0.00126774805566724,-0.00162493008938327,0.00251833545885246,-0.00212248966136505,0.00375254538149315,0.00250041917780707,0.000909855254956797,1.02018700119934e-05,0.00115618306411921,0.0111523344795443,-0.000355555946045665,-0.00492238222640890,0.00605608520586014,0.00192850255029737,-0.00204887645146614,0.00827673972155679,0.00174225820738359,0.000930353738865019,-0.00245975806631721,-0.00336760465250650,-0.00559221618830554,-0.00133738900042038,-0.00333020228569715,0.00204838194043099,-0.00100442852477603,0.00559404252026491,0.00477688096216171,0.000518646161193544,-0.000894177377486050,0.00364346819528503,-0.00362557547225520,0.00213042233775862,-0.00211592107739555,-0.00126593153307527,-0.00212442580764172,0.00182029877968559,-0.00246054774133712,-0.00336327583210399,0.00174867092871773,-0.00133899955456138,0.00114343901360263,-0.00111277148865976,0.000852362559329186,-0.00810950090949490,0.00147319172489749,0.00586147436020894,0.00328652146184998,0.00288050790394540,-0.000758096892062805,0.000572366184261010,0.000772384885394098,0.000304821065379139,-0.00262617197749499,-0.00111391921746526,-0.000552687203105348,-0.00151995957070835,0.00264631003772490,0.00802696541597762,-0.00418475034039212,0.000405847547670668,-0.00456120337416651,0.00411889261342656,0.00445853163932465,-0.00525742249423334,0.00614647000443551,-0.00343011768353023,0.000717264577612525,0.00347511926712415,0.000465451703771071,0.00725953271570279,0.00870435228464071,0.000437399051189540,-0.00603067286720033,-0.00115420918906293,-0.00268195934296820,-0.00241836248016380,-0.00356608411949787,0.000247254996195312,0.00666174789848659,-0.00226370821939686,-0.000887068410452435,0.00368871784792581,0.00383527807833193,0.00153541541646950,0.00324454901326202,0.00275347744460022,-0.00120722441080199,0.00135627883820980,-0.000945933760942991,-0.00284563411788330,0.00200724139202651,0.000213306983375309,-0.000591727118710457,0.000922523213811848,0.00312336485929921,0.00124256821223166,0.000615225463837640,0.000884757717535303,0.000161972847892563,-0.00244907730176413,0.00248802222623614,0.00445535497638268,-0.00168896801985261,0.00609610741679478,-0.000557343681352226,-0.000770806325948875,-0.00283846251079093,-0.00250558916785587,-0.00301357057590773,0.00111914731174359,0.00505024066680508,0.00166800739158957,0.00270122485419688,0.00424329128004053,-0.00790421876425806,-0.000529869101250211,0.00111633244282650,0.00226815543279002,-0.00412630318699508,-0.00318083691515725,0.00250036067264636,-0.000368630908434087,0.00174902379650255,-0.00303782560532018,-0.00516653681734514,0.00240712664626136,0.00377356854754973,0.00516101807402325,-0.00484520895260088,-0.00422749849438919,-0.00466071185516981,-0.000131750209101611,-0.00194640509554633,0.00415572239379469,-0.00460132454784112,-0.00550979201650762,0.000649230413502844,0.00377237714939360,-0.00253874954884004,-0.00400229378393857,-0.000472227202135134,-0.00517489877269906,5.48476380241025e-05,0.00261959054521155,0.000688549114848724,-0.00603756249905350,-0.00169757965294837,-0.000955109990026237,0.00573505025743931,0.00289301526037522,-0.000180505072762793,0.00414056644779159,-0.00330374483420282,-0.00110131635410127,0.00446691060219573,0.00475095197207572,0.00230965169104858,0.00155189494611685,-0.00185349359722320,0.00235557952360388,-0.00261885596017386,0.00181679407499857,0.000891260708050068,0.00360280276264491,-0.00134671237423545,0.00201165096732554,0.00250824932731342,-0.00284091787832730,0.000494089580575396,0.00505096036124963,0.000355565584926332,-0.000975957735888988,0.00144408448020605,-0.000869945210797862,0.00140134313430340,-0.000426164749605429,-5.79589514531076e-05,0.00145714410474218,0.00430801975899159,0.00142895284962630,0.00521264681406375,-0.00641424371554000,-0.00142067477851071,0.000746276029725324,-0.00264104880574845,-0.00403492450862230,0.00195123625307381,0.00193753227752513,0.000915103562662722,0.00125009934247022,-0.00275296142720960,-0.00157382884012069,-0.000337325904046226,-0.00217510670897647,0.00104949948311539,0.00747949736479805,-0.00152494742806386,0.00204741100016592,-0.00327113817443558,0.00423604357952800,-0.00306469089680506,0.000660016683231679,-0.00195616394838527,0.00161913563184457,3.59050416218754e-05,-0.000139104250144684,0.00932584946117143,-0.00199238100266563,-0.000148245677881742,0.00848447163437527,-0.00362615434002711,0.00174873557888910,-0.00340406037917362,0.00325916853244290,0.00103574020903263,0.00206219972232042,-0.000881836278642800,0.000775363899294557,0.00465649647837430,-0.00719450278197986,-0.00516491877197867,0.00131382813790182,-0.00207056091280472,-0.000937135657438803,-0.00473367312207440,-0.00286133775893519,-0.00127813427050449,-0.00229517532628776,-0.00274006623856515,-0.00133399664980560,-0.00298097265826558,0.00424340890162851,-0.00312570500922501,0.00574883954860142,-0.00118407251590939,-0.00459080724695150,-0.00195644365882319,0.00295515151647312,0.00333914149852512,0.000506683137811862,0.000908839612230166,0.00200142316727349,-0.00461389550785343,-0.00183952766954754,-0.00578744031606003,-0.00142018863652064,0.00300187018856139,0.00226874894156697,0.00723474929000679,0.000527239165142831,-0.00681942252845980,0.00534234968897928,0.00405492776059484,-0.00184244088267767,0.000703968798937615,0.00246484197981810,0.00121655085014018,0.00220210556351409,-0.000356437894728676,-0.000122771322129836,0.000278560703958632,-0.00249711144332058,0.00449979657612787,2.00225432743274e-05,0.00217084304923870,-0.00270353753061283,-0.00340019262388500,-0.000287663706256545,-0.000799334720422774,0.00377836466950379,0.00191654172876137,0.00170925670433795,-0.00456929964567994,-0.00306011650999594,0.000638942433052363,-0.00110008674275168,0.00407961643091986,0.00424110076029348,-0.00183664355826843,0.00276742176379632,0.00441280000333200,0.00101504439662646,0.00513358608217026,0.00335970911881327,0.000677060211161813,0.00277269517794113,0.000614768948785874,-0.00131200420821233,0.00113354604787010,0.000114546133947624,-0.00115306499704931,0.00560045561250300,0.000699726878833684,0.00863421204045267,-0.000936557175473918,0.00178445921761641,0.00500468596727510,0.00863058344808676,0.000959954543728714,-0.00249901673262876,0.00254051136187661,-0.00417389882926478,-0.000865976327998896,0.000859718692722611,0.00471038178129735,0.00454464053834318,-8.71567886262525e-05,0.00292172735735463,-0.00101597789470737,0.00209066045805484,0.00605669123449837,0.000495717412141494,-0.000950379727022499,-0.00158124880610011,0.00226568144093109,0.00422887826672074,0.00672199020861364,0.000170907776753326,0.000515564841398142,-0.00200079439082623,0.00509756468579514,-0.000238589814985035,-0.00149650724631867,0.00690717584470713,0.00256106892975938,0.00226527484698837,-0.00317989513422445,0.00137238617183644,0.00164483846303753,-0.00345398043663081,-0.000714024750725129,-0.00128047508809714,0.00166923740463654,-0.00318429616981064,0.00344380502800745,0.00564426942675979,-0.000960556133149382,-2.75011634913724e-05,0.00160212062627096,0.00380501688337254,0.00165076500483807,0.00125556998772813,-0.00152678193442807,-0.000732058406515135,0.00193969435403973,0.00532164065644523,0.00179741830073599,-0.00381379936822079,0.00136945719352227,-0.000291311385018700,-0.000771769478181805,-0.000693135412514566,-0.00278206663339548,-0.00101447235051460,-0.00248053895973785,-0.00115411284890030,0.000370842111275275,0.000551310503082757,-0.000681965457238477,-0.000482599872702174,0.000106531505085299,0.00144921558050469,0.00405287377836568,0.00196089691733535,-0.000906542351012915,0.00189109173360627,-0.000776442494110514,-0.00563118538753561,-0.00742262217676353,-0.00541886413203556,-0.000749862239973189,-0.00195942887190661,-0.00227734708032863,0.000128569271902637,-0.00208388225007565,-0.00199386360271383,0.00192780380692061,0.00247396039997701,0.00770515628265882,0.000956296217586426,0.000184423571096324,-0.00181557100322159,-0.000617315814831745,-0.000159793930058844,-0.00555224818757724,-0.000813836263727241,0.00237025955946960,-0.00180491522357136,0.00156290316368614,0.00313520995108463,0.00340621611758413,0.00245658946395501,-0.00714624265919352,-0.00178471580228150,0.00285076622602748,0.00124807361649349,1.53510356793083e-05,0.00138165801672489,0.00357360371681119,0.000486265779338827,-0.00239898971016650,-0.000569725737219686,-0.000657088366164899,0.00283575759089445,0.00130383143527813,0.00173140927542811,0.000467495455604896,-0.00114558933241891,0.000193345751357412,0.000685283121245090,-0.00442125127318298,0.000565637784560438,0.00293327885115633,-0.000348413224736227,0.00497235868494002,0.00177242694737404,-0.00132924635594809,-0.000486818066626068,-0.000870254364086758,0.000762489827557533,0.00238652792337171,-0.000923100154871849,0.00144973158350931,0.00555071002731297,0.00294563188828891,0.00260971530686494,-0.00257664639702728,-0.00168930194117186,0.000767015692889537,-0.000318276760892335,-0.00513885440847626,-0.00478902650256677,0.00324509579116956,-0.00239740958078470,0.00657230329673892,-0.00702653860284990,0.00141911522877579,1.97995076457207e-06,-0.00239143867295451,0.00127858736513716,-0.00251038321296399,0.00271887319245452,0.000211459010887323,-0.00518419813145241,-0.00766773248255215,-0.000897549035234594,0.00362335766210876,0.000572907597039570,0.000171554285785675,0.00217486801661226,-0.00440634078258119,0.00450740222511364,-0.00282660554801274,0.000119422467008095,-0.00114970703796389,0.000472939123418396,-0.00614910616691024,0.00481897878143749,0.00172600330115985,0.00635594881448419,0.00447990598264744,3.63050522069860e-05,-0.00296953468984925,-0.00549891114849753,5.36669242641970e-05,0.000693041905661998,0.00330717515197698,-0.00300727120185669,0.00251337013467490,0.000225880892077025,-0.00244661280702085,0.00244811470335875,0.000840073979982800,-0.000743468968220641,0.00593651926459628,0.00192658415203416,-0.000348716624071801,0.000877397564018041,0.000275263350744856,0.000548949428521039,0.00143438117115540,-0.00190849158690309,-0.00252041096212091,0.00114047195170867,0.00596118329862635,-0.000970255820725316,-0.00320251435758637,-0.000754347130822026,-0.00153058922490565,-0.00103515426811343,0.00150371989776125,-0.000411111562972092,-0.00187951010483383,-0.00140331418614706,-0.00418220595996748,-0.00271804458238584,-0.00446830204151279,-0.00163169068567635,-0.00343138147035432,-0.00223623181375940,-0.000953915431128678,-0.00379612618752941,-6.12288619896560e-05,0.00107634623131494,-0.00304600381659007,0.00352253250880335,-0.00501570575538787,-0.00123896349760940,-0.00469499007528971,-0.00108980679499702,-0.00418658969263144,-0.00181778772330951,-0.00234232033745517,-0.00374730495495291,-0.00652966076473737,0.00178687602094601,0.00632500552303339,0.00703077958092867,-0.00155640218467506,-0.000145474052056987,-0.00147282135184249,0.000240166867958138,-0.00290540472056683,-0.00606988612670097,-0.000115243337007821,-0.00387418768714384,-0.00601602554309850,0.00750803315199269,-0.000737903937712463,0.00127718303923652,0.00377091681213931,-0.00532767526951228,0.00130649036659208,0.00158665769805388,0.000262672523069329,0.000499001254573470,-0.00166950081882244,0.00228651869801433,-0.00268775149880018,-0.00251838749286426,0.00229371879725881,0.00533332192243929,-0.00122188565022047,-0.00159719818412651,0.00129044296067127,0.00339108787115264,0.00306103067210184,0.000854275183218123,-0.00200616961495731,0.00199148603634902,-0.000250559130052341,0.00435429558560330,-0.00445315889768599,0.000446613797032147,0.00407845083050584,-0.00156512600045674,-0.00197586998832155,-0.00295241087077847,-0.000881405568261662,-0.000634115599393637,0.000432413525853992,-0.00279339436173376,0.000261007829147619,-0.00190962009965401,-0.00116602115242292,-0.00265052760271708,-0.000893264513000425,0.0112889131205647,0.0107755634785245,0.00362687272617324,0.00248952690944981,-0.00404182524921881,-0.00184864570447019,-0.00195873269458713,0.00169277053873873,0.00152733916751477,0.000343028333174900,-0.00107607478607519,-0.00292778977492603,1.68286607525880e-05,0.00360230698682584,0.00135143492592349,0.000572473921535810,0.00207913348973066,0.00184754682767008,-0.00511166782044554,5.93697141065830e-05,-0.00134700619006845,-0.00643215898080274,-0.00420125205503186,-0.00101156714633377,0.00261024031808432,-0.000725087528388568,0.000829309888243590,-0.00283966065356511,-0.00682199015359385,0.000296990860960578,-0.00300789989706629,0.00370805494156673,0.00548685489647172,-0.00117540610058597,0.00377216758575349,0.00301569984895994,-0.00447476372117628,-0.000105481939387531,0.000825726870314248,0.00165385393232387,0.00214018791356607,0.00213262632212358,0.00214528587398688,-0.000988463863882627,0.00119927408783005,-0.00712428975880758,-0.00369464930723695,0.00380094903376149,-0.00208943888599350,0.00103583263471863,0.00476911657107704,-0.00281097693936805,-0.00303352435678439,-0.00155811524857841,0.00139474336719403,-0.000647521408011720,-0.00309209700666735,-0.00497409385415770,-0.00117086987705693,-0.000699323367461480,-0.00169249155087925,-0.000828428750438925,-0.00346400612589326,0.00173682879509784,-0.00687675403614174,0.000457311681632655,0.00211566948636222,-0.00268423348920199,-0.000180534808540188,0.000922709185310011,-0.00194359447898684,-4.31435504190669e-05,0.00130321730232463,-0.00296352722964777,0.00264099843896370,0.00346123452312969,0.00101566265674402,4.77909917095953e-05,-0.00368244874852185,0.00156482384091472,-0.00384485208284813,0.00503051328096815,0.00166486028480972,0.000837429916731303,-0.00124466581646865,-0.00688209661583095,-0.00378099129967580,0.00115526981401248,0.00762881478611897,0.00234086724863991,0.000979504085010907,-0.00171391396125681,0.000386693381415393,0.00304299443686051,-0.000803138973285877,0.00598225770333810,-0.00385878239788295,-0.00118976631536094,0.000165795525919857,-0.00617888089088448,0.00178801684077956,0.000246007690533234,0.000255199562779751,0.00251308675214545,0.00330043420799153,0.00253673059178750,-0.00148255281546228,-0.000147338024467203,0.00111771663581118,-0.00397435234424470,-0.00327621907123854,-0.00135017456924008,0.000245609929862667,0.00566341874883070,0.00252116740237307,-0.00139931020731793,-0.00198936070490829,0.00485028968406409,0.00864421368099502,0.000529488854170146,-0.00151430461541824,-0.00446720381633592,0.00308318294547560,0.000916171871520932,0.00368534447740465,-0.00287357947015476,0.000760765065824898,-0.00206827611449145,0.00403176025421762,-0.00174301775545727,-0.000276411111468144,-0.00109990442218544,0.00314318551680459,0.00135483413876125,-0.00317551267812610,-0.00200073473823104,-0.00330682534426552,0.00159918597860198,0.00104972983738272,-0.00517162848565622,-0.00602995818278229,-0.000127751973052093,0.00220471889115925,0.000533800613446767,-0.00488191263270987,-0.00490723004399013,0.00274194076801348,-0.000459709760007754,-0.00122140338491480,0.00416220286074664,-0.00251864103088117,0.000428303224576376,0.00132121994052337,0.00259268708845772,-0.00270170260468061,0.00112994058898069,0.00869141438936416,-0.00478445334698296,0.00137236220032144,-0.000726589370560804,-0.00261547677080021,-0.00263096003830710,0.00157449646770358,0.00732265269590915,-0.00251029728240326,0.00171066436099471,-0.00176790724025744,0.00625045069009356,0.00172236733715670,-0.000436095664574254,0.00196021887501696,-1.76543113694083e-05,0.00350127143916024,-0.000586887453859042,-0.00354623449622127,0.000779341800068223,0.00493643315970571,-0.00378405011563410,-0.000766363058642041,0.00317754565356221,-0.00607197093826717,0.00197783321603551,0.00238106990814491,0.000675094683214361,-0.00243569400173282,-2.25617523046950e-05,0.000294681665532370,0.00295752399977722,0.00209822790132943,-0.00110753293787791,0.00512250223868294,-0.000160748365400976,-0.00256997379136947,-0.00138640556526459,0.00271516320483312,0.000617326990913047,0.00281082893219242,0.000218898618268626,0.00786401950600673,-0.00526722602148988,-0.00131527964824529,-0.000266341591479369,0.000282239439729493,0.00460474176197989,0.000693972959434519,-0.000363273767406025,0.000216940056678827,0.00237643539792798,-0.00218015978358607,0.00142559772724205,-0.00494904251315298,-0.000249174589110057,-0.00297820770428769,-0.00206452935502655,0.000893435903733808,-0.00355781232355623,-0.00312741066225830,-0.00479356629603567,-0.00704716889646715,-0.000479153618329731,0.00367692053184365,-0.000575333053283056,-0.000739826054105830,-0.00331006376532927,0.00500689391614884,-0.000788714491033404,0.00409204740195446,0.00114468170357007,-0.000831845071724813,0.00342204122537093,0.00310672934438205,-0.000352416758631235,0.00409815621763088,0.00563294945266990,-0.000207492455724267,-0.000808533888691676,0.00127957820445757,0.00111235252285968,0.00255357418603554,-0.000808248103976283,0.00226138674599374,0.00331595585698113,0.000561457829123979,0.000484769844087074,-0.00396652227638217,-0.00370872195405636,-0.00462148480345648,-0.00393478410444248,-0.000490467289727193,-0.00510680587553347,0.00710268164644734,0.00233781220928703,-0.00653846873940600,-0.00365100951110930,-0.000338970481553735,-0.00541659926989985,-0.00145431423659959,0.00345004525413761,-0.000518234874884455,-0.000212633036912879,-0.00316731344815335,-0.00175715578089070,-0.00427399642841619,0.00115173732946472,-0.00143000600698185,0.00247722070630682,0.00391248581193176,0.00340639974472103,-0.000110177306827268,-0.00159374788719806,-0.00387068785966003,0.000374758625025951,0.00303412161689902,-0.00107811670963744,-0.000548080686168870,0.00194891332737057,0.00273195292263392,-0.00448067601660509,0.000632303611835240,0.000619258881933145,-0.000477922621538986,0.00282323141411587,-0.00115167049582937,-0.00261263803291824,0.000872824384605364,0.00145400673307163,-0.000687816484696880,0.00251756187465529,-0.00480040885405673,-0.00339918611804860,-0.00971504106887448,0.00164883430444231,-0.00313389187470270,-0.000800453864920431,0.00319157699234173,0.000161314275908632,-0.00139277077581904,-0.00268309586470392,-0.000760119335128295,0.00190663028663153,-0.00479481504778935,-0.000216136941870522,0.00247414347912787,-0.00449272984776169,0.00211671839969733,0.00216058395608449,-0.00278955967193586,-0.00475767442698184,0.00136970704470935,0.00255592898630691,0.00183076265918755,0.00241234074861903,-0.00373821391092663,0.00184628850735746,-0.00183415165970304,-0.00177519892153448,-0.00492017668611660,0.00347916462287074,0.000553582957329112,0.00317369762615859,0.00477822739385418,-0.00359626557983912,0.00203340269977158,-4.03508022611553e-05,0.00289114310398886,0.00350283781208210,0.00259455857340052,-0.00258551563182918,-0.000399981389042468,0.000835293210067478,0.00998814276404236,0.00387890425930021,0.00733849323411373,0.00131075732488639,0.000669870231347791,0.00193900396358571,-0.00166897729274063,0.00392628789998917,-0.000498471986815131,-0.00434371023738778,0.00275383204228674,-0.00496013782059118,-0.00583203973245461,0.000912031898199439,-0.00300704501534055,-0.00287998775546955,-0.000512128243330690,-0.00154604313174989,-0.000704498566781928,0.000860349803766369,-0.00369521914077664,-0.00387136879961403,-0.00663913458982557,-0.00123405555108258,0.00210064336261873,-0.00222075378144621,0.00158533686217099,0.00170862208750189,0.00313302971149985,0.00312868831590618,-0.00217830708414601,-0.00270955842174508,0.000153022671820602,-0.00210245106317508,0.00459397344922741,0.00436345539648458,0.000300847772376267,-0.00135069437248969,0.00161531612570169,-0.00207531942133610,-0.000395337757728709,-0.00167748299584491,0.000333893511619499,0.00356815728371973,0.00234792172252230,0.00361639070763320,-0.00289258042257656,0.000568582810387519,-0.00310961884399642,0.00121693479228346,0.00102994634640130,0.00409929331914088,0.00347606883904517,0.00206567265416657,-0.00159718228931395,-0.00150522458220207,-0.00648760685272024,-0.00141766342527800,-0.00490531414872144,0.00294036728710268,0.00285218462382256,0.000437303310824263,-0.00119663040114385,0.000452408905100417,0.00507557791852691,0.00426627955946004,-0.00141809847060386,0.000532563357870031,-0.00354332166693127,0.00126722239672576,0.00233712129080922,0.00284619126260312,-0.00484213733489028,0.00159575104116445,-0.00273288666844307,-0.00119077131249458,0.00249190769985963,0.000943009038242000,-0.000517797152562924,0.00191865677444074,0.00516873865789156,-0.00197166027566182,-0.00426939159375187,-0.00367532868376641,-0.00298607302364863,-0.00212255536042400,0.00182362598049380,-0.00659578415277735,0.000746183317645404,-0.00246158444530397,0.00347712017589510,-0.00270553185892755,2.38993041577117e-05,-0.00296490653117472,-0.00215528095807024,-0.000822633109254589,-0.000723514469303841,-0.00165960440666038,0.00356805643276518,0.00173969305874569,0.00586649105505950,-0.000876895783135817,0.00337298265837838,-0.00663837612184438,0.00201906296041176,0.00117467691511100,-0.00118325884101587,0.00219888447782356,0.00277530576117898,0.00326854805194946,0.00132749671433753,0.00190074779154355,-0.00213143305601191,-0.00346325836816003,-0.000846278393123678,0.000589924073559622,0.00300715109178440,-0.00249983974163248,-0.00154786528740931,0.00940611227175925,-0.00196878776558274,0.00607253124638774,0.00303941977916056,-0.00176392848626206,-0.000336956975371838,-0.000680399603150084,0.00149730587564290,0.00431853589453546,-0.00517919010306618,0.00639959257992306,0.00245958568213445,-0.00173578028945309,-0.000398482909023667,0.000947356429428670,0.000936575518778016,0.00379720899487512,0.00344742917570595,-0.00113431919614193,-0.000410867243337982,0.00232028177986354,0.000380521836625958,0.00359339503612005,-0.00217176729092994,0.00149159218174932,0.000911818936989217,0.00440143145106586,-0.00425485094844413,2.36350590321344e-06,0.000169165434925531,-0.00740575447693914,0.00394682339338826,0.00888357113276228,-0.000734233001422391,0.000907675345871217,-0.00146920839920373,0.00121531951970277,-0.00120112009181728,-0.000321851015258612,0.00511704320618376,-0.00267917613093072,-0.00182110250458578,-0.000240058389953335,-0.000418911956550527,0.00455149680328892,0.00642341733811125,-0.00309334509860260,-0.00202709482493146,0.00164588858237180,-0.00120387909306396,0.00630195117381716,0.00517307594065708,0.00176777295166336,0.00178237854160157,-0.00107010407589025,0.00241486502341067,0.00356528574400157,0.000447687339559917,0.00609729539963131,0.00212074327944253,-0.000348202304896717,0.00117308566127669,0.00346773690103464,-0.00125910229885974,-0.000270256316720628,0.00750499376144803,-0.00149866985402548,0.00299259255548059,0.00258725407377233,0.00502476713051892,0.00166339598776424,-0.00779563914868503,-0.00269593006744110,0.00161824946368951,0.000815155843591173,0.00620580355646940,0.00444715821965601,0.00157112621128319,0.000261933236663077,-0.00489671695968025,0.00589182808517527,0.000423829392045768,-0.00488888940177345,0.00137015924202102,0.000325569829886421,-0.00180359273020407,0.00155919944318709,-0.00223735322935022,-0.00426282945659830,-0.00554758854047873,-0.00115046492985060,-0.00198304536481699,0.00139187731127511,-0.00475176847319960,-0.000658498293723150,-0.00475962461659071,0.00572290297423944,-0.000369899737854280,0.00387761328050105,0.00156514764879226,0.00287322921007934,-0.00364996043613426,0.00397673971919463,0.00459331081212492,-0.00656745456391239,-0.000558104072547380,-0.00206206494669739,0.000495003350478419,-0.00268865003543704,0.000882420674891987,0.00188817616500605,0.000773862178165975,-0.000374244528131606,-0.00407746573992020,0.000182032218277028,-0.00164733443186871,-0.00404463816662937,-0.000177806118065837,-0.000663067275253226,0.000607478466989403,0.00313803022893988,0.00182224414078813,0.00412925084980875,-0.00230626753953878,-0.00273402522007582,-0.000300166530606050,0.00437410646443504,0.00412260248348983,-0.000397853047949481,-0.00188748063610658,-0.00480870590450266,0.00212454968494991,7.22399881068481e-05,-0.00372449453471213,-0.00105802905391283,-0.00578524533645941,0.00135974649654674,-0.000550215638889906,0.00515844146083810,-0.00429888886277662,0.00306901159943540,0.000454228963814751,0.000261215490969469,0.00226629060308325,0.00377412735459048,-0.00338699517830776,0.00417073499245579,-0.00382636590213337,-0.00339664955833174,-0.00212682172193295,0.00232889790435498,-0.00338351279610061,0.00105846214499811,0.00130248712958758,0.000487370826020905,0.00175370652822693,-0.00370886371942969,0.00318626886770135,0.000358982645768613,0.00230862354890566,-0.00311013733204713,0.000164538229433298,0.00277521289053412,0.00320699555803117,-0.000266733095101834,-0.00586138149629634,-0.00346845162799819,0.000691361262418422,0.00251162591041432,0.00146452729551532,-0.00193730623954058,0.00709741538167086,0.000228783225681428,0.00273699683998230,-0.00131454764972649,-0.00352574386484100,0.00216695844442845,0.00328141082723340,0.00576233880845881,-0.00167280849414276,-0.00514808283124925,0.00511435934952561,0.000835273718188256,-0.00356434920265400,-0.00176826932713254,-0.00255779296905350,0.00367141791570173,0.00187240126509009,0.000767635516457487,0.000760456577575064,-0.00259781235909335,0.00314049629076631,0.00109539629894380,-0.000825776719912217,-0.000584113493304514,-0.000321714316425139,-0.00280507671733294,0.00234444023256919,0.00440254784841947,0.00782315961857866,0.00159353256369029,-0.00260091188130133,0.000635560479643780,-0.00318457971035806,-0.00193901872677880,-0.00208382520975224,-0.00263490248818818,0.00119590794208440,-0.00352702297479085,0.00211000242056888,0.00251506315743240,0.00328083731361023,-6.46091039380434e-05,0.00195730151613654,0.00570178745980347,0.000167579564438818,-0.000562537847561146,0.00560508200870961,-0.00793353361939540,-0.00144386178073599,0.00768552859083212,-0.00149086872363261,-0.00177191426991420,-0.00387843037697814,0.00250752922042903,-0.00667221749190716,-0.00252790934861611,0.00179293267014713,-4.56284683895695e-06,0.00197302303372540,0.000399841015314079,0.00215309301508738,-0.00407116658374706,0.000689644857160062,-0.00495392006030359,0.00247695495149900,-0.000982108284270754,0.00207231774687983,-0.00169962102455649,0.00103926169226933,0.00333326824745948,-0.00626035893081182,-0.00590519993898245,-0.00579441740396630,0.00268348388830268,0.00128131462067789,-0.00222136103166413,0.00474039974467273,0.000435745625585033,-0.00501796986359180,-0.00322282109403188,-0.00438049371335776,0.00301961602655822,-0.00190090935702007,-0.00370584411010537,-0.00182498303158492,-0.00264502556176085,0.00269732648979899,0.00150945372283079,0.000956020019224999,0.00131479975922089,0.000135898342659776,-0.00300053737218842,0.00171271603716993,-0.00259663554867971,-0.00338966138853227,-0.00339657598669267,0.00274976741690344,0.00310235697162982,-0.00556189417296570,-0.000468320538175491,0.000796709755594252,-0.00193020566657115,0.00240642945369277,0.000804576731054169,-0.000483302522300475,-0.00176268795820890,0.00214091781178822,0.00268571432268486,0.00148407961926077,-0.000758256327423478,0.00291241172592309,-0.00286781072335944,0.000456761302446095,0.00441583307427674,-0.000599880149660183,-0.00266844338640735,0.00614569072895336,-0.000780834471574306,0.00139652239089718,-0.00254124264400480,0.000909500883895066,0.00147684088477237,1.44250760120608e-05,0.00103118825620740,0.00380923766342944,-0.00444020412804641,0.000650049039158014,-0.00629671396191076,8.98369370789442e-05,0.00610482574970833,0.00297613584088800,-2.18970376608339e-05,-0.00106961400490778,0.00167052308636693,0.00334220997622292,4.66139225790090e-05,0.00510632348086192,-0.00257995991981532,-0.00631746904938180,-0.00236598897604365,-0.000630254652046778,-0.00117877086716855,-0.00267962288966008,0.00422871799011149,-0.00511124395655311,-0.00155526379332984,-0.00306520069131380,-0.00149926088559111,-0.00210659498242358,0.00151275357360470,-0.00329211487696093,-0.00259515190900054,0.000319799893876887,0.00342785376033952,-0.00586453005294996,0.00569131802832349,-0.00277766344379691,0.00204831073055970,0.00331901605438595,0.00418398862791593,-0.00163603269932479,7.68906222793901e-05,-0.000513449136989749,-0.00191526852210420,0.000859221716775333,0.00113413005030040,-0.00111411824210885,0.000418558844047465,0.00845460792667098,-2.39260313534216e-05,0.00224617510855632,-0.00146267789397174,-0.00166929649236431,-0.00109347471684725,0.00178528843575458,-0.00253468932882825,-0.00585953222421830,0.000168283823155344,-0.00138006609145021,0.000885461374227506,0.000267547306951038,0.00230567691367531,0.00284843139168831,-0.00419203636426180,-0.00482114157048383,0.00158883370486862,0.000968894760598553,-0.00296988615879054,0.00391300910105490,0.000104392839916764,0.000390757332215576,0.000866272380193773,0.00238488168759429,0.00482088440536440,-0.000828440100486797,-0.00547290179345223,0.00320485551523682,-0.00293375913864850,0.00393286238551665,-0.00186412693929761,0.00471647937046465,-0.00254872652350000,-0.00351834712924595,0.00302610861833183,-0.00431034758935341,0.00215219862346910,0.00138451986073360,-0.000453051762268127,-0.00108002060951969,0.00650736859695811,-0.00118438377547737,-0.000601475322197716,-0.00296853253095338,-0.00257239386227665,-0.00184556454001424,0.00540599388869870,-0.00123461586782436,-0.00218217828235568,-0.00141739831253536,0.00225905637287263,-0.00416070753323113,0.00198313419204865,-0.00420992394194062,-0.000413778187183913,-0.00577715294810858,0.00169473563900021,0.00219103061114420,-0.00217422323074607,0.00100426272000263,0.000514952694304521,0.00366544633455407,0.000405998689744294,0.00328705523362037,-0.000369262771499679,-0.00205009483597885,-0.000120107115722460,-0.000630320421520169,0.00278808493991874,-0.000177543141179905,-0.00266023088352908,-0.000489659209994221,0.00375866637340437,-0.00131205202016877,-0.00208272907470221,0.00311165170754257,0.000320109444637340,-0.00114697652482809,-0.00233637874729120,-0.00467967259443988,0.000485004057057536,-0.00100249726914903,0.00100850806499408,-0.00460600473605888,0.00418000771575011,0.00154067412766390,-0.00495410718950962,0.00334271605009295,-0.00185808413973365,0.000955708670807528,0.000694001008150869,-0.00277711572444772,-0.00904854053555337,0.00169357455017638,-0.00108161694404729,-0.00189059570026562,0.00132471829936653,-0.00218096193595152,0.00212249243557949,0.000477179668375428,-0.00313482556361722,0.00264628864912442,0.00150052911612453,0.00395969610936453,-0.00282272068295586,-0.00283110569525602,0.000990823580967359,0.00210934406447205,0.00261873447336514,2.05841451220666e-05,-0.000745956625213484,0.00206440156465604,0.00621239727398426,0.00279730077032092,0.000267329330820632,-0.00181677298137028,0.00158035025525494,-0.00153087279055086,0.000754031306775982,0.00246103686996763,0.00292280764443276,0.00185985538746858,0.00435741078198437,0.00585402400337742,-0.00600094290057895,-0.00562469324408754,-0.00291764777087161,-0.00631800018320083,-0.00112924953498128,-0.00106379260786009,0.000791916560463957,0.000904923387261780,-0.00216985553405169,-0.00257192623528568,0.00250895918737770,-0.00120781694397765,-0.00433612831483610,3.25950328631253e-05,0.000645522207993299,-0.00129977677640949,0.00209836469359548,0.000713985815598561,-0.000673069021776662,-0.000139249540187403,0.00144889814271509,-0.00139588431581594,-0.00333603445252551,-0.000492000628109168,0.000408401402820280,0.00161095381981865,-9.52589643653523e-05,-0.00144631496291725,0.00188577882732383,-0.000359008467594846,0.00255203528015979,-0.000283981197200078,-1.98974469930446e-05,-0.000290488949148737,-0.00291321123943955,-0.00293127812559965,-0.00303964665993617,0.00564412752665056,-0.000633053158923536,0.00297384276571144,0.00110412928489279,0.00587956055885197,0.00293165899009745,-0.00388000035313274,-0.00103482102351760,0.00281963349372846,0.000911322815704829,0.00716317691550117,-0.000151442522163647,-0.00490742507553754,0.00140431473689118,-0.00288342446425460,0.000156326081549973,0.00340908038657795,0.000974546808026666,0.000947540269712292,-0.000623659516132746,-0.000463028388642650,-0.000325938708916007,-0.00885115807852044,0.00124364530350707,0.00313143644887637,-0.00410347556451740,-0.00481288655075396,0.00196381018493741,-0.00476720499313608,-0.00531073586456843,0.00249496181397424,-0.00206902249216101,0.00393672897860153,-0.00408649889964496,-0.00194275310280589,0.000764307367438100,0.00173719453832699,0.00147878955555669,0.000605440203498274,-0.000726707077816746,-0.00183164447328221,0.00151941489268603,-0.00122327222159913,0.00133326540765222,0.00343962792695074,-0.00711301201275361,0.00570626723357748,-0.00199875041775510,0.00416300637916313,0.00490656490425967,-0.00464509528055979,0.000559528210680726,0.0109612762916180,-0.000678709295987678,0.00153776048683163,0.00104635062281455,0.00400945842580547,0.00344850871029001,-0.00299293962151764,-0.00138665604584309,0.00108535906441321,-0.000184687710007736,0.00801629382411695,0.00138711866856389,0.00138355250555455,-0.00264896408603937,-0.00413468631326674,0.00251129976796338,-0.000623802874524003,0.00205280144887698,-0.00262935251585528,0.00283325550847879,-0.00573474759433901,0.00495428808697507,0.00267687014085161,0.000348340177850404,-0.00367172542449801,-0.00125711827133090,0.000804149218911259,0.00381936555188500,-0.00326834555269528,0.00409561364771782,0.00875357362893559,-0.00156642522455153,0.00148236674573632,-0.00207855526235168,-0.00542949553070837,0.00465018971176645,0.00219505476809838,-0.00161496567207653,0.000358562389220496,-0.000726714009204932,-0.00462240510512757,-0.00911474718442717,-0.000150105754871767,-0.00146244574341795,-0.00182351443079929,-0.00267518684446497,-0.00574660326950409,-0.00164985706665513,0.000510505070698752,-0.00335774080891863,0.00142458628758464,-0.000862663252692618,-0.000320826826855729,-0.00451922981314858,-0.00241727489119560,0.00129696879081186,-0.00249798668538939,0.000511141483258375,0.00625468162482031,0.00251485325696358,0.00328044164570331,0.00746401871876665,0.00371692566562910,0.00125776566411748,0.00617039022648818,-0.00286077461065518,-0.00215715463622579,0.00638239836473572,0.00143675928298150,-0.000133145107241409,0.00144885223082276,-0.000835297100436910,-0.000923338108571106,-0.00122316312847354,-0.00175187947589382,-0.00298432974534984,-0.000189256570992238,-0.00181731281014565,0.00455954680258821,0.000744800915929583,0.00322987624798368,-0.000442182970533332,-0.000257887231366349,0.00397892559469733,0.00464391226770968,0.000104168133159688,0.00535208582919125,0.00150438579249531,0.00116539487679925,0.00693171492131512,0.00485626270015435,0.00286900871087519,0.00127205649087077,-0.00170251337429493,-0.000364343364775323,0.00576167007171021,-0.00639256534466560,-0.00201429959407585,-0.000597048217929272,0.000468886852702177,-0.00564112401144796,0.00167305848760860,0.00230761476345209,-0.00297296766580912,-0.000819937328280340,-0.00383756571681770,0.00513727711925937,0.00118114994453089,-0.000793389517475873,-0.00292654852281299,0.000311991355995134,0.00532616051166834,0.000870446650568568,0.00111719911204194,-0.00379592082713998,0.000525345000486177,0.00245443900672120,-0.00436848231402998,0.00356793154028268,0.00779640452224495,-0.00492656681618775,-0.00653531423331255,-0.000229577138000758,0.00240052114894218,-0.000258244712247779,-0.000501136546735892,2.05485956629698e-05,-0.00336658546795099,-0.00519851591198395,0.00500129968953739,0.000925327159093436,-0.00375554807625322,0.00340241070579583,-0.00410264923162573,-0.000385071277467453,0.00234252528868451,-0.00265858256601539,-0.00110512371550431,9.37044747716387e-05,0.00617394697832885,0.00145155986054812,-0.00126273519715858,-0.000712728822600317,-0.000886332488774289,0.00413222589223417,-0.000899273136098056,-0.00250360839533116,0.000760903734917773,-0.000299296880305833,0.00250842830090231,0.00303401418714144,0.00343772095728490,0.00204652716868270,0.00200029927199841,0.00601868819628104,-0.00366832284161001,-0.00109828832330440,-0.00536026509868592,0.00290735399556064,6.80876860576496e-05,-0.000946597250181980,-0.00544232995446115,0.000580062508211995,-0.000821345639507819,-0.00428421881969322,-0.00366015298115334,-0.00240961244290061,-0.000791516792870989,-0.00521384667174699,-0.000575504863351627,0.00194697397219508,-0.00119114863192417,-0.00220738133902148,0.000961719566440613,0.00348192043017277,-0.00141229840966605,-0.00147587371800649,-0.00454046355889962,-0.00309180980805826,0.00191600695646258,-0.000359407164580768,0.00241775591251869,0.00211840175792574,0.00118833236407034,0.00242436906736496,0.00481764098009760,0.00182407826190954,0.00134704495271324,-0.000135759649092143,-0.00392838056850159,-0.00159679739017050,0.00103043232072752,-0.00351462930236096,0.00148052882897144,0.00102019149126247,0.000316295557727557,0.000953219840932371,7.53369569096519e-05,-6.97431932500447e-05,-2.76950024419697e-05,0.00293919519736422,-0.000285972080105493,-0.00835203632103234,-0.00153734126014004,0.000619710357954776,0.00303490809595354,0.00436496894980746,-0.00297716943016982,0.00240607620886922,0.000752370517330569,-0.000658934735762414,7.82322170900923e-05,-8.88318693824446e-05,0.000443854535571105,0.000751313477833919,-0.00212362353253655,-0.00330458021302289,0.00305402227651014,-0.000694931135743456,0.00447315514229789,-0.00292253481586334,-0.00187883824178735,0.00449446760906469,0.00445124621547216,-0.00325398610136163,0.000653049015911233,0.00424096632245466,0.00421441984969495,-0.00406319381786324,0.00511775392568498,0.00209230130690574,0.000718932575509701,-0.000713334358844908,-0.00305473946666290,0.000300472859195100,-0.000811859452219732,0.00730527693557913,0.000601021613146346,-0.000548351576489803,-4.43630338109458e-05,-0.00193764868066804,0.00655160667977839,0.00201444703404008,0.000236835410564407,0.00355208275142682,-0.000104759737716509,-0.000309105385164049,-0.00176018665519939,-0.00194637875678827,0.00507404276926221,0.00243019594332550,0.000274907780472677,0.00538965683046555,7.47368127594350e-05,0.000917195929319825,-0.00449011553975409,0.00150294695159112,-0.00457682465994902,-0.00312521574439861,0.00300220165544041,0.00111066772842383,-0.00275839653071852,-0.00125898866041796,0.000810921464896086,0.000695781573853305,-0.00541205032091119,-0.00381293286247722,-0.00560644523036447,-0.000229238700591550,-0.00544264303241676,0.00221954333190444,-0.00317956897782312,-0.00349882882115926,0.00566224758184758,0.00683805910914570,-0.00259078299164484,-0.000117161089925501,0.00620756367196318,-0.00170847227516313,0.00543122387505723,0.00259246141424963,0.000175572292216986,-0.00111668035878965,0.00535420816575621,0.00224853881092268,-0.00200097526107212,0.00124190988130654,-0.00277635824705169,0.000471006803373863,0.00484422387937383,0.00168185029385270,-0.00240227834949458,0.00110042247424358,-0.00220664588949454,0.00638563399660019,-0.00567217596563052,-0.00208554599969912,0.00243954965648596,-0.00259414632203381,5.65673977522829e-05,0.00206982211506046,0.00397719271235975,-0.00293168434328939,-0.000537200348789790,-0.00149155937046341,-0.000361238011037601,0.00116842014514833,-0.00195623327556504,0.00253018618197309,0.00134933139397897,-0.00149364099537808,0.000872636150582085,0.00311239936816254,0.00314048146188872,0.00211306278049273,-0.000205543065030955,-0.00196092405771185,0.000708679917471700,-0.00147405207599283,-0.00105015092308369,0.00292452120308551,0.00457589647715362,0.00188418656272227,0.00649301161034721,-0.00483591419227447,7.17444122234623e-05,0.000301317026364087,0.00510558056134414,0.00158516495329175,-0.00102407266499627,0.00175258680500168,0.00203158458661690,0.000577511319694302,-0.00641144324760762,0.00323526600744695,-0.0110412246885689,0.000346236627312686,-0.00490574086814510,-0.00112295930654471,0.00442262707772734,-0.00162375038503737,0.00606265435597853,0.00246155033552631,-0.000779359489042009,-0.00285721796435379,-0.00156818063260455,0.00118425649609579,-0.00749628069995256,0.00194499684648886,0.000883745868828501,0.00258947877529092,0.00647478419697667,-0.00102376952931216,-0.00310074698779816,0.00373033078448026,0.00282891905557581,-0.000451986316240993,-0.00187671859685090,0.000787145295503056,-0.00357268546795198,0.000209009522946002,-0.00201729469357126,-0.00259087826755722,0.00306093779765437,9.59719958587568e-05,0.00427254235401264,-0.00343541706155792,0.000759784765574256,-0.00330831568641987,0.00195655698574254,0.00412688052136645,0.00323656298199282,-0.00668942666629924,0.00215581596741687,2.75411471111209e-05,0.00105706507855974,-0.00173107115192016,-0.00522087090515311,0.00282326023968582,-0.00160345043801724,-0.00104289118434442,0.000532381455207176,0.00802187632696305,0.00725308435212901,-0.00416997196061841,-0.00149934567736532,0.00312237601857032,-0.00655548517592508,0.00393395600788948,-0.000996875084438464,0.00442495615283767,-0.00278242928037908,-0.00291711403768058,0.00731878458265456,0.00185946101918966,-0.000979571271268909,-0.00326651944691938,0.00348910137711156,0.00108184342912288,-0.00715937519021898,-0.00285644055884937,0.00939205619934835,-3.72082948214558e-05,-0.00632309772790990,-0.00280815098096832,-0.00132784797095176,0.00219644961931159,-0.000514669211644336,0.000321213544725030,-5.64734136596634e-05,-0.00303682090900104,0.00370873709171060,-0.00115509364622979,-0.00146543312872199,0.000616611167429948,-0.000211703429762400,-0.00164922310029062,0.000401924734956816,0.00668195111564851,0.00171168111817666,-0.00207156152562482,-0.00274969126871627,-0.000755461465909546,-0.00498370949665189,0.00577353232141020,0.000645950484956970,-0.00367898052428889,0.000381401735098152,-0.00456480590662944,0.00184153989190072,-0.000573844191832817,0.000132846593975611,0.00114424470251273,0.00269968267827364,-0.00256072396289453,-0.00463922155586549,-0.000328548750511009,-0.00260228063544410,0.00134390923644145,-0.00586502695758923,0.00271505282286533,0.000968901796661870,-0.00351506689799452,-0.00100320324773451,0.00264955435255188,0.00767315704479277,-0.00111024229852566,0.00437014705051098,-0.00272163154121796,0.000654245123070496,-0.000656163879975580,0.00107598722106173,-0.00157516890878895,-0.00449484459845484,-0.000856263056794426,0.00139033683015344,-0.00160056714328187,-0.000582960297337398,0.00127123248862226,0.00170518942111503,-0.00231982544444531,-0.000848666746506965]; a=[1,1,1,1,0,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,0,0,0,0,1,1,1,0,1,0,1,1,1,1]; figure (2) subplot(611); t=0.001:0.001:3; for i=1:M m(1,60*(i-1)+1:(60*i))=a(i)*ones(1,60); end plot(t,m); axis([0 3 -1.2 1.2]); title(\u0026#39;information source\u0026#39;); f=150; carry=cos(2*pi*f*t); st=m.*carry; subplot(612); plot(t,st) axis([0 3 -1.2 1.2]) title(\u0026#39;2ASK signal\u0026#39;) subplot(613); anst=noise+st; plot(t,anst) axis([0 3 -1.2 1.2]) title(\u0026#39;2ASK signal and noise\u0026#39;) subplot(614) %%%%%%%%% begin %%%%%%%%% nst=anst.*carry; plot(t,nst); %%%%%%%%% end %%%%%%%%% axis([0 3 -1.2 1.2]); title(\u0026#39;signal multiply by carrier\u0026#39;) subplot(615) %%%%%%%%% begin %%%%%%%%%% N=10; wc=1010.5; [B,A]=butter(N,wc,\u0026#39;s\u0026#39;); h=tf(B,A); dst=lsim(h,nst,t); plot(t,dst); %%%%%%%%% end %%%%%%%%% axis([0 3 -1.2 1.2]); title(\u0026#39;after Low pass filtering signal\u0026#39;); subplot(616) pdst=zeros(1,3000); %%%%%%%%% begin %%%%%%%%% k=0.25; pdst=1*(dst\u0026gt;0.25); plot(t,pdst); %%%%%%%%% end %%%%%%%%% axis([0 3 -1.2 1.2]); title(\u0026#39;Sampling decision\u0026#39;) %%%%%%%%% begin %%%%%%%%% errornumber=0; err=0; for i=1:M if a(i)~=pdst(60*(i-1)+30); errornumber=errornumber+1; end end err=errornumber/M; %%%%%%%%% end %%%%%%%%% %%%%%%%%% test %%%%%%%%% sa=pwd; print(2,\u0026#39;-djpeg\u0026#39;,\u0026#39;./picture/step2/student2.jpg\u0026#39;) run(\u0026#39;./step2/f_t_2.m\u0026#39;); system(\u0026#39;python3 ./step2/test2.py\u0026#39;);   ","description":"一天只有84600秒，你还要等多久！","id":375,"section":"touge","tags":[""],"title":"2ASK数字带通传输系统仿真设计","uri":"https://www.zhugeqing.top/touge/5/"},{"content":"第一题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;using namespace std; class Student { private: int SID; string Name; public: Student(); ~Student(); Student(int sid, string name); }; Student::Student() { SID = 0; Name = \u0026#34;王小明\u0026#34;; } Student::Student(int sid, string name) : SID(sid), Name(name) { } Student::~Student() { cout \u0026lt;\u0026lt; SID \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; Name \u0026lt;\u0026lt; \u0026#34; 退出程序\u0026#34; \u0026lt;\u0026lt; endl; }   第二题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  #include \u0026lt;string\u0026gt;#include \u0026lt;iostream\u0026gt;using namespace std; class Student { public: int SID; string Name; float Score; Student(); Student(int sid, string name, float sco); ~Student(); }; //当前下标 int Real_size = 0; Student stu[10]; Student::Student() { } Student::Student(int sid, string name, float sco) { SID = sid; Name = name; Score = sco; } Student::~Student() { } void Add(int sid, string name, float sco) { stu[Real_size] = Student(sid, name, sco); Real_size++; } void PrintAll() { for (int i = 0; i \u0026lt; Real_size; i++) { cout \u0026lt;\u0026lt; stu[i].SID \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; stu[i].Name \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; stu[i].Score \u0026lt;\u0026lt; endl; } } void Average() { float avg = 0; for (int i = 0; i \u0026lt; Real_size; i++) { avg += float(stu[i].Score); } cout \u0026lt;\u0026lt; \u0026#34;平均成绩 \u0026#34; \u0026lt;\u0026lt; avg / Real_size \u0026lt;\u0026lt; endl; }   第三题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  #include \u0026lt;string\u0026gt;#include \u0026lt;iostream\u0026gt;using namespace std; class User { private: string Name; int Books; //已有用户数量  static int UserCount; //已有书籍数  static int BookCount; public: ~User(); User(string name, int books); static void GetState(); }; //初始化静态变量 int User::UserCount = 0; int User::BookCount = 0; User::User(string name, int books) { Name = name; Books = books; BookCount += books; UserCount++; cout \u0026lt;\u0026lt; Name \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; books \u0026lt;\u0026lt; \u0026#34; 进入\u0026#34; \u0026lt;\u0026lt; endl; } User::~User() { cout \u0026lt;\u0026lt; Name \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; Books \u0026lt;\u0026lt; \u0026#34; 离开\u0026#34; \u0026lt;\u0026lt; endl; //释放  BookCount -= Books; UserCount--; } void User::GetState() { if (UserCount == 0) { return; } cout \u0026lt;\u0026lt; \u0026#34;书店人数:\u0026#34; \u0026lt;\u0026lt; UserCount \u0026lt;\u0026lt; \u0026#34;，书店共享书数量:\u0026#34; \u0026lt;\u0026lt; BookCount \u0026lt;\u0026lt; \u0026#34;，人均共享数量:\u0026#34; \u0026lt;\u0026lt; BookCount / UserCount \u0026lt;\u0026lt; endl; }   ","description":"一天只有84600秒，你还要等多久！","id":376,"section":"touge","tags":[""],"title":"C++ 面向对象 - 构造函数与析构函数","uri":"https://www.zhugeqing.top/touge/2/"},{"content":"第一题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  #include \u0026lt;iostream\u0026gt;#include \u0026lt;string.h\u0026gt;using namespace std; class StInfo { public: int SID; char *Name; char *Class; char *Phone; void SetInfo(int sid, char *name, char *cla, char *phone); void PrintInfo(); }; void StInfo::SetInfo(int sid, char *name, char *cla, char *phone) { SID = sid; Name = name; Class = cla; Phone = phone; } //成员函数 void StInfo::PrintInfo() { printf(\u0026#34;学号：%d\\n\u0026#34;, SID); printf(\u0026#34;姓名：%s\\n\u0026#34;, Name); printf(\u0026#34;班级：%s\\n\u0026#34;, Class); printf(\u0026#34;手机号：%s\\n\u0026#34;, Phone); }   第二题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  class Rectangle { private: int height; int width; public: void Set(int h, int w) { height = h; width = w; } int GetArea() { return height * width; } }; /********* End *********/ Rectangle GetRect(int h, int w) { /********* Begin *********/ //返回一个 h*w 的 Rectangle 对象  Rectangle rect; rect.Set(h, w); return rect; /********* End *********/ } int GetRectArea(Rectangle rect) { /********* Begin *********/ //返回 rect 对象的面积  return rect.GetArea(); /********* End *********/ }   第三题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109  #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;using namespace std; /********* Begin *********/ //在此处实现一个汽车类 class Car { private: string car_door; string car_light; int car_rate; public: //构造函数  Car(); void open_door(); void close_door(); void open_light(); void close_light(); void add_rate(); void decrease_rate(); void print_status(); //加速，减速两个函数，每次调用就将内部的速度变量分别对应增加10或者减少10。  //车门，车灯两个函数的初始状态都为 OFF，速度的初始值为0。  //根据输入的命令（命令由1-6表示，分别对应调用打开车门、  //关闭车门、打开车灯、关闭车灯、加速、减速函数）输出汽车的最终状态。 }; Car::Car() { //构造函数初始化  car_door = \u0026#34;OFF\u0026#34;; car_light = \u0026#34;OFF\u0026#34;; car_rate = 0; } void Car::open_door() { car_door = \u0026#34;ON\u0026#34;; } void Car::close_door() { car_door = \u0026#34;OFF\u0026#34;; } void Car::open_light() { car_light = \u0026#34;ON\u0026#34;; } void Car::close_light() { car_light = \u0026#34;OFF\u0026#34;; } void Car::add_rate() { car_rate += 10; } void Car::decrease_rate() { car_rate -= 10; } void Car::print_status() { cout \u0026lt;\u0026lt; \u0026#34;车门 \u0026#34; \u0026lt;\u0026lt; car_door \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;车灯 \u0026#34; \u0026lt;\u0026lt; car_light \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;速度 \u0026#34; \u0026lt;\u0026lt; car_rate \u0026lt;\u0026lt; endl; } int main() { char cmds[25]; cin \u0026gt;\u0026gt; cmds; Car *car = new Car(); for (int i = 0; cmds[i] != \u0026#39;\\0\u0026#39;; i++) { switch (cmds[i]) { case \u0026#39;1\u0026#39;: car-\u0026gt;open_door(); break; case \u0026#39;2\u0026#39;: car-\u0026gt;close_door(); break; case \u0026#39;3\u0026#39;: car-\u0026gt;open_light(); break; case \u0026#39;4\u0026#39;: car-\u0026gt;close_light(); break; case \u0026#39;5\u0026#39;: car-\u0026gt;add_rate(); break; case \u0026#39;6\u0026#39;: car-\u0026gt;decrease_rate(); break; default: cout \u0026lt;\u0026lt; \u0026#34;www.zhugeqing.top\u0026#34; \u0026lt;\u0026lt; endl; break; } } //查看状态  car-\u0026gt;print_status(); }   ","description":"一天只有84600秒，你还要等多久！","id":377,"section":"touge","tags":[""],"title":"C++ 面向对象 - 类和对象的创建和使用","uri":"https://www.zhugeqing.top/touge/1/"},{"content":"第1关：典型随机信号 - 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  %%%%%%%%%%%%%%%%%% %请不要修改 %%%%%%%%%%%%%%%%% warning(\u0026#39;off\u0026#39;,\u0026#39;all\u0026#39;); graphics_toolkit(\u0026#39;gnuplot\u0026#39;) myFile = \u0026#39;./task1/huochemingdi.wav\u0026#39;; % 1.读取 \u0026#39;myFile\u0026#39;，请将数据命名为data %%%%%%%%% Begin %%%%%%%%% data = wavread(myFile) %%%%%%%%% End %%%%%%%%% %用于生成txt文件，请不要修改 save(\u0026#39;./picans/data.txt\u0026#39;,\u0026#39;data\u0026#39;); % 2.显示波形 %%%%%%%%% Begin %%%%%%%%% plot(data) %%%%%%%%%%End %%%%%%%%% %用于生成图像，请不要修改 sa=pwd; print(1,\u0026#39;-djpeg\u0026#39;,\u0026#39;./picture/step1/picture1.jpg\u0026#39;);   第2关：典型随机信号 - 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82  %%%%%%%%%%%%%%%%%% pkg load signal warning(\u0026#39;off\u0026#39;,\u0026#39;all\u0026#39;); graphics_toolkit(\u0026#39;gnuplot\u0026#39;) %请不要修改上述代码 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% t1 = -3*pi:0.0001:7*pi; sp = sprintf(\u0026#39;t1 is %d:\u0026#39;,t1); % 1.生成长度为t1的三角波 % 三角波命名为y1 %%%%%%%%% Begin %%%%%%%%% y1=sawtooth(t1) %%%%%%%%% End %%%%%%%%% plot(t1,y1); %用于生成图像，请不要修改 sa=pwd; print(\u0026#39;-djpeg\u0026#39;,\u0026#39;./picture/step2/picture1.jpg\u0026#39;); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% t2 = -3:0.001:3; w2 = 1.5; % 2.生成长度为t2.宽度为w2的矩形脉冲 % 矩形脉冲命名为y2 %%%%%%%%% Begin %%%%%%%%% y2 = rectpuls(t2,w2) %%%%%%%%% End %%%%%%%%% %用于生成图像，请不要修改 plot(t2,y2); sa=pwd; print(\u0026#39;-djpeg\u0026#39;,\u0026#39;./picture/step2/picture2.jpg\u0026#39;); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% t3 = 0:pi/180:4*pi; % 3.生成长度为t3的正弦波 % 正弦波冲命名为y3 %%%%%%%%% Begin %%%%%%%%% y3=sin(t3) %%%%%%%%% End %%%%%%%%% %用于生成图像，请不要修改 plot(t3,y3); sa=pwd; print(\u0026#39;-djpeg\u0026#39;,\u0026#39;./picture/step2/picture3.jpg\u0026#39;); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% t = -5:0.2:9; t4 = pi./2*t; duty = 20; % 4.生成长度为t4，占空比为20的方波 % 方波冲命名为y4 %%%%%%%%% Begin %%%%%%%%% y4 = square(t4,duty) %%%%%%%%% End %%%%%%%%% %用于生成图像，请不要修改 plot(t4,y4); sa=pwd; print(\u0026#39;-djpeg\u0026#39;,\u0026#39;./picture/step2/picture4.jpg\u0026#39;);   第3关：典型噪音生成 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66  %%%%%%%%%%%%%%%%%% %请不要修改 %%%%%%%%%%%%%%%%%% pkg load signal pkg load symbolic pkg load communications warning(\u0026#39;off\u0026#39;,\u0026#39;all\u0026#39;); graphics_toolkit(\u0026#39;gnuplot\u0026#39;) rand(\u0026#39;seed\u0026#39;,0) m1 = 1000; % 1.生成基于均值0，方差为sigma1，长度为m1的均匀分布白噪音; % 输出命名为y1 %%%%%%%%% Begin %%%%%%%%% y1 = rand(m1); %%%%%%%%% End %%%%%%%%% plot(y1); %用于生成图像，请不要修改 sa=pwd; print(1,\u0026#39;-djpeg\u0026#39;,\u0026#39;./picture/step3/picture1.jpg\u0026#39;); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% m2 = 1; n2 = 600; p2 = 8; img = 5; state = 50; % 2.生成长度m2*n2,强度为p2的高斯白噪音,负载阻抗的欧姆数为img,并固定状态种子参数为state % 输出命名为y2 %%%%%%%%% Begin %%%%%%%%% y2 = wgn(m2,n2,p2,img,state); %%%%%%%%% End %%%%%%%%% %用于生成图像，请不要修改 plot(y2); sa=pwd; print(1,\u0026#39;-djpeg\u0026#39;,\u0026#39;./picture/step3/picture2.jpg\u0026#39;); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% b3 = fir1(64, 0.8); rand(\u0026#39;seed\u0026#39;,0) n3 = rand(1,200); % 3.使用b3信号对n3信号进行100倍的窄带滤通 % 输出命名为y3 %%%%%%%%% Begin %%%%%%%%% y3 = filter(b3,100,n3); %%%%%%%%% End %%%%%%%%% %用于生成图像，请不要修改 plot(y3); sa=pwd; print(1,\u0026#39;-djpeg\u0026#39;,\u0026#39;./picture/step3/picture3.jpg\u0026#39;);   第4关：混合信号产生 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  %%%%%%%%%%%%%%%%%% %请不要修改 %%%%%%%%%%%%%%%%%% warning(\u0026#39;off\u0026#39;,\u0026#39;all\u0026#39;); graphics_toolkit(\u0026#39;gnuplot\u0026#39;) pkg load signal pkg load symbolic pkg load communications m1 = 1; n1 = 500; p1 = 2; state = 50; y1 = wgn(m1,n1,p1,[],state); m2 = 1; n2 = 500; p2 = 8; y2 = wgn(m2,n2,p2,[],state); A1 = 3; A2 = 4; % 1.对信号y1进行幅度操作A1，信号y2进行幅度操作A2，然后相加。 % 新信号命名为yf %%%%%%%%% Begin %%%%%%%%% yf = A1*y1 + A2*y2; %%%%%%%%% End %%%%%%%%% plot(yf); %用于生成图像，请不要修改 sa=pwd; print(1,\u0026#39;-djpeg\u0026#39;,\u0026#39;./picture/step4/picture1.jpg\u0026#39;); filename = \u0026#39;./picture/step4/newData.txt\u0026#39;; % 2.保存新信号yf为txt文件filename； %%%%%%%%% Begin %%%%%%%%% save(filename,\u0026#39;y2\u0026#39;); %%%%%%%%% End %%%%%%%%%   ","description":"一天只有84600秒，你还要等多久！","id":378,"section":"touge","tags":[""],"title":"Matlab典型随机信号模拟","uri":"https://www.zhugeqing.top/touge/6/"},{"content":"早日放假早回家,祝大家愉快\n第1关：循环结构 1 2 3 4 5 6 7 8 9  x=[]; %定义一个空矩阵，用于存放获得的整数 % ********** Begin ********** %  for i=1:1000 if rem(i,13)==2 x=[x,i]; end end % ********** End ********** %  disp(num2str(x(20:30)))   第2关：符号替换 1 2 3 4 5 6 7 8 9 10 11 12 13  %已知变量x和数学函数f,g，用fg和gf分别表示f(f(x))和g(f(x)) % ********** Begin ********** % %已知变量x和数学函数f,g，用fg和gf分别表示f(f(x))和g(f(x)) pkg load symbolic % ********** Begin ********** %  syms x; f=x*sin(x)/(sqrt(x^2-2)*(x+5)); g=tan(x); fg=subs(f,x,g); gf=subs(g,x,f); % ********** End ********** %  disp(fg) disp(gf)   第3关：Fibonacci数列计算 1 2 3 4 5 6 7 8 9 10  pkg load symbolic a=sym([1,1]);%a(1)=a(2)=1 %Fibonacci的最高项a(120) % ********** Begin ********** %  for i=3:120 a=[a,a(i-1)+a(i-2)]; end % ********** End ********** % disp(a(100:120))   第4关：序列稳态值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  pkg load symbolic x1=sym(1); x2=x1/2+3/(2*x1); e=10^(-14); %求取达到e精度的稳态值steady_value和n % ********** Begin ********** % n=2; while double(abs(x2-x1))\u0026gt;e %符号数转数值 n=n+1; x1=x2; x2=x1/2+3/(2*x1); end steady_value=x2; % ********** End ********** % disp(num2str(n)) disp(steady_value)   第5关：分段函数 1 2 3 4 5 6 7 8  D=str2num(input(\u0026#39;\u0026#39;,\u0026#39;s\u0026#39;)); h=str2num(input(\u0026#39;\u0026#39;,\u0026#39;s\u0026#39;)); x=str2num(input(\u0026#39;\u0026#39;,\u0026#39;s\u0026#39;)); y=h.*(x\u0026gt;D)+h./(D.*x).*((x\u0026lt;=D) \u0026amp; (x\u0026gt;=-D))-h.*(x\u0026lt;-D); disp(num2str(y))   ","description":"一天只有84600秒，你还要等多久！","id":379,"section":"touge","tags":[""],"title":"Matlab语言程序设计基础","uri":"https://www.zhugeqing.top/touge/3/"},{"content":"第一关 1 2 3 4 5 6 7 8 9 10 11 12 13  # UDPPingerServer.py  from socket import * ########## Begin ########## # 创建UDP套接字 serverSocket = socket(AF_INET, SOCK_DGRAM) # 绑定本机IP地址和端口号 serverSocket.bind((\u0026#39;\u0026#39;, 12000)) ########## End ########## # 输出socket信息 print( serverSocket)   第二关 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  from socket import * # 创建UDP套接字 serverSocket = socket(AF_INET, SOCK_DGRAM) # 绑定本机IP地址和端口号 serverSocket.bind((\u0026#39;\u0026#39;, 12000)) ########## Begin ########## # 接收客户端消息 message, address = serverSocket.recvfrom(1024) # 将数据包消息转换为大写 message = message.upper() #将消息传回给客户端 serverSocket.sendto(message, address) ########## End ##########   第三关 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  from socket import * import random # 创建UDP套接字 serverSocket = socket(AF_INET, SOCK_DGRAM) # 绑定本机IP地址和端口号 serverSocket.bind((\u0026#39;\u0026#39;, 12000)) num=0 while True: # 接收客户端消息 message, address = serverSocket.recvfrom(1024) # 将数据包消息转换为大写 message = message.upper() num=num+1 if num\u0026gt;=8: break ########## Begin ########## # 对消息计数器模 3 为 1 的消息丢包 if num % 3 == 1: continue ########## End ########## #将消息传回给客户端 serverSocket.sendto(message, address)   第四关 1 2 3 4 5 6 7 8 9 10 11  from socket import * ########## Begin ########## # 创建UDP套接字，使用IPv4协议 clientSocket = socket(AF_INET, SOCK_DGRAM) # 设置套接字超时值1秒 clientSocket.settimeout(1) ########## End ########## print(clientSocket) print(clientSocket.gettimeout())   第五关 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  from socket import * import time serverName = \u0026#39;127.0.0.1\u0026#39; # 服务器地址，本例中使用本机地址 serverPort = 12000 # 服务器指定的端口 clientSocket = socket(AF_INET, SOCK_DGRAM) # 创建UDP套接字，使用IPv4协议 clientSocket.settimeout(1) # 设置套接字超时值1秒 for i in range(0, 9): sendTime = time.time() message = (\u0026#39;Ping %d%s\u0026#39; % (i+1, sendTime)).encode() # 生成数据报，编码为bytes以便发送 try: ########## Begin ########## # 将信息发送到服务器 clientSocket.sendto(message, (serverName, serverPort)) # 从服务器接收信息，同时也能得到服务器地址（BUFSIZE为1024） modifiedMessage, serverAddress = clientSocket.recvfrom(1024) ########## End ########## rtt = time.time() - sendTime # 计算往返时间 print(\u0026#39;Sequence %d: Reply from %sRTT = %.3fs\u0026#39; % (i+1, serverName, rtt)) # 显示信息 except Exception as e: print(\u0026#39;Sequence %d: Request timed out.\u0026#39; % (i+1)) clientSocket.close() # 关闭套接字   ","description":"纸上得来终觉浅，绝知此事要躬行","id":380,"section":"touge","tags":[""],"title":"UDP Ping程序实现","uri":"https://www.zhugeqing.top/touge/8/"},{"content":"第一关 1 2 3 4 5 6 7 8 9 10  #import socket module from socket import * serverSocket = socket(AF_INET, SOCK_STREAM) #Prepare a sever socket  ########## Begin ########## serverSocket.bind((\u0026#39;127.0.0.1\u0026#39;, 6789)) serverSocket.listen(1) ########## End ########## print(serverSocket) serverSocket.close()   第二关 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #import socket module from socket import * serverSocket = socket(AF_INET, SOCK_STREAM) #Prepare a sever socket  serverSocket.bind((\u0026#34;127.0.0.1\u0026#34;,6789)) serverSocket.listen(1) #while True: #Establish the connection print(\u0026#39;开始WEB服务...\u0026#39;) try: ########## Begin ########## connectionSocket, addr = serverSocket.accept() message = connectionSocket.recv(1024) # 获取客户发送的报文 ########## End ########## print(addr[0]) print(message) connectionSocket.close() except IOError: connectionSocket.close() serverSocket.close()   第三关 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #import socket module from socket import * serverSocket = socket(AF_INET, SOCK_STREAM) #Prepare a sever socket  serverSocket.bind((\u0026#34;127.0.0.1\u0026#34;,6789)) serverSocket.listen(1) #while True: print(\u0026#39;开始WEB服务...\u0026#39;) try: connectionSocket, addr = serverSocket.accept() message = connectionSocket.recv(1024) # 获取客户发送的报文 #读取文件内容 ######### Begin ######### filename = message.split()[1] f = open(filename[1:]) outputdata = f.read(); ######### End ######### print(outputdata) connectionSocket.close() except IOError: connectionSocket.close() serverSocket.close()   第四关 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  #import socket module from socket import * serverSocket = socket(AF_INET, SOCK_STREAM) #Prepare a sever socket  serverSocket.bind((\u0026#34;127.0.0.1\u0026#34;,6789)) serverSocket.listen(1) #while True: print(\u0026#39;开始WEB服务...\u0026#39;) try: connectionSocket, addr = serverSocket.accept() message = connectionSocket.recv(1024) # 获取客户发送的报文 #读取文件内容 filename = message.split()[1] f = open(filename[1:]) outputdata = f.read(); #发送响应的头部信息 header = \u0026#39; HTTP/1.1 200 OK\\nConnection: close\\nContent-Type: text/html\\nContent-Length: %d\\n\\n\u0026#39; % (len(outputdata)) #########Begin######### connectionSocket.send(header.encode()) #########End######### connectionSocket.close() except IOError: connectionSocket.close() serverSocket.close()   第五关 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  #import socket module from socket import * serverSocket = socket(AF_INET, SOCK_STREAM) #Prepare a sever socket  serverSocket.bind((\u0026#34;127.0.0.1\u0026#34;,6789)) serverSocket.listen(1) #while True: print(\u0026#39;开始WEB服务...\u0026#39;) try: connectionSocket, addr = serverSocket.accept() message = connectionSocket.recv(1024) # 获取客户发送的报文 #读取文件内容 filename = message.split()[1] f = open(filename[1:]) outputdata = f.read(); #向套接字发送头部信息 header = \u0026#39; HTTP/1.1 200 OK\\nConnection: close\\nContent-Type: text/html\\nContent-Length: %d\\n\\n\u0026#39; % (len(outputdata)) connectionSocket.send(header.encode()) #发送文件内容 #########Begin######### for i in range(0, len(outputdata)): connectionSocket.send(outputdata[i].encode()) #########End######### #关闭连接 connectionSocket.close() except IOError: #异常处理 #发送文件未找到的消息 #关闭连接 connectionSocket.close() #关闭套接字 serverSocket.close()   第六关 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  #import socket module from socket import * serverSocket = socket(AF_INET, SOCK_STREAM) #Prepare a sever socket  serverSocket.bind((\u0026#34;127.0.0.1\u0026#34;,6789)) serverSocket.listen(1) #while True: print(\u0026#39;开始WEB服务...\u0026#39;) try: connectionSocket, addr = serverSocket.accept() message = connectionSocket.recv(1024) # 获取客户发送的报文 #读取文件内容 filename = message.split()[1] f = open(filename[1:]) outputdata = f.read(); #向套接字发送头部信息 header = \u0026#39; HTTP/1.1 200 OK\\nConnection: close\\nContent-Type: text/html\\nContent-Length: %d\\n\\n\u0026#39; % (len(outputdata)) connectionSocket.send(header.encode()) #S发送请求文件的内容 for i in range(0, len(outputdata)): connectionSocket.send(outputdata[i].encode()) #关闭连接 connectionSocket.close() except IOError: #异常处理 #发送文件未找到的消息 header = \u0026#39; HTTP/1.1 404 not Found\u0026#39; #########Begin######### connectionSocket.send(header.encode()) #########End######### #关闭连接 connectionSocket.close() #关闭套接字 serverSocket.close()   ","description":"圆圈正义","id":381,"section":"touge","tags":[""],"title":"头歌计算机网络实验web编程答案","uri":"https://www.zhugeqing.top/touge/7/"},{"content":"第1关：智取第一式：分支结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  %%%%% answer_me.m %%%%% clc; clear; question=input(\u0026#39;\u0026#39;,\u0026#39;s\u0026#39;); %输入问题 answer=\u0026#39;\u0026#39;; switch question case \u0026#39;田鸡炖土鸡\u0026#39; answer=\u0026#39;附近有妖气\u0026#39;; case \u0026#39;熟读唐诗三百首\u0026#39; answer=\u0026#39;不会吟诗我不走\u0026#39;; case \u0026#39;天空飘来5个字\u0026#39; answer=\u0026#39;关我什么事\u0026#39;; case \u0026#39;Who are you\u0026#39; answer=\u0026#39;社会主义接班人\u0026#39;; otherwise answer=\u0026#39;我不认识你\u0026#39;; end disp(answer);   第2关：智取第二式：循环结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  %%%%%\tfibonacci.m %%%%% clc; clear; num=input(\u0026#39;\u0026#39;); %输入待输出斐波那契数的序号 %% 创建大小为100的全0数组 f=zeros(1,100); f(1)=1; f(2)=1; %% 别学了 for index =3:1:100 f(index)=f(index-1)+f(index-2); end disp(num2str(f(num)));   第3关：智取第三式：自定义函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  %%%%%\tfunction_test.m %%%%% %%%%%构造主函数function_test functionfunction_test(string,datain)%string是待执行函数名，datain是函数的输入参数 if strcmp(string,\u0026#39;answer_me\u0026#39;) %如果是answer_me函数 answer_me(datain); %执行函数，在函数内输出回答 end if strcmp(string,\u0026#39;fibonacci\u0026#39;) %如果是fibonacci函数 fab=fibonacci(datain); %执行函数，返回对应于序号num的斐波那契数 disp(num2str(fab)); %输出对应于序号num的斐波那契数 end end %%%%%%%%%% begin %%%%%%%%% %%%%% 1. 构造函数answer_me(question) functionanswer_me(haha)switch haha case \u0026#39;田鸡炖土鸡\u0026#39; haha = \u0026#39;附近有妖气\u0026#39;; case \u0026#39;熟读唐诗三百首\u0026#39; haha = \u0026#39;不会吟诗我不走\u0026#39;; case \u0026#39;天空飘来5个字\u0026#39; haha = \u0026#39;关我什么事\u0026#39;; case \u0026#39;Who are you\u0026#39; haha = \u0026#39;社会主义接班人\u0026#39;; otherwise haha = \u0026#39;我不认识你\u0026#39;; end disp(haha) end %%%%% 2. 构造函数fab=fibonacci(num) functionfab =fibonacci(num)f=zeros(1,num); f(1)=1; f(2)=1; %% 别学了 for index =3:1:num f(index)=f(index-1)+f(index-2); end fab = f(num); end %%%%%%%%% end %%%%%%%%%%%%   ","description":"一天只有84600秒，你还要等多久！","id":382,"section":"touge","tags":[""],"title":"智取MATLAB——程序控制结构","uri":"https://www.zhugeqing.top/touge/4/"},{"content":"1  RIPv2 配置 标准 ACL 配置 多区域OSPF协议配置   cd /data/workspace/ git clone https://gitee.com/xing-you-ji/touge_route_help.git mv touge_route_help/* myshixun  2  扩展 ACL 配置 OSPF高级配置   cd /data/workspace/ git clone https://gitee.com/xing-you-ji/touge_route2_help.git mv touge_route2_help/* myshixun  3  动态 NAT 配置 VLAN配置   cd /data/workspace/ git clone https://gitee.com/xing-you-ji/touge_route3_help.git mv touge_route3_help/* myshixun  4  GNS3组建小型局域网 三层交换实现 VALN 间路由   cd /data/workspace/ git clone https://gitee.com/xing-you-ji/touge_route4_help.git mv touge_route4_help/* myshixun  5  链路聚合   cd /data/workspace/ git clone https://gitee.com/xing-you-ji/touge_route5_help.git cd touge_route5_help mv .test.sh ../myshixun  6  生成树协议 STP 与 PVST 配置   cd /data/workspace/ git clone https://gitee.com/xing-you-ji/touge_route6_help.git mv touge_route6_help/* myshixun  7   IP 通信原理  第一关  ABCD B  第二关  A A B  第三关  cd /data/workspace/ git clone https://gitee.com/xing-you-ji/touge_route6_help.git mv touge_route6_help/* myshixun  ","description":"尺有所短，寸有所长。物有所不足，智有所不明","id":383,"section":"touge","tags":[""],"title":"网络路由实验一站通关","uri":"https://www.zhugeqing.top/touge/9/"}]