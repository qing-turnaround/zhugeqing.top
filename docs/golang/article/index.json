[{"content":"题目：65,8,50,15,37,24,()。括号中的数字是()？ A. 25\nB. 26\nC. 22\nD. 27\n答案：\r65=8^2+1 这里将8作为65的特征\r8=3^2-1 这里得到3\r50=7^2+1 这里得到7\r15=4^2-1 这里得到4\r37=6^2+1 这里得到6\r24=5^2-1 这里得到5\r我们发现8,3,7,4,6,5 这组数的特点，以奇数项开始 奇数项加偶数项的和为11，\r以偶数项开始的话 偶数项+奇数项的和为10 8+3=7+4=6+5 3+7=4+6=5+x 这里得到x为5 特征为5 转换为5^2+1 得到26\r","description":"括号中的数字是什么?","id":0,"section":"intelligence","tags":null,"title":"智力题2.1","uri":"https://2110833194.github.io/intelligence/niuke_part2/%E6%8B%AC%E5%8F%B7%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88_1/"},{"content":"题目：5 , 6 , 6 , 9 ,（）, 90。括号中的数字是()？ A. 12\nB. 15\nC. 18\nD. 21\n答案：整个数列规律为：\r（5-3）*（6-3）=6\r（6-3）*（6-3）=9\r（6-3）*（9-3）=18\r（9-3）*（18-3）=90\r规律很多，仅供参考，自我挖掘！\r","description":"括号中的数字是什么?","id":1,"section":"intelligence","tags":null,"title":"智力题2.2","uri":"https://2110833194.github.io/intelligence/niuke_part2/%E6%8B%AC%E5%8F%B7%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88_2/"},{"content":"题目：2 ，3 ，10 ，15 ，26 ，35 ，( )。括号中的数字是是什么？ A. 40\nB. 45\nC. 50\nD. 55\n1^2+1=2 2^2-1=3 3^2+1=10 4^2-1=15 5^2+1+26 6^2-1=35 奇数项平方加一，偶数项平方减一\r","description":"括号中的数字是什么?","id":2,"section":"intelligence","tags":null,"title":"智力题2.3","uri":"https://2110833194.github.io/intelligence/niuke_part2/%E6%8B%AC%E5%8F%B7%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88_3/"},{"content":"《上部分》 这似乎是一个很凝重的话题，但是它真的很有趣。\n1. 指针是指向某一类型的东西，任何一个整体，只要能称为整体就能拥有它自己的独一无二的指针类型，所以指针的类型其实是近似无穷无尽的\n2. 函数名在表达式中总是以函数指针的身份呈现，除了取地址运算符以及sizeof\n3. C语言最晦涩难明的就是它复杂的声明: void (signal(int sig, void (func)(int)))(int),\n试试着把它改写成容易理解的形式\n4. 对于指针，尽最大的限度使用const保护它，无论是传递给函数，还是自己使用\n先来看看一个特殊的指针，姑且称它为指针，因为它依赖于环境: NULL，是一个神奇的东西。先附上定义，在编译器中会有两种NULL(每种环境都有唯一确定的NULL):\n1 2  #define NULL 0 #define NULL ((void*)0)   有什么区别吗？看起来没什么区别都是0，只不过一个是常量，一个是地址为0的指针。\n当它们都作为指针的值时并不会报错或者警告，即编译器或者说C标准认为这是合法的:\n1 2 3  int* temp_int_1 = 0; //无警告 int* temp_int_2 = (void*)0; //无警告 int* temp_int_3 = 10; //出现警告   为什么？为什么0可以赋值给指针，但是10却不行？他们都是常量。\n因为C语言规定当处理上下文的编译器发现常量0出现在指针赋值的语句中，它就作为指针使用，似乎很扯淡，可是却是如此。\n回到最开始，对于NULL的两种情况，会有什么区别？拿字符串来说，实际上我是将字符数组看作是C风格字符串。\n在C语言中，字符数组是用来存储一连串有意义的字符，默认在这些字符的结尾添加'\\0'，好这里又出现了一个0值。\n对于某些人，在使用字符数组的时候总是分不清楚NULL与'\\0\u0026rsquo;的区别而误用，在字符数组的末尾使用NULL是绝对错误的！虽然它们的本质都是常量0，但由于位置不同所以含义也不同。\n开胃菜已过\n对于一个函数，我们进行参数传递，参数有两种形式: 形参与实参\n1 2 3 4 5 6  int function(int value) { /*...*/ } //... function(11);   其中，value是形参，11是实参，我们知道场面上，C语言拥有两种传递方式:按值传递和按址传递，但是你是否有认真研究过？这里给出一个实质，其实C语言只有按值传递，所谓按址传递只不过是按值传递的一种假象。至于原因稍微一想便能明白。\n对于形参和实参而言两个关系紧密，可以这么理解总是实参将自己的一份拷贝传递给形参，这样形参便能安全的使用实参的值，但也带给我们一些麻烦，最经典的交换两数\n1 2 3 4 5 6 7  void swap_v1(int* val_1, int* val_2) { int temp = *val_1; *val_1 = *val_2; *val_2 = *val_1; }   这就是所谓的按址传递，实际上只是将外部指针(实参)的值做一个拷贝，传递给形参val_1与val_2，实际上我们使用:\n1 2  #define SWAP_V2(a, b) (a += b, b = a - b, a -= b) #define SWAP_V3(x, y) {x ^= y; y ^= x; x ^= y}   试一试是不是很神奇，而且省去了函数调用的时间，空间开销。上述两种写法的原理实质是一样的。\n但是，动动脑筋想一想，这种写法真的没有瑕疵吗？如果输入的两个参数本就指向同一块内存，会发生什么？\n1 2 3 4 5 6 7 8  ... int test_1 = 10, test_2 = 100; SWAP_V2(test_1, test_2); printf(\u0026#34;Now the test_1 is %d, test_2 is %d\\n\u0026#34;, test_1, test_2); .../*恢复原值*/ SWAP_V2(test_1, test_1); printf(\u0026#34;Now the test_1 is %d\\n\u0026#34;, test_1);   会输出什么？:\n1 2  $: Now the test_1 is 100, test_2 is 10 $: Now the test_1 is 0   对，输出了0，为什么？稍微动动脑筋就能相通，那么对于后面的SWAP_V3亦是如此，所以在斟酌之下，解决方案应该尽可能短小精悍:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  static inline void swap_final(int* val_1, int* val_2) { if(val_1 == val_2) return; *val_1 ^= *val_2; *val_2 ^= *val_1; *val_1 ^= *val_2; } #define SWAP(x, y) do{ if(\u0026amp;x == \u0026amp;y) break; x ^= y; y ^= x; x ^= y; }while(0)   这便是目前能找到最好的交换函数，我们在此基础上可以考虑的更深远一些，如何让这个交换函数更加通用？即适用范围更大？暂不考虑浮点类型。\n提示：可用void*\n与上面的情况类似，偶尔的不经意就会造成严重的后果:\n1 2 3 4 5 6 7 8 9 10 11  int combine_1(int* dest, int* add) { *dest += *add; *dest += *add; return *dest; } int combine_2(int* dest, int* add) { *dest += 2 * (*add);//在不确定优先级时用括号是一个明智的选择  return *dest; }   上述两个函数的功能一样吗？恩看起来是一样的\n1 2 3 4 5 6  int test_3 = 10, test_4 = 100; combine_1(\u0026amp;test_3, \u0026amp;test_4); printf(\u0026#34;After combine_1, test_3 = %d\\n\u0026#34;,test_3); .../*恢复原值*/ combine_2(\u0026amp;test_3, \u0026amp;test_4); printf(\u0026#34;After combine_2, test_3 = %d\\n\u0026#34;,test_3);   输出\n1 2 3 4  $: After combine_1, test_3 = 210 $: After combine_2, test_3 = 210   如果传入两个同一对象呢？\n1 2 3 4 5 6  ... /*恢复test_3原值*/ combine_1(\u0026amp;test_3, \u0026amp;test_3); printf(\u0026#34;After second times combine_1, test_3 = %d\\n\u0026#34;,test_3); ... combine_2(\u0026amp;test_3, \u0026amp;test_3); printf(\u0026#34;After second times combine_2, test_3 = %d\\n\u0026#34;,test_3);   输出\n1 2 3  $: After second times combine_1, test_3 = 40 $: After second times combine_2, test_3 = 30   知道真相总是令人吃惊，指针也是那么令人又爱又恨。\n C99 标准之后出现了一个新的关键字， restrict，被用于修饰指针，它并没有太多的显式作用，甚至加与不加，在 你自己 看来，效果毫无区别。但是反观标准库的代码中，许多地方都使用了该关键字，这是为何\n首先这个关键字是写给编译器看的\n其次这个关键字的作用在于辅助编译器更好的优化该程序(后方文章会有介绍)\n最后，如果不熟悉，绝对不要乱用这个关键字  关于数组的那些事\n数组和指针一样吗？\n不一样!\n要时刻记住，数组与指针是不同的东西。但是为什么下面代码是正确的？\n1 2  int arr[10] = {10, 9, 8, 7}; int* parr = arr;   我们还是那句话，结合上下文，编译器推出 arr处于赋值操作符的右侧，默默的将他转换为对应类型的指针，而我们在使用arr时也总是将其当成是指向该数组内存块首位的指针。\n1 2 3 4 5 6 7 8 9 10  //int function2(const int test_arr[10] //int function2(const int test_arr[]) 考虑这三种写法是否一样 int function2(const int* test_arr) { return sizeof(test_arr); } int size_out = sizeof(arr); int size_in = function2(arr); printf(\u0026#34;size_out = %d, size_in = %d\\n\u0026#34;, size_out, size_in);   1  输出: size_out = 40, size_in = 8   这就是为什么数组与指针不同的原因所在，在外部即定义数组的代码块中，编译器通过上下文发觉此处arr是一个数组，而arr代表的是一个指向10个int类型的数组的指针，只所谓最开始的代码是正确的，只是因为这种用法比较多，就成了标准的一部分。就像世上本没有路，走的多了就成了路。”正确”的该怎么写\n1  int (*p)[10] = \u0026amp;arr;   此时p的类型就是一个指向含有10个元素的数组的指针,此时(*p)[0]产生的效果是arr[0]，也就是parr[0]，但是(*p)呢？这里不记录，结果是会溢出，为什么？\n这就是数组与指针的区别与联系，但是既然我们可以使用像parr这样的指针，又为什么要写成int (*p)[10]这样丑陋不堪的模式呢？原因如下:\n回到最开始说过的传递方式，按值传递在传递arr时只是纯粹的将其值进行传递，而丢失了上下文的它只是一个普通指针，只不过我们程序员知道它指向了一块有意义的内存的起始位置，我想要将数组的信息一起传递，除了额外增加一个参数用来记录数组的长度以外，也可以使用这个方法，传递一个指向数组的指针\n这样我们就能只传递一个参数而保留所有信息。但这么做的也有限制:对于不同大小，或者不同存储类型的数组而言，它们的类型也有所不同\n1 2 3 4  int arr_2[5]; int (*p_2)[5] = \u0026amp;arr_2; float arr_3[5]; float (*p_3)[5] = \u0026amp;arr_3;   如上所示，指向数组的指针必须明确指定数组的大小，数组存储类型，这就让指向数组的指针有了比较大的限制。\n这种用法在多维数组中使用的比较多，但总体来说平常用的并不多，就我而言，更倾向于使用一维数组来表示多维数组，实际上诚如前面所述，C语言是一个非常简洁的语言，它没有太多的废话，就本质而言C语言并没有多维数组，因为内存是一种线性存在，即便是多维数组也是实现成一维数组的形式。\n就多维数组在这里解释一下。所谓多维数组就是将若干个降一维的数组组合在一起，降一维的数组又由若干个更降一维的数组组合在一起，直到最低的一维数组，举个例子:\n1  int dou_arr[5][3];   就这个二维数组而言，将5个每个为3个int类型的数组组合在一起，要想指向这个数组该怎么做？\n1 2 3  int (*p)[3] = \u0026amp;dou_arr[0]; int (*dou_p)[5][3] = \u0026amp;dou_arr; int (*what_p)[3] = dou_arr;   实际上多维数组只是将多个降一维的数组组合在一起，令索引时比较直观而已。当真正理解了内存的使用，反而会觉得多维数组带给自己更多限制\n对于第三句的解释，当数组名出现在赋值号右侧时，它将是一个指针，类型则是 指向该数组元素的类型，而对于一个多维数组来说，其元素类型则是其降一维数组，即指向该降一维数组的指针类型。这个解释有点绕，自己动手写一写就好很多。\n对于某种形式下的操作，我们总是自然的将相似的行为结合在一起考虑。考虑如下代码:\n1 2 3  int* arr_3[5] = {1, 2, 3, 4, 5}; int* p_4 = arr_3; printf(\u0026#34;%d == %d == %d ?\\n\u0026#34;, arr_3[2], *(p_4 + 2), *(arr_3 + 2));     输出: 3 == 3 == 3 ?\n  实际上对于数组与指针而言， []操作在大多数情况下都能有相同的结果，对于指针而言*(p_4 + 2)相当于p_4[2]，也就是说[]便是指针运算的语法糖，有意思的是2[p_4]也相当于p_4[2]，\u0026ldquo;Iamastring\u0026rdquo;[2] == \u0026rsquo;m'，但这只是娱乐而已，实际中请不要这么做，除非是代码混乱大赛或者某些特殊用途。\n在此处，应该声明的是这几种写法的执行效率完全一致，并不存在一个指针运算便快于[]运算，这些说法都是上个世纪的说法了，随着时代的发展，我们应该更加注重代码整洁之道\n  在此处还有一种奇异又实用的技巧，在char数组中使用指针运算进行操作，提取不同类型的数据，或者是在不同类型数组中，使用char*指针抽取其中内容，才是显示指针运算的用途。但在使用不同类型指针操作内存块的时候需要注意，不要操作无意义的区域或者越界操作。\n  实际上，最简单的安全研究之一，便是利用溢出进行攻击。\n Advance:对于一个函数中的某个数组的增长方向，总是向着返回地址的，中间可能隔着许多其他自动变量，我们只需要一直进行溢出试验，直到某一次，该函数无法正常返回了！那就证明我们找到了该函数的返回地址存储地区，这时候我们可以进行一些操作，例如将我们想要的返回地址覆盖掉原先的返回地址，这就是所谓的溢出攻击中的一种。  《下部分》 内存的使用的那些事儿\n你一直以为你操作的是真实物理内存，实际上并不是，你操作的只是操作系统为你分配的资格虚拟地址，但这并不意味着我们可以无限使用内存，那内存卖那么贵干嘛，实际上存储数据的还是物理内存，只不过在操作系统这个中介的介入情况下，不同程序窗口(可以是相同程序)可以共享使用同一块内存区域，一旦某个傻大个程序的使用让物理内存不足了，我们就会把某些没用到的数据写到你的硬盘上去，之后再使用时，从硬盘读回。这个特性会导致什么呢？假设你在Windows上使用了多窗口，打开了两个相同的程序:\n1 2 3 4 5 6 7 8 9 10 11 12 13  ... int stay_here; char tran_to_int[100]; printf(\u0026#34;Address: %p\\n\u0026#34;,\u0026amp;stay_here); fgets(tran_to_int,sizeof(tran_to_int), stdin); sscanf(tran_to_int,\u0026#34;%d\u0026#34;,\u0026amp;stay_here); for(;;) { printf(\u0026#34;%d\\n\u0026#34;, stay_here); getchar(); ++stay_here; } ...   对此程序(引用前桥和弥的例子)，每敲击一次回车，值加1。当你同时打开两个该程序时，你会发现，两个程序的stay_here都是在同一个地址，但对它进行分别操作时，产生的结果是独立的！这在某一方面验证了虚拟地址的合理性。虚拟地址的意义就在于，即使一个程序出现了错误，导致所在内存完蛋了，也不会影响到其他进程。对于程序中部的两个读取语句，是一种理解C语言输入流本质的好例子，建议查询用法，这里稍微解释一下:\n通俗地说，fgets将输入流中由调用起，stdin输入的东西存入起始地址为tran_to_int的地方，并且最多读取sizeof(tran_to_int)个，并在后方sscanf函数中将刚才读入的数据按照%d的格式存入stay_here，这就是C语言一直在强调的流概念的意义所在，这两个语句组合看起来也就是读取一个数据这么简单，但是我们要知道一个问题，一个关于scanf的问题\nscanf(\u0026quot;%d\u0026quot;,\u0026amp;stay_here);\n这个语句将会读取键盘输入，直到回车之前的所有数据，什么意思？就是回车会留在输入流中，被下一个输入读取或者丢弃。这就有可能会影响我们的程序，产生意料之外的结果。而使用上当两句组合则不会。\n函数与函数指针的那些事\n事实上，函数名出现在赋值符号右边就代表着函数的地址\n1 2 3 4 5  intfunction(int argc){/*...*/ } ... int(*p_fun)(int)=function; int(*p_fuc)(int)=\u0026amp;function;//和上一句意义一致   上述代码即声明并初始化了函数指针，p_fun的类型是指向一个返回值是int类型，参数是int类型的函数的指针\n1 2 3  p_fun(11); (*p_fun)(11); function(11);   上述三个代码的意义也相同，同样我们也能使用函数指针数组这个概念\nint(*p_func_arr[])(int)={func1, func2,};\r其中func1,func2都是返回值为int参数为int的函数，接着我们能像数组索引一样使用这个函数了。\nTips: 我们总是忽略函数声明，这并不是什么好事。\n在C语言中，因为编译器并不会对有没有函数声明过分深究，甚至还会放纵，当然这并不包含内联函数(inline)，因为它本身就只在本文件可用。\n比如，当我们在某个地方调用了一个函数，但是并没有声明它：\n1  CallWithoutDeclare(100);//参数100为 int 型   那么，C编译器就会推测，这个使用了int型参数的函数，一定是有一个int型的参数列表，一旦函数定义中的参数列表与之不符合，将会导致参数信息传递错误(编译器永远坚信自己是对的！)，我们知道C语言是强类型语言，一旦类型不正确，会导致许多意想不到的结果(往往是Bug)发生。\n对函数指针的调用同样如此\nC语言中malloc的那些事儿\n我们常常见到这种写法:\n1  int* pointer =(int*)malloc(sizeof(int));   这有什么奇怪的吗？看下面这个例子:\nint* pointer_2 = malloc(sizeof(int));\n哪个写法是正确的？两个都正确，这是为什么呢，这又要追求到远古C语言时期，在那个时候， void* 这个类型还没有出现的时候，malloc 返回的是 char* 的类型，于是那时的程序员在调用这个函数时总要加上强制类型转换，才能正确使用这个函数，但是在标准C出现之后，这个问题不再拥有，由于任何类型的指针都能与 void* 互相转换，并且C标准中并不赞同在不必要的地方使用强制类型转换，故而C语言中比较正统的写法是第二种。\n题外话: C++中的指针转换需要使用强制类型转换，而不能像第二种例子，但是C++中有一种更好的内存分配方法，所以这个问题也不再是问题。\nTips:\nC语言的三个函数malloc, calloc, realloc都是拥有很大风险的函数，在使用的时候务必记得对他们的结果进行校验，最好的办法还是对他们进行再包装，可以选择宏包装，也可以选择函数包装。\nrealloc函数是最为人诟病的一个函数，因为它的职能过于宽广，既能分配空间，也能释放空间，虽然看起来是一个好函数，但是有可能在不经意间会帮我们做一些意料之外的事情，例如多次释放空间。正确的做法就是，应该使用再包装阉割它的功能，使他只能进行扩展或者缩小堆内存块大小。\n指针与结构体\n1 2 3 4 5 6 7 8 9 10 11  typedefstruct tag{ int value; long vari_store[1]; }vari_struct; ```c 乍一看，似乎是一个很中规中矩的结构体 ```c ... vari_struct vari_1; vari_struct* vari_p_1 =\u0026amp;vari_1; vari_struct* vari_p_2 = malloc(sizeof(vari_struct))(   似乎都是这么用的，但总有那么一些人想出了一些奇怪的用法\n1 2  int what_spa_want =10; vari_struct* vari_p_3 = malloc(sizeof(vari_struct)+sizeof(long)*what_spa_want);    这么做是什么意思呢？这叫做可变长结构体，即便我们超出了结构体范围，只要在分配空间内，就不算越界。what_spa_want解释为你需要多大的空间，即在一个结构体大小之外还需要多少的空间，空间用来存储long类型，由于分配的内存是连续的，故可以直接使用数组vari_store直接索引。\n而且由于C语言中，编译器并不对数组做越界检查，故对于一个有N个数的数组arr，表达式\u0026amp;arr[N]是被标准允许的行为，但是要记住arr[N]却是非法的。\n这种用法并非是娱乐，而是成为了标准(C99)的一部分，运用到了实际中  对于内存的理解\n在内存分配的过程中，我们使用 malloc 进行分配，用 free 进行释放，但这是我们理解中的分配与释放吗？\n在调用 malloc 时，该函数或使用 brk() 或使用 mmap() 向操作系统申请一片内存，在使用时分配给需要的地方，与之对应的是 free，与我们硬盘删除东西一样，实际上:\n1 2 3 4  int* value = malloc(sizeof(int)*5); ... free(value); printf(\u0026#34;%d\\n\u0026#34;, value[0]);   代码中，为什么在 free 之后，我又继续使用这个内存呢？因为 free 只是将该内存标记上释放的标记，示意分配内存的函数，我可以使用，但并没有破坏当前内存中的内容，直到有操作对它进行写入。\n这便引申出几个问题:\nBug更加难以发现，让我们假设，如果我们有两个指针p1,p2指向同一个内存，如果我们对其中某一个指针使用了 free(p1); 操作，却忘记了还有另一个指针指向它，那这就会导致很严重的安全隐患，而且这个隐患十分难以发现，原因在于这个Bug并不会在当时显露出来，而是有可能在未来的某个时刻，不经意的让你的程序崩溃。\n有可能会让某些问题更加简化，例如释放一个条条相连的链表域。\n某些大哥提到说，free并不是什么都不做，而是将该段地址空间的前面一小部分置零\n但是如果地址空间很长的话，依旧有误用的风险，希望大家还是警惕\n实际上之所以库作者不让free操作将地址空间清空，有一部分原因是为了性能考虑，因为置零操作是一个消耗性能的行为，具体可以自行尝试，所谓双刃剑就在于此。\n 总的来说，还是那句话C语言是一把双刃剑。     所以，指针其实就是一个存放了另外一个存储空间的地址的存储空间，从而可以由本指针存储空间访问到另外一个存储空间！      \u0026mdash;\u0026ndash;摘抄自《c语言进阶》一书\n","description":"都2021年了，还搞不懂c语言指针是什么？","id":3,"section":"article","tags":null,"title":"c语言指针！","uri":"https://2110833194.github.io/article/pointer/"},{"content":"题目：一台指针式钟表的时针和分针指向的重合的时间间隔是？\n答案：\r由于分针总是比时针走的快，所以问题就转换成时针在一圈的范围内追击分针的问题：\r分针走的角速度是360°/60分 = 6°/分\r时针走的角速度是360°/720分 = 0.5°/分\r下一次追到比上一次追到，分针比时针多走过的角度是360°，\r那么在一圈的角度内 360°/(6°/分-0.5°/分) = 720/11 分钟，\r经过这么多时间 分针和时间重合一次，\r所以引申到一昼夜时间内分针 时针相遇多少次：24*60/(720/11) = 22 次\r","description":"时针和分针指向的重合的时间间隔是？","id":4,"section":"intelligence","tags":null,"title":"智力题1.3","uri":"https://2110833194.github.io/intelligence/niuke_part1/%E6%97%B6%E9%92%88%E4%B8%8E%E5%88%86%E9%92%88%E9%87%8D%E5%90%88/"},{"content":"题目：对一批编号为1～100，全部开关朝上(开)的灯进行以下操作：\n凡是1的倍数反方向拨一次开关；2的倍数反方向又拨一次开关；\n3的倍数反方向又拨一次开关……100的倍数反方向又拨一次开关 ,\n问：最后为关熄状态的灯有几个?\n答案：分析：所有的灯都会根据它是否是某数的倍数来拨动开关，比如1是1的倍数，\r但它不是其他剩余99个数的倍数，故只拨动一次开关，初始状态为开，\r只要经过奇数次拨动开关，最终状态都会是关着的灯\r进一步分析：上述分析又可以根据题意来化解为只有这个编号含有奇数个因数的灯，\r在经过所有关灯操作之后，它的最终状态就是关闭的，所以2不是（1，2），\r3不是（1,3）,4是(1，2，4)，...9是（1,3,9）,...16是（1,2,4,8,16），\r发现规律的吧，1的平方，2的平方，3的平方，4的平方，\r所有1-100一共有10个最后为关熄状态的灯。\r","description":"最后为关熄状态的灯有几个?","id":5,"section":"intelligence","tags":null,"title":"智力题1.4","uri":"https://2110833194.github.io/intelligence/niuke_part1/%E6%9C%80%E5%90%8E%E4%B8%BA%E5%85%B3%E7%86%84%E7%8A%B6%E6%80%81%E7%9A%84%E7%81%AF%E6%9C%89%E5%87%A0%E4%B8%AA/"},{"content":"题目：假设一个5位数字的180度旋转图像是另一个5位数字，并且这两个数字之间的差是78633，那么原始的5位数字是什么？\n答案：\r首先，只有0，1，2，6，8，9，6个数字反转仍有效。另外要注意，旋转180度，\r数字所在位也变了。考虑首位和末位，要求差为7和3，只有1和8满足。\r1xxx8和8xxx1。考虑倒数第二位3，由于末位退位，要求差4，只有0和6。\r所以是10x68和89x01。最后看中间，78633+10x68=89x01。\r所有原始数字是10968或者89601\r","description":"原始的5位数字是什么？","id":6,"section":"intelligence","tags":null,"title":"智力题1.5","uri":"https://2110833194.github.io/intelligence/niuke_part1/%E5%8E%9F%E5%A7%8B%E7%9A%845%E4%BD%8D%E6%95%B0%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88/"},{"content":"题目：医院里的医务人员，包括我在内，总共是16名医生和护士。下面讲到的人员情况，无论是否把我计算在内，都不会有任何变化。在这些医务人员中： (1)护士多于医生;(2)男医生多于男护士;(3)男护士多於女护士;(4)至少有一位女医生。 这位说话的人是什么性别和职务？\n答案：\r先考虑不把说话者计算在内的情况，这时医生和护士共有15名。\r首先由条件（1）可知，则护士至少应有8名；再由条件（3）可知，\r则男护士至少有5名；接着由条件（2）可知，男医生至少有6名；\r结合条件（4）可知，医生至少有7名，则护士至多8名。所以，\r要满足条件，只能是护士8名，其中男护士5名，女护士3名，医生7名，\r其中男医生6名，女医生1名。加上说话者后，要仍满足这四个条件，\r由条件（1）可知，说话者是护士；由条件（2）可知，说话者不能是男护士，\r所以只能是女护士。\r","description":"题目：这位说话的人是什么性别和职务","id":7,"section":"intelligence","tags":null,"title":"智力题3.1","uri":"https://2110833194.github.io/intelligence/niuke_part3/%E8%BF%99%E4%BD%8D%E8%AF%B4%E8%AF%9D%E7%9A%84%E4%BA%BA%E6%98%AF%E4%BB%80%E4%B9%88%E6%80%A7%E5%88%AB%E5%92%8C%E8%81%8C%E5%8A%A1/"},{"content":"题目：\n已知每个城市的用水需求相同，每月水库的进水速率恒定不变。现有一座水库供水，如果供应10个城市的话，一个月水库就会枯竭；如果供应8个城市的话，一个半月水库就会枯竭。当前城市化进程不断加快，新的城市不断产生，为了能够持续满足12个城市的供水，还至少需要建设几个这样的水库？\n假设水库库存的水量为M\r水库每月进水为X\r每个城市每月消耗水m\r由题意：\rM + X = 10 * m\rM + 1.5 * X = 8 * m * 1.5\r解得：\rX = 4m\r因此：\r要维持12个城市每月持续不断的供水，要满足：(?) * X = m * 12\r解得：(?) = 3\r题目问的是：\u0026quot;还至少需要建设几个这样的水库？\u0026quot;\r不应该是2个吗？(因为现在已经有一个水库了...)\r","description":"还至少需要建设几个这样的水库?","id":8,"section":"intelligence","tags":null,"title":"智力题4.1","uri":"https://2110833194.github.io/intelligence/niuke_part4/%E8%BF%98%E8%87%B3%E5%B0%91%E9%9C%80%E8%A6%81%E5%BB%BA%E8%AE%BE%E5%87%A0%E4%B8%AA%E8%BF%99%E6%A0%B7%E7%9A%84%E6%B0%B4%E5%BA%93/"},{"content":"题目：把21、26、65、99、10、35、18、77分成若干组，要求每组中任意两个数都互质，至少要分成多少组。\n答案：1.首先把含有相同因数的数分到一组，或者是没有相同因数的质数分为一组\r2.列出来：含有因数3的：21，99，18。含有因数5的：10，35，65。\r是质数（77不是质数，但剩下的数里面没有和它有相同因数的，故分到一组）的：26，77\r3.然后把这些组组合起来，所以至少是三组。\r解惑（思路有很多，比如也可以在第一第二步选择将偶数分为一组，然后再细分）\r","description":"题目：至少要分为多少组？","id":9,"section":"intelligence","tags":null,"title":"智力题4.2","uri":"https://2110833194.github.io/intelligence/niuke_part4/%E8%87%B3%E5%B0%91%E8%A6%81%E5%88%86%E4%B8%BA%E5%A4%9A%E5%B0%91%E7%BB%84/"},{"content":"题目：1000 个瓶子中有一瓶毒药，一只老鼠吃到毒药一周之内会死，如果要在一周之内检测出有毒药的一瓶，问至少需要几只老鼠？\nA:8\nB:10\nC:24\nD:999\n答案是十只 000=0\r001=1\r010=2\r011=3\r100=4\r101=5\r110=6\r111=7\r一位表示一个老鼠，0-7表示8个瓶子。\r也就是分别将1、3、5、7号瓶子的药混起来给老鼠1吃，\r2、3、6、7号瓶子的药混起来给老鼠2吃，\r4、5、6、7号瓶子的药混起来给老鼠3吃，\r哪个老鼠死了，相应的位标为1。\r如老鼠1死了、老鼠2没死、老鼠3死了，\r那么就是101=5号瓶子有毒。\r同样道理10个老鼠可以确定1000个瓶子\r","description":"问至少需要几只老鼠？","id":10,"section":"intelligence","tags":null,"title":"智力题1.1","uri":"https://2110833194.github.io/intelligence/niuke_part1/%E8%80%81%E9%BC%A0%E6%B5%8B%E6%AF%92%E8%8D%AF/"},{"content":"1\n1 1\n2 1\n1 2 1 1\n1 1 1 2 2 1\n下一行是什么\nA:1111211\nB:312211\nC:312112\nD:213112\n微软的题\r答案：后一行数是前一行数的描述，把“个”字去掉组成新的数：\r-1：1个1 ——11\r- 11：2个1——21\r- 21：1个2，1个1——1211\r- 1211：1个1,1个2,2个1——111221\r- 111221：3个1，2个2，1个1——312211\r","description":"题目：下一行输出什么","id":11,"section":"intelligence","tags":null,"title":"智力题1.2","uri":"https://2110833194.github.io/intelligence/niuke_part1/%E4%B8%8B%E4%B8%80%E8%A1%8C%E8%AF%A5%E8%BE%93%E5%87%BA%E4%BB%80%E4%B9%88/"},{"content":"历史上，有多种辅助存储设备，比如软盘、光盘、硬盘、U 盘等，相对于内存，它们就是人们常说的“外存”，即外存储器（设备）。\n从软盘（Floppy Disk）启动计算机，这已经是过去的事了。软盘的尺寸比烟盒稍大一点，但是比较薄，采用塑料作为基片，上面是一层磁性物质，可以用来记录二进制位。这种塑料介质比较柔软，所以称为软盘。\n在数据记录原理上和软盘很相似的设备是硬盘（Hard Disk，HDD），而且它们几乎是同一个时代的产物。但是，与软盘不同，硬盘是多盘片、密封、高转速的，采用铝合金作为基片，并在表面涂上磁性物质来记录二进制位。这就使得它的盘片具有较高的硬度，故称为硬盘。\n   图1-1 一块被拆开密封盖的硬盘\r 如图1-1 所示，这是一块被拆开的硬盘，中间是用于记录数据的铝合金盘片，固定在中心的轴上，由一个高速旋转的马达驱动。附着在盘片表面的扁平锥状物，就是用于在盘片上读写数据的磁头。\n为了进一步搞清楚硬盘的内部构造，图1-2 给出了更为详细的图示。\n硬盘可以只有一个盘片（这称为单碟），也可能有好几个盘片。但无论如何，它们都串在同一个轴上，由电动机带动着一起高速旋转。一般来说，转速可以达到每分钟3600 转或者7200转，有的能达到一万多转，这个参数就是我们常说的“转/分钟”（Round Per Minute，RPM）。\n   图1-2 硬盘的结构示意图\r 每个盘片都有两个磁头（Head），上面一个，下面一个，所以经常用磁头来指代盘面。磁头都有编号，第1 个盘片，上面的磁头编号为0，下面的磁头编号为1；第2 个盘片，上面的磁头编号为2，下面的磁头编号为3，以此类推。\n每个磁头不是单独移动的。相反，它们都通过磁头臂固定在同一个支架上，由步进电动机带动着一起在盘片的中心和边缘之间来回移动。也就是说，它们是同进退的。步进电动机由脉冲驱动，每次可以旋转一个固定的角度，即可以步进一次。\n可以想象，当盘片高速旋转时，磁头每步进一次，都会从它所在的位置开始，绕着圆心“画”出一个看不见的圆圈，这就是磁道（Track）。磁道是数据记录的轨迹。因为所有磁头都是联动的，故每个盘面上的同一条磁道又可以形成一个虚拟的圆柱，称为柱面（Cylinder）。\n磁道，或者柱面，也要编号。编号是从盘面最边缘的那条磁道开始，向着圆心的方向，从0开始编号。\n柱面是一个用来优化数据读写的概念。初看起来，用硬盘来记录数据时，应该先将一个盘面填满后，再填写另一个盘面。实际上，移动磁头是一个机械动作，看似很快，但对处理器来说，却很后，再填写另一个盘面。实际上，移动磁头是一个机械动作，看似很快，但对处理器来说，却很漫长，这就是寻道时间。为了加速数据在硬盘上的读写，最好的办法就是尽量不移动磁头。这样，当0 面的磁道不足以容纳要写入的数据时，应当把剩余的部分写在1 面的同一磁道上。如果还写不下，那就继续把剩余的部分写在2 面的同一磁道上。换句话说，在硬盘上，数据的访问是以柱面来组织的。\n实际上，磁道还不是硬盘数据读写的最小单位，磁道还要进一步划分为扇区（Sector）。磁道很窄，也看不见，但在想象中，它仍呈带状，占有一定的宽度。将它划分许多分段之后，每一部分都呈扇形，这就是扇区的由来。\n每条磁道能够划分为几个扇区，取决于磁盘的制造者，但通常为63 个。而且，每个扇区都有一个编号，与磁头和磁道不同，扇区的编号是从1 开始的。\n扇区与扇区之间以间隙（空白）间隔开来，每个扇区以扇区头开始，然后是512 个字节的数据区。扇区头包含了每个扇区自己的信息，主要有本扇区的磁道号、磁头号和扇区号，用来供硬盘定位机构使用。现代的硬盘还会在扇区头部包括一个指示扇区是否健康的标志，以及用来替换该扇区的扇区地址。用于替换扇区的，是一些保留和隐藏的磁道。\n","description":"硬盘的构造及其工作原理","id":12,"section":"article","tags":null,"title":"硬盘到底是什么！","uri":"https://2110833194.github.io/article/hard_disk/"},{"content":"1.创建仓库命令 1.创建版本库(初始化仓库) \u0026mdash;\u0026mdash; git init\n2.拷贝一份远程仓库，也就是下载一个项目 \u0026mdash;\u0026mdash; git clone\n2.提交与修改 1.添加文件到暂存区 \u0026mdash;\u0026mdash; git add\n2.查看仓库当前的状态，显示有变更的文件 \u0026mdash;\u0026mdash; git status\n3.比较文件的不同，即暂存区和工作区的区别 \u0026mdash;\u0026mdash; git diff\n4.提交暂存区到本地仓库 \u0026mdash;\u0026mdash; git commit\n7.回退版本 \u0026mdash;\u0026mdash; git reset\n8.删除工作区的文件 \u0026mdash;\u0026mdash; git rm\n9.移动或者重命名工作区的文件 \u0026mdash;\u0026mdash; git mv\n2.1提交日志 1.查看历史提交记录 \u0026mdash;\u0026mdash; git log\n2.以列表形式查看指定文件的历史修改记录 \u0026mdash;\u0026mdash; git blame \n2.2远程操作 1.远程仓库操作 \u0026mdash;\u0026mdash; git remote\n2.从远程获取代码库 \u0026mdash;\u0026mdash; git fetch\n3.下载远程代码并合并 \u0026mdash;\u0026mdash; git pull\n4.上传远程代码并合并 \u0026mdash;\u0026mdash; git push\n3.git 分支管理 1.列出分支 \u0026mdash;\u0026mdash; git branch(无参数时)\n2.创建新分支 \u0026mdash;\u0026mdash; git branch branchname(branchname为想要创建的分支名)\n3.切换到分支 \u0026mdash;\u0026mdash; git checkout branchname(branchname为想要切换到的分支名)\n4.创建新分支并切换到该分支下 \u0026mdash;\u0026mdash; git checkout -b branchname(branchname为想要创建的分支名)\n5.删除分支 \u0026mdash;\u0026mdash; git branch -d branchname(branchname为想要删除的分支名)\n6.合并分支 \u0026mdash;\u0026mdash; git merge /git rebase\nrebase优缺点 优点： Rebase 使你的提交树变得很干净, 所有的提交都在一条线上 缺点： Rebase 修改了提交树的历史 merge优缺点 优点: merge可以保留提交历史 缺点： merge使你的提交树变得复杂，提交由多条线相连 7.解决冲突 \u0026mdash;\u0026mdash; 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。\n4.git 查看提交历史 1.查看历史提交记录 \u0026mdash;\u0026mdash; git log\n2.以列表形式查看指定文件的历史修改记录 \u0026mdash;\u0026mdash; git blame \n5.git 标签 1.查看所有标签 \u0026mdash;\u0026mdash; git tag\n2.为当前分支创建标签 \u0026mdash;\u0026mdash; git tag -a v1.0(不带\u0026quot;-a\u0026quot;也行,但建议带上)\n3.创建带有说明的标签 \u0026mdash;\u0026mdash; git tag -a v0.1 -m \u0026ldquo;runoob.com标签\u0026rdquo;（用-a指定标签名，-m指定说明文字：）\n4.查看标签说明文字 \u0026mdash;\u0026mdash; git show v0.1\n(注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。) 6.git 远程仓库(Github) 1添加远程库 \u0026mdash;\u0026mdash; git remote add origin [url](origin 为给远程库取的一个别名) 由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息： 使用以下命令生成 SSH Key：ssh-keygen -t rsa -C \u0026ldquo;youremail@example.com\u0026rdquo; 后面的 your_email@youremail.com 改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在 ~/ 下生成 .ssh 文件夹，进去，打开 id_rsa.pub，复制里面的 key。回到 github 上，进入 Account =\u0026gt; Settings（账户配置）。左边选择 SSH and GPG keys，然后点击 New SSH key 按钮,title 设置标题，可以随便填，粘贴在你电脑上生成的 key 2查看当前的远程库 \u0026mdash;\u0026mdash; git remote -v 3拉取远程仓库 1.从远程仓库下载新分支与数据 \u0026mdash;\u0026mdash; git fetch\n2从远端仓库提取数据并尝试合并到当前分支 \u0026mdash;\u0026mdash; git merge\n4推送到远程仓库 \u0026mdash;\u0026mdash; git push origin branch(branch为远程仓库的分支名) 5删除远程仓库 \u0026mdash;\u0026mdash; git remote rm origin 7.git 服务器搭建 1.安装 git \u0026mdash;\u0026mdash;sudo apt-get install git(ubuntu下的下载,windows可上网查询) 接下来我们 创建一个用户用来运行git服务的用户 $ sudo adduser zhugeqing 2.创建证书登录 虽然是私有的Git服务器，但是也不能允许主机随意向Git服务器推送代码。因此，必须将需要使用Git服务器，即需要登录到Git服务器的主机的公钥（即id_rsa.pub文件）导入Git服务器的/home/git/.ssh/authorized_keys文件里，一行一个 ###3.初始化Git仓库\n如果我们使用/tmp/xingyouji.git做为远程仓库，则需要在/tmp目录下执行： sudo git init \u0026ndash;bare xingyouji.git 以上命令Git创建一个空仓库，服务器上的Git仓库通常都以.git结尾。然后，把仓库所属用户改为git: sudo chown -R zhugeqing:zhugeqing xingyouji.git ###4.克隆仓库\ngit clone git@192.168.45.4:/home/gitrepo/xingyouji.git 192.168.45.4 为 Git 所在服务器 ip ，你需要将其修改为你自己的 Git 服务 ip，这样我们的 Git 服务器安装就完成。 8.Git Gitee（码云) 大家都知道国内访问 Github 速度比较慢，很影响我们的使用。如果你希望体验到 Git 飞一般的速度，可以使用国内的 Git 托管服务——Gitee（gitee.com）， Gitee 提供免费的 Git 仓库，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee 还提供了项目管理、代码托管、文档管理的服务，5 人以下小团队免费 。 1.我们先在 Gitee 上注册账号并登录后，然后上传自己的 SSH 公钥\n2.其他操作根据需求操作，与上述操作无大区别\n  ","description":"关于git 的使用","id":13,"section":"about","tags":null,"title":"git笔记","uri":"https://2110833194.github.io/about/git/"},{"content":"一、B语言 B语言之父：Ken Thompson（肯.汤普森）。B语言是贝尔实验室开发的一种通用的程序设计语言，它是于1969年前后Ken Thompson（肯.汤普森）在Dennis Ritchie丹尼斯.里奇（Dennis Ritchie）的支持下设计出来。该语言得名于汤姆森的妻子Bonnie，它是一门开发于60年代中期的语言，现在使用者已经很少了。\n  二、C语言 C语言之父：Dennis Ritchie（丹尼斯·里奇）。美国著名计算机专家、C语言发明人、UNIX之父。在1969-1973年期间发明了C语言和Unix操作系统。\n到了70年代，诞生了一门非常重要的语言，这就是今天的大名鼎鼎的C语言。而C语言之父是美国著名的计算机专家。丹尼斯.利奇。 在开发C语言的时候其实是以B语言为基础。之所以发明C语言，实际上是因为这两个人，刚刚的B语言之父肯.汤普森和丹尼斯.里奇，一块写了一个操作系统，就是Unix系统。在写Unix系统的过程中，需要一种便利的语言，而B语言又达不到这个要求，所以丹尼斯.里奇就在B语言上进行改造，发明了C语言。目前 C语言是世界上最常用的程序语言之一。自从被C语言取代之后，B语言几乎已遭弃置。\n  三、Unix系统 Unix之父：Dennis Ritchie（丹尼斯·里奇）及Ken Thompson（肯.汤普森）\n提到C语言就不得不说一下Unix系统。而Unix之父，自然就是这两个人，左侧这个是B语言之父肯汤普森。右侧这个是C语言之父丹尼斯.里奇。有意思的是，肯.汤普森当年开发 Unix的初衷是运行他编写的一款计算机游戏 Space Travel，这款游戏模拟太阳系天体运动，由玩家驾驶飞船，观赏景色并尝试在各种行星和月亮上登录。他先后在多个系统上试验，但运行效果不甚理想，于是决定自己开发操作系统，就这样，Unix 诞生了。英文中的前缀 Uni 是小的意思，小而且巧。这是 Unix 的设计初衷，这个理念也一直影响至今。 因为他们俩在1973年左右的时候发明了Unix操作系统，也因此获得了1983年的图灵大奖。这个奖项就相当于IT行业的诺贝尔奖。\n  四、C++语言 C++之父：Bjarne Stroustrup（本贾尼·斯特劳斯特卢普）。1982年，美国贝尔实验室的Bjarne Stroustrup博士在C语言的基础上引入并扩充了面向对象的概念，发明了—种新的程序语言。为了表达该语言与c语言的渊源关系，它被命名为C++。\n  五、Python语言 Python之父：Guido van Rossum（吉多.范.罗苏姆）。1989年，为了打发圣诞节假期，Guido开始写Python语言的编译/解释器。1994年发布1.0版本。2019年10月发布了Python3.5版。\npython语言的理念就是：人生苦短，我用python。吉多推崇的是简洁，大方，美观，精致。吉多一直认为python是一门很优秀的语言，实际上python也确实是可以做各个行业，无论是web开发，还是服务器端维护，还有爬虫等等，但是在每个方向上都没有做到最精，所以在某些地方没有得到很大的体现。但是吉多一直认为酒香不怕巷子深，所以也没有大力的宣传。但是近几年随着人工智能也被大众所熟知。\n  六、Java语言 Java之父是James Gosling（詹姆斯.高斯林）。1991年开发Oak，1994年更名为Java。1995年5月正式发布。\n实际上python比java的产生还要更早一点。java的出现，正是互联网大力兴起的时候，而java因为语言的特性，在互联网上有很大的优势，发布最初就异常火爆，掩盖住了python的势头。java最初的模型是在1991年的时候开发出，他的创始人詹姆斯高斯林。那个时候还叫做Oak橡树，后来詹姆斯希望使用java语言可以像喝咖啡一样轻松，愉悦。改名为java。\n  七、JavaScript语言 Javascript之父是Brendan Eich（布兰登.艾奇)。JavaScript，是一门运行在浏览器端的脚本语言。这门语言是由网景公司在1995年发布的。当时网景公司主要是做浏览器方面，他们想把java语言应用在浏览器端，能够实现一些比如用户登录并验证的工作。招聘了一个新员工，叫做布兰登.艾奇，布兰登对java没有兴趣，为了应付公司的任务，只用了10天时间就设计出了JavaScript这门语言。但是JavaScript发展至今，随着前端开发异常的火爆，它已经是浏览器端的龙头语言了。\n  八、Golang Go的三个作者分别是： Rob Pike（罗伯.派克），Ken Thompson（肯.汤普森）和Robert Griesemer（罗伯特.格利茨默）\n  ","description":"了解知名语言的发展简史","id":14,"section":"golang","tags":null,"title":"第1节：知名编程语言或系统的发展简史","uri":"https://2110833194.github.io/golang/article/goinitial/1/"},{"content":"一、 为什么需要一个新的语言 最近十年来，C/C++在计算领域没有很好得到发展，并没有新的系统编程语言出现。对开发程度和系统效率在很多情况下不能兼得。要么执行效率高，但低效的开发和编译，如C++；要么执行低效，但拥有有效的编译，如.NET、Java；所以需要一种拥有较高效的执行速度、编译速度和开发速度的编程语言，Go就横空出世了\n传统的语言比如c++，大家花费太多时间来学习如何使用这门语言，而不是如何更好的表达写作者的思想，同时编译花费的时间实在太长，对于编写-编译-运行这个链条来说周期太长。动态语言如Python，由于没有强类型的约束，很多问题需要在运行时发现，这种低级错误更应该交给编译器来发现。\n 人力成本越来越高 机器越来越便宜 机器的性能越来越厉害 在开发效率和运行速度上达到平衡  go出现之前，无论汇编语言、还是动态脚本语言，在执行效率和开发效率上都不能兼备。  执行效率 execution speed： C/C++ \u0026gt; Java \u0026gt; PHP 开发效率 developing efficiency： PHP \u0026gt; Java \u0026gt; C/C++   二、 谷歌工程师的20%时间 谷歌的“20%时间”工作方式，允许工程师拿出20%的时间来研究自己喜欢的项目。语音服务Google Now、谷歌新闻Google News、谷歌地图Google Map上的交通信息等，全都是20%时间的产物。\nGo语言最开始也是20%时间的产物。\n 三、 创始人 Go的三个作者分别是： Rob Pike（罗伯.派克），Ken Thompson（肯.汤普森）和Robert Griesemer（罗伯特.格利茨默） 。\nRob Pike：曾是贝尔实验室（Bell Labs）的Unix团队，和Plan 9操作系统计划的成员。他与Thompson共事多年，并共创出广泛使用的UTF-8 字元编码。\nKen Thompson：主要是B语言、C语言的作者、Unix之父。1983年图灵奖（Turing Award）和1998年美国国家技术奖（National Medal of Technology）得主。他与Dennis Ritchie是Unix的原创者。Thompson也发明了后来衍生出C语言的B程序语言。\nRobert Griesemer：在开发Go之前是Google V8、Chubby和HotSpot JVM的主要贡献者。\n此外还有Plan 9开发者Russ Cox、和曾改善目前广泛使用之开原码编译器GCC的Ian Taylor。\n 四、 Go的缔造与发展 4.1 Go的命名   这是一封由 Rob Pike 在 2007 年 9 月 25 号，星期二，下午 3：12 回复给 Robert Griesemer、Ken Thompson 的有关编程语言讨论主题的邮件，邮件正文大意为：在开车回家的路上我得到了些灵感。1.给这门编程语言取名为“go”，它很简短，易书写。工具类可以命名为：goc、 gol、goa。交互式的调试工具也可以直接命名为“go”。语言文件后缀名为 .go 等等\n这就是 Go 语言名字的来源，自此之后 Robert、Rob 和 Ken 三个人开始在 Google 内部进行了研发，一直到了 2009 年，Go 正式开源了，Go 项目团队将 2009 年 11 月 10 日，即该语言正式对外开源的日字作为其官方生日。源代码最初托管在 http://code.google.com 上，之后几年才逐步的迁移到 GitHub 上。\n 4.2 Go的发展过程中的记事 第一个事情是在开发设计 Go 语言过程中的第一个重大惊喜是收到了以下这封邮件：\n  这是一封由 Ian Lance Taylor 在 2008 年 6月 7 日（星期六）的晚上 7：06 写给 Robert Griesemer、Rob Pike、 Ken Thompson 的关于 Go gcc 编译器前端的邮件。邮件正文大意如下：我的同事向我推荐了这个网站 http://…/go_lang.html 。这似乎是一门很有趣的编程语言。我为它写了一个 gcc 编译器前端。虽然这个工具仍缺少很多的功能，但它确实可以编译网站上展示的那个素数筛选程序了。\nIan Lance Taylor 的加入以及第二个编译器 (gcc go) 的实现 在带来震惊的同时，也伴随着喜悦。这对 Go 项目来说不仅仅是鼓励，更是一种对可行性的证明。语言的第二次实现对制定语言规范和确定标准库的过程至关重要，同时也有助于保证其高可移植性，这也是 Go 语言承诺的一部分。自此之后 Ian Lance Taylor 成为了设计和实现 Go 语言及其工具的核心人物。\n 第二件事情是 Russ Cox 在2008年带着他的语言设计天赋和编程技巧加入了刚成立不久的 Go 团队。\nRuss 发现 Go 方法的通用性意味着函数也能拥有自己的方法，这直接促成了 http.HandlerFunc 的实现，这是一个让 Go 一下子变得无限可能的特性。Russ 还提出了更多的泛化性的想法，比如 io.Reader 和 io.Writer 接口，奠定了所有 I/O 库的整体结构。\n 第三件事情是聘请了安全专家 Adam Langley 帮助 Go 走向 Google 外面的世界。\nAdam 为 Go 团队做了许多不为外人知晓的工作，包括创建最初的 http://golang.org 网站以及 build dashboard。不过他最大的贡献当属创建了 cryptographic 库。起先，在我们中的部分人看来，这个库无论在规模还是复杂度上都不成气候。但是就是这个库在后期成为了很多重要的网络和安全软件的基础，并且成为了 Go 语言开发历史的关键组成部分。许多网络基础设施公司，比如 Cloudflare，均重度依赖 Adam 在 Go 项目上的工作，互联网也因它变得更好。我记得当初 beego 设计的时候，session 模块设计的时候也得到了 Adam 的很多建议，因此，就 Go 而言，我们由衷地感谢 Adam。\n 第四个事情就是一家叫做 Docker 的公司。\n就是使用 Go 进行项目开发，并促进了计算机领域的容器行业，进而出现了像 Kubernetes 这样的项目。现在，我们完全可以说 Go 是容器语言，这是另一个完全出乎意料的结果。\n  除了大名鼎鼎的Docker，完全用GO实现。业界最为火爆的容器编排管理系统kubernetes完全用GO实现。之后的Docker Swarm，完全用GO实现。除此之外，还有各种有名的项目，如etcd/consul/flannel，七牛云存储等等 均使用GO实现。有人说，GO语言之所以出名，是赶上了云时代。但为什么不能换种说法？也是GO语言促使了云的发展。\n除了云项目外，还有像今日头条、UBER这样的公司，他们也使用GO语言对自己的业务进行了彻底的重构。\n 五、最后 Go语言是谷歌2009年发布的第二款开源编程语言（系统开发语言)，它是基于编译、垃圾收集和并发的编程语言。 Go语言专门针对多处理器系统应用程序的编程进行了优化，使用Go编译的程序可以媲美 C / C++代码的速度，而且更加安全、支持并行进程。作为出现在21世纪的语言，其近C的执行性能和近解析型语言的开发效率，以及近乎于完美的编译速度，已经风靡全球。特别是在云项目中，大部分都使用了Golang来开发。不得不说，Golang早已深入人心。而对于一个没有历史负担的新项目，Golang或许就是个不二的选择。 很多人将Go语言称为21世纪的C语言，因为Go不仅拥有C的简洁和性能。而且还很好的提供了21世纪互联网环境下服务端开发的各种实用特性。被称为Go语言之父的罗勃·派克(Rob Pike)就曾说过，你是否同意Go语言，取决于你是认可少就是多，还是少就是少(Less is more or less is less)。Go语言的整个设计哲学就是：将简单、实用体现得淋漓尽致。 如今 Go 已经是云计算编程语言，GO语言背靠Google这棵大树，又不乏牛人坐镇，是名副其实的“牛二代”。想象一下：一个只有十几年发展经历的编程语言，已经成为了如此巨大而且正在不断发展的行业的主导者，这种成功是每个人都无法想象的。 ","description":"了解Go语言的前世今生","id":15,"section":"golang","tags":null,"title":"第2节：Go语言的前世今生","uri":"https://2110833194.github.io/golang/article/goinitial/2/"},{"content":"一、 Go的logo 1.1 Go语言的logo   Go语言的logo就是很简洁的GO两个字母。 1.2 Go的吉祥物   Go之所以叫Go，是想表达这门语言的运行速度、开发速度、学习速度（develop）都像gopher一样快。\ngopher是一种生活在加拿大的小动物，go的吉祥物就是这个小动物， 它的中文名叫做囊地鼠，他们最大的特点就是挖洞速度特别快，当然可能不止是挖洞啦。\n 二、Go的官网    三、 Go语言主要发展过程  2007年9月，雏形设计 ，Rob Pike（罗伯.派克） 正式命名为Go； 2008年5月，Google全力支持该项目； 2009年11月10日，首次公开发布，Go将代码全部开源，它获得了当年的年度语言； 2011年3月16日，Go语言的第一个稳定(stable)版本r56发布。 2012年3月28日，Go语言的第一个正式版本Go1发布。 2013年4月04日，Go语言的第一个Go 1.1beta1测试版发布。 2013年4月08日，Go语言的第二个Go 1.1beta2测试版发布。 2013年5月02日，Go语言Go 1.1RC1版发布。 2013年5月07日，Go语言Go 1.1RC2版发布。 2013年5月09日，Go语言Go 1.1RC3版发布。 2013年5月13日，Go语言Go 1.1正式版发布。 2013年9月20日，Go语言Go 1.2RC1版发布。 2013年12月1日，Go语言Go 1.2正式版发布。 2014年6月18日，Go语言Go 1.3版发布。 2014年12月10日，Go语言Go 1.4版发布。 2015年8月19日，Go语言Go 1.5版发布，本次更新中移除了”最后残余的C代码”。 2016年2月17日，Go语言Go 1.6版发布。 2016年8月15日，Go语言Go 1.7版发布。 2017年2月17日，Go语言Go 1.8版发布。 2017年8月24日，Go语言Go 1.9版发布。 2018年2月16日，Go语言Go 1.10版发布。 2018年8月24日，Go语言Go 1.11版发布。 2019年2月25日，GO语言Go1.12版发布。 2019 年 9 月,GO语言Go1.13版发布。 2020 年 2 月,GO语言Go1.14版发布。\nGo 语言起源 2007 年，并于 2009 年正式对外发布。它从 2009 年 9 月 21 日开始作为谷歌公司 20% 兼职项目，即相关员工利用 20% 的空余时间来参与 Go 语言的研发工作。  其实可以看到，Go语言的历史不算很短。\n2009年11月 GO语言第一个版本发布。2012年3月 第一个正式版本Go1.0发布。\n2015年8月 go1.5发布，这个版本被认为是历史性的。完全移除C语言部分，使用GO编译GO，少量代码使用汇编实现。另外，他们请来了内存管理方面的权威专家Rick Hudson，对GC进行了重新设计，支持并发GC，解决了一直以来广为诟病的GC时延（STW）问题。并且在此后的版本中，又对GC做了更进一步的优化。到go1.8时，相同业务场景下的GC时延已经可以从go1.1的数秒，控制在1ms以内。GC问题的解决，可以说GO语言在服务端开发方面，几乎抹平了所有的弱点。\n直到2020的2月，Go语言发布最新的版本是Go 1.14。\n在GO语言的版本迭代过程中，语言特性基本上没有太大的变化，基本上维持在GO1.1的基准上，并且官方承诺，新版本对老版本下开发的代码完全兼容。事实上，GO开发团队在新增语言特性上显得非常谨慎，而在稳定性、编译速度、执行效率以及GC性能等方面进行了持续不断的优化。\nGo稳定版发布时，Go Team承诺后续的版本都会兼容之前的版本。这对于开发者来说非常重要，Go后续的版本也一直在提升内功，从而可以让用户无缝的升级Go版本。\n ","description":"了解Go语言logo和版本","id":16,"section":"golang","tags":null,"title":"第3节：Go语言logo和版本","uri":"https://2110833194.github.io/golang/article/goinitial/3/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":17,"section":"gallery","tags":null,"title":"Cartoon","uri":"https://2110833194.github.io/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":18,"section":"gallery","tags":null,"title":"Photo","uri":"https://2110833194.github.io/gallery/photo/"}]