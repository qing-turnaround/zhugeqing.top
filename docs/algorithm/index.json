[{"content":"题目：65,8,50,15,37,24,()。括号中的数字是()？ A. 25\nB. 26\nC. 22\nD. 27\n答案：\r65=8^2+1 这里将8作为65的特征\r8=3^2-1 这里得到3\r50=7^2+1 这里得到7\r15=4^2-1 这里得到4\r37=6^2+1 这里得到6\r24=5^2-1 这里得到5\r我们发现8,3,7,4,6,5 这组数的特点，以奇数项开始 奇数项加偶数项的和为11，\r以偶数项开始的话 偶数项+奇数项的和为10 8+3=7+4=6+5 3+7=4+6=5+x 这里得到x为5 特征为5 转换为5^2+1 得到26\r","description":"括号中的数字是什么?","id":0,"section":"intelligence","tags":null,"title":"智力题2.1","uri":"https://2110833194.github.io/intelligence/niuke_part2/%E6%8B%AC%E5%8F%B7%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88_1/"},{"content":"题目：5 , 6 , 6 , 9 ,（）, 90。括号中的数字是()？ A. 12\nB. 15\nC. 18\nD. 21\n答案：整个数列规律为：\r（5-3）*（6-3）=6\r（6-3）*（6-3）=9\r（6-3）*（9-3）=18\r（9-3）*（18-3）=90\r规律很多，仅供参考，自我挖掘！\r","description":"括号中的数字是什么?","id":1,"section":"intelligence","tags":null,"title":"智力题2.2","uri":"https://2110833194.github.io/intelligence/niuke_part2/%E6%8B%AC%E5%8F%B7%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88_2/"},{"content":"题目：2 ，3 ，10 ，15 ，26 ，35 ，( )。括号中的数字是是什么？ A. 40\nB. 45\nC. 50\nD. 55\n1^2+1=2 2^2-1=3 3^2+1=10 4^2-1=15 5^2+1+26 6^2-1=35 奇数项平方加一，偶数项平方减一\r","description":"括号中的数字是什么?","id":2,"section":"intelligence","tags":null,"title":"智力题2.3","uri":"https://2110833194.github.io/intelligence/niuke_part2/%E6%8B%AC%E5%8F%B7%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88_3/"},{"content":"《上部分》 这似乎是一个很凝重的话题，但是它真的很有趣。\n1. 指针是指向某一类型的东西，任何一个整体，只要能称为整体就能拥有它自己的独一无二的指针类型，所以指针的类型其实是近似无穷无尽的\n2. 函数名在表达式中总是以函数指针的身份呈现，除了取地址运算符以及sizeof\n3. C语言最晦涩难明的就是它复杂的声明: void (signal(int sig, void (func)(int)))(int),\n试试着把它改写成容易理解的形式\n4. 对于指针，尽最大的限度使用const保护它，无论是传递给函数，还是自己使用\n先来看看一个特殊的指针，姑且称它为指针，因为它依赖于环境: NULL，是一个神奇的东西。先附上定义，在编译器中会有两种NULL(每种环境都有唯一确定的NULL):\n1 2  #define NULL 0 #define NULL ((void*)0)   有什么区别吗？看起来没什么区别都是0，只不过一个是常量，一个是地址为0的指针。\n当它们都作为指针的值时并不会报错或者警告，即编译器或者说C标准认为这是合法的:\n1 2 3  int* temp_int_1 = 0; //无警告 int* temp_int_2 = (void*)0; //无警告 int* temp_int_3 = 10; //出现警告   为什么？为什么0可以赋值给指针，但是10却不行？他们都是常量。\n因为C语言规定当处理上下文的编译器发现常量0出现在指针赋值的语句中，它就作为指针使用，似乎很扯淡，可是却是如此。\n回到最开始，对于NULL的两种情况，会有什么区别？拿字符串来说，实际上我是将字符数组看作是C风格字符串。\n在C语言中，字符数组是用来存储一连串有意义的字符，默认在这些字符的结尾添加'\\0'，好这里又出现了一个0值。\n对于某些人，在使用字符数组的时候总是分不清楚NULL与'\\0\u0026rsquo;的区别而误用，在字符数组的末尾使用NULL是绝对错误的！虽然它们的本质都是常量0，但由于位置不同所以含义也不同。\n开胃菜已过\n对于一个函数，我们进行参数传递，参数有两种形式: 形参与实参\n1 2 3 4 5 6  int function(int value) { /*...*/ } //... function(11);   其中，value是形参，11是实参，我们知道场面上，C语言拥有两种传递方式:按值传递和按址传递，但是你是否有认真研究过？这里给出一个实质，其实C语言只有按值传递，所谓按址传递只不过是按值传递的一种假象。至于原因稍微一想便能明白。\n对于形参和实参而言两个关系紧密，可以这么理解总是实参将自己的一份拷贝传递给形参，这样形参便能安全的使用实参的值，但也带给我们一些麻烦，最经典的交换两数\n1 2 3 4 5 6 7  void swap_v1(int* val_1, int* val_2) { int temp = *val_1; *val_1 = *val_2; *val_2 = *val_1; }   这就是所谓的按址传递，实际上只是将外部指针(实参)的值做一个拷贝，传递给形参val_1与val_2，实际上我们使用:\n1 2  #define SWAP_V2(a, b) (a += b, b = a - b, a -= b) #define SWAP_V3(x, y) {x ^= y; y ^= x; x ^= y}   试一试是不是很神奇，而且省去了函数调用的时间，空间开销。上述两种写法的原理实质是一样的。\n但是，动动脑筋想一想，这种写法真的没有瑕疵吗？如果输入的两个参数本就指向同一块内存，会发生什么？\n1 2 3 4 5 6 7 8  ... int test_1 = 10, test_2 = 100; SWAP_V2(test_1, test_2); printf(\u0026#34;Now the test_1 is %d, test_2 is %d\\n\u0026#34;, test_1, test_2); .../*恢复原值*/ SWAP_V2(test_1, test_1); printf(\u0026#34;Now the test_1 is %d\\n\u0026#34;, test_1);   会输出什么？:\n1 2  $: Now the test_1 is 100, test_2 is 10 $: Now the test_1 is 0   对，输出了0，为什么？稍微动动脑筋就能相通，那么对于后面的SWAP_V3亦是如此，所以在斟酌之下，解决方案应该尽可能短小精悍:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  static inline void swap_final(int* val_1, int* val_2) { if(val_1 == val_2) return; *val_1 ^= *val_2; *val_2 ^= *val_1; *val_1 ^= *val_2; } #define SWAP(x, y) do{ if(\u0026amp;x == \u0026amp;y) break; x ^= y; y ^= x; x ^= y; }while(0)   这便是目前能找到最好的交换函数，我们在此基础上可以考虑的更深远一些，如何让这个交换函数更加通用？即适用范围更大？暂不考虑浮点类型。\n提示：可用void*\n与上面的情况类似，偶尔的不经意就会造成严重的后果:\n1 2 3 4 5 6 7 8 9 10 11  int combine_1(int* dest, int* add) { *dest += *add; *dest += *add; return *dest; } int combine_2(int* dest, int* add) { *dest += 2 * (*add);//在不确定优先级时用括号是一个明智的选择  return *dest; }   上述两个函数的功能一样吗？恩看起来是一样的\n1 2 3 4 5 6  int test_3 = 10, test_4 = 100; combine_1(\u0026amp;test_3, \u0026amp;test_4); printf(\u0026#34;After combine_1, test_3 = %d\\n\u0026#34;,test_3); .../*恢复原值*/ combine_2(\u0026amp;test_3, \u0026amp;test_4); printf(\u0026#34;After combine_2, test_3 = %d\\n\u0026#34;,test_3);   输出\n1 2 3 4  $: After combine_1, test_3 = 210 $: After combine_2, test_3 = 210   如果传入两个同一对象呢？\n1 2 3 4 5 6  ... /*恢复test_3原值*/ combine_1(\u0026amp;test_3, \u0026amp;test_3); printf(\u0026#34;After second times combine_1, test_3 = %d\\n\u0026#34;,test_3); ... combine_2(\u0026amp;test_3, \u0026amp;test_3); printf(\u0026#34;After second times combine_2, test_3 = %d\\n\u0026#34;,test_3);   输出\n1 2 3  $: After second times combine_1, test_3 = 40 $: After second times combine_2, test_3 = 30   知道真相总是令人吃惊，指针也是那么令人又爱又恨。\n C99 标准之后出现了一个新的关键字， restrict，被用于修饰指针，它并没有太多的显式作用，甚至加与不加，在 你自己 看来，效果毫无区别。但是反观标准库的代码中，许多地方都使用了该关键字，这是为何\n首先这个关键字是写给编译器看的\n其次这个关键字的作用在于辅助编译器更好的优化该程序(后方文章会有介绍)\n最后，如果不熟悉，绝对不要乱用这个关键字  关于数组的那些事\n数组和指针一样吗？\n不一样!\n要时刻记住，数组与指针是不同的东西。但是为什么下面代码是正确的？\n1 2  int arr[10] = {10, 9, 8, 7}; int* parr = arr;   我们还是那句话，结合上下文，编译器推出 arr处于赋值操作符的右侧，默默的将他转换为对应类型的指针，而我们在使用arr时也总是将其当成是指向该数组内存块首位的指针。\n1 2 3 4 5 6 7 8 9 10  //int function2(const int test_arr[10] //int function2(const int test_arr[]) 考虑这三种写法是否一样 int function2(const int* test_arr) { return sizeof(test_arr); } int size_out = sizeof(arr); int size_in = function2(arr); printf(\u0026#34;size_out = %d, size_in = %d\\n\u0026#34;, size_out, size_in);   1  输出: size_out = 40, size_in = 8   这就是为什么数组与指针不同的原因所在，在外部即定义数组的代码块中，编译器通过上下文发觉此处arr是一个数组，而arr代表的是一个指向10个int类型的数组的指针，只所谓最开始的代码是正确的，只是因为这种用法比较多，就成了标准的一部分。就像世上本没有路，走的多了就成了路。”正确”的该怎么写\n1  int (*p)[10] = \u0026amp;arr;   此时p的类型就是一个指向含有10个元素的数组的指针,此时(*p)[0]产生的效果是arr[0]，也就是parr[0]，但是(*p)呢？这里不记录，结果是会溢出，为什么？\n这就是数组与指针的区别与联系，但是既然我们可以使用像parr这样的指针，又为什么要写成int (*p)[10]这样丑陋不堪的模式呢？原因如下:\n回到最开始说过的传递方式，按值传递在传递arr时只是纯粹的将其值进行传递，而丢失了上下文的它只是一个普通指针，只不过我们程序员知道它指向了一块有意义的内存的起始位置，我想要将数组的信息一起传递，除了额外增加一个参数用来记录数组的长度以外，也可以使用这个方法，传递一个指向数组的指针\n这样我们就能只传递一个参数而保留所有信息。但这么做的也有限制:对于不同大小，或者不同存储类型的数组而言，它们的类型也有所不同\n1 2 3 4  int arr_2[5]; int (*p_2)[5] = \u0026amp;arr_2; float arr_3[5]; float (*p_3)[5] = \u0026amp;arr_3;   如上所示，指向数组的指针必须明确指定数组的大小，数组存储类型，这就让指向数组的指针有了比较大的限制。\n这种用法在多维数组中使用的比较多，但总体来说平常用的并不多，就我而言，更倾向于使用一维数组来表示多维数组，实际上诚如前面所述，C语言是一个非常简洁的语言，它没有太多的废话，就本质而言C语言并没有多维数组，因为内存是一种线性存在，即便是多维数组也是实现成一维数组的形式。\n就多维数组在这里解释一下。所谓多维数组就是将若干个降一维的数组组合在一起，降一维的数组又由若干个更降一维的数组组合在一起，直到最低的一维数组，举个例子:\n1  int dou_arr[5][3];   就这个二维数组而言，将5个每个为3个int类型的数组组合在一起，要想指向这个数组该怎么做？\n1 2 3  int (*p)[3] = \u0026amp;dou_arr[0]; int (*dou_p)[5][3] = \u0026amp;dou_arr; int (*what_p)[3] = dou_arr;   实际上多维数组只是将多个降一维的数组组合在一起，令索引时比较直观而已。当真正理解了内存的使用，反而会觉得多维数组带给自己更多限制\n对于第三句的解释，当数组名出现在赋值号右侧时，它将是一个指针，类型则是 指向该数组元素的类型，而对于一个多维数组来说，其元素类型则是其降一维数组，即指向该降一维数组的指针类型。这个解释有点绕，自己动手写一写就好很多。\n对于某种形式下的操作，我们总是自然的将相似的行为结合在一起考虑。考虑如下代码:\n1 2 3  int* arr_3[5] = {1, 2, 3, 4, 5}; int* p_4 = arr_3; printf(\u0026#34;%d == %d == %d ?\\n\u0026#34;, arr_3[2], *(p_4 + 2), *(arr_3 + 2));     输出: 3 == 3 == 3 ?\n  实际上对于数组与指针而言， []操作在大多数情况下都能有相同的结果，对于指针而言*(p_4 + 2)相当于p_4[2]，也就是说[]便是指针运算的语法糖，有意思的是2[p_4]也相当于p_4[2]，\u0026ldquo;Iamastring\u0026rdquo;[2] == \u0026rsquo;m'，但这只是娱乐而已，实际中请不要这么做，除非是代码混乱大赛或者某些特殊用途。\n在此处，应该声明的是这几种写法的执行效率完全一致，并不存在一个指针运算便快于[]运算，这些说法都是上个世纪的说法了，随着时代的发展，我们应该更加注重代码整洁之道\n  在此处还有一种奇异又实用的技巧，在char数组中使用指针运算进行操作，提取不同类型的数据，或者是在不同类型数组中，使用char*指针抽取其中内容，才是显示指针运算的用途。但在使用不同类型指针操作内存块的时候需要注意，不要操作无意义的区域或者越界操作。\n  实际上，最简单的安全研究之一，便是利用溢出进行攻击。\n Advance:对于一个函数中的某个数组的增长方向，总是向着返回地址的，中间可能隔着许多其他自动变量，我们只需要一直进行溢出试验，直到某一次，该函数无法正常返回了！那就证明我们找到了该函数的返回地址存储地区，这时候我们可以进行一些操作，例如将我们想要的返回地址覆盖掉原先的返回地址，这就是所谓的溢出攻击中的一种。  《下部分》 内存的使用的那些事儿\n你一直以为你操作的是真实物理内存，实际上并不是，你操作的只是操作系统为你分配的资格虚拟地址，但这并不意味着我们可以无限使用内存，那内存卖那么贵干嘛，实际上存储数据的还是物理内存，只不过在操作系统这个中介的介入情况下，不同程序窗口(可以是相同程序)可以共享使用同一块内存区域，一旦某个傻大个程序的使用让物理内存不足了，我们就会把某些没用到的数据写到你的硬盘上去，之后再使用时，从硬盘读回。这个特性会导致什么呢？假设你在Windows上使用了多窗口，打开了两个相同的程序:\n1 2 3 4 5 6 7 8 9 10 11 12 13  ... int stay_here; char tran_to_int[100]; printf(\u0026#34;Address: %p\\n\u0026#34;,\u0026amp;stay_here); fgets(tran_to_int,sizeof(tran_to_int), stdin); sscanf(tran_to_int,\u0026#34;%d\u0026#34;,\u0026amp;stay_here); for(;;) { printf(\u0026#34;%d\\n\u0026#34;, stay_here); getchar(); ++stay_here; } ...   对此程序(引用前桥和弥的例子)，每敲击一次回车，值加1。当你同时打开两个该程序时，你会发现，两个程序的stay_here都是在同一个地址，但对它进行分别操作时，产生的结果是独立的！这在某一方面验证了虚拟地址的合理性。虚拟地址的意义就在于，即使一个程序出现了错误，导致所在内存完蛋了，也不会影响到其他进程。对于程序中部的两个读取语句，是一种理解C语言输入流本质的好例子，建议查询用法，这里稍微解释一下:\n通俗地说，fgets将输入流中由调用起，stdin输入的东西存入起始地址为tran_to_int的地方，并且最多读取sizeof(tran_to_int)个，并在后方sscanf函数中将刚才读入的数据按照%d的格式存入stay_here，这就是C语言一直在强调的流概念的意义所在，这两个语句组合看起来也就是读取一个数据这么简单，但是我们要知道一个问题，一个关于scanf的问题\nscanf(\u0026quot;%d\u0026quot;,\u0026amp;stay_here);\n这个语句将会读取键盘输入，直到回车之前的所有数据，什么意思？就是回车会留在输入流中，被下一个输入读取或者丢弃。这就有可能会影响我们的程序，产生意料之外的结果。而使用上当两句组合则不会。\n函数与函数指针的那些事\n事实上，函数名出现在赋值符号右边就代表着函数的地址\n1 2 3 4 5  intfunction(int argc){/*...*/ } ... int(*p_fun)(int)=function; int(*p_fuc)(int)=\u0026amp;function;//和上一句意义一致   上述代码即声明并初始化了函数指针，p_fun的类型是指向一个返回值是int类型，参数是int类型的函数的指针\n1 2 3  p_fun(11); (*p_fun)(11); function(11);   上述三个代码的意义也相同，同样我们也能使用函数指针数组这个概念\nint(*p_func_arr[])(int)={func1, func2,};\r其中func1,func2都是返回值为int参数为int的函数，接着我们能像数组索引一样使用这个函数了。\nTips: 我们总是忽略函数声明，这并不是什么好事。\n在C语言中，因为编译器并不会对有没有函数声明过分深究，甚至还会放纵，当然这并不包含内联函数(inline)，因为它本身就只在本文件可用。\n比如，当我们在某个地方调用了一个函数，但是并没有声明它：\n1  CallWithoutDeclare(100);//参数100为 int 型   那么，C编译器就会推测，这个使用了int型参数的函数，一定是有一个int型的参数列表，一旦函数定义中的参数列表与之不符合，将会导致参数信息传递错误(编译器永远坚信自己是对的！)，我们知道C语言是强类型语言，一旦类型不正确，会导致许多意想不到的结果(往往是Bug)发生。\n对函数指针的调用同样如此\nC语言中malloc的那些事儿\n我们常常见到这种写法:\n1  int* pointer =(int*)malloc(sizeof(int));   这有什么奇怪的吗？看下面这个例子:\nint* pointer_2 = malloc(sizeof(int));\n哪个写法是正确的？两个都正确，这是为什么呢，这又要追求到远古C语言时期，在那个时候， void* 这个类型还没有出现的时候，malloc 返回的是 char* 的类型，于是那时的程序员在调用这个函数时总要加上强制类型转换，才能正确使用这个函数，但是在标准C出现之后，这个问题不再拥有，由于任何类型的指针都能与 void* 互相转换，并且C标准中并不赞同在不必要的地方使用强制类型转换，故而C语言中比较正统的写法是第二种。\n题外话: C++中的指针转换需要使用强制类型转换，而不能像第二种例子，但是C++中有一种更好的内存分配方法，所以这个问题也不再是问题。\nTips:\nC语言的三个函数malloc, calloc, realloc都是拥有很大风险的函数，在使用的时候务必记得对他们的结果进行校验，最好的办法还是对他们进行再包装，可以选择宏包装，也可以选择函数包装。\nrealloc函数是最为人诟病的一个函数，因为它的职能过于宽广，既能分配空间，也能释放空间，虽然看起来是一个好函数，但是有可能在不经意间会帮我们做一些意料之外的事情，例如多次释放空间。正确的做法就是，应该使用再包装阉割它的功能，使他只能进行扩展或者缩小堆内存块大小。\n指针与结构体\n1 2 3 4 5 6 7 8 9 10 11  typedefstruct tag{ int value; long vari_store[1]; }vari_struct; ```c 乍一看，似乎是一个很中规中矩的结构体 ```c ... vari_struct vari_1; vari_struct* vari_p_1 =\u0026amp;vari_1; vari_struct* vari_p_2 = malloc(sizeof(vari_struct))(   似乎都是这么用的，但总有那么一些人想出了一些奇怪的用法\n1 2  int what_spa_want =10; vari_struct* vari_p_3 = malloc(sizeof(vari_struct)+sizeof(long)*what_spa_want);    这么做是什么意思呢？这叫做可变长结构体，即便我们超出了结构体范围，只要在分配空间内，就不算越界。what_spa_want解释为你需要多大的空间，即在一个结构体大小之外还需要多少的空间，空间用来存储long类型，由于分配的内存是连续的，故可以直接使用数组vari_store直接索引。\n而且由于C语言中，编译器并不对数组做越界检查，故对于一个有N个数的数组arr，表达式\u0026amp;arr[N]是被标准允许的行为，但是要记住arr[N]却是非法的。\n这种用法并非是娱乐，而是成为了标准(C99)的一部分，运用到了实际中  对于内存的理解\n在内存分配的过程中，我们使用 malloc 进行分配，用 free 进行释放，但这是我们理解中的分配与释放吗？\n在调用 malloc 时，该函数或使用 brk() 或使用 mmap() 向操作系统申请一片内存，在使用时分配给需要的地方，与之对应的是 free，与我们硬盘删除东西一样，实际上:\n1 2 3 4  int* value = malloc(sizeof(int)*5); ... free(value); printf(\u0026#34;%d\\n\u0026#34;, value[0]);   代码中，为什么在 free 之后，我又继续使用这个内存呢？因为 free 只是将该内存标记上释放的标记，示意分配内存的函数，我可以使用，但并没有破坏当前内存中的内容，直到有操作对它进行写入。\n这便引申出几个问题:\nBug更加难以发现，让我们假设，如果我们有两个指针p1,p2指向同一个内存，如果我们对其中某一个指针使用了 free(p1); 操作，却忘记了还有另一个指针指向它，那这就会导致很严重的安全隐患，而且这个隐患十分难以发现，原因在于这个Bug并不会在当时显露出来，而是有可能在未来的某个时刻，不经意的让你的程序崩溃。\n有可能会让某些问题更加简化，例如释放一个条条相连的链表域。\n某些大哥提到说，free并不是什么都不做，而是将该段地址空间的前面一小部分置零\n但是如果地址空间很长的话，依旧有误用的风险，希望大家还是警惕\n实际上之所以库作者不让free操作将地址空间清空，有一部分原因是为了性能考虑，因为置零操作是一个消耗性能的行为，具体可以自行尝试，所谓双刃剑就在于此。\n 总的来说，还是那句话C语言是一把双刃剑。     所以，指针其实就是一个存放了另外一个存储空间的地址的存储空间，从而可以由本指针存储空间访问到另外一个存储空间！      \u0026mdash;\u0026ndash;摘抄自《c语言进阶》一书\n","description":"都2020年了，还搞不懂c语言指针是什么？","id":3,"section":"article","tags":null,"title":"c语言指针！","uri":"https://2110833194.github.io/article/program/c/c_pointer/"},{"content":"题目：一台指针式钟表的时针和分针指向的重合的时间间隔是？\n答案：\r由于分针总是比时针走的快，所以问题就转换成时针在一圈的范围内追击分针的问题：\r分针走的角速度是360°/60分 = 6°/分\r时针走的角速度是360°/720分 = 0.5°/分\r下一次追到比上一次追到，分针比时针多走过的角度是360°，\r那么在一圈的角度内 360°/(6°/分-0.5°/分) = 720/11 分钟，\r经过这么多时间 分针和时间重合一次，\r所以引申到一昼夜时间内分针 时针相遇多少次：24*60/(720/11) = 22 次\r","description":"时针和分针指向的重合的时间间隔是？","id":4,"section":"intelligence","tags":null,"title":"智力题1.3","uri":"https://2110833194.github.io/intelligence/niuke_part1/%E6%97%B6%E9%92%88%E4%B8%8E%E5%88%86%E9%92%88%E9%87%8D%E5%90%88/"},{"content":"题目：对一批编号为1～100，全部开关朝上(开)的灯进行以下操作：\n凡是1的倍数反方向拨一次开关；2的倍数反方向又拨一次开关；\n3的倍数反方向又拨一次开关……100的倍数反方向又拨一次开关 ,\n问：最后为关熄状态的灯有几个?\n答案：分析：所有的灯都会根据它是否是某数的倍数来拨动开关，比如1是1的倍数，\r但它不是其他剩余99个数的倍数，故只拨动一次开关，初始状态为开，\r只要经过奇数次拨动开关，最终状态都会是关着的灯\r进一步分析：上述分析又可以根据题意来化解为只有这个编号含有奇数个因数的灯，\r在经过所有关灯操作之后，它的最终状态就是关闭的，所以2不是（1，2），\r3不是（1,3）,4是(1，2，4)，...9是（1,3,9）,...16是（1,2,4,8,16），\r发现规律的吧，1的平方，2的平方，3的平方，4的平方，\r所有1-100一共有10个最后为关熄状态的灯。\r","description":"最后为关熄状态的灯有几个?","id":5,"section":"intelligence","tags":null,"title":"智力题1.4","uri":"https://2110833194.github.io/intelligence/niuke_part1/%E6%9C%80%E5%90%8E%E4%B8%BA%E5%85%B3%E7%86%84%E7%8A%B6%E6%80%81%E7%9A%84%E7%81%AF%E6%9C%89%E5%87%A0%E4%B8%AA/"},{"content":"题目：假设一个5位数字的180度旋转图像是另一个5位数字，并且这两个数字之间的差是78633，那么原始的5位数字是什么？\n答案：\r首先，只有0，1，2，6，8，9，6个数字反转仍有效。另外要注意，旋转180度，\r数字所在位也变了。考虑首位和末位，要求差为7和3，只有1和8满足。\r1xxx8和8xxx1。考虑倒数第二位3，由于末位退位，要求差4，只有0和6。\r所以是10x68和89x01。最后看中间，78633+10x68=89x01。\r所有原始数字是10968或者89601\r","description":"原始的5位数字是什么？","id":6,"section":"intelligence","tags":null,"title":"智力题1.5","uri":"https://2110833194.github.io/intelligence/niuke_part1/%E5%8E%9F%E5%A7%8B%E7%9A%845%E4%BD%8D%E6%95%B0%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88/"},{"content":"题目：医院里的医务人员，包括我在内，总共是16名医生和护士。下面讲到的人员情况，无论是否把我计算在内，都不会有任何变化。在这些医务人员中： (1)护士多于医生;(2)男医生多于男护士;(3)男护士多於女护士;(4)至少有一位女医生。 这位说话的人是什么性别和职务？\n答案：\r先考虑不把说话者计算在内的情况，这时医生和护士共有15名。\r首先由条件（1）可知，则护士至少应有8名；再由条件（3）可知，\r则男护士至少有5名；接着由条件（2）可知，男医生至少有6名；\r结合条件（4）可知，医生至少有7名，则护士至多8名。所以，\r要满足条件，只能是护士8名，其中男护士5名，女护士3名，医生7名，\r其中男医生6名，女医生1名。加上说话者后，要仍满足这四个条件，\r由条件（1）可知，说话者是护士；由条件（2）可知，说话者不能是男护士，\r所以只能是女护士。\r","description":"题目：这位说话的人是什么性别和职务","id":7,"section":"intelligence","tags":null,"title":"智力题3.1","uri":"https://2110833194.github.io/intelligence/niuke_part3/%E8%BF%99%E4%BD%8D%E8%AF%B4%E8%AF%9D%E7%9A%84%E4%BA%BA%E6%98%AF%E4%BB%80%E4%B9%88%E6%80%A7%E5%88%AB%E5%92%8C%E8%81%8C%E5%8A%A1/"},{"content":"题目：\n已知每个城市的用水需求相同，每月水库的进水速率恒定不变。现有一座水库供水，如果供应10个城市的话，一个月水库就会枯竭；如果供应8个城市的话，一个半月水库就会枯竭。当前城市化进程不断加快，新的城市不断产生，为了能够持续满足12个城市的供水，还至少需要建设几个这样的水库？\n假设水库库存的水量为M\r水库每月进水为X\r每个城市每月消耗水m\r由题意：\rM + X = 10 * m\rM + 1.5 * X = 8 * m * 1.5\r解得：\rX = 4m\r因此：\r要维持12个城市每月持续不断的供水，要满足：(?) * X = m * 12\r解得：(?) = 3\r题目问的是：\u0026quot;还至少需要建设几个这样的水库？\u0026quot;\r不应该是2个吗？(因为现在已经有一个水库了...)\r","description":"还至少需要建设几个这样的水库?","id":8,"section":"intelligence","tags":null,"title":"智力题4.1","uri":"https://2110833194.github.io/intelligence/niuke_part4/%E8%BF%98%E8%87%B3%E5%B0%91%E9%9C%80%E8%A6%81%E5%BB%BA%E8%AE%BE%E5%87%A0%E4%B8%AA%E8%BF%99%E6%A0%B7%E7%9A%84%E6%B0%B4%E5%BA%93/"},{"content":"题目：把21、26、65、99、10、35、18、77分成若干组，要求每组中任意两个数都互质，至少要分成多少组。\n答案：1.首先把含有相同因数的数分到一组，或者是没有相同因数的质数分为一组\r2.列出来：含有因数3的：21，99，18。含有因数5的：10，35，65。\r是质数（77不是质数，但剩下的数里面没有和它有相同因数的，故分到一组）的：26，77\r3.然后把这些组组合起来，所以至少是三组。\r解惑（思路有很多，比如也可以在第一第二步选择将偶数分为一组，然后再细分）\r","description":"题目：至少要分为多少组？","id":9,"section":"intelligence","tags":null,"title":"智力题4.2","uri":"https://2110833194.github.io/intelligence/niuke_part4/%E8%87%B3%E5%B0%91%E8%A6%81%E5%88%86%E4%B8%BA%E5%A4%9A%E5%B0%91%E7%BB%84/"},{"content":"题目：1000 个瓶子中有一瓶毒药，一只老鼠吃到毒药一周之内会死，如果要在一周之内检测出有毒药的一瓶，问至少需要几只老鼠？\nA:8\nB:10\nC:24\nD:999\n答案是十只 000=0\r001=1\r010=2\r011=3\r100=4\r101=5\r110=6\r111=7\r一位表示一个老鼠，0-7表示8个瓶子。\r也就是分别将1、3、5、7号瓶子的药混起来给老鼠1吃，\r2、3、6、7号瓶子的药混起来给老鼠2吃，\r4、5、6、7号瓶子的药混起来给老鼠3吃，\r哪个老鼠死了，相应的位标为1。\r如老鼠1死了、老鼠2没死、老鼠3死了，\r那么就是101=5号瓶子有毒。\r同样道理10个老鼠可以确定1000个瓶子\r","description":"问至少需要几只老鼠？","id":10,"section":"intelligence","tags":null,"title":"智力题1.1","uri":"https://2110833194.github.io/intelligence/niuke_part1/%E8%80%81%E9%BC%A0%E6%B5%8B%E6%AF%92%E8%8D%AF/"},{"content":"1\n1 1\n2 1\n1 2 1 1\n1 1 1 2 2 1\n下一行是什么\nA:1111211\nB:312211\nC:312112\nD:213112\n微软的题\r答案：后一行数是前一行数的描述，把“个”字去掉组成新的数：\r-1：1个1 ——11\r- 11：2个1——21\r- 21：1个2，1个1——1211\r- 1211：1个1,1个2,2个1——111221\r- 111221：3个1，2个2，1个1——312211\r","description":"题目：下一行输出什么","id":11,"section":"intelligence","tags":null,"title":"智力题1.2","uri":"https://2110833194.github.io/intelligence/niuke_part1/%E4%B8%8B%E4%B8%80%E8%A1%8C%E8%AF%A5%E8%BE%93%E5%87%BA%E4%BB%80%E4%B9%88/"},{"content":"此文章借鉴于微信公众号“小林coding”\n　Go语言之父Rob Pike大神曾吐槽：不能掌握正则表达式或浮点数就不配当码农！\nYou should not be permitted to write production code if you do not have an journeyman license in regular expressions or floating point math. 来看看一个有趣的问题，在编程语言中，0.1 + 0.2 == 0.3？，你认为是true还是false。\n来直接看看下面代码吧（下面只展示c和golang）\nc golang  1 2 3 4 5 6 7 8  #include \u0026lt;stdio.h\u0026gt; int main() { int bool_num = (0.1 + 0.2 == 0.3); printf(\u0026#34;%d\u0026#34;, bool_num); return 0; }    \r1 2 3 4 5 6 7 8 9 10  package main import( \u0026#34;fmt\u0026#34; ) func main(){ fmt.Printf(0.1+0.2==0.3) }    \r  'use strict'; var containerId = JSON.parse(\"\\\"5cdb15baa5b4cf80\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  结果出其所料，答案是false\n你可能会怀疑自己？我以前的数学老师教错了吗？或者是这计算机太蠢了吧，连这都算不清？\n别急，听我一一道来\n关于这个计算其实是两个问题了：\n1.我们日常或者说是人脑计算0.1+0.2，答案当然是0.3\n2.你把这个计算交给计算机，它得到的是0.30000000000000004（单精度）\n为什么会出现这个结果呢？这就需要一定计算机知识的人才会知道。\n什么是浮点数 我们知道，数学中并没有浮点数的概念，虽然小数看起来像浮点数，但从不这么叫。那为什么计算机中不叫小数而叫浮点数呢？\n因为资源的限制，数学中的小数无法直接在计算机中准确表示。为了更好地表示它，计算机科学家们发明了浮点数，这是对小数的近似表示。维基百科中关于浮点数的概念说明如下：\nThe term floating point refers to the fact that a number's radix point (decimal point, or, more commonly in computers, binary point) can float; that is, it can be placed anywhere relative to the significant digits of the number.（浮点数是指一个数字的小数点(小数点,或者更常见的在电脑、二进制点)可以浮动;也就是说,它可以放置在任何地方相对于数量的有效数字。\r） 具体来说，浮点数是指用符号、尾数、基数和指数这四部分来表示的小数。\n知道了浮点数的概念，但需要确定一套具体的表示、运算标准。其中最有名的就是 IEEE754 标准。William Kahan 正是因为浮点数标准化的工作获得了图灵奖。\n　标准中规定：\nfloat32位单精度浮点数在机器中表示用 1 位表示数字的符号，用 8 位表示指数，用 23 位表示尾数。\ndouble64位双精度浮点数，用 1 位表示符号，用 11 位表示指数，52 位表示尾数。\n今天，我们来一步一步思考下面这些问题，然后最后再来说说为什么计算机里 0.1 + 0.2 != 0.3。\n  为什么负数要用补码表示？\n  十进制小数怎么转成二进制？\n  计算机是怎么存小数的？\n  0.1 + 0.2 == 0.3 吗？\n  别看这些问题都看似简单，但是其实还是有点东西。\n为什么负数要用补码表示？ 十进制转换二进制的方法相信大家都熟能生巧了，如果你说你还不知道，我觉得你还是太谦虚，可能你只是忘记了，即使你真的忘记了，不怕，让我们一起来重新回顾一下\n十进制数转二进制采用的是除 2 取余法，比如数字 8 转二进制的过程如下图：\n  \n接着，我们看看「整数类型」的数字在计算机的存储方式，这其实很简单，也很直观，就是将十进制的数字转换成二进制即可。\n我们以 int 类型的数字作为例子，int 类型是 32 位的，其中最高位是作为「符号标志位」，正数的符号位是 0，负数的符号位是 1，剩余的 31 位则表示二进制数据。\n那么，对于 int 类型的数字 1 的二进制数表示如下：\n  \n而负数就比较特殊了点，负数在计算机中是以「补码」表示的，所谓的补码就是把正数的二进制全部取反再加 1，比如 -1 的二进制是把数字 1 的二进制取反后再加 1，如下图：\n  \n不知道你有没有想过，为什么计算机要用补码的方式来表示负数？在回答这个问题前，我们假设不用补码的方式来表示负数，而只是把最高位的符号标志位变为 1 表示负数，如下图过程：\n  \n如果采用这种方式来表示负数的二进制的话，试想一下 -2 + 1 的运算过程，如下图：\n  \n按道理，-2 + 1 = -1，但是上面的运算过程中得到结果却是 -3，所可以发现，这种负数的表示方式是不能用常规的加法来计算了，就需要特殊处理，要先判断数字是否为负数，如果是负数就要把加法操作变成减法操作才可以得到正确对结果。\n到这里，我们就可以回答前面提到的「负数为什么要用补码方式来表示」的问题了。\n如果负数不是使用补码的方式表示，则在做基本对加减法运算的时候，还需要多一步操作来判断是否为负数，如果为负数，还得把加法反转成减法，或者把减法反转成加法，这就非常不好了，毕竟加减法运算在计算机里是很常使用的，所以为了性能考虑，应该要尽量简化这个运算过程。\n而用了补码的表示方式，对于负数的加减法操作，实际上是和正数加减法操作一样的。你可以看到下图，用补码表示的负数在运算 -2 + 1 过程的时候，其结果是正确的：\n  \n十进制小数与二进制的转换 好了，整数十进制转二进制我们知道了，接下来看看小数是怎么转二进制的，小数部分的转换不同于整数部分，它采用的是乘 2 取整法，将十进制中的小数部分乘以 2 作为二进制的一位，然后继续取小数部分乘以 2 作为下一位，直到不存在小数为止。\n话不多说，我们就以 8.625转二进制作为例子，直接上图：\n  \n最后把「整数部分 + 小数部分」结合在一起后，其结果就是 1000.101。\n但是，并不是所有小数都可以用二进制表示，前面提到的 0.625 小数是一个特例，刚好通过乘 2 取整法的方式完整的转换成二进制。\n如果我们用相同的方式，来把 0.1 转换成二进制，过程如下：\n  \n可以发现，0.1 的二进制表示是无限循环的。\n由于计算机的资源是有限的，所以是没办法用二进制精确的表示 0.1，只能用「近似值」来表示，就是在有限的精度情况下，最大化接近 0.1 的二进制数，于是就会造成精度缺失的情况。\n对于二进制小数转十进制时，需要注意一点，小数点后面的指数幂是负数。\n比如，二进制 0.1 转成十进制就是 2^(-1)，也就是十进制 0.5，二进制 0.01转成十进制就是 2^-2，也就是十进制 0.25，以此类推。\n举个例子，二进制 1010.101 转十进制的过程，如下图：\n  \n计算机是怎么存小数的？ 1000.101 这种二进制小数是「定点数」形式，代表着小数点是定死的，不能移动，如果你移动了它的小数点，这个数就变了， 就不再是它原来的值了。\n然而，计算机并不是这样存储的小数的，计算机存储小数的采用的是浮点数，名字里的「浮点」表示小数点是可以浮动的。\n比如 1000.101 这个二进制数，可以表示成 1.000101 x 2^3，类似于数学上的科学记数法。\n既然提到了科学计数法，我再帮大家复习一下。\n比如有个很大的十进制数 1230000，我们可以也可以表示成 1.23 x 10^6，这种方式就称为科学记数法。\n该方法在小数点左边只有一个数字，而且把这种整数部分没有前导 0 的数字称为规格化，比如 1.0 x 10^(-9) 是规格化的科学记数法，而 0.1 x 10^(-9) 和 10.0 x 10^(-9) 就不是了。\n因此，如果二进制要用到科学记数法，同时要规范化，那么不仅要保证基数为 2，还要保证小数点左侧只有 1 位，而且必须为 1。\n所以通常将 1000.101 这种二进制数，规格化表示成 1.000101 x 2^3，其中，最为关键的是 000101 和 3 这两个东西，它就可以包含了这个二进制小数的所有信息：\n  000101 称为尾数，即小数点后面的数字；\n  3 称为指数，指定了小数点在数据中的位置；\n  现在绝大多数计算机使用的浮点数，一般采用的是 IEEE 制定的国际标准，这种标准形式如下图：\n  \n这三个重要部分的意义如下：\n  符号位：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；\n  指数位：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，指数位的长度越长则数值的表达范围就越大；\n  尾数位：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且尾数的长度决定了这个数的精度，因此如果要表示精度更高的小数，则就要提高尾数位的长度；\n  用 32 位来表示的浮点数，则称为单精度浮点数，也就是我们编程语言中的 float 变量，而用 64 位来表示的浮点数，称为双精度浮点数，也就是 double 变量，它们的结构如下：\n  \n可以看到：\n  double 的尾数部分是 52 位，float 的尾数部分是 23 位，由于同时都带有一个固定隐含位（这个后面会说），所以 double 有 53 个二进制有效位，float 有 24 个二进制有效位，所以所以它们的精度在十进制中分别是 log10(2^53)约等于 15.95和 log10(2^24)约等于 7.22 位，因此 double 的有效数字是 15~16 位，float 的有效数字是 7~8 位，这些是有效位是包含整数部分和小数部分；\n  double 的指数部分是 11 位，而 float 的指数位是 8 位，意味着 double 相比 float 能表示更大的数值范围；\n  那二进制小数，是如何转换成二进制浮点数的呢？\n我们就以 10.625作为例子，看看这个数字在 float 里是如何存储的。\n  \n首先，我们计算出 10.625 的二进制小数为 1010.101。\n然后把小数点，移动到第一个有效数字后面，即将 1010.101 右移 3 位成 1.010101，右移 3 位就代表 +3，左移 3 位就是 -3。\nfloat 中的「指数位」就跟这里移动的位数有关系，把移动的位数再加上「偏移量」，float 的话偏移量是 127，相加后就是指数位的值了，即指数位这 8 位存的是 10000010（十进制 130），因此你可以认为「指数位」相当于指明了小数点在数据中的位置。\n1.010101 这个数的小数点右侧的数字就是 float 里的「尾数位」，由于尾数位是 23 位，则后面要补充 0，所以最终尾数位存储的数字是 01010100000000000000000。\n在算指数的时候，你可能会有疑问为什么要加上偏移量呢？\n前面也提到，指数可能是正数，也可能是负数，即指数是有符号的整数，而有符号整数的计算是比无符号整数麻烦的，所以为了减少不必要的麻烦，在实际存储指数的时候，需要把指数转换成无符号整数。\nfloat 的指数部分是 8 位，IEEE 标准规定单精度浮点的指数取值范围是 -126 ~ +127，于是为了把指数转换成无符号整数，就要加个偏移量，比如 float 的指数偏移量是 127，这样指数就不会出现负数了。\n比如，指数如果是 8，则实际存储的指数是 8 + 127（偏移量）= 135，即把 135 转换为二进制之后再存储，而当我们需要计算实际的十进制数的时候，再把指数减去「偏移量」即可。\n细心的朋友肯定发现，移动后的小数点左侧的有效位（即 1）消失了，它并没有存储到 float 里。\n这是因为 IEEE 标准规定，二进制浮点数的小数点左侧只能有 1 位，并且还只能是 1，既然这一位永远都是 1，那就可以不用存起来了。\n于是就让 23 位尾数只存储小数部分，然后在计算时会自动把这个 1 加上，这样就可以节约 1 位的空间，尾数就能多存一位小数，相应的精度就更高了一点。\n那么，对于我们在从 float 的二进制浮点数转换成十进制时，要考虑到这个隐含的 1，转换公式如下：\n  \n举个例子，我们把下图这个 float 的数据转换成十进制，过程如下：\n  \n0.1 + 0.2 == 0.3 ? 前面提到过，并不是所有小数都可以用「完整」的二进制来表示的，比如十进制 0.1 在转换成二进制小数的时候，是一串无限循环的二进制数，计算机是无法表达无限循环的二进制数的，毕竟计算机的资源是有限。\n因此，计算机只能用「近似值」来表示该二进制，那么意味着计算机存放的小数可能不是一个真实值。\n现在基本都是用 IEEE 754 规范的「单精度浮点类型」或「双精度浮点类型」来存储小数的，根据精度的不同，近似值也会不同。\n那计算机是存储 0.1 是一个怎么样的二进制浮点数呢？\n偷个懒，我就不自己手动算了，可以使用 baseconvert 这个工具，将十进制 0.1 小数转换成 float 浮点数：\n  \n可以看到，8 位指数部分是 01111011，23 位的尾数部分是 10011001100110011001101，可以看到尾数部分是 0011 是一直循环的，只不过尾数是有长度限制的，所以只会显示一部分，所以是一个近似值，精度十分有限。\n接下来，我们看看 0.2 的 float 浮点数：\n  \n可以看到，8 位指数部分是 01111100，稍微和 0.1 的指数不同，23 位的尾数部分是 10011001100110011001101和 0.1 的尾数部分是相同的，也是一个近似值。\n0.1的二进制浮点数转换成十进制的结果是 0.100000001490116119384765625：\n  \n0.2 的二进制浮点数转换成十进制的结果是 0.20000000298023223876953125：\n  \n这两个结果相加就是 0.300000004470348358154296875：\n  \n所以，你会看到在计算机中 0.1 + 0.2 并不等于完整的 0.3。\n这主要是因为有的小数无法可以用「完整」的二进制来表示，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。\n总结 为什么负数要用补码表示？ 负数之所以用补码的方式来表示，主要是为了统一和正数的加减法操作一样，毕竟数字的加减法是很常用的一个操作，就不要搞特殊化，尽量以统一的方式来运算。\n十进制小数怎么转成二进制？ 十进制整数转二进制使用的是「除 2 取余法」，十进制小数使用的是「乘 2 取整法」。\n计算机是怎么存小数的？s 计算机是以浮点数的形式存储小数的，大多数计算机都是 IEEE 754 标准定义的浮点数格式，包含三个部分：\n  符号位：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；\n  指数位：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，指数位的长度越长则数值的表达范围就越大；\n  尾数位：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且尾数的长度决定了这个数的精度，因此如果要表示精度更高的小数，则就要提高尾数位的长度；\n  用 32 位来表示的浮点数，则称为单精度浮点数，也就是我们编程语言中的 float 变量，而用 64 位来表示的浮点数，称为双精度浮点数，也就是 double 变量。\n0.1 + 0.2 == 0.3 吗？ 不是的，0.1 和 0.2 这两个数字用二进制表达会是一个一直循环的二进制数，比如 0.1 的二进制表示为 0.0 0011 0011 0011… （0011 无限循环)，对于计算机而言，0.1 无法精确表达，这是浮点数计算造成精度损失的根源。\n因此，IEEE 754 标准定义的浮点数只能根据精度舍入，然后用「近似值」来表示该二进制，那么意味着计算机存放的小数可能不是一个真实值。\n0.1 + 0.2 并不等于完整的 0.3，这主要是因为这两个小数无法用「完整」的二进制来表示，只能根据精度舍入，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。\n学到的伙计顺便教一下身边的朋友吧（没学到的再看一遍）\n","description":"一篇文章带你了解浮点数","id":12,"section":"article","tags":["计算机"],"title":"你真的了解浮点数吗？","uri":"https://2110833194.github.io/article/computer/float/"},{"content":"1\r此文章取自于微信公众号“低并发编程”\n正文开始：\n小宇：闪客，我最近在研究动态规划，但感觉就是想不明白，你能不能给我讲讲呀？ \n闪客：没问题，这个我擅长，你先说说提到动态规划，你最先想到的是什么？\n小宇：就什么子问题呀、状态转移方程呀乱七八糟的，哎呀不行不行，我一想到这些脑子又嗡嗡响了。\n闪客：你先别急，你先把所有的名词都抛在脑后，听我讲。\n小宇：好滴，你说吧。\n闪客：小宇我问你，从 1 一直加到 100 等于多少？\n1 + 2 + 3 + ... + 100 = ？\r小宇：5050！\n闪客：你这，怎么不按套路出牌呀，你应该说不知道。\n小宇：人家高斯早就算出来了，我还装不知道，这也太假了吧。\n全剧终...\r2\r闪客：好吧，那我再给你出一个题。\n小宇：行，你说吧，这回我肯定说不知道。\n闪客：一个楼梯有 10 级台阶，你从下往上走，每跨一步只能向上迈 1 级或者 2 级台阶，请问一共有多少种走法？\n小宇：额，这我真不知道了，我想想哈。\n  \n小宇：不行了不行了，实在想不明白，想了后面的就忘了前面的。\n闪客：你还是陷入了穷举的思想，你仔细想想我给你出的第一个题，看看有没有思路。\n小宇：啊！原来是有关联的呀。\n闪客：对呀，我本来想说假如我告诉你 1+\u0026hellip;+99 是多少，你是不是就直接能算出 1+\u0026hellip;+100 的值了。\n小宇：哦你这么一提示我有点感觉了！要想走到第 10 级台阶，要么是先走到第 9 级，然后再迈一步 1 级台阶上去，要么是先走到第 8 级，然后一次迈 2 级台阶上去。\n  闪客：太棒了！你找到感觉了！接着往下说。\n小宇：这样的话，走到 10 级台阶的走法数，就等于走到 9 级台阶的走法数，加上走到 8 级台阶的走法数。\n闪客：很好，那假如走到第 x 级台阶的走法数我们定义为 F(x)，那你能把刚刚的描述公式化么？\n小宇：那太简单了，公式就是：\nF(10) = F(9) + F(8)\r闪客：没错，而且不光是 10 级台阶如此，走到任何一级台阶的走法数，都符合这个逻辑，因此就可以得出一个通用公式：\nF(x) = F(x-1) + F(x-2)\r小宇：嗯嗯，这样计算 F(10)，只需要知道 F(9) 和 F(8) 就可以了，而计算 F(8)，就只需要知道 F(7) 和 F(6) 就可以了，依次类推。\n闪客：没错，那你想想看 F(2) 和 F(1) 怎么计算？\n小宇：简单，还是刚刚都逻辑被，想知道 F(2)，只需要知道 F(1) 和 F(0)，诶不对 F(0) 是什么鬼？还有 F(1) 的计算需要知道 F(0) 和 F(-1)，不行呀，这解释不通了。\n闪客：哈哈，别急，在这道题里，如果只迈到 1 级台阶，那一共就一种走法；如果只迈到 2 级台阶，就只有两种走法。可以直接很直观地得出，没必要推导。\n  小宇：哦哦我懂了，这道题里由于每一个递推项都需要前两项的支持，所以必须有最开头的两项作为已知，就是你说的 F(1) = 1 和 F(2) = 2。\n闪客：没错。\n小宇：嗯嗯，感觉这样就推出全部结果了！我写一下程序你看看。\n闪客：先别急，由于这道题是一道经典的动态规划题，所以我们以这道题为例子来定义动态规划的三要素，在本题中\nF(x-1) 和 F(x-2) 被称为 F(x) 的最优子结构\nF(x) = F(x-1) + F(x-2) 叫状态转移方程\nF(1) = 1, F(2) = 2 是问题的边界\n之后做动态规划问题，只要找好这三个要素就好了。\n小宇：哇，升华了诶，逼格瞬间高了不少呢。\n闪客：先别说这些废话了，那接下来你看看能不能写出程序，计算出 F(10) 的结果，这才是难点。\n小宇：编程的话这似乎是个递归问题，简单！\n c golang  1 2 3 4 5 6 7 8 9  int getWays(int n) { if (n == 1) { return 1; } if (n == 2) { return 2; } return getWays(n-1) + getWays(n-2); }    \r1 2 3 4 5 6 7 8 9  func getways(n int)int{ if n == 1 { return 1 } if n == 2 { return 2 } return getWays(n-1) + getways(n-2) }    \r  'use strict'; var containerId = JSON.parse(\"\\\"b059bc293d889ef1\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \n闪客：嗯不错，这样很简洁，但复杂度太高了，是 O(2^n)，具体你可以之后想想为什么。现在你看看能不能将复杂度降低。\n小宇：我想想看，计算 F(10) 时需要计算 F(9) 和 F(8)，而在递归计算 F(9) 时要计算 F(8) 和 F(7)，这样 F(8) 在这里重复计算了，浪费了时间。\n  \n闪客：没错，其实计算新一个阶段的值，只需要一直将其前两个阶段的值保存起来，就可以一直算到最终的结果了。比如定义两个变量 a 和 b 用于存储前两个阶段的值，在计算 F(3) 时。\n\n\r\r台阶\r1\r2\r3\r4\r...\r10\r\r\r走法\ra=1\rb=2\r3\r\r\r\r\r\r\n计算 F(4) 时，F(1) 的值就不用保存了，a 和 b 依次替换新值。\n\r\r台阶\r1\r2\r3\r4\r...\r10\r\r\r走法\r\ra=2\rb=3\r5\r\r\r\r\r\n依此类推，最终就算出了 F(10) 的值。\n\r\r台阶\r1\r2\r...\r8\r9\r10\r\r\r走法\r\r\r\ra=33\rb=55\r89\r\r\r\n当然你也可以把之前的值都保留，但这样就增加了空间复杂度，看你的需求了。\n小宇：好的，那这样代码也很好写，就这样。\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  int getWays2(int n) { if (n == 1) { return 1; } if (n == 2) { return 2; } int a = 1; int b = 2; int temp = 0; for (int i = 3; i \u0026lt;= n; i++) { temp = a + b; a = b; b = temp; } return temp; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func getWays2(int n)int{ if n == 1 { return 1 } if n == 2 { return 2 } var a int = 1 var b int = 2 var temp int = 0 for i := 3; i \u0026lt;= n; i++ { temp = a + b a = b b = temp } return temp }    \r  'use strict'; var containerId = JSON.parse(\"\\\"54d85b8113d2ff7d\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  闪客：不错，这就是这道题正确的动态规划解法，而且时间复杂度是 O(N)，空间复杂度是 O(1)\n小宇：哇，这就是动态规划呀，原来这么简单。\n3\r闪客：不错，动态规划理解起来不难，难在当需要考虑的因素，也就是变化的维度多起来的时候，有的人就会头脑发蒙，不好找递推公式了，而且这也确实是个难点。\n小宇：哦是吗？\n闪客：那当然，我再给你出一道题。\n小宇：来吧兄弟。\n闪客：咳咳，那你听好了。\n有一个背包，可以装载重量为 5kg 的物品。\r有 4 个物品，他们的重量和价值如下。\r\n  \n那么请问，在不得超过背包的承重的情况下，将哪些物品放入背包，可以使得总价值最大？\r小宇：明白了，就是我用这个背包最多能装走多少钱的东西。\n闪客：是的。\n小宇：哎呀不行，我又陷入走楼梯时的遍历思想了。\n闪客：没关系，这道题能想出遍历思想，其实也不容易了，你可以先说一下，找找感觉。\n小宇：嗯嗯，那就是每个物品都可以有放入背包和不放入背包两种选择。\n如果总重量超过了背包承重，那就不算，或者说将价值记为 0，然后将所有情况中价值最大的那个作为结果。\n这样的复杂度也很容易得出，就是 O(2^N)\n闪客：没错，这个复杂度很高的算法你已经说的很明白了，那接下来你想想看用动态规划思想，能不能解决这个问题。\n小宇：好的，你之前说过，动态规划的三要素是最优子结构、状态转移方程和边界\n闪客：没错，之前的变量很少所以比较简单，现在变量多了，定义就变得难了起来，我们先来几个定义方便描述。我们将 4 个物品的重量和价值分别表示为：w1，w2，w3，w4，v1，v2，v3，v4。\n  \n假如我们用\nF(W,i) \r表示\n用载重为 W 的背包，装前 i 件物品的最大价值\r那本题其实就是\nF(5,4) 其实就是求解 你能找到状态转移方程么？\n小宇：我想想，单看这个物品 4，有两种可能：\n第一种可能：如果选择把它装入背包，那已经得到了 6 元钱。\n此时背包剩余载重为 1kg（5kg-4kg），剩余物品是除去物品 4 后的前 3 件物品。\n那这部分能获取到的最大价值，相当于\n用一个载重为 1kg 的背包，装前 3 件物品的最大价值 \n哇，那这部分就是\nF(1,3) 闪客：哈哈，你这自己说着说着就说对啦！\n小宇：所以最终，如果选择将物品 4 放入背包，这种情况下，最大价值就等于二者之和。\nF(1, 3) + 6\r\n  \n闪客：太好了小宇，那另一种情况呢？\n小宇：第二种可能：如果选择不装这个物品 4，那更简单了，就直接等于用一个载重为 5 的背包装前 3 件物品的价值。\nF(5, 3)\r\n  \n闪客：没错，而且就只有这两种情况！所以你看看 F(5,4)是否能用这两种情况的值表示呢？\n小宇：哈哈，很简单，就等于这两种情况当中的最大值呗。\nF(5,4) = max { F(1, 3) + 6，F(5, 3) }\r闪客：太好了，现在状态转移方程出来了，此时我们画个表格。\n  我们的目标就是要计算右下角那个值，即背包载重 W = 5 时，选择前 4 件物品放入背包的最大价值 F(5,4)\n小宇：哇这个表格好清晰呀，根据上面的公式\nF(5,4) = max { F(1,3) + 6, F(5,3) }\r\n那也就是说只要知道 F(1,3) 和 F(5,3) 的值就可以了对吧？\n  闪客：没错，那你再看看 F(1,3) 怎么计算？\n小宇：好的，F(1,3) 此时背包重量为 1，如果选择放第三件物品的话，诶？好像不行，第三件物品根本放不下呀！\n闪客：是的，所以这种情况就没必要讨论放第三件物品的情况了，因为根本放不下，因此 F(1,3) 直接就等于 F(1,2)，所以只需要知道 F(1,2) 即可。\n  \n同理 F(1,2) 也直接等于 F(1,1)，因为在背包重量为 1 时第二件物品也放不下。\n闪客：小宇你想想看，那 F(1,1) 又等于什么呢？\n小宇：显然嘛，现在只有一件物品可以选了，那能放下当然就放咯，所以最大价值就是第一件物品的价值 3，即 F(1,1) = 3\n闪客：没错，这样我们就找到了一个边界值，小宇你想想看还有哪些边界值可以直接得出？你写在表格里吧。\n小宇：好的，首先第一列表示背包重量为 0 时的情况，那显然什么都装不了，就全都是 0 了。\n  \n然后第一行也比较好算，背包重量 \u0026gt;= 1 时可以放下第一件物品，所以最大价值都等于 3\n  \n闪客：很好，接下来，就依次把表格的所有项都填出来，自然就可以算出 F(5,4) 啦。\n  \n小宇：哇塞，这样看好清晰呀！\n闪客：是呀，不过刚刚我们用的都是具体的数字，那我们试着把这个问题抽象化，用一个载重为 W 的背包，装载 N 件物品，每件物品的重量和价值分别用 wi 和 vi 来表示，那刚刚的状态转移方程是什么呢？\n小宇：emm，刚刚 F(5,4) = max { F(1,3) + 6, F(5,3) }，如果都用变量表示的话，就是\n\nF(W,N) = max { F(W-wn, N-1) + vn，F(W, N-1) }\r闪客：很好，这就是状态转移方程。\nF(W-wn, N-1) 和 F(W, N-1) 就是 F(W,N) 的最优子结构。\n而刚刚表格中的第一行和第一列，即 F(0,\u0026hellip;) 和 F(\u0026hellip;,1) 就是边界值！\n小宇：哇塞我爱你闪客！终于有点理解动态规划的思想了呢！\n4\r闪客：别高兴太早，虽然过程看着清晰了，但代码写起来还是有难度的，你今天回去就把代码试着实现一下吧。\n小宇：好的，保证完成任务。\n闪客：快到晚饭时间了，旁边新开了家饺子馆，要不要一块去吃呀？\n小宇：哦不了，晚上想利用晚饭时间再去消化消化动态规划的知识，不是还得代码实现呢么，下次吧，\n闪客：哦好吧~\n后记\r本文通过直观演示 01 背包问题的解题思路，简单说明了动态规划思想的算法核心。可能不少人觉得动态规划难在理解，所以花很多时间在理解其思想上。但其实理解核心思想，这一篇文章就够了，更多的是通过不断做题，反过来帮助自己理解动态规划的思想。所以希望读者在读完本文后，和小宇一样，动手将其代码实现，并找来其他变种题目，继续巩固。\n","description":"了解什么是动态规划","id":13,"section":"article","tags":["算法"],"title":"图解 | 你管这破玩意叫动态规划","uri":"https://2110833194.github.io/article/algorithm/dynamic-programming/"},{"content":"历史上，有多种辅助存储设备，比如软盘、光盘、硬盘、U 盘等，相对于内存，它们就是人们常说的“外存”，即外存储器（设备）。\n从软盘（Floppy Disk）启动计算机，这已经是过去的事了。软盘的尺寸比烟盒稍大一点，但是比较薄，采用塑料作为基片，上面是一层磁性物质，可以用来记录二进制位。这种塑料介质比较柔软，所以称为软盘。\n在数据记录原理上和软盘很相似的设备是硬盘（Hard Disk，HDD），而且它们几乎是同一个时代的产物。但是，与软盘不同，硬盘是多盘片、密封、高转速的，采用铝合金作为基片，并在表面涂上磁性物质来记录二进制位。这就使得它的盘片具有较高的硬度，故称为硬盘。\n   图1-1 一块被拆开密封盖的硬盘\r 如图1-1 所示，这是一块被拆开的硬盘，中间是用于记录数据的铝合金盘片，固定在中心的轴上，由一个高速旋转的马达驱动。附着在盘片表面的扁平锥状物，就是用于在盘片上读写数据的磁头。\n为了进一步搞清楚硬盘的内部构造，图1-2 给出了更为详细的图示。\n硬盘可以只有一个盘片（这称为单碟），也可能有好几个盘片。但无论如何，它们都串在同一个轴上，由电动机带动着一起高速旋转。一般来说，转速可以达到每分钟3600 转或者7200转，有的能达到一万多转，这个参数就是我们常说的“转/分钟”（Round Per Minute，RPM）。\n   图1-2 硬盘的结构示意图\r 每个盘片都有两个磁头（Head），上面一个，下面一个，所以经常用磁头来指代盘面。磁头都有编号，第1 个盘片，上面的磁头编号为0，下面的磁头编号为1；第2 个盘片，上面的磁头编号为2，下面的磁头编号为3，以此类推。\n每个磁头不是单独移动的。相反，它们都通过磁头臂固定在同一个支架上，由步进电动机带动着一起在盘片的中心和边缘之间来回移动。也就是说，它们是同进退的。步进电动机由脉冲驱动，每次可以旋转一个固定的角度，即可以步进一次。\n可以想象，当盘片高速旋转时，磁头每步进一次，都会从它所在的位置开始，绕着圆心“画”出一个看不见的圆圈，这就是磁道（Track）。磁道是数据记录的轨迹。因为所有磁头都是联动的，故每个盘面上的同一条磁道又可以形成一个虚拟的圆柱，称为柱面（Cylinder）。\n磁道，或者柱面，也要编号。编号是从盘面最边缘的那条磁道开始，向着圆心的方向，从0开始编号。\n柱面是一个用来优化数据读写的概念。初看起来，用硬盘来记录数据时，应该先将一个盘面填满后，再填写另一个盘面。实际上，移动磁头是一个机械动作，看似很快，但对处理器来说，却很后，再填写另一个盘面。实际上，移动磁头是一个机械动作，看似很快，但对处理器来说，却很漫长，这就是寻道时间。为了加速数据在硬盘上的读写，最好的办法就是尽量不移动磁头。这样，当0 面的磁道不足以容纳要写入的数据时，应当把剩余的部分写在1 面的同一磁道上。如果还写不下，那就继续把剩余的部分写在2 面的同一磁道上。换句话说，在硬盘上，数据的访问是以柱面来组织的。\n实际上，磁道还不是硬盘数据读写的最小单位，磁道还要进一步划分为扇区（Sector）。磁道很窄，也看不见，但在想象中，它仍呈带状，占有一定的宽度。将它划分许多分段之后，每一部分都呈扇形，这就是扇区的由来。\n每条磁道能够划分为几个扇区，取决于磁盘的制造者，但通常为63 个。而且，每个扇区都有一个编号，与磁头和磁道不同，扇区的编号是从1 开始的。\n扇区与扇区之间以间隙（空白）间隔开来，每个扇区以扇区头开始，然后是512 个字节的数据区。扇区头包含了每个扇区自己的信息，主要有本扇区的磁道号、磁头号和扇区号，用来供硬盘定位机构使用。现代的硬盘还会在扇区头部包括一个指示扇区是否健康的标志，以及用来替换该扇区的扇区地址。用于替换扇区的，是一些保留和隐藏的磁道。\n","description":"硬盘的构造及其工作原理","id":14,"section":"article","tags":null,"title":"硬盘到底是什么！","uri":"https://2110833194.github.io/article/computer/hard_disk/"},{"content":"1.创建仓库命令 1.创建版本库(初始化仓库) \u0026mdash;\u0026mdash; git init\n2.拷贝一份远程仓库，也就是下载一个项目 \u0026mdash;\u0026mdash; git clone\n2.提交与修改 1.添加文件到暂存区 \u0026mdash;\u0026mdash; git add\n2.查看仓库当前的状态，显示有变更的文件 \u0026mdash;\u0026mdash; git status\n3.比较文件的不同，即暂存区和工作区的区别 \u0026mdash;\u0026mdash; git diff\n4.提交暂存区到本地仓库 \u0026mdash;\u0026mdash; git commit\n7.回退版本 \u0026mdash;\u0026mdash; git reset\n8.删除工作区的文件 \u0026mdash;\u0026mdash; git rm\n9.移动或者重命名工作区的文件 \u0026mdash;\u0026mdash; git mv\n2.1提交日志 1.查看历史提交记录 \u0026mdash;\u0026mdash; git log\n2.以列表形式查看指定文件的历史修改记录 \u0026mdash;\u0026mdash; git blame \n2.2远程操作 1.远程仓库操作 \u0026mdash;\u0026mdash; git remote\n2.从远程获取代码库 \u0026mdash;\u0026mdash; git fetch\n3.下载远程代码并合并 \u0026mdash;\u0026mdash; git pull\n4.上传远程代码并合并 \u0026mdash;\u0026mdash; git push\n3.git 分支管理 1.列出分支 \u0026mdash;\u0026mdash; git branch(无参数时)\n2.创建新分支 \u0026mdash;\u0026mdash; git branch branchname(branchname为想要创建的分支名)\n3.切换到分支 \u0026mdash;\u0026mdash; git checkout branchname(branchname为想要切换到的分支名)\n4.创建新分支并切换到该分支下 \u0026mdash;\u0026mdash; git checkout -b branchname(branchname为想要创建的分支名)\n5.删除分支 \u0026mdash;\u0026mdash; git branch -d branchname(branchname为想要删除的分支名)\n6.合并分支 \u0026mdash;\u0026mdash; git merge /git rebase\nrebase优缺点 优点： Rebase 使你的提交树变得很干净, 所有的提交都在一条线上 缺点： Rebase 修改了提交树的历史 merge优缺点 优点: merge可以保留提交历史 缺点： merge使你的提交树变得复杂，提交由多条线相连 7.解决冲突 \u0026mdash;\u0026mdash; 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。\n4.git 查看提交历史 1.查看历史提交记录 \u0026mdash;\u0026mdash; git log\n2.以列表形式查看指定文件的历史修改记录 \u0026mdash;\u0026mdash; git blame \n5.git 标签 1.查看所有标签 \u0026mdash;\u0026mdash; git tag\n2.为当前分支创建标签 \u0026mdash;\u0026mdash; git tag -a v1.0(不带\u0026quot;-a\u0026quot;也行,但建议带上)\n3.创建带有说明的标签 \u0026mdash;\u0026mdash; git tag -a v0.1 -m \u0026ldquo;runoob.com标签\u0026rdquo;（用-a指定标签名，-m指定说明文字：）\n4.查看标签说明文字 \u0026mdash;\u0026mdash; git show v0.1\n(注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。) 6.git 远程仓库(Github) 1添加远程库 \u0026mdash;\u0026mdash; git remote add origin [url](origin 为给远程库取的一个别名) 由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息： 使用以下命令生成 SSH Key：ssh-keygen -t rsa -C \u0026ldquo;youremail@example.com\u0026rdquo; 后面的 your_email@youremail.com 改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在 ~/ 下生成 .ssh 文件夹，进去，打开 id_rsa.pub，复制里面的 key。回到 github 上，进入 Account =\u0026gt; Settings（账户配置）。左边选择 SSH and GPG keys，然后点击 New SSH key 按钮,title 设置标题，可以随便填，粘贴在你电脑上生成的 key 2查看当前的远程库 \u0026mdash;\u0026mdash; git remote -v 3拉取远程仓库 1.从远程仓库下载新分支与数据 \u0026mdash;\u0026mdash; git fetch\n2从远端仓库提取数据并尝试合并到当前分支 \u0026mdash;\u0026mdash; git merge\n4推送到远程仓库 \u0026mdash;\u0026mdash; git push origin branch(branch为远程仓库的分支名) 5删除远程仓库 \u0026mdash;\u0026mdash; git remote rm origin 7.git 服务器搭建 1.安装 git \u0026mdash;\u0026mdash;sudo apt-get install git(ubuntu下的下载,windows可上网查询) 接下来我们 创建一个用户用来运行git服务的用户 $ sudo adduser zhugeqing 2.创建证书登录 虽然是私有的Git服务器，但是也不能允许主机随意向Git服务器推送代码。因此，必须将需要使用Git服务器，即需要登录到Git服务器的主机的公钥（即id_rsa.pub文件）导入Git服务器的/home/git/.ssh/authorized_keys文件里，一行一个 ###3.初始化Git仓库\n如果我们使用/tmp/xingyouji.git做为远程仓库，则需要在/tmp目录下执行： sudo git init \u0026ndash;bare xingyouji.git 4.克隆仓库 git clone git@192.168.45.4:/home/gitrepo/xingyouji.git 192.168.45.4 为 Git 所在服务器 ip ，你需要将其修改为你自己的 Git 服务 ip，这样我们的 Git 服务器安装就完成。 8.Git Gitee（码云) 大家都知道国内访问 Github 速度比较慢，很影响我们的使用。如果你希望体验到 Git 飞一般的速度，可以使用国内的 Git 托管服务——Gitee（gitee.com）， Gitee 提供免费的 Git 仓库，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee 还提供了项目管理、代码托管、文档管理的服务，5 人以下小团队免费 。 1.我们先在 Gitee 上注册账号并登录后，然后上传自己的 SSH 公钥\n2.其他操作根据需求操作，与上述操作无大区别\n  ","description":"关于git 的使用","id":15,"section":"about","tags":null,"title":"git笔记","uri":"https://2110833194.github.io/about/git/"},{"content":"1.启动mysql服务 net start mysql(windows)　service mysqld start(linux)  2.关闭mysql服务 net stop mysql service mysqld stop(linux)\r 3.重启mysql服务 service mysqld restart\r 4.创建一个数据库（比如数据库的名字叫zhugeqing） create database zhugeqing;\r 5.查看所有数据库 show databases;\r information_schema：主要存储了系统中的一些数据库对象信息，比如用户表信息、列信息、权限信息、字符集信息、分区信息等。\ncluster：存储了系统的集群信息。\nmysql：存储了系统的用户权限信息。\ntest：系统自动创建的测试数据库，任何用户都可以使用。\n6.删除一个数据库（比如数据库的名字叫zhugeqing） drop database zhugeqing;\r 7.使用数据库（比如数据库的名字叫zhugeqing） use zhugeqing;\r 8.查看数据库里面所有的表 show tables;\r 9.创建表 create table emp(ename varchar(10),hiredate date,sal decimal(10,2),deptno int(2));\r 10.查看表 desc emp;\r 11.查看你创建表信息 虽然desc命令可以查看表定义，但是其输出的信息还是不够全面。为了得到更全面的表定义信息，有时就需要查看创建表的SQL语句，可以使用如下命令查看： show create table emp \\G;\r 12.删除表 drop table emp;\r 13.修改表 13.1修改表类型， alter table emp modify ename varchar(20);\r 13.2增加表字段（增加字段age） alter table emp add column age int(3);\r 13.3删除表字段（删除字段age） alter table emp drop column age;\r 13.4修改字段（将age改成age1） alter table emp change age age1 int(4) ;\r 13.5修改字段排列顺序（将新增的字段 birth date加在 ename之后） 前面介绍的字段增加和修改语法（add/CHANGE/MODIFY）中，都有一个可选项first|after column_name，这个选项可以用来修改字段在表中的位置，ADD增加的新字段默认是加在表的最后位置，而CHANGE/MODIFY默认都不会改变字段的位置。 alter table emp add birth date after ename;\r 修改字段age，将它放在最前面： ","description":"深入浅出mysql","id":16,"section":"databases","tags":[""],"title":"mysql基础","uri":"https://2110833194.github.io/databases/mysql/1/"},{"content":"题目入口\n难度：简单\n找出数组中重复的数字。\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n示例 1：\n输入：\n[2, 3, 1, 0, 2, 5, 3]\n输出：2 或 3\n解题思路：使用哈希表来记录每一个数组出现的次数，如果有一个索引的值超过1，就是重复元素元素，则返回该索引\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  //时间复杂度o(n)，空间复杂度o(n) int findRepeatNumber(int* nums, int numsSize){ int hash[numsSize];//定义哈希表  memset(hash,0,sizeof(hash));//初始化为零  for(int i=0;i\u0026lt;numsSize;i++) { if(++(hash[nums[i]]) == 2){ return nums[i]; } } return nums[numsSize-1]; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  //时间复杂度o(n),空间复杂度o(n) func findRepeatNumber(nums []int) int { if len(nums) \u0026lt;=1 { return 0 } hash := make([]int,len(nums))//定义哈希表  for i:=0;i\u0026lt;len(nums);i++{ hash[nums[i]]++ if hash[nums[i]] \u0026gt;= 2{ return nums[i] } } return 0 }    \r  'use strict'; var containerId = JSON.parse(\"\\\"461c122e7357e92c\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":17,"section":"algorithm","tags":["算法"],"title":"剑指 Offer 03. 数组中重复的数字","uri":"https://2110833194.github.io/algorithm/offer/03/"},{"content":"题目入口\n难度：中等\n在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n示例:\n现有矩阵 matrix 如下：\n[\n[1, 4, 7, 11, 15],\n[2, 5, 8, 12, 19],\n[3, 6, 9, 16, 22],\n[10, 13, 14, 17, 24],\n[18, 21, 23, 26, 30]\n]\n给定 target = 5，返回 true。\n给定 target = 20，返回 false。\n限制：\n0 \u0026lt;= n \u0026lt;= 1000\n0 \u0026lt;= m \u0026lt;= 1000\n解题思路：从左下角开始找，利用递增关系，大于往右边找，小于往上找，超出返回false。\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  bool findNumberIn2DArray(int** matrix, int matrixSize, int* matrixColSize, int target){ //时间复杂度o(m+n)，空间复杂度o(1)  int x = matrixSize-1;//行标  int y = 0;//列标  while(x\u0026gt;=0 \u0026amp;\u0026amp; y\u0026lt;*(matrixColSize+x)){ if(target == matrix[x][y]){ return true ; } if (target \u0026gt; matrix[x][y]){ y++; }else if(target \u0026lt; matrix[x][y]){ x--; } } return false; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  func findNumberIn2DArray(matrix [][]int, target int) bool { //时间复杂度o(m+n)，空间复杂度o(1)  xindex := len(matrix) - 1 yindex := 0 for xindex \u0026gt;= 0 \u0026amp;\u0026amp; yindex \u0026lt;= len(matrix[0])-1 { if target == matrix[xindex][yindex] { return true } if target \u0026gt; matrix[xindex][yindex] { yindex++ }else if target \u0026lt; matrix[xindex][yindex] { xindex-- } } return false }    \r  'use strict'; var containerId = JSON.parse(\"\\\"310c70690e2451d0\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":18,"section":"algorithm","tags":["算法"],"title":"剑指 Offer 04. 二维数组中的查找","uri":"https://2110833194.github.io/algorithm/offer/04/"},{"content":"题目入口\n难度：简单\n请实现一个函数，把字符串 s 中的每个空格替换成\u0026quot;%20\u0026quot;。\n示例 1：\n输入：s = \u0026ldquo;We are happy.\u0026rdquo; 输出：\u0026ldquo;We%20are%20happy.\u0026rdquo;\n限制：\n0 \u0026lt;= s 的长度 \u0026lt;= 10000\n解题思路：构建一个长度为3*len(s)的返回数组res，遍历字符串s，遇到等于' \u0026lsquo;的字符就进行替换，并赋给res。\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  char* replaceSpace(char* s){ int n = 0; for(int i = 0; s[i] != \u0026#39;\\0\u0026#39;; ++i) { ++n; } // printf(\u0026#34;%d\u0026#34;, n);  char* res; res = (char*)malloc(3 * (n + 3) * sizeof(char)); int k = 0; for(int i = 0; i \u0026lt; n; ++i) { if(s[i] != \u0026#39; \u0026#39;){ res[k++] = s[i]; }else { res[k++] = \u0026#39;%\u0026#39;; res[k++] = \u0026#39;2\u0026#39;; res[k++] = \u0026#39;0\u0026#39;; } } res[k] = \u0026#39;\\0\u0026#39;;//c语言字符串需要在末尾加上\u0026#39;\\0\u0026#39;  return res; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  func replaceSpace(s string) string { //时间复杂度o(n)，空间复杂度o(3*n)  res := make([]rune, 3*len(s)) //乘以三的目的是为了假设s字符串都是空格,就使用3个字符%20替换  i := 0 for _, v := range s { if v == \u0026#39; \u0026#39; { res[i] = \u0026#39;%\u0026#39; res[i+1] = \u0026#39;2\u0026#39; res[i+2] = \u0026#39;0\u0026#39; i += 3 //下标移到后三位  } else { res[i] = v i++ } } return string(res[:i]) }    \r  'use strict'; var containerId = JSON.parse(\"\\\"b4ba0e16f761d543\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":19,"section":"algorithm","tags":["算法"],"title":"剑指 Offer 05. 替换空格","uri":"https://2110833194.github.io/algorithm/offer/05/"},{"content":"题目入口\n难度：简单\n输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。\n示例 1：\n输入：head = [1,3,2]\n输出：[2,3,1]\n限制：\n0 \u0026lt;= 链表长度 \u0026lt;= 10000\n解题思路：1.构建数组，存储到数组中，然后倒置数组2.递归法\n第一种方法：\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  int* reversePrint(struct ListNode* head, int* returnSize){ //时间复杂度o(n)，空间复杂度o(n)  //先确定数组长度，再倒序存储  struct ListNode *p; int *res; p=head; int j=0; while(p!=NULL) { p=p-\u0026gt;next; j++; } res=(int *)malloc(sizeof(int)*j); p=head; *returnSize=j; j=j-1; while(j\u0026gt;=0) { res[j]=p-\u0026gt;val; p=p-\u0026gt;next; j--; } return res; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  func reversePrint(head *ListNode) []int { //时间复杂度o(n)，空间复杂度o(n)  //先用数组存起来，然后逆转数组  if head == nil { return make([]int, 0) } res := make([]int, 0) for head != nil { res = append(res, head.Val) head = head.Next } //倒置数组  len_s := len(res) for i := 0; i \u0026lt; len_s/2; i++ { res[i], res[len_s-i-1] = res[len_s-i-1], res[i] } return res }    \r  'use strict'; var containerId = JSON.parse(\"\\\"6edea2b534f8ef16\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \n第二种方法\nc golang  1 2 3 4 5 6 7 8 9 10  int* reversePrint(struct ListNode* head, int* returnSize){ //递归，直到最后一个节点的下一个节点为空时，存储值并返回上一个栈  if(head == NULL){ *returnSize = 0; return malloc(sizeof(int) * 10000); } int *ans = reversePrint(head-\u0026gt;next, returnSize); ans[(*returnSize)++] = head-\u0026gt;val; return ans; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14  func reversePrint(head *ListNode) []int { var dfs func(head *ListNode) res := make([]int, 0) dfs = func(head *ListNode) { if head == nil { return } dfs(head.Next) res = append(res, head.Val) } dfs(head) return res }    \r  'use strict'; var containerId = JSON.parse(\"\\\"caea30a3ed2070ac\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \n","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":20,"section":"algorithm","tags":["算法"],"title":"剑指 Offer 06. 从尾到头打印链表","uri":"https://2110833194.github.io/algorithm/offer/06/"},{"content":"题目入口\n难度：中等\n输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n例如，给出\n前序遍历 preorder = [3,9,20,15,7]\n中序遍历 inorder = [9,3,15,20,7]\n返回如下的二叉树：\n  限制：\n0 \u0026lt;= 节点个数 \u0026lt;= 5000\n解题思路：递归：\n对于任意一颗树而言，前序遍历的形式总是[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]\n即根节点总是前序遍历中的第一个节点。\n而中序遍历的形式总是[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]\n只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。\n这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。\n\rc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  //1.先看前序遍历数组第一个位置得到根节点，再到中序遍历数组得到根节点在中序遍历中的位置 //2.求出左右子树节点数，而左子树节点数对应了[0,left),右子树节点对应[left,left+right) //不断缩小前序 中序遍历数组区间; struct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize){ //递归终止条件  if(preorderSize == 0 || inorderSize == 0) return NULL; //根节点：  struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode)); root-\u0026gt;val = preorder[0]; //在中序遍历数组中寻找index  int left; for(left=0;left\u0026lt;inorderSize;left++) { if(inorder[left]==root-\u0026gt;val)//从中序遍历里面找到与前序遍历子节点值相同的节点  break; } int right = inorderSize-left-1;//右边区间长度  //前序数组左子树首地址为preorder+1，意为在根节点的基础上加一，left为前序数组当前根节点的左子树数组的首地址  //中序数组左子树首地址依然不变，可重看解题思路，下同  root-\u0026gt;left = buildTree(preorder+1,left,inorder,left); root-\u0026gt;right = buildTree(preorder+left+1,right,inorder+left+1,right); return root; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder) == 0 { return nil } root := \u0026amp;TreeNode{preorder[0], nil, nil} i := 0 for ; i \u0026lt; len(inorder); i++ { if inorder[i] == preorder[0] { break } } root.Left = buildTree(preorder[1:i+1], inorder[:i]) root.Right = buildTree(preorder[i+1:], inorder[i+1:]) return root }    \r  'use strict'; var containerId = JSON.parse(\"\\\"fb11dbd9df4800df\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":21,"section":"algorithm","tags":["算法"],"title":"剑指 Offer 07. 重建二叉树","uri":"https://2110833194.github.io/algorithm/offer/07/"},{"content":"题目入口\n难度：中等\n用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )\n示例 1：\n输入：\n[\u0026ldquo;CQueue\u0026rdquo;,\u0026ldquo;appendTail\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;]\n[[],[3],[],[]]\n输出：[null,null,3,-1]\n示例 2：\n输入：\n[\u0026ldquo;CQueue\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;,\u0026ldquo;appendTail\u0026rdquo;,\u0026ldquo;appendTail\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;]\n[[],[],[5],[2],[],[]]\n输出：[null,-1,null,null,5,2]\n提示：\n 1 \u0026lt;= values \u0026lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用  解题思路：栈的性质：先进后出，只能在栈顶进行操作。\n队列的性质：先进先出，之只能在队头进行删除（出队）操作，在队尾进行插入（入队）操作。\n本题是用两个栈来构建一个队列，使得一个队列具有队列尾部插入整数（队尾入队）和在队列头部删除整数（队头出队），考虑到栈的性质，所以构建两个栈，一个入队栈，一个出队栈，入队栈负责队尾入队操作，出队栈负责对头出队操作。\n1.初始化，实例化一个队列，并将两个栈顶赋值为-1。\n2.队尾入队，直接将入队栈栈顶（top_in）加1，并插入数值。\n3.队头出队：首先判断是否两个栈均为空，若为空，则返回-1，然后有两种情况，入队栈为空 or 出队栈为空，若只是入队栈为空，则无需理会，直接删除出队栈的一个栈顶元素，top_out减一;若是出队栈为空，则需要将入队栈的元素移至出队栈，然后再进行出队栈出队，top_out减一。\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  typedef struct { int out_stack[500];//出队栈（进行出队操作-队列头部） int top_out;//出队栈栈顶 int in_stack[500];//入队栈（进行入队操作-队列尾部） int top_in;//入队栈栈顶 } CQueue; CQueue* cQueueCreate() { CQueue* res = (CQueue*)malloc(sizeof(CQueue));//队列实例化  res-\u0026gt;top_out = -1;//初始化出队栈栈顶  res-\u0026gt;top_in = -1;//初始化入队栈栈顶  return res; } void cQueueAppendTail(CQueue* obj, int value) { obj-\u0026gt;top_in++;//入队栈栈顶加1  obj-\u0026gt;in_stack[obj-\u0026gt;top_in] = value;//入队 } int cQueueDeleteHead(CQueue* obj) { if(obj-\u0026gt;top_out == -1 \u0026amp;\u0026amp; obj-\u0026gt;top_in == -1){//如果两个栈都为空，返回-1  return -1; }else if(obj-\u0026gt;top_out == -1){//出队栈为空，把入队栈的数移到出队栈  while(obj-\u0026gt;top_in \u0026gt;=0){ obj-\u0026gt;out_stack[++obj-\u0026gt;top_out] = obj-\u0026gt;in_stack[obj-\u0026gt;top_in--]; } return obj-\u0026gt;out_stack[obj-\u0026gt;top_out--];//出队  }else{//入队栈为空，直接对出队栈进行出队操作  return obj-\u0026gt;out_stack[obj-\u0026gt;top_out--];//出队  } } void cQueueFree(CQueue* obj) { free(obj); } /** * Your CQueue struct will be instantiated and called as such: * CQueue* obj = cQueueCreate(); * cQueueAppendTail(obj, value); * int param_2 = cQueueDeleteHead(obj); * cQueueFree(obj); */    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  //剑指 Offer 09. 用两个栈实现队列 type CQueue struct { IntStack []int //入队栈  OutStack []int //出队栈  } func Constructor() CQueue { return CQueue{} //队列初始化 } func (this *CQueue) AppendTail(value int) { this.IntStack = append(this.IntStack, value) //对入队栈进行入队操作 } func (this *CQueue) DeleteHead() int { if len(this.OutStack) == 0 { //判断出队栈是否有数据，如果没有就把入队栈的数据移到出队上来  if len(this.IntStack) == 0 { return -1 //如果入队栈也没有数，那就返回-1  } //如果有,那就把入队栈的数据全部转移到出队栈（而且是转移所有数据）  for len(this.IntStack) \u0026gt; 0 { value := this.IntStack[len(this.IntStack)-1] //找到出队栈的栈顶  this.IntStack = this.IntStack[:len(this.IntStack)-1] //移除一个栈顶元素  this.OutStack = append(this.OutStack, value) //将元素添加到出队栈里面  } } //如果出队栈当中有数据则出栈  res := this.OutStack[len(this.OutStack)-1] //选中出队栈最后一个元素  this.OutStack = this.OutStack[:len(this.OutStack)-1] //出队栈移除一个栈顶元素  return res }    \r  'use strict'; var containerId = JSON.parse(\"\\\"6df9c9c6d7ed2fbf\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":22,"section":"algorithm","tags":["算法"],"title":"剑指 Offer 09. 用两个栈实现队列","uri":"https://2110833194.github.io/algorithm/offer/09/"},{"content":"题目入口\n难度：简单\n写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：\nF(0) = 0, F(1) = 1\nF(N) = F(N - 1) + F(N - 2), 其中 N \u0026gt; 1.\n斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n示例 1：\n输入：n = 2\n输出：1\n示例 2：\n输入：n = 5\n输出：5\n提示：\n 0 \u0026lt;= n \u0026lt;= 100  解题思路：1.递归，地球人都知道，就不解答了。2.动态规划（递推，这里可以讲成是迭代，递推：一个主观意志选择的第k个计算值，或者每一个计算值。迭代：不是第k个，也不是第k+1个，而是最终收敛的那一个，），已知斐波拉契数由之前两数相加得出，即f(n) = f(n-1) + f(n-2)，最优子结构：dp[i]表示第斐波拉契数列第i个数的值，动态转移方程：dp[n] = dp[n-1]+dp[n-2]，边界：dp[0]=0,dp[1]=1\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  int fib(int n){ //动态规划  if (n==0 || n==1){ return n; } int dp1 = 0;//为了节省空间，可以理解为dp[n-2]  int dp2 = 1;//dp[n-1]  int res = 0;//dp[n]  for(int i=2;i\u0026lt;=n;i++){ res = (dp1 + dp2) % (1000000007);//dp[n] = dp[n-1]+dp[n-2]  dp1 = dp2;//记录数列下一个数的值  dp2 = res;//同上  } return res; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func fib(n int) int { //动态规划  if n == 0 || n == 1 { return n } dp1 := 0//为了节省空间，可以理解为dp[n-2]  dp2 := 1//dp[n-1]  res := 0//dp[n]  for i := 2; i \u0026lt;= n; i++ { res = (dp1 + dp2) % (1000000007)//dp[n] = dp[n-1]+dp[n-2]  dp1 = dp2 //记录数列下一个数的值  dp2 = res //同上  } return res }    \r  'use strict'; var containerId = JSON.parse(\"\\\"b24cbf0fe42fff03\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":23,"section":"algorithm","tags":["算法"],"title":"剑指 Offer 10- I. 斐波那契数列","uri":"https://2110833194.github.io/algorithm/offer/10-1/"},{"content":"题目入口\n难度：简单\n一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n示例 1：\n输入：n = 2\n输出：2\n示例 2：\n输入：n = 7\n输出：21\n示例 3：\n输入：n = 0\n输出：1\n提示：\n 0 \u0026lt;= n \u0026lt;= 100  解题思路：不了解动态规划的第一想法肯定是穷举，比如到第一级台阶有一种方法（跳一阶），到第二级台阶有两种（跳一阶，或者跳两阶），第三级有三种（(1,1,1),(1,2),(2,1)），第四级有\u0026hellip;，虽然计算机最擅长的就是穷举，但是我们人脑不行（至少，数大了，我不行），所以动态规划请先学习图解 | 你管这破玩意叫动态规划，\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  int numWays(int n){ if(n==0 || n==1){ return 1; } if(n==2){ return 2; } //类似于斐波拉契的动态规划  int dp1 = 1;//dp[n-2]  int dp2 = 2;//dp[n-1]  int res = 2; for(int i=3;i\u0026lt;=n;i++){ res = (dp1 + dp2) % (1000000007);//状态转移方程  dp1 = dp2; dp2 = res; } return res; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  func numWays(n int) int { //动态规划  //1.最优子结构  //f(n)表示n级台阶共有f(n)种跳法  //f(n) = f(n-1) + f(n-2) + 2  //2.边界  //f(1) = 1,f(2) = 2  if n == 1 || n == 2 { return n } dp1 := 1 dp2 := 2 res := 1 for i := 3; i \u0026lt;= n; i++ { res = (dp1 + dp2) % (1e9 + 7) dp1 = dp2 dp2 = res } return res }    \r  'use strict'; var containerId = JSON.parse(\"\\\"4b51c7cb376a0437\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":24,"section":"algorithm","tags":["算法"],"title":"剑指 Offer 10- II. 青蛙跳台阶问题","uri":"https://2110833194.github.io/algorithm/offer/10-2/"},{"content":"题目入口\n难度：简单\n把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例 1：\n输入：[3,4,5,1,2]\n输出：1\n示例 2：\n输入：[2,2,2,0,1]\n输出：0\n解题思路：二分法，参考力扣官方题解\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  int minArray(int* numbers, int numbersSize){ int low = 0; int high = numbersSize-1; int center = (low+high)/2; if(numbers[low]\u0026lt;numbers[high]){//只要low下标的数小于high下标的数即可返回  return numbers[low]; } while(low \u0026lt; high){ if(numbers[low]\u0026lt;numbers[high]){ return numbers[low]; } center = (low+high)/2; if(numbers[low] == numbers[high]){ low++; continue; } if(numbers[center] \u0026lt;= numbers[high]){//若相等，也是向左缩小区间  high = center; low ++; }else{//向右缩小区间  low = center+1; } } return numbers[low]; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  func minArray(numbers []int) int { //二分法  //旋转之后有三种情况：  //1.最小值在数组中间，  //2.最小值在数组中心的左边，  //3.最小值在数组中心的右边  low,high := 0,len(numbers)-1 if numbers[low] \u0026lt; numbers[high]{ return numbers[low]//旋转之后若第一个数仍然小于最后一个数，则是旋转之后仍然与原数组相同  } for low \u0026lt; high{ if numbers[low] \u0026lt; numbers[high]{ return numbers[low] } if numbers[low] == numbers[high]{ low++ //跳过  continue } private := (low+high)/2 if numbers[private] \u0026gt; numbers[high]{ //说明最小数在中心的右边  low = private+1//加1因为privat已经不可能是最小的了  }else { //说明最小数在中心的左边  high = private } } return numbers[low] }    \r  'use strict'; var containerId = JSON.parse(\"\\\"601ea4a5c76cf542\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":25,"section":"algorithm","tags":["算法"],"title":"剑指 Offer 11. 旋转数组的最小数字","uri":"https://2110833194.github.io/algorithm/offer/11/"},{"content":"题目入口\n难度：中等\n给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n例如，在下面的 3×4 的矩阵中包含单词 \u0026ldquo;ABCCED\u0026rdquo;（单词中的字母已标出）。\n  示例 1：\n输入：board = [[\u0026ldquo;A\u0026rdquo;,\u0026ldquo;B\u0026rdquo;,\u0026ldquo;C\u0026rdquo;,\u0026ldquo;E\u0026rdquo;],[\u0026ldquo;S\u0026rdquo;,\u0026ldquo;F\u0026rdquo;,\u0026ldquo;C\u0026rdquo;,\u0026ldquo;S\u0026rdquo;],[\u0026ldquo;A\u0026rdquo;,\u0026ldquo;D\u0026rdquo;,\u0026ldquo;E\u0026rdquo;,\u0026ldquo;E\u0026rdquo;]], word = \u0026ldquo;ABCCED\u0026rdquo;\n输出：true\n示例 2：\n输入：board = [[\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;],[\u0026ldquo;c\u0026rdquo;,\u0026ldquo;d\u0026rdquo;]], word = \u0026ldquo;abcd\u0026rdquo;\n输出：false\n 提示：\n 1 \u0026lt;= board.length \u0026lt;= 200 1 \u0026lt;= board[i].length \u0026lt;= 200 board 和 word 仅由大小写英文字母组成  \n解题思路：dfs（深度优先搜索），首先逐个遍历矩阵，找到起点（不过所有数都得进入search函数），然后进入search函数，递归true终止条件：当递归遍历word的下标k等于word长度时，则终止递归，递归false终止条件：超出矩阵边界；搜索过程\n\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  bool dfs(char** board, int boardSize,int* boardColSize,char* word,int i,int j,int k) { if(k == strlen(word)){ return true; } //递归终止条件  if(i\u0026lt;0 || j\u0026lt;0 || i== boardSize || j == *boardColSize) { return false;//超出边界，直接返回false  } if(word[k] == board[i][j]){ //匹配成功，往下递归  int temp = board[i][j]; board[i][j] = \u0026#39; \u0026#39;;//记录当前字符，防止向下递归重复遍历  if (dfs(board,boardSize,boardColSize,word,i-1,j,k+1)|| //向上递归 dfs(board,boardSize,boardColSize,word,i+1,j,k+1) || //向下递归 dfs(board,boardSize,boardColSize,word,i,j-1,k+1) || //向左递归 dfs(board,boardSize,boardColSize,word,i,j+1,k+1)) //向右递归  { return true; }else{ board[i][j] = temp;//还原字符  } } return false; } bool exist(char** board, int boardSize, int* boardColSize, char* word) { for(int i=0;i\u0026lt;boardSize;i++){ for(int j=0;j\u0026lt;*boardColSize;j++){ if(dfs(board,boardSize,boardColSize,word,i,j,0)) { return true; } } } return false; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  func exist(board [][]byte, word string) bool { m,n := len(board), len(board[0]) for i := 0; i \u0026lt; m; i++ {//行范围  for j := 0; j \u0026lt; n; j++ {//列范围  //如果在数组中找得到第一个数，就执行下一步，否则返回false  if search(board, i, j, 0,word) { //dsf深度优先搜索，从一个起点开始搜索，若搜索到，则返回true，否则，下一个矩阵单元  return true } } } return false } func search(board [][]byte, i,j,k int, word string) bool { //如果找到最后一个数，则返回true,搜索成功  if k == len(word) { //k表示word当前遍历下标  return true } //i,j的约束条件  if i \u0026lt; 0 || j \u0026lt; 0 || i == len(board) || j == len(board[0]) { return false } //进入DFS深度优先搜索  //先把正在遍历的该值重新赋值，如果在该值的周围都搜索不到目标字符，则再把该值还原  //如果在数组中找到第一个字符，则进入下一个字符的查找  if board[i][j] == word[k] { temp := board[i][j] board[i][j] = \u0026#39; \u0026#39;//防止递归重复搜索  //下面这个if语句，如果成功进入，说明找到该字符，然后进行下一个字符的搜索,直到所有的搜索都成功，  //即k == len(word) - 1 的大小时，会返回true，进入该条件语句，然后返回函数true值。  if search(board, i, j + 1, k + 1, word) || //向下搜索  search(board, i, j - 1, k + 1, word) || //向上搜索  search(board, i + 1, j, k + 1, word) || //向右搜索  search(board, i - 1, j, k + 1, word) { //向左搜索  return true }else { //没有找到目标字符，还原之前重新赋值的board[i][j]  board[i][j] = temp } } return false }    \r  'use strict'; var containerId = JSON.parse(\"\\\"a12d40f1e642a5c8\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":26,"section":"algorithm","tags":["算法"],"title":"剑指 Offer 12. 矩阵中的路径","uri":"https://2110833194.github.io/algorithm/offer/12/"},{"content":"题目入口\n难度：中等\n地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、\n上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格\n[35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？\n示例 1：\n输入：m = 2, n = 3, k = 1\n输出：3\n示例 2：\n输入：m = 3, n = 1, k = 0\n输出：1\n提示：\n 1 \u0026lt;= n,m \u0026lt;= 100 0 \u0026lt;= k \u0026lt;= 20  解题思路：\n1.三个函数，第一个movingCount用来调用dfs函数，初始化，第二个dfs函数用来深度优先搜索来递归，第三个getDigGitSum函数用来求i，j的各位数之和\n2.额外空间flag来判断是否遍历过该方格\n3.继续向下向右dfs（深度优先搜索）\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  int digitSum(int i, int j) { int res = 0; while (i \u0026gt; 0 || j \u0026gt; 0) { res += i % 10; res += j % 10; i /= 10; j /= 10; } return res; } int dfsTraversal(int i, int j, int m, int n, int **visited, int k) { /* 特判，返回0表示不能到达。 * 1、超出边界 * 2、位数和不满足小于等于k的条件 * 3、当前节点已经访问过 */ if (i \u0026gt;= m || j \u0026gt;= n || digitSum(i, j) \u0026gt; k || visited[i][j] == 1) { return 0; } /* 标记当前节点已到达 */ visited[i][j] = 1; /* 再次进入下一层递归 * 这里只遍历了右、下，左、上不需要遍历， * 因为是从左上开始的，到右n下结束，所以当前节点都是从左上来的 */ return 1 + dfsTraversal(i, j + 1, m, n, visited, k) + dfsTraversal(i + 1, j, m, n, visited, k); } int movingCount(int m, int n, int k) { /* 路径数组，用于存放遍历结果 */ int **visited = (int **)calloc(m, sizeof(int *)); for (int i = 0; i \u0026lt; m; i++) { *(visited + i) = (int *)calloc(sizeof(int), n); } /* dfs深度搜索 */ return dfsTraversal(0, 0, m, n, visited, k); }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  var flag [][]int //全局变量数组，记录机器人是否曾访问过此方格  func movingCount(m int, n int, k int) int { //也不能进入行坐标和列坐标的数位之和大于k的格子  //递归深度搜索  if k == 0 { //机器人不移动，只访问一个方格  return 1 } var getDigGitSum func(i int, j int) int //用来计算行列坐标的数位之和  getDigGitSum = func(i int, j int) int { //求各位数之和的函数  res := 0 //返回结果  for i \u0026gt; 0 || j \u0026gt; 0 { res += i % 10 //求个位数值  res += j % 10 i /= 10 //整除  j /= 10 } return res } var dfs func(i, j int) int //用深度优先搜索  dfs = func(i, j int) int { //一个flag数组  //递归终止条件  //1.行标超出边界，列标超出边界  //2.行坐标和列坐标的数位之和大于k的格子  //3.方格已经被遍历过  if i \u0026gt;= m || j \u0026gt;= n || getDigGitSum(i, j) \u0026gt; k { return 0 } if flag[i][j] == 1 { //判断该方格是否被遍历过  return 0 } flag[i][j] = 1 //设置遍历位  return 1 + dfs(i+1, j) + dfs(i, j+1) //深度优先搜索（向右递归向下递归）  } flag = make([][]int, m) //初始化flag数组  for i := range flag { flag[i] = make([]int, n)//初始化各一维数组  } return 1 + dfs(1, 0) + dfs(0, 1) //  }    \r  'use strict'; var containerId = JSON.parse(\"\\\"fdf46ef6fa1c71c9\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":27,"section":"algorithm","tags":["算法"],"title":"剑指 Offer 13. 机器人的运动范围","uri":"https://2110833194.github.io/algorithm/offer/13/"},{"content":" 此文章取自于微信公众号“低并发编程”\n你是一台电脑，你的名字叫 A\r\n  \n经过《如果让你来设计网络》这篇文章中的一番折腾，只要你知道另一位伙伴 B 的 IP 地址，且你们之间的网络是通的，无论多远，你都可以将一个数据包发送给你的伙伴 B\n  \n这就是物理层、数据链路层、网络层这三层所做的事情。\n站在第四层的你，就可以不要脸地利用下三层所做的铺垫，随心所欲地发送数据，而不必担心找不到对方了。\n\n  \n虽然你此时还什么都没干，但你还是给自己这一层起了个响亮的名字，叫做传输层。\n你本以为自己所在的第四层万事大吉，啥事没有，但很快问题就接踵而至。\n问题来了\r\n前三层协议只能把数据包从一个主机搬到另外一台主机，但是，到了目的地以后，数据包具体交给哪个程序（进程）呢？\n  \n所以，你需要把通信的进程区分开来，于是就给每个进程分配一个数字编号，你给它起了一个响亮的名字：端口号。\n  \n然后你在要发送的数据包上，增加了传输层的头部，源端口号与目标端口号。\n  \nOK，这样你将原本主机到主机的通信，升级为了进程和进程之间的通信。\n你没有意识到，你不知不觉实现了 UDP 协议！\n（当然 UDP 协议中不光有源端口和目标端口，还有数据包长度和校验值，我们暂且略过）\n就这样，你用 UDP 协议无忧无虑地同 B 进行着通信，一直没发生什么问题。\n  \n但很快，你发现事情变得非常复杂......\r\n丢包问题\r\n由于网络的不可靠，数据包可能在半路丢失，而 A 和 B 却无法察觉。\n\n  \n对于丢包问题，只要解决两个事就好了。\n第一个，A 怎么知道包丢了？\n答案：让 B 告诉 A \n第二个，丢了的包怎么办？\n答案：重传 \n于是你设计了如下方案，A 每发一个包，都必须收到来自 B 的确认（ACK），再发下一个，否则在一定时间内没有收到确认，就重传这个包。\n  \n你管它叫停止等待协议。只要按照这个协议来，虽然 A 无法保证 B 一定能收到包，但 A 能够确认 B 是否收到了包，收不到就重试，尽最大努力让这个通信过程变得可靠，于是你们现在的通信过程又有了一个新的特征，可靠交付。\n效率问题\r\n停止等待虽然能解决问题，但是效率太低了，A 原本可以在发完第一个数据包之后立刻开始发第二个数据包，但由于停止等待协议，A 必须等数据包到达了 B ，且 B 的 ACK 包又回到了 A，才可以继续发第二个数据包，这效率慢得可不是一点两点。\n于是你对这个过程进行了改进，采用流水线（Pipelining）的方式，不再傻傻地等。\n\n顺序问题\r\n但是网路是复杂的、不可靠的。\n有的时候 A 发出去的数据包，分别走了不同的路由到达 B，可能无法保证和发送数据包时一样的顺序。\n  在流水线中有多个数据包和ACK包在乱序流动，他们之间对应关系就乱掉了。\n难道还回到停止等待协议？A 每收到一个包的确认（ACK）再发下一个包，那就根本不存在顺序问题。应该有更好的办法！\nA 在发送的数据包中增加一个序号（seq），同时 B 要在 ACK 包上增加一个确认号（ack），这样不但解决了停止等待协议的效率问题，也通过这样标序号的方式解决了顺序问题。\n  而 B 这个确认号意味深长：比如 B 发了一个确认号为 ack = 3，它不仅仅表示 A 发送的序号为 2 的包收到了，还表示 2 之前的数据包都收到了。这种方式叫累计确认或累计应答。\n  \n注意，实际上 ack 的号是收到的最后一个数据包的序号 seq + 1，也就是告诉对方下一个应该发的序号是多少。但图中为了便于理解，ack 就表示收到的那个序号，不必纠结。  \n流量问题\r\n有的时候，A 发送数据包的速度太快，而 B 的接收能力不够，但 B 却没有告知 A 这个情况。\n  怎么解决呢？\n很简单，B 告诉 A 自己的接收能力，A 根据 B 的接收能力，相应控制自己的发送速率，就好了。\nB 怎么告诉 A 呢？B 跟 A 说\u0026quot;我很强\u0026quot;这三个字么？那肯定不行，得有一个严谨的规范。\n于是 B 决定，每次发送数据包给 A 时，顺带传过来一个值，叫窗口大小（win)，这个值就表示 B 的接收能力。同理，每次 A 给 B 发包时也带上自己的窗口大小，表示 A 的接收能力。\n\n  \nB 告诉了 A 自己的窗口大小值，A 怎么利用它去做 A 这边发包的流量控制呢？\n很简单，假如 B 给 A 传过来的窗口大小 win = 5，那 A 根据这个值，把自己要发送的数据分成这么几类。\n  \n图片过于清晰，就不再文字解释了。\n当 A 不断发送数据包时，已发送的最后一个序号就往右移动，直到碰到了窗口的上边界，此时 A 就无法继续发包，达到了流量控制。\n\n  \n但是当 A 不断发包的同时，A 也会收到来自 B 的确认包，此时整个窗口会往右移动，因此上边界也往右移动，A 就能发更多的数据包了。\n\n  \n以上都是在窗口大小不变的情况下，而 B 在发给 A 的 ACK 包中，每一个都可以重新设置一个新的窗口大小，如果 A 收到了一个新的窗口大小值，A 会随之调整。\n如果 A 收到了比原窗口值更大的窗口大小，比如 win = 6，则 A 会直接将窗口上边界向右移动 1 个单位。\n  如果 A 收到了比原窗口值小的窗口大小，比如 win = 4，则 A 暂时不会改变窗口大小，更不会将窗口上边界向左移动，而是等着 ACK 的到来，不断将左边界向右移动，直到窗口大小值收缩到新大小为止。\n\n  \nOK，终于将流量控制问题解决得差不多了，你看着上面一个个小动图，给这个窗口起了一个更生动的名字，滑动窗口(一种算法)。\n拥塞问题\r\n但有的时候，不是 B 的接受能力不够，而是网络不太好，造成了网络拥塞。\n  \n拥塞控制与流量控制有些像，但流量控制是受 B 的接收能力影响，而拥塞控制是受网络环境的影响。\n拥塞控制的解决办法依然是通过设置一定的窗口大小，只不过，流量控制的窗口大小是 B 直接告诉 A 的，而拥塞控制的窗口大小按理说就应该是网络环境主动告诉 A。\n但网络环境怎么可能主动告诉 A 呢？只能 A 单方面通过试探，不断感知网络环境的好坏，进而确定自己的拥塞窗口的大小。\n\n  \n拥塞窗口大小的计算有很多复杂的算法，就不在本文中展开了，假如拥塞窗口的大小为 cwnd，上一部分流量控制的滑动窗口的大小为 rwnd，那么窗口的右边界受这两个值共同的影响，需要取它俩的最小值。\n窗口大小 = min(cwnd, rwnd)\r\n含义很容易理解，当 B 的接受能力比较差时，即使网络非常通畅，A 也需要根据 B 的接收能力限制自己的发送窗口。当网络环境比较差时，即使 B 有很强的接收能力，A 也要根据网络的拥塞情况来限制自己的发送窗口。正所谓受其短板的影响嘛~\n连接问题\r\n有的时候，B 主机的相应进程还没有准备好或是挂掉了，A 就开始发送数据包，导致了浪费。\n\n  \n这个问题在于，A 在跟 B 通信之前，没有事先确认 B 是否已经准备好，就开始发了一连串的信息。就好比你和另一个人打电话，你还没有\u0026quot;喂\u0026quot;一下确认对方有没有在听，你就巴拉巴拉说了一堆。\n这个问题该怎么解决呢？\n地球人都知道，三次握手嘛！\n* A：我准备好了(SYN)\n* B：我知道了(ACK)，我也准备好了(SYN)\n* A：我知道了(ACK)\n\n  \nA 与 B 各自在内存中维护着自己的状态变量，三次握手之后，双方的状态都变成了连接已建立（ESTABLISHED）。\n虽然就只是发了三次数据包，并且在各自的内存中维护了状态变量，但这么说总觉得太 low，你看这个过程相当于双方建立连接的过程，于是你灵机一动，就叫它面向连接吧。\n注意：这个连接是虚拟的，是由 A 和 B 这两个终端共同维护的，在网络中的设备根本就不知道连接这回事儿！  \n但凡事有始就有终，有了建立连接的过程，就要考虑释放连接的过程，又是地球人都知道，四次挥手嘛！\n* A：再见，我要关闭了(FIN)\n* B：我知道了(ACK)\n给 B 一段时间把自己的事情处理完\u0026hellip;\n* B：再见，我要关闭了(FIN)\n* A：我知道了(ACK)\n  \n总结\r\n以上讲述的，就是 TCP 协议的核心思想，上面过程中需要传输的信息，就体现在 TCP 协议的头部，这里放上最常见的 TCP 协议头解读的图。\n  \n不知道你现在再看下面这句话，是否能理解：\nTCP 是\n面向连接的、可靠的、基于字节流的\n传输层通信协议  \n面向连接、可靠，这两个词通过上面的讲述很容易理解，那什么叫做基于字节流呢？\n很简单，TCP 在建立连接时，需要告诉对方 MSS（最大报文段大小）。\n也就是说，如果要发送的数据很大，在 TCP 层是需要按照 MSS 来切割成一个个的TCP 报文段 的。\n切割的时候我才不管你原来的数据表示什么意思，需要在哪里断句啥的，我就把它当成一串毫无意义的字节，在我想要切割的地方咔嚓就来一刀，标上序号，只要接收方再根据这个序号拼成最终想要的完整数据就行了。\n在我 TCP 传输这里，我就把它当做一个个的字节，也就是基于字节流的含义了。\n  \n最后留给大家一个作业，模拟 A 与 B 建立一个 TCP 连接。\n第一题：A 给 B 发送 \"aaa\" ，然后 B 给 A 回复一个简单的字符串 \"success\"，并将此过程抓包。 第二题：A 给 B 发送 \"aaaaaa ... a\" 超过最大报文段大小，然后 B 给 A 回复一个简单的字符串 \"success\"，并将此过程抓包。 下面是我抓的包（第二题）\n三次握手阶段\rA -\u0026gt; B\t[SYN] Seq=0 Win=64240 Len=0\rMSS=1460 WS=256\rB - \u0026gt;A\t[SYN, ACK] Seq=0 Ack=1 Win=29200 Len=0\rMSS=1424 WS=512\rA -\u0026gt; B\t[ACK] Seq=1 Ack=1 Win=132352 Len=0\r数据发送阶段\rA -\u0026gt; B\t[ACK] Seq=1 Ack=1 Win=132352 Len=1424\rA -\u0026gt; B\t[ACK] Seq=1425 Ack=1 Win=132352 Len=1424\rA -\u0026gt; B\t[PSH, ACK] Seq=2849 Ack=1 Win=132352 Len=1247\rB -\u0026gt; A\t[ACK] Seq=1 Ack=1425 Win=32256 Len=0\rB -\u0026gt; A\t[ACK] Seq=1 Ack=2849 Win=35328 Len=0\rB -\u0026gt; A\t[ACK] Seq=1 Ack=4096 Win=37888 Len=0\rB -\u0026gt; A\t[PSH, ACK] Seq=1 Ack=4096 Win=37888 Len=7\r四次挥手阶段\rB -\u0026gt; A\t[FIN, ACK] Seq=8 Ack=4096 Win=37888 Len=0\rA -\u0026gt; B\t[ACK] Seq=4096 Ack=9 Win=132352 Len=0\rA -\u0026gt; B\t[FIN, ACK] Seq=4096 Ack=9 Win=132352 Len=0（下面少复制了一行ACK，抱歉）\r后记\r一提到 TCP，可能很多人都想起被三次握手和四次挥手所支配的恐惧。但其实你跟着文中的思路你就会发现，三次握手与四次挥手只占 TCP 所解决的核心问题中很小的一部分，只是因为它在面试中很适合作为知识点进行考察，所以在很多人的印象中就好像 TCP 的核心就是握手和挥手似的。\n本文希望你能从问题出发，真正理解 TCP 所想要解决的问题，你会发现很多原理就好像生活常识一样顺其自然，并不复杂，希望你有收获～\n","description":"了解tcp","id":28,"section":"article","tags":["网络"],"title":"图解 | 你管这破玩意儿叫TCP？","uri":"https://2110833194.github.io/article/network/interesting/2/"},{"content":" 此文章取自于微信公众号“低并发编程”\n正文开始：\n你是一台电脑，你的名字叫 A\n很久很久之前，你不与任何其他电脑相连接，孤苦伶仃。\n  直到有一天，你希望与另一台电脑 B 建立通信，于是你们各开了一个网口，用一根网线连接了起来。\n  用一根网线连接起来怎么就能\u0026quot;通信\u0026quot;了呢？我可以给你讲 IO、讲中断、讲缓冲区，但这不是研究网络时该关心的问题。\n如果你纠结，要么去研究一下操作系统是如何处理网络 IO 的，要么去研究一下包是如何被网卡转换成电信号发送出去的，要么就仅仅把它当做电脑里有个小人在开枪吧~\n  反正，你们就是连起来了，并且可以通信。\n  有一天，一个新伙伴 C 加入了，但聪明的你们很快发现，可以每个人开两个网口，用一共三根网线，彼此相连。\n  随着越来越多的人加入，你发现身上开的网口实在太多了，而且网线密密麻麻，混乱不堪。（而实际上一台电脑根本开不了这么多网口，所以这种连线只在理论上可行，所以连不上的我就用红色虚线表示了，就是这么严谨哈哈~）\n  于是你们发明了一个中间设备，你们将网线都插到这个设备上，由这个设备做转发，就可以彼此之间通信了，本质上和原来一样，只不过网口的数量和网线的数量减少了，不再那么混乱。\n  你给它取名叫集线器，它仅仅是无脑将电信号转发到所有出口（广播），不做任何处理，你觉得它是没有智商的，因此把人家定性在了物理层。\n  由于转发到了所有出口，那 BCDE 四台机器怎么知道数据包是不是发给自己的呢？\n首先，你要给所有的连接到集线器的设备，都起个名字。原来你们叫 ABCD，但现在需要一个更专业的，全局唯一的名字作为标识，你把这个更高端的名字称为MAC 地址\n你的 MAC 地址是 aa-aa-aa-aa-aa-aa，你的伙伴 b 的 MAC 地址是 bb-bb-bb-bb-bb-bb，以此类推，不重复就好。\n这样，A 在发送数据包给 B 时，只要在头部拼接一个这样结构的数据，就可以了。\n  B 在收到数据包后，根据头部的目标 MAC 地址信息，判断这个数据包的确是发给自己的，于是便收下。\n其他的 CDE 收到数据包后，根据头部的目标 MAC 地址信息，判断这个数据包并不是发给自己的，于是便丢弃。\n  虽然集线器使整个布局干净不少，但原来我只要发给电脑 B 的消息，现在却要发给连接到集线器中的所有电脑，这样既不安全，又不节省网络资源。\n  如果把这个集线器弄得更智能一些，只发给目标 MAC 地址指向的那台电脑，就好了\n  虽然只比集线器多了这一点点区别，但看起来似乎有智能了，你把这东西叫做交换机。也正因为这一点点智能，你把它放在了另一个层级，数据链路层。\n  如上图所示，你是这样设计的。\n交换机内部维护一张 MAC 地址表，记录着每一个 MAC 地址的设备，连接在其哪一个端口上。\n  假如你仍然要发给 B 一个数据包，构造了如下的数据结构从网口出去。\n  到达交换机时，交换机内部通过自己维护的 MAC 地址表，发现目标机器 B 的 MAC 地址 bb-bb-bb-bb-bb-bb 映射到了端口 1 上，于是把数据从 1 号端口发给了 B，完事~\n你给这个通过这样传输方式而组成的小范围的网络，叫做以太网。\n当然最开始的时候，MAC 地址表是空的，是怎么逐步建立起来的呢？\n假如在 MAC 地址表为空是，你给 B 发送了如下数据：\n  由于这个包从端口 4 进入的交换机，所以此时交换机就可以在 MAC地址表记录第一条数据：\n  交换机看目标 MAC 地址（bb-bb-bb-bb-bb-bb）在地址表中并没有映射关系，于是将此包发给了所有端口，也即发给了所有机器。\n之后，只有机器 B 收到了确实是发给自己的包，于是做出了响应，响应数据从端口 1 进入交换机，于是交换机此时在地址表中更新了第二条数据：\n  过程如下：\n  经过该网络中的机器不断地通信，交换机最终将 MAC 地址表建立完毕~\n  随着机器数量越多，交换机的端口也不够了，但聪明的你发现，只要将多个交换机连接起来，这个问题就轻而易举搞定~\n  你完全不需要设计额外的东西，只需要按照之前的设计和规矩来，按照上述的接线方式即可完成所有电脑的互联，所以交换机设计的这种规则，真的很巧妙。你想想看为什么（比如 A 要发数据给 F）。\n但是你要注意，上面那根红色的线，最终在 MAC 地址表中可不是一条记录呀，而是要把 EFGH 这四台机器与该端口（端口6）的映射全部记录在表中。\n最终，两个交换机将分别记录 A ~ H 所有机器的映射记录。\n左边的交换机\n  右边的交换机\n  这在只有 8 台电脑的时候还好，甚至在只有几百台电脑的时候，都还好，所以这种交换机的设计方式，已经足足支撑一阵子了。\n但很遗憾，人是贪婪的动物，很快，电脑的数量就发展到几千、几万、几十万。\n  交换机已经无法记录如此庞大的映射关系了。\n此时你动了歪脑筋，你发现了问题的根本在于，连出去的那根红色的网线，后面不知道有多少个设备不断地连接进来，从而使得地址表越来越大。\n那我可不可以让那根红色的网线，接入一个新的设备，这个设备就跟电脑一样有自己独立的 MAC 地址，而且同时还能帮我把数据包做一次转发呢？\n这个设备就是路由器，它的功能就是，作为一台独立的拥有 MAC 地址的设备，并且可以帮我把数据包做一次转发，你把它定在了网络层。\n  注意，路由器的每一个端口，都有独立的 MAC 地址。\n好了，现在交换机的 MAC 地址表中，只需要多出一条 MAC 地址 ABAB 与其端口的映射关系，就可以成功把数据包转交给路由器了，这条搞定。\n那如何做到，把发送给 C 和 D，甚至是把发送给 DEFGH\u0026hellip;. 的数据包，统统先发送给路由器呢？\n不难想到这样一个点子，假如电脑 C 和 D 的 MAC 地址拥有共同的前缀，比如分别是：\n  那我们就可以说，将目标 MAC 地址为 FFFF-FFFF-？开头的，统统先发送给路由器。\n这样是否可行呢？答案是否定的。\n我们先从现实中 MAC 地址的结构入手，MAC地址也叫物理地址、硬件地址，长度为 48 位，一般这样来表示：   它是由网络设备制造商生产时烧录在网卡的EPROM（一种闪存芯片，通常可以通过程序擦写）。其中前 24 位（00-16-EA）代表网络硬件制造商的编号，后 24 位（AE-3C-40）是该厂家自己分配的，一般表示系列号。只要不更改自己的 MAC 地址，MAC 地址在世界是唯一的。形象地说，MAC地址就如同身份证上的身份证号码，具有唯一性。\n那如果你希望向上面那样将目标 MAC 地址表示为 FFFF-FFFF-？开头的，统一从路由器出去发给某一群设备（后面会提到这其实是子网的概念），那你就需要要求某一子网下统统买一个厂商制造的设备，要么你就需要要求厂商在生产网络设备烧录 MAC 地址时，提前按照你规划好的子网结构来定 MAC 地址，并且日后这个网络的结构都不能轻易改变。\n这显然是不现实的。\n于是你发明了一个新的地址，给每一台机器一个 32 位的编号，如：\n11000000101010000000000000000001\n你觉得有些不清晰，于是把它分成四个部分，中间用点相连。\n11000000.10101000.00000000.00000001\n你还觉得不清晰，于是把它转换成 10 进制。\n192.168.0.1\n最后你给了这个地址一个响亮的名字，IP 地址。现在每一台电脑，同时有自己的 MAC 地址，又有自己的 IP 地址，只不过 IP 地址是软件层面上的，可以随时修改，MAC 地址一般是无法修改的。\n这样一个可以随时修改的 IP 地址，就可以根据你规划的网络拓扑结构，来调整了。\n  如上图所示，假如我想要发送数据包给 ABCD 其中一台设备，不论哪一台，我都可以这样描述，\u0026ldquo;将 IP 地址为 192.168.0 开头的全部发送给到路由器，之后再怎么转发，交给它！\u0026quot;，巧妙吧。\n那交给路由器之后，路由器又是怎么把数据包准确转发给指定设备的呢？\n别急我们慢慢来。\n我们先给上面的组网方式中的每一台设备，加上自己的 IP 地址。\n  现在两个设备之间传输，除了加上数据链路层的头部之外，还要再增加一个网络层的头部。\n假如 A 给 B 发送数据，由于它们直接连着交换机，所以 A 直接发出如下数据包即可，其实网络层没有体现出作用。\n  但假如 A 给 C 发送数据，A 就需要先转交给路由器，然后再由路由器转交给 C。由于最底层的传输仍然需要依赖以太网，所以数据包是分成两段的。\nA ~ 路由器这段的包如下：   路由器到 C 这段的包如下：\n  好了，上面说的两种情况（A-\u0026gt;B，A-\u0026gt;C），相信细心的读者应该会有不少疑问，下面我们一个个来展开。\nA 给 C 发数据包，怎么知道是否要通过路由器转发呢？\n答案：子网 \n如果源 IP 与目的 IP 处于一个子网，直接将包通过交换机发出去。\n如果源 IP 与目的 IP 不处于一个子网，就交给路由器去处理。\n好，那现在只需要解决，什么叫处于一个子网就好了。\n 192.168.0.1 和 192.168.0.2 处于同一个子网 192.168.0.1 和 192.168.1.1 处于不同子网  这两个是我们人为规定的，即我们想表示，对于 192.168.0.1 来说：\n192.168.0.xxx 开头的，就算是在一个子网，否则就是在不同的子网。 \n那对于计算机来说，怎么表达这个意思呢？于是人们发明了子网掩码的概念。\n假如某台机器的子网掩码定为 255.255.255.0。\n这表示，将源 IP 与目的 IP 分别同这个子网掩码进行与运算，相等则是在一个子网，不相等就是在不同子网，就这么简单。\n比如：\n  A电脑：192.168.0.1 \u0026amp; 255.255.255.0 = 192.168.0.0\n  B电脑：192.168.0.2 \u0026amp; 255.255.255.0 = 192.168.0.0\n  C电脑：192.168.1.1 \u0026amp; 255.255.255.0 = 192.168.1.0\n  D电脑：192.168.1.2 \u0026amp; 255.255.255.0 = 192.168.1.0\n那么 A 与 B 在同一个子网，C 与 D 在同一个子网，但是 A 与 C 就不在同一个子网，与 D 也不在同一个子网，以此类推。\n    所以如果 A 给 C 发消息，A 和 C 的 IP 地址分别 \u0026amp; A 机器配置的子网掩码，发现不相等，则 A 认为 C 和自己不在同一个子网，于是把包发给路由器，就不管了，之后怎么转发，A 不关心。\nA 如何知道，哪个设备是路由器？\n答案：在 A 上要设置默认网关 \n上一步 A 通过是否与 C 在同一个子网内，判断出自己应该把包发给路由器，那路由器的 IP 是多少呢？\n其实说发给路由器不准确，应该说 A 会把包发给默认网关。\n对 A 来说，A 只能直接把包发给同处于一个子网下的某个 IP 上，所以发给路由器还是发给某个电脑，对 A 来说也不关心，只要这个设备有个 IP 地址就行。\n所以默认网关，就是 A 在自己电脑里配置的一个 IP 地址，以便在发给不同子网的机器时，发给这个 IP 地址。\n  路由器如何知道C在哪里？\n答案：路由表 \n现在 A 要给 C 发数据包，已经可以成功发到路由器这里了，最后一个问题就是，路由器怎么知道，收到的这个数据包，该从自己的哪个端口出去，才能直接（或间接）地最终到达目的地 C 呢。\n路由器收到的数据包有目的 IP 也就是 C 的 IP 地址，需要转化成从自己的哪个端口出去，很容易想到，应该有个表，就像 MAC 地址表一样。\n这个表就叫路由表。\n至于这个路由表是怎么出来的，有很多路由算法，本文不展开，因为我也不会哈哈~\n不同于 MAC 地址表的是，路由表并不是一对一这种明确关系，我们下面看一个路由表的结构。\n  我们学习一种新的表示方法，由于子网掩码其实就表示前多少位表示子网的网段，所以如 192.168.0.0（255.255.255.0） 也可以简写为 192.168.0.0/24。\n  这就很好理解了，路由表就表示，这个子网下的，都转发到 0 号端口，192.168.1.xxx 这个子网下的，都转发到 1 号端口192.168.0.xxx 。下一跳列还没有值，我们先不管。\n配合着结构图来看（这里把子网掩码和默认网关都补齐了）结果应该是 0\n  刚才说的都是 IP 层，但发送数据包的数据链路层需要知道 MAC 地址，可是我只知道 IP 地址该怎么办呢？\n答案：arp 假如你（A）此时不知道你同伴 B 的 MAC 地址（现实中就是不知道的，刚刚我们只是假设已知），你只知道它的 IP 地址，你该怎么把数据包准确传给 B 呢？\n答案很简单，在网络层，我需要把 IP 地址对应的 MAC 地址找到，也就是通过某种方式，找到192.168.0.2  对应的 MAC 地址 BBBB。\n这种方式就是 arp 协议，同时电脑 A 和 B 里面也会有一张 arp 缓存表，表中记录着 IP 与 MAC 地址的对应关系。\n  一开始的时候这个表是空的，电脑 A 为了知道电脑 B（192.168.0.2）的 MAC 地址，将会广播一条 arp 请求，B 收到请求后，带上自己的 MAC 地址给 A 一个响应。此时 A 便更新了自己的 arp 表。\n这样通过大家不断广播 arp 请求，最终所有电脑里面都将 arp 缓存表更新完整\n总结一下 好了，总结一下，到目前为止就几条规则：\n从各个节点的视角来看\n电脑视角：\n  首先我要知道我的 IP 以及对方的 IP\n  通过子网掩码判断我们是否在同一个子网\n  在同一个子网就通过 arp 获取对方 mac 地址直接扔出去\n  不在同一个子网就通过 arp 获取默认网关的 mac 地址直接扔出去\n  交换机视角：\n  我收到的数据包必须有目标 MAC 地址\n  通过 MAC 地址表查映射关系\n  查到了就按照映射关系从我的指定端口发出去\n  查不到就所有端口都发出去\n  路由器视角：\n  我收到的数据包必须有目标 IP 地址\n  通过路由表查映射关系\n  查到了就按照映射关系从我的指定端口发出去（不在任何一个子网范围，走其路由器的默认网关也是查到了）\n  查不到则返回一个路由不可达的数据包\n  如果你嗅觉足够敏锐，你应该可以感受到下面这句话：\n网络层（IP协议）本身没有传输包的功能，包的实际传输是委托给数据链路层（以太网中的交换机）来实现的。 涉及到的三张表分别是\n  交换机中有 MAC地址表用于映射 MAC 地址和它的端口\n  路由器中有路由表用于映射 IP 地址(段)和它的端口\n  电脑和路由器中都有 arp 缓存表用于缓存 IP 和 MAC 地址的映射关系\n  这三张表是怎么来的\n  MAC 地址表是通过以太网内各节点之间不断通过交换机通信，不断完善起来的。\n  路由表是各种路由算法 + 人工配置逐步完善起来的。\n  arp 缓存表是不断通过 arp 协议的请求逐步完善起来的。\n知道了以上这些，目前网络上两个节点是如何发送数据包的这个过程，就完全可以解释通了！\n  那接下来我们就放上本文 最后一个网络拓扑图吧，请做好 战斗准备！\n  这时路由器 1 连接了路由器 2，所以其路由表有了下一条地址这一个概念，所以它的路由表就变成了这个样子。如果匹配到了有下一跳地址的一项，则需要再次匹配，找到其端口，并找到下一跳 IP 的 MAC 地址。\n也就是说找来找去，最终必须能映射到一个端口号，然后从这个端口号把数据包发出去。\n  这时如果 A 给 F 发送一个数据包，能不能通呢？如果通的话整个过程是怎样的呢？\n  思考一分钟\u0026hellip;\n详细过程文字描述：\n1. 首先A（192.168.0.1） 通过子网掩码（255.255.255.0）计算出自己与F（192.168.2.2） 并不在同一个子网内，于是决定发送给默认网关（192.168.0.254） 。\n2. A 通过 ARP 找到默认网关 192.168.0.254 的 MAC 地址。\n3. A 将源 MAC 地址（AAAA）与网关 MAC 地址（ABAB）封装在数据链路层头部，又将源 IP 地址（192.168.0.1）和目的 IP 地址（192.168.2.2）（注意这里千万不要以为填写的是默认网关的 IP 地址，从始至终这个数据包的两个 IP 地址都是不变的，只有 MAC 地址在不断变化）封装在网络层头部，然后发包。\n  4. 交换机 1 收到数据包后，发现目标 MAC 地址是 ABAB，转发给路由器 1。\n5. 数据包来到了路由器 1，发现其目标 IP 地址是 192.168.2.2，查看其路由表，发现了下一跳的地址是 192.168.100.5。\n6. 所以此时路由器 1 需要做两件事，第一件是再次匹配路由表，发现匹配到了端口为 2，于是将其封装到数据链路层，最后把包从2 号口发出去。\n7. 此时路由器 2 收到了数据包，看到其目的地址是 192.168.2.2，查询其路由表，匹配到端口号为 1，准备从1 号口 把数据包送出去。\n8. 但此时路由器 2 需要知道192.168.2.2 的 MAC 地址了，于是查看其 arp 缓存，找到其 MAC 地址为FFFF ，将其封装在数据链路层头部，并从 1 号端口把包发出去。\n9.交换机 3 收到了数据包，发现目的 MAC 地址为FFFF ，查询其 MAC 地址表，发现应该从其6 号端口 出去，于是从 6 号端口把数据包发出去。\n10. F 最终收到了数据包！并且发现目的 MAC 地址就是自己，于是收下了这个包。\n  至此，经过物理层、数据链路层、网络层这前三层的协议，以及根据这些协议设计的各种网络设备（网线、集线器、交换机、路由器），理论上只要拥有对方的 IP 地址，就已经将地球上任意位置的两个节点连通了。\n  - 完 -\n","description":"了解网络","id":29,"section":"article","tags":["网络"],"title":"如果让你来设计网络，你会把它弄成啥样？","uri":"https://2110833194.github.io/article/network/interesting/1/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":30,"section":"gallery","tags":null,"title":"Cartoon","uri":"https://2110833194.github.io/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":31,"section":"gallery","tags":null,"title":"Photo","uri":"https://2110833194.github.io/gallery/photo/"}]