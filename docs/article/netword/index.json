[{"content":"题目：65,8,50,15,37,24,()。括号中的数字是()？ A. 25\nB. 26\nC. 22\nD. 27\n答案：\r65=8^2+1 这里将8作为65的特征\r8=3^2-1 这里得到3\r50=7^2+1 这里得到7\r15=4^2-1 这里得到4\r37=6^2+1 这里得到6\r24=5^2-1 这里得到5\r我们发现8,3,7,4,6,5 这组数的特点，以奇数项开始 奇数项加偶数项的和为11，\r以偶数项开始的话 偶数项+奇数项的和为10 8+3=7+4=6+5 3+7=4+6=5+x 这里得到x为5 特征为5 转换为5^2+1 得到26\r","description":"括号中的数字是什么?","id":0,"section":"intelligence","tags":null,"title":"智力题2.1","uri":"https://2110833194.github.io/intelligence/niuke_part2/%E6%8B%AC%E5%8F%B7%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88_1/"},{"content":"题目：5 , 6 , 6 , 9 ,（）, 90。括号中的数字是()？ A. 12\nB. 15\nC. 18\nD. 21\n答案：整个数列规律为：\r（5-3）*（6-3）=6\r（6-3）*（6-3）=9\r（6-3）*（9-3）=18\r（9-3）*（18-3）=90\r规律很多，仅供参考，自我挖掘！\r","description":"括号中的数字是什么?","id":1,"section":"intelligence","tags":null,"title":"智力题2.2","uri":"https://2110833194.github.io/intelligence/niuke_part2/%E6%8B%AC%E5%8F%B7%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88_2/"},{"content":"题目：2 ，3 ，10 ，15 ，26 ，35 ，( )。括号中的数字是是什么？ A. 40\nB. 45\nC. 50\nD. 55\n1^2+1=2 2^2-1=3 3^2+1=10 4^2-1=15 5^2+1+26 6^2-1=35 奇数项平方加一，偶数项平方减一\r","description":"括号中的数字是什么?","id":2,"section":"intelligence","tags":null,"title":"智力题2.3","uri":"https://2110833194.github.io/intelligence/niuke_part2/%E6%8B%AC%E5%8F%B7%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88_3/"},{"content":"《上部分》 这似乎是一个很凝重的话题，但是它真的很有趣。\n1. 指针是指向某一类型的东西，任何一个整体，只要能称为整体就能拥有它自己的独一无二的指针类型，所以指针的类型其实是近似无穷无尽的\n2. 函数名在表达式中总是以函数指针的身份呈现，除了取地址运算符以及sizeof\n3. C语言最晦涩难明的就是它复杂的声明: void (signal(int sig, void (func)(int)))(int),\n试试着把它改写成容易理解的形式\n4. 对于指针，尽最大的限度使用const保护它，无论是传递给函数，还是自己使用\n先来看看一个特殊的指针，姑且称它为指针，因为它依赖于环境: NULL，是一个神奇的东西。先附上定义，在编译器中会有两种NULL(每种环境都有唯一确定的NULL):\n1 2  #define NULL 0 #define NULL ((void*)0)   有什么区别吗？看起来没什么区别都是0，只不过一个是常量，一个是地址为0的指针。\n当它们都作为指针的值时并不会报错或者警告，即编译器或者说C标准认为这是合法的:\n1 2 3  int* temp_int_1 = 0; //无警告 int* temp_int_2 = (void*)0; //无警告 int* temp_int_3 = 10; //出现警告   为什么？为什么0可以赋值给指针，但是10却不行？他们都是常量。\n因为C语言规定当处理上下文的编译器发现常量0出现在指针赋值的语句中，它就作为指针使用，似乎很扯淡，可是却是如此。\n回到最开始，对于NULL的两种情况，会有什么区别？拿字符串来说，实际上我是将字符数组看作是C风格字符串。\n在C语言中，字符数组是用来存储一连串有意义的字符，默认在这些字符的结尾添加'\\0'，好这里又出现了一个0值。\n对于某些人，在使用字符数组的时候总是分不清楚NULL与'\\0\u0026rsquo;的区别而误用，在字符数组的末尾使用NULL是绝对错误的！虽然它们的本质都是常量0，但由于位置不同所以含义也不同。\n开胃菜已过\n对于一个函数，我们进行参数传递，参数有两种形式: 形参与实参\n1 2 3 4 5 6  int function(int value) { /*...*/ } //... function(11);   其中，value是形参，11是实参，我们知道场面上，C语言拥有两种传递方式:按值传递和按址传递，但是你是否有认真研究过？这里给出一个实质，其实C语言只有按值传递，所谓按址传递只不过是按值传递的一种假象。至于原因稍微一想便能明白。\n对于形参和实参而言两个关系紧密，可以这么理解总是实参将自己的一份拷贝传递给形参，这样形参便能安全的使用实参的值，但也带给我们一些麻烦，最经典的交换两数\n1 2 3 4 5 6 7  void swap_v1(int* val_1, int* val_2) { int temp = *val_1; *val_1 = *val_2; *val_2 = *val_1; }   这就是所谓的按址传递，实际上只是将外部指针(实参)的值做一个拷贝，传递给形参val_1与val_2，实际上我们使用:\n1 2  #define SWAP_V2(a, b) (a += b, b = a - b, a -= b) #define SWAP_V3(x, y) {x ^= y; y ^= x; x ^= y}   试一试是不是很神奇，而且省去了函数调用的时间，空间开销。上述两种写法的原理实质是一样的。\n但是，动动脑筋想一想，这种写法真的没有瑕疵吗？如果输入的两个参数本就指向同一块内存，会发生什么？\n1 2 3 4 5 6 7 8  ... int test_1 = 10, test_2 = 100; SWAP_V2(test_1, test_2); printf(\u0026#34;Now the test_1 is %d, test_2 is %d\\n\u0026#34;, test_1, test_2); .../*恢复原值*/ SWAP_V2(test_1, test_1); printf(\u0026#34;Now the test_1 is %d\\n\u0026#34;, test_1);   会输出什么？:\n1 2  $: Now the test_1 is 100, test_2 is 10 $: Now the test_1 is 0   对，输出了0，为什么？稍微动动脑筋就能相通，那么对于后面的SWAP_V3亦是如此，所以在斟酌之下，解决方案应该尽可能短小精悍:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  static inline void swap_final(int* val_1, int* val_2) { if(val_1 == val_2) return; *val_1 ^= *val_2; *val_2 ^= *val_1; *val_1 ^= *val_2; } #define SWAP(x, y) do{ if(\u0026amp;x == \u0026amp;y) break; x ^= y; y ^= x; x ^= y; }while(0)   这便是目前能找到最好的交换函数，我们在此基础上可以考虑的更深远一些，如何让这个交换函数更加通用？即适用范围更大？暂不考虑浮点类型。\n提示：可用void*\n与上面的情况类似，偶尔的不经意就会造成严重的后果:\n1 2 3 4 5 6 7 8 9 10 11  int combine_1(int* dest, int* add) { *dest += *add; *dest += *add; return *dest; } int combine_2(int* dest, int* add) { *dest += 2 * (*add);//在不确定优先级时用括号是一个明智的选择  return *dest; }   上述两个函数的功能一样吗？恩看起来是一样的\n1 2 3 4 5 6  int test_3 = 10, test_4 = 100; combine_1(\u0026amp;test_3, \u0026amp;test_4); printf(\u0026#34;After combine_1, test_3 = %d\\n\u0026#34;,test_3); .../*恢复原值*/ combine_2(\u0026amp;test_3, \u0026amp;test_4); printf(\u0026#34;After combine_2, test_3 = %d\\n\u0026#34;,test_3);   输出\n1 2 3 4  $: After combine_1, test_3 = 210 $: After combine_2, test_3 = 210   如果传入两个同一对象呢？\n1 2 3 4 5 6  ... /*恢复test_3原值*/ combine_1(\u0026amp;test_3, \u0026amp;test_3); printf(\u0026#34;After second times combine_1, test_3 = %d\\n\u0026#34;,test_3); ... combine_2(\u0026amp;test_3, \u0026amp;test_3); printf(\u0026#34;After second times combine_2, test_3 = %d\\n\u0026#34;,test_3);   输出\n1 2 3  $: After second times combine_1, test_3 = 40 $: After second times combine_2, test_3 = 30   知道真相总是令人吃惊，指针也是那么令人又爱又恨。\n C99 标准之后出现了一个新的关键字， restrict，被用于修饰指针，它并没有太多的显式作用，甚至加与不加，在 你自己 看来，效果毫无区别。但是反观标准库的代码中，许多地方都使用了该关键字，这是为何\n首先这个关键字是写给编译器看的\n其次这个关键字的作用在于辅助编译器更好的优化该程序(后方文章会有介绍)\n最后，如果不熟悉，绝对不要乱用这个关键字  关于数组的那些事\n数组和指针一样吗？\n不一样!\n要时刻记住，数组与指针是不同的东西。但是为什么下面代码是正确的？\n1 2  int arr[10] = {10, 9, 8, 7}; int* parr = arr;   我们还是那句话，结合上下文，编译器推出 arr处于赋值操作符的右侧，默默的将他转换为对应类型的指针，而我们在使用arr时也总是将其当成是指向该数组内存块首位的指针。\n1 2 3 4 5 6 7 8 9 10  //int function2(const int test_arr[10] //int function2(const int test_arr[]) 考虑这三种写法是否一样 int function2(const int* test_arr) { return sizeof(test_arr); } int size_out = sizeof(arr); int size_in = function2(arr); printf(\u0026#34;size_out = %d, size_in = %d\\n\u0026#34;, size_out, size_in);   1  输出: size_out = 40, size_in = 8   这就是为什么数组与指针不同的原因所在，在外部即定义数组的代码块中，编译器通过上下文发觉此处arr是一个数组，而arr代表的是一个指向10个int类型的数组的指针，只所谓最开始的代码是正确的，只是因为这种用法比较多，就成了标准的一部分。就像世上本没有路，走的多了就成了路。”正确”的该怎么写\n1  int (*p)[10] = \u0026amp;arr;   此时p的类型就是一个指向含有10个元素的数组的指针,此时(*p)[0]产生的效果是arr[0]，也就是parr[0]，但是(*p)呢？这里不记录，结果是会溢出，为什么？\n这就是数组与指针的区别与联系，但是既然我们可以使用像parr这样的指针，又为什么要写成int (*p)[10]这样丑陋不堪的模式呢？原因如下:\n回到最开始说过的传递方式，按值传递在传递arr时只是纯粹的将其值进行传递，而丢失了上下文的它只是一个普通指针，只不过我们程序员知道它指向了一块有意义的内存的起始位置，我想要将数组的信息一起传递，除了额外增加一个参数用来记录数组的长度以外，也可以使用这个方法，传递一个指向数组的指针\n这样我们就能只传递一个参数而保留所有信息。但这么做的也有限制:对于不同大小，或者不同存储类型的数组而言，它们的类型也有所不同\n1 2 3 4  int arr_2[5]; int (*p_2)[5] = \u0026amp;arr_2; float arr_3[5]; float (*p_3)[5] = \u0026amp;arr_3;   如上所示，指向数组的指针必须明确指定数组的大小，数组存储类型，这就让指向数组的指针有了比较大的限制。\n这种用法在多维数组中使用的比较多，但总体来说平常用的并不多，就我而言，更倾向于使用一维数组来表示多维数组，实际上诚如前面所述，C语言是一个非常简洁的语言，它没有太多的废话，就本质而言C语言并没有多维数组，因为内存是一种线性存在，即便是多维数组也是实现成一维数组的形式。\n就多维数组在这里解释一下。所谓多维数组就是将若干个降一维的数组组合在一起，降一维的数组又由若干个更降一维的数组组合在一起，直到最低的一维数组，举个例子:\n1  int dou_arr[5][3];   就这个二维数组而言，将5个每个为3个int类型的数组组合在一起，要想指向这个数组该怎么做？\n1 2 3  int (*p)[3] = \u0026amp;dou_arr[0]; int (*dou_p)[5][3] = \u0026amp;dou_arr; int (*what_p)[3] = dou_arr;   实际上多维数组只是将多个降一维的数组组合在一起，令索引时比较直观而已。当真正理解了内存的使用，反而会觉得多维数组带给自己更多限制\n对于第三句的解释，当数组名出现在赋值号右侧时，它将是一个指针，类型则是 指向该数组元素的类型，而对于一个多维数组来说，其元素类型则是其降一维数组，即指向该降一维数组的指针类型。这个解释有点绕，自己动手写一写就好很多。\n对于某种形式下的操作，我们总是自然的将相似的行为结合在一起考虑。考虑如下代码:\n1 2 3  int* arr_3[5] = {1, 2, 3, 4, 5}; int* p_4 = arr_3; printf(\u0026#34;%d == %d == %d ?\\n\u0026#34;, arr_3[2], *(p_4 + 2), *(arr_3 + 2));     输出: 3 == 3 == 3 ?\n  实际上对于数组与指针而言， []操作在大多数情况下都能有相同的结果，对于指针而言*(p_4 + 2)相当于p_4[2]，也就是说[]便是指针运算的语法糖，有意思的是2[p_4]也相当于p_4[2]，\u0026ldquo;Iamastring\u0026rdquo;[2] == \u0026rsquo;m'，但这只是娱乐而已，实际中请不要这么做，除非是代码混乱大赛或者某些特殊用途。\n在此处，应该声明的是这几种写法的执行效率完全一致，并不存在一个指针运算便快于[]运算，这些说法都是上个世纪的说法了，随着时代的发展，我们应该更加注重代码整洁之道\n  在此处还有一种奇异又实用的技巧，在char数组中使用指针运算进行操作，提取不同类型的数据，或者是在不同类型数组中，使用char*指针抽取其中内容，才是显示指针运算的用途。但在使用不同类型指针操作内存块的时候需要注意，不要操作无意义的区域或者越界操作。\n  实际上，最简单的安全研究之一，便是利用溢出进行攻击。\n Advance:对于一个函数中的某个数组的增长方向，总是向着返回地址的，中间可能隔着许多其他自动变量，我们只需要一直进行溢出试验，直到某一次，该函数无法正常返回了！那就证明我们找到了该函数的返回地址存储地区，这时候我们可以进行一些操作，例如将我们想要的返回地址覆盖掉原先的返回地址，这就是所谓的溢出攻击中的一种。  《下部分》 内存的使用的那些事儿\n你一直以为你操作的是真实物理内存，实际上并不是，你操作的只是操作系统为你分配的资格虚拟地址，但这并不意味着我们可以无限使用内存，那内存卖那么贵干嘛，实际上存储数据的还是物理内存，只不过在操作系统这个中介的介入情况下，不同程序窗口(可以是相同程序)可以共享使用同一块内存区域，一旦某个傻大个程序的使用让物理内存不足了，我们就会把某些没用到的数据写到你的硬盘上去，之后再使用时，从硬盘读回。这个特性会导致什么呢？假设你在Windows上使用了多窗口，打开了两个相同的程序:\n1 2 3 4 5 6 7 8 9 10 11 12 13  ... int stay_here; char tran_to_int[100]; printf(\u0026#34;Address: %p\\n\u0026#34;,\u0026amp;stay_here); fgets(tran_to_int,sizeof(tran_to_int), stdin); sscanf(tran_to_int,\u0026#34;%d\u0026#34;,\u0026amp;stay_here); for(;;) { printf(\u0026#34;%d\\n\u0026#34;, stay_here); getchar(); ++stay_here; } ...   对此程序(引用前桥和弥的例子)，每敲击一次回车，值加1。当你同时打开两个该程序时，你会发现，两个程序的stay_here都是在同一个地址，但对它进行分别操作时，产生的结果是独立的！这在某一方面验证了虚拟地址的合理性。虚拟地址的意义就在于，即使一个程序出现了错误，导致所在内存完蛋了，也不会影响到其他进程。对于程序中部的两个读取语句，是一种理解C语言输入流本质的好例子，建议查询用法，这里稍微解释一下:\n通俗地说，fgets将输入流中由调用起，stdin输入的东西存入起始地址为tran_to_int的地方，并且最多读取sizeof(tran_to_int)个，并在后方sscanf函数中将刚才读入的数据按照%d的格式存入stay_here，这就是C语言一直在强调的流概念的意义所在，这两个语句组合看起来也就是读取一个数据这么简单，但是我们要知道一个问题，一个关于scanf的问题\nscanf(\u0026quot;%d\u0026quot;,\u0026amp;stay_here);\n这个语句将会读取键盘输入，直到回车之前的所有数据，什么意思？就是回车会留在输入流中，被下一个输入读取或者丢弃。这就有可能会影响我们的程序，产生意料之外的结果。而使用上当两句组合则不会。\n函数与函数指针的那些事\n事实上，函数名出现在赋值符号右边就代表着函数的地址\n1 2 3 4 5  intfunction(int argc){/*...*/ } ... int(*p_fun)(int)=function; int(*p_fuc)(int)=\u0026amp;function;//和上一句意义一致   上述代码即声明并初始化了函数指针，p_fun的类型是指向一个返回值是int类型，参数是int类型的函数的指针\n1 2 3  p_fun(11); (*p_fun)(11); function(11);   上述三个代码的意义也相同，同样我们也能使用函数指针数组这个概念\nint(*p_func_arr[])(int)={func1, func2,};\r其中func1,func2都是返回值为int参数为int的函数，接着我们能像数组索引一样使用这个函数了。\nTips: 我们总是忽略函数声明，这并不是什么好事。\n在C语言中，因为编译器并不会对有没有函数声明过分深究，甚至还会放纵，当然这并不包含内联函数(inline)，因为它本身就只在本文件可用。\n比如，当我们在某个地方调用了一个函数，但是并没有声明它：\n1  CallWithoutDeclare(100);//参数100为 int 型   那么，C编译器就会推测，这个使用了int型参数的函数，一定是有一个int型的参数列表，一旦函数定义中的参数列表与之不符合，将会导致参数信息传递错误(编译器永远坚信自己是对的！)，我们知道C语言是强类型语言，一旦类型不正确，会导致许多意想不到的结果(往往是Bug)发生。\n对函数指针的调用同样如此\nC语言中malloc的那些事儿\n我们常常见到这种写法:\n1  int* pointer =(int*)malloc(sizeof(int));   这有什么奇怪的吗？看下面这个例子:\nint* pointer_2 = malloc(sizeof(int));\n哪个写法是正确的？两个都正确，这是为什么呢，这又要追求到远古C语言时期，在那个时候， void* 这个类型还没有出现的时候，malloc 返回的是 char* 的类型，于是那时的程序员在调用这个函数时总要加上强制类型转换，才能正确使用这个函数，但是在标准C出现之后，这个问题不再拥有，由于任何类型的指针都能与 void* 互相转换，并且C标准中并不赞同在不必要的地方使用强制类型转换，故而C语言中比较正统的写法是第二种。\n题外话: C++中的指针转换需要使用强制类型转换，而不能像第二种例子，但是C++中有一种更好的内存分配方法，所以这个问题也不再是问题。\nTips:\nC语言的三个函数malloc, calloc, realloc都是拥有很大风险的函数，在使用的时候务必记得对他们的结果进行校验，最好的办法还是对他们进行再包装，可以选择宏包装，也可以选择函数包装。\nrealloc函数是最为人诟病的一个函数，因为它的职能过于宽广，既能分配空间，也能释放空间，虽然看起来是一个好函数，但是有可能在不经意间会帮我们做一些意料之外的事情，例如多次释放空间。正确的做法就是，应该使用再包装阉割它的功能，使他只能进行扩展或者缩小堆内存块大小。\n指针与结构体\n1 2 3 4 5 6 7 8 9 10 11  typedefstruct tag{ int value; long vari_store[1]; }vari_struct; ```c 乍一看，似乎是一个很中规中矩的结构体 ```c ... vari_struct vari_1; vari_struct* vari_p_1 =\u0026amp;vari_1; vari_struct* vari_p_2 = malloc(sizeof(vari_struct))(   似乎都是这么用的，但总有那么一些人想出了一些奇怪的用法\n1 2  int what_spa_want =10; vari_struct* vari_p_3 = malloc(sizeof(vari_struct)+sizeof(long)*what_spa_want);    这么做是什么意思呢？这叫做可变长结构体，即便我们超出了结构体范围，只要在分配空间内，就不算越界。what_spa_want解释为你需要多大的空间，即在一个结构体大小之外还需要多少的空间，空间用来存储long类型，由于分配的内存是连续的，故可以直接使用数组vari_store直接索引。\n而且由于C语言中，编译器并不对数组做越界检查，故对于一个有N个数的数组arr，表达式\u0026amp;arr[N]是被标准允许的行为，但是要记住arr[N]却是非法的。\n这种用法并非是娱乐，而是成为了标准(C99)的一部分，运用到了实际中  对于内存的理解\n在内存分配的过程中，我们使用 malloc 进行分配，用 free 进行释放，但这是我们理解中的分配与释放吗？\n在调用 malloc 时，该函数或使用 brk() 或使用 mmap() 向操作系统申请一片内存，在使用时分配给需要的地方，与之对应的是 free，与我们硬盘删除东西一样，实际上:\n1 2 3 4  int* value = malloc(sizeof(int)*5); ... free(value); printf(\u0026#34;%d\\n\u0026#34;, value[0]);   代码中，为什么在 free 之后，我又继续使用这个内存呢？因为 free 只是将该内存标记上释放的标记，示意分配内存的函数，我可以使用，但并没有破坏当前内存中的内容，直到有操作对它进行写入。\n这便引申出几个问题:\nBug更加难以发现，让我们假设，如果我们有两个指针p1,p2指向同一个内存，如果我们对其中某一个指针使用了 free(p1); 操作，却忘记了还有另一个指针指向它，那这就会导致很严重的安全隐患，而且这个隐患十分难以发现，原因在于这个Bug并不会在当时显露出来，而是有可能在未来的某个时刻，不经意的让你的程序崩溃。\n有可能会让某些问题更加简化，例如释放一个条条相连的链表域。\n某些大哥提到说，free并不是什么都不做，而是将该段地址空间的前面一小部分置零\n但是如果地址空间很长的话，依旧有误用的风险，希望大家还是警惕\n实际上之所以库作者不让free操作将地址空间清空，有一部分原因是为了性能考虑，因为置零操作是一个消耗性能的行为，具体可以自行尝试，所谓双刃剑就在于此。\n 总的来说，还是那句话C语言是一把双刃剑。     所以，指针其实就是一个存放了另外一个存储空间的地址的存储空间，从而可以由本指针存储空间访问到另外一个存储空间！      \u0026mdash;\u0026ndash;摘抄自《c语言进阶》一书\n","description":"都2021年了，还搞不懂c语言指针是什么？","id":3,"section":"article","tags":null,"title":"c语言指针！","uri":"https://2110833194.github.io/article/program/c/c_pointer/"},{"content":"题目：一台指针式钟表的时针和分针指向的重合的时间间隔是？\n答案：\r由于分针总是比时针走的快，所以问题就转换成时针在一圈的范围内追击分针的问题：\r分针走的角速度是360°/60分 = 6°/分\r时针走的角速度是360°/720分 = 0.5°/分\r下一次追到比上一次追到，分针比时针多走过的角度是360°，\r那么在一圈的角度内 360°/(6°/分-0.5°/分) = 720/11 分钟，\r经过这么多时间 分针和时间重合一次，\r所以引申到一昼夜时间内分针 时针相遇多少次：24*60/(720/11) = 22 次\r","description":"时针和分针指向的重合的时间间隔是？","id":4,"section":"intelligence","tags":null,"title":"智力题1.3","uri":"https://2110833194.github.io/intelligence/niuke_part1/%E6%97%B6%E9%92%88%E4%B8%8E%E5%88%86%E9%92%88%E9%87%8D%E5%90%88/"},{"content":"题目：对一批编号为1～100，全部开关朝上(开)的灯进行以下操作：\n凡是1的倍数反方向拨一次开关；2的倍数反方向又拨一次开关；\n3的倍数反方向又拨一次开关……100的倍数反方向又拨一次开关 ,\n问：最后为关熄状态的灯有几个?\n答案：分析：所有的灯都会根据它是否是某数的倍数来拨动开关，比如1是1的倍数，\r但它不是其他剩余99个数的倍数，故只拨动一次开关，初始状态为开，\r只要经过奇数次拨动开关，最终状态都会是关着的灯\r进一步分析：上述分析又可以根据题意来化解为只有这个编号含有奇数个因数的灯，\r在经过所有关灯操作之后，它的最终状态就是关闭的，所以2不是（1，2），\r3不是（1,3）,4是(1，2，4)，...9是（1,3,9）,...16是（1,2,4,8,16），\r发现规律的吧，1的平方，2的平方，3的平方，4的平方，\r所有1-100一共有10个最后为关熄状态的灯。\r","description":"最后为关熄状态的灯有几个?","id":5,"section":"intelligence","tags":null,"title":"智力题1.4","uri":"https://2110833194.github.io/intelligence/niuke_part1/%E6%9C%80%E5%90%8E%E4%B8%BA%E5%85%B3%E7%86%84%E7%8A%B6%E6%80%81%E7%9A%84%E7%81%AF%E6%9C%89%E5%87%A0%E4%B8%AA/"},{"content":"题目：假设一个5位数字的180度旋转图像是另一个5位数字，并且这两个数字之间的差是78633，那么原始的5位数字是什么？\n答案：\r首先，只有0，1，2，6，8，9，6个数字反转仍有效。另外要注意，旋转180度，\r数字所在位也变了。考虑首位和末位，要求差为7和3，只有1和8满足。\r1xxx8和8xxx1。考虑倒数第二位3，由于末位退位，要求差4，只有0和6。\r所以是10x68和89x01。最后看中间，78633+10x68=89x01。\r所有原始数字是10968或者89601\r","description":"原始的5位数字是什么？","id":6,"section":"intelligence","tags":null,"title":"智力题1.5","uri":"https://2110833194.github.io/intelligence/niuke_part1/%E5%8E%9F%E5%A7%8B%E7%9A%845%E4%BD%8D%E6%95%B0%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88/"},{"content":"题目：医院里的医务人员，包括我在内，总共是16名医生和护士。下面讲到的人员情况，无论是否把我计算在内，都不会有任何变化。在这些医务人员中： (1)护士多于医生;(2)男医生多于男护士;(3)男护士多於女护士;(4)至少有一位女医生。 这位说话的人是什么性别和职务？\n答案：\r先考虑不把说话者计算在内的情况，这时医生和护士共有15名。\r首先由条件（1）可知，则护士至少应有8名；再由条件（3）可知，\r则男护士至少有5名；接着由条件（2）可知，男医生至少有6名；\r结合条件（4）可知，医生至少有7名，则护士至多8名。所以，\r要满足条件，只能是护士8名，其中男护士5名，女护士3名，医生7名，\r其中男医生6名，女医生1名。加上说话者后，要仍满足这四个条件，\r由条件（1）可知，说话者是护士；由条件（2）可知，说话者不能是男护士，\r所以只能是女护士。\r","description":"题目：这位说话的人是什么性别和职务","id":7,"section":"intelligence","tags":null,"title":"智力题3.1","uri":"https://2110833194.github.io/intelligence/niuke_part3/%E8%BF%99%E4%BD%8D%E8%AF%B4%E8%AF%9D%E7%9A%84%E4%BA%BA%E6%98%AF%E4%BB%80%E4%B9%88%E6%80%A7%E5%88%AB%E5%92%8C%E8%81%8C%E5%8A%A1/"},{"content":"题目：\n已知每个城市的用水需求相同，每月水库的进水速率恒定不变。现有一座水库供水，如果供应10个城市的话，一个月水库就会枯竭；如果供应8个城市的话，一个半月水库就会枯竭。当前城市化进程不断加快，新的城市不断产生，为了能够持续满足12个城市的供水，还至少需要建设几个这样的水库？\n假设水库库存的水量为M\r水库每月进水为X\r每个城市每月消耗水m\r由题意：\rM + X = 10 * m\rM + 1.5 * X = 8 * m * 1.5\r解得：\rX = 4m\r因此：\r要维持12个城市每月持续不断的供水，要满足：(?) * X = m * 12\r解得：(?) = 3\r题目问的是：\u0026quot;还至少需要建设几个这样的水库？\u0026quot;\r不应该是2个吗？(因为现在已经有一个水库了...)\r","description":"还至少需要建设几个这样的水库?","id":8,"section":"intelligence","tags":null,"title":"智力题4.1","uri":"https://2110833194.github.io/intelligence/niuke_part4/%E8%BF%98%E8%87%B3%E5%B0%91%E9%9C%80%E8%A6%81%E5%BB%BA%E8%AE%BE%E5%87%A0%E4%B8%AA%E8%BF%99%E6%A0%B7%E7%9A%84%E6%B0%B4%E5%BA%93/"},{"content":"题目：把21、26、65、99、10、35、18、77分成若干组，要求每组中任意两个数都互质，至少要分成多少组。\n答案：1.首先把含有相同因数的数分到一组，或者是没有相同因数的质数分为一组\r2.列出来：含有因数3的：21，99，18。含有因数5的：10，35，65。\r是质数（77不是质数，但剩下的数里面没有和它有相同因数的，故分到一组）的：26，77\r3.然后把这些组组合起来，所以至少是三组。\r解惑（思路有很多，比如也可以在第一第二步选择将偶数分为一组，然后再细分）\r","description":"题目：至少要分为多少组？","id":9,"section":"intelligence","tags":null,"title":"智力题4.2","uri":"https://2110833194.github.io/intelligence/niuke_part4/%E8%87%B3%E5%B0%91%E8%A6%81%E5%88%86%E4%B8%BA%E5%A4%9A%E5%B0%91%E7%BB%84/"},{"content":"题目：1000 个瓶子中有一瓶毒药，一只老鼠吃到毒药一周之内会死，如果要在一周之内检测出有毒药的一瓶，问至少需要几只老鼠？\nA:8\nB:10\nC:24\nD:999\n答案是十只 000=0\r001=1\r010=2\r011=3\r100=4\r101=5\r110=6\r111=7\r一位表示一个老鼠，0-7表示8个瓶子。\r也就是分别将1、3、5、7号瓶子的药混起来给老鼠1吃，\r2、3、6、7号瓶子的药混起来给老鼠2吃，\r4、5、6、7号瓶子的药混起来给老鼠3吃，\r哪个老鼠死了，相应的位标为1。\r如老鼠1死了、老鼠2没死、老鼠3死了，\r那么就是101=5号瓶子有毒。\r同样道理10个老鼠可以确定1000个瓶子\r","description":"问至少需要几只老鼠？","id":10,"section":"intelligence","tags":null,"title":"智力题1.1","uri":"https://2110833194.github.io/intelligence/niuke_part1/%E8%80%81%E9%BC%A0%E6%B5%8B%E6%AF%92%E8%8D%AF/"},{"content":"1\n1 1\n2 1\n1 2 1 1\n1 1 1 2 2 1\n下一行是什么\nA:1111211\nB:312211\nC:312112\nD:213112\n微软的题\r答案：后一行数是前一行数的描述，把“个”字去掉组成新的数：\r-1：1个1 ——11\r- 11：2个1——21\r- 21：1个2，1个1——1211\r- 1211：1个1,1个2,2个1——111221\r- 111221：3个1，2个2，1个1——312211\r","description":"题目：下一行输出什么","id":11,"section":"intelligence","tags":null,"title":"智力题1.2","uri":"https://2110833194.github.io/intelligence/niuke_part1/%E4%B8%8B%E4%B8%80%E8%A1%8C%E8%AF%A5%E8%BE%93%E5%87%BA%E4%BB%80%E4%B9%88/"},{"content":"1\r此文章取自于微信公众号“低并发编程”\n正文开始：\n小宇：闪客，我最近在研究动态规划，但感觉就是想不明白，你能不能给我讲讲呀？ \n闪客：没问题，这个我擅长，你先说说提到动态规划，你最先想到的是什么？\n小宇：就什么子问题呀、状态转移方程呀乱七八糟的，哎呀不行不行，我一想到这些脑子又嗡嗡响了。\n闪客：你先别急，你先把所有的名词都抛在脑后，听我讲。\n小宇：好滴，你说吧。\n闪客：小宇我问你，从 1 一直加到 100 等于多少？\n1 + 2 + 3 + ... + 100 = ？\r小宇：5050！\n闪客：你这，怎么不按套路出牌呀，你应该说不知道。\n小宇：人家高斯早就算出来了，我还装不知道，这也太假了吧。\n全剧终...\r2\r闪客：好吧，那我再给你出一个题。\n小宇：行，你说吧，这回我肯定说不知道。\n闪客：一个楼梯有 10 级台阶，你从下往上走，每跨一步只能向上迈 1 级或者 2 级台阶，请问一共有多少种走法？\n小宇：额，这我真不知道了，我想想哈。\n  \n小宇：不行了不行了，实在想不明白，想了后面的就忘了前面的。\n闪客：你还是陷入了穷举的思想，你仔细想想我给你出的第一个题，看看有没有思路。\n小宇：啊！原来是有关联的呀。\n闪客：对呀，我本来想说假如我告诉你 1+\u0026hellip;+99 是多少，你是不是就直接能算出 1+\u0026hellip;+100 的值了。\n小宇：哦你这么一提示我有点感觉了！要想走到第 10 级台阶，要么是先走到第 9 级，然后再迈一步 1 级台阶上去，要么是先走到第 8 级，然后一次迈 2 级台阶上去。\n  闪客：太棒了！你找到感觉了！接着往下说。\n小宇：这样的话，走到 10 级台阶的走法数，就等于走到 9 级台阶的走法数，加上走到 8 级台阶的走法数。\n闪客：很好，那假如走到第 x 级台阶的走法数我们定义为 F(x)，那你能把刚刚的描述公式化么？\n小宇：那太简单了，公式就是：\nF(10) = F(9) + F(8)\r闪客：没错，而且不光是 10 级台阶如此，走到任何一级台阶的走法数，都符合这个逻辑，因此就可以得出一个通用公式：\nF(x) = F(x-1) + F(x-2)\r小宇：嗯嗯，这样计算 F(10)，只需要知道 F(9) 和 F(8) 就可以了，而计算 F(8)，就只需要知道 F(7) 和 F(6) 就可以了，依次类推。\n闪客：没错，那你想想看 F(2) 和 F(1) 怎么计算？\n小宇：简单，还是刚刚都逻辑被，想知道 F(2)，只需要知道 F(1) 和 F(0)，诶不对 F(0) 是什么鬼？还有 F(1) 的计算需要知道 F(0) 和 F(-1)，不行呀，这解释不通了。\n闪客：哈哈，别急，在这道题里，如果只迈到 1 级台阶，那一共就一种走法；如果只迈到 2 级台阶，就只有两种走法。可以直接很直观地得出，没必要推导。\n  小宇：哦哦我懂了，这道题里由于每一个递推项都需要前两项的支持，所以必须有最开头的两项作为已知，就是你说的 F(1) = 1 和 F(2) = 2。\n闪客：没错。\n小宇：嗯嗯，感觉这样就推出全部结果了！我写一下程序你看看。\n闪客：先别急，由于这道题是一道经典的动态规划题，所以我们以这道题为例子来定义动态规划的三要素，在本题中\nF(x-1) 和 F(x-2) 被称为 F(x) 的最优子结构\nF(x) = F(x-1) + F(x-2) 叫状态转移方程\nF(1) = 1, F(2) = 2 是问题的边界\n之后做动态规划问题，只要找好这三个要素就好了。\n小宇：哇，升华了诶，逼格瞬间高了不少呢。\n闪客：先别说这些废话了，那接下来你看看能不能写出程序，计算出 F(10) 的结果，这才是难点。\n小宇：编程的话这似乎是个递归问题，简单！\n c golang  1 2 3 4 5 6 7 8 9  int getWays(int n) { if (n == 1) { return 1; } if (n == 2) { return 2; } return getWays(n-1) + getWays(n-2); }    \r1 2 3 4 5 6 7 8 9  func getways(n int)int{ if n == 1 { return 1 } if n == 2 { return 2 } return getWays(n-1) + getways(n-2) }    \r  'use strict'; var containerId = JSON.parse(\"\\\"b059bc293d889ef1\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \n闪客：嗯不错，这样很简洁，但复杂度太高了，是 O(2^n)，具体你可以之后想想为什么。现在你看看能不能将复杂度降低。\n小宇：我想想看，计算 F(10) 时需要计算 F(9) 和 F(8)，而在递归计算 F(9) 时要计算 F(8) 和 F(7)，这样 F(8) 在这里重复计算了，浪费了时间。\n  \n闪客：没错，其实计算新一个阶段的值，只需要一直将其前两个阶段的值保存起来，就可以一直算到最终的结果了。比如定义两个变量 a 和 b 用于存储前两个阶段的值，在计算 F(3) 时。\n\n\r\r台阶\r1\r2\r3\r4\r...\r10\r\r\r走法\ra=1\rb=2\r3\r\r\r\r\r\r\n计算 F(4) 时，F(1) 的值就不用保存了，a 和 b 依次替换新值。\n\r\r台阶\r1\r2\r3\r4\r...\r10\r\r\r走法\r\ra=2\rb=3\r5\r\r\r\r\r\n依此类推，最终就算出了 F(10) 的值。\n\r\r台阶\r1\r2\r...\r8\r9\r10\r\r\r走法\r\r\r\ra=33\rb=55\r89\r\r\r\n当然你也可以把之前的值都保留，但这样就增加了空间复杂度，看你的需求了。\n小宇：好的，那这样代码也很好写，就这样。\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  int getWays2(int n) { if (n == 1) { return 1; } if (n == 2) { return 2; } int a = 1; int b = 2; int temp = 0; for (int i = 3; i \u0026lt;= n; i++) { temp = a + b; a = b; b = temp; } return temp; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func getWays2(int n)int{ if n == 1 { return 1 } if n == 2 { return 2 } var a int = 1 var b int = 2 var temp int = 0 for i := 3; i \u0026lt;= n; i++ { temp = a + b a = b b = temp } return temp }    \r  'use strict'; var containerId = JSON.parse(\"\\\"54d85b8113d2ff7d\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  闪客：不错，这就是这道题正确的动态规划解法，而且时间复杂度是 O(N)，空间复杂度是 O(1)\n小宇：哇，这就是动态规划呀，原来这么简单。\n3\r闪客：不错，动态规划理解起来不难，难在当需要考虑的因素，也就是变化的维度多起来的时候，有的人就会头脑发蒙，不好找递推公式了，而且这也确实是个难点。\n小宇：哦是吗？\n闪客：那当然，我再给你出一道题。\n小宇：来吧兄弟。\n闪客：咳咳，那你听好了。\n有一个背包，可以装载重量为 5kg 的物品。\r有 4 个物品，他们的重量和价值如下。\r\n  \n那么请问，在不得超过背包的承重的情况下，将哪些物品放入背包，可以使得总价值最大？\r小宇：明白了，就是我用这个背包最多能装走多少钱的东西。\n闪客：是的。\n小宇：哎呀不行，我又陷入走楼梯时的遍历思想了。\n闪客：没关系，这道题能想出遍历思想，其实也不容易了，你可以先说一下，找找感觉。\n小宇：嗯嗯，那就是每个物品都可以有放入背包和不放入背包两种选择。\n如果总重量超过了背包承重，那就不算，或者说将价值记为 0，然后将所有情况中价值最大的那个作为结果。\n这样的复杂度也很容易得出，就是 O(2^N)\n闪客：没错，这个复杂度很高的算法你已经说的很明白了，那接下来你想想看用动态规划思想，能不能解决这个问题。\n小宇：好的，你之前说过，动态规划的三要素是最优子结构、状态转移方程和边界\n闪客：没错，之前的变量很少所以比较简单，现在变量多了，定义就变得难了起来，我们先来几个定义方便描述。我们将 4 个物品的重量和价值分别表示为：w1，w2，w3，w4，v1，v2，v3，v4。\n  \n假如我们用\nF(W,i) \r表示\n用载重为 W 的背包，装前 i 件物品的最大价值\r那本题其实就是\nF(5,4) 其实就是求解 你能找到状态转移方程么？\n小宇：我想想，单看这个物品 4，有两种可能：\n第一种可能：如果选择把它装入背包，那已经得到了 6 元钱。\n此时背包剩余载重为 1kg（5kg-4kg），剩余物品是除去物品 4 后的前 3 件物品。\n那这部分能获取到的最大价值，相当于\n用一个载重为 1kg 的背包，装前 3 件物品的最大价值 \n哇，那这部分就是\nF(1,3) 闪客：哈哈，你这自己说着说着就说对啦！\n小宇：所以最终，如果选择将物品 4 放入背包，这种情况下，最大价值就等于二者之和。\nF(1, 3) + 6\r\n  \n闪客：太好了小宇，那另一种情况呢？\n小宇：第二种可能：如果选择不装这个物品 4，那更简单了，就直接等于用一个载重为 5 的背包装前 3 件物品的价值。\nF(5, 3)\r\n  \n闪客：没错，而且就只有这两种情况！所以你看看 F(5,4)是否能用这两种情况的值表示呢？\n小宇：哈哈，很简单，就等于这两种情况当中的最大值呗。\nF(5,4) = max { F(1, 3) + 6，F(5, 3) }\r闪客：太好了，现在状态转移方程出来了，此时我们画个表格。\n  我们的目标就是要计算右下角那个值，即背包载重 W = 5 时，选择前 4 件物品放入背包的最大价值 F(5,4)\n小宇：哇这个表格好清晰呀，根据上面的公式\nF(5,4) = max { F(1,3) + 6, F(5,3) }\r\n那也就是说只要知道 F(1,3) 和 F(5,3) 的值就可以了对吧？\n  闪客：没错，那你再看看 F(1,3) 怎么计算？\n小宇：好的，F(1,3) 此时背包重量为 1，如果选择放第三件物品的话，诶？好像不行，第三件物品根本放不下呀！\n闪客：是的，所以这种情况就没必要讨论放第三件物品的情况了，因为根本放不下，因此 F(1,3) 直接就等于 F(1,2)，所以只需要知道 F(1,2) 即可。\n  \n同理 F(1,2) 也直接等于 F(1,1)，因为在背包重量为 1 时第二件物品也放不下。\n闪客：小宇你想想看，那 F(1,1) 又等于什么呢？\n小宇：显然嘛，现在只有一件物品可以选了，那能放下当然就放咯，所以最大价值就是第一件物品的价值 3，即 F(1,1) = 3\n闪客：没错，这样我们就找到了一个边界值，小宇你想想看还有哪些边界值可以直接得出？你写在表格里吧。\n小宇：好的，首先第一列表示背包重量为 0 时的情况，那显然什么都装不了，就全都是 0 了。\n  \n然后第一行也比较好算，背包重量 \u0026gt;= 1 时可以放下第一件物品，所以最大价值都等于 3\n  \n闪客：很好，接下来，就依次把表格的所有项都填出来，自然就可以算出 F(5,4) 啦。\n  \n小宇：哇塞，这样看好清晰呀！\n闪客：是呀，不过刚刚我们用的都是具体的数字，那我们试着把这个问题抽象化，用一个载重为 W 的背包，装载 N 件物品，每件物品的重量和价值分别用 wi 和 vi 来表示，那刚刚的状态转移方程是什么呢？\n小宇：emm，刚刚 F(5,4) = max { F(1,3) + 6, F(5,3) }，如果都用变量表示的话，就是\n\nF(W,N) = max { F(W-wn, N-1) + vn，F(W, N-1) }\r闪客：很好，这就是状态转移方程。\nF(W-wn, N-1) 和 F(W, N-1) 就是 F(W,N) 的最优子结构。\n而刚刚表格中的第一行和第一列，即 F(0,\u0026hellip;) 和 F(\u0026hellip;,1) 就是边界值！\n小宇：哇塞我爱你闪客！终于有点理解动态规划的思想了呢！\n4\r闪客：别高兴太早，虽然过程看着清晰了，但代码写起来还是有难度的，你今天回去就把代码试着实现一下吧。\n小宇：好的，保证完成任务。\n闪客：快到晚饭时间了，旁边新开了家饺子馆，要不要一块去吃呀？\n小宇：哦不了，晚上想利用晚饭时间再去消化消化动态规划的知识，不是还得代码实现呢么，下次吧，\n闪客：哦好吧~\n后记\r本文通过直观演示 01 背包问题的解题思路，简单说明了动态规划思想的算法核心。可能不少人觉得动态规划难在理解，所以花很多时间在理解其思想上。但其实理解核心思想，这一篇文章就够了，更多的是通过不断做题，反过来帮助自己理解动态规划的思想。所以希望读者在读完本文后，和小宇一样，动手将其代码实现，并找来其他变种题目，继续巩固。\n","description":"了解什么是动态规划","id":12,"section":"article","tags":null,"title":"图解 | 你管这破玩意叫动态规划","uri":"https://2110833194.github.io/article/algorithm/dynamic-programming/"},{"content":"历史上，有多种辅助存储设备，比如软盘、光盘、硬盘、U 盘等，相对于内存，它们就是人们常说的“外存”，即外存储器（设备）。\n从软盘（Floppy Disk）启动计算机，这已经是过去的事了。软盘的尺寸比烟盒稍大一点，但是比较薄，采用塑料作为基片，上面是一层磁性物质，可以用来记录二进制位。这种塑料介质比较柔软，所以称为软盘。\n在数据记录原理上和软盘很相似的设备是硬盘（Hard Disk，HDD），而且它们几乎是同一个时代的产物。但是，与软盘不同，硬盘是多盘片、密封、高转速的，采用铝合金作为基片，并在表面涂上磁性物质来记录二进制位。这就使得它的盘片具有较高的硬度，故称为硬盘。\n   图1-1 一块被拆开密封盖的硬盘\r 如图1-1 所示，这是一块被拆开的硬盘，中间是用于记录数据的铝合金盘片，固定在中心的轴上，由一个高速旋转的马达驱动。附着在盘片表面的扁平锥状物，就是用于在盘片上读写数据的磁头。\n为了进一步搞清楚硬盘的内部构造，图1-2 给出了更为详细的图示。\n硬盘可以只有一个盘片（这称为单碟），也可能有好几个盘片。但无论如何，它们都串在同一个轴上，由电动机带动着一起高速旋转。一般来说，转速可以达到每分钟3600 转或者7200转，有的能达到一万多转，这个参数就是我们常说的“转/分钟”（Round Per Minute，RPM）。\n   图1-2 硬盘的结构示意图\r 每个盘片都有两个磁头（Head），上面一个，下面一个，所以经常用磁头来指代盘面。磁头都有编号，第1 个盘片，上面的磁头编号为0，下面的磁头编号为1；第2 个盘片，上面的磁头编号为2，下面的磁头编号为3，以此类推。\n每个磁头不是单独移动的。相反，它们都通过磁头臂固定在同一个支架上，由步进电动机带动着一起在盘片的中心和边缘之间来回移动。也就是说，它们是同进退的。步进电动机由脉冲驱动，每次可以旋转一个固定的角度，即可以步进一次。\n可以想象，当盘片高速旋转时，磁头每步进一次，都会从它所在的位置开始，绕着圆心“画”出一个看不见的圆圈，这就是磁道（Track）。磁道是数据记录的轨迹。因为所有磁头都是联动的，故每个盘面上的同一条磁道又可以形成一个虚拟的圆柱，称为柱面（Cylinder）。\n磁道，或者柱面，也要编号。编号是从盘面最边缘的那条磁道开始，向着圆心的方向，从0开始编号。\n柱面是一个用来优化数据读写的概念。初看起来，用硬盘来记录数据时，应该先将一个盘面填满后，再填写另一个盘面。实际上，移动磁头是一个机械动作，看似很快，但对处理器来说，却很后，再填写另一个盘面。实际上，移动磁头是一个机械动作，看似很快，但对处理器来说，却很漫长，这就是寻道时间。为了加速数据在硬盘上的读写，最好的办法就是尽量不移动磁头。这样，当0 面的磁道不足以容纳要写入的数据时，应当把剩余的部分写在1 面的同一磁道上。如果还写不下，那就继续把剩余的部分写在2 面的同一磁道上。换句话说，在硬盘上，数据的访问是以柱面来组织的。\n实际上，磁道还不是硬盘数据读写的最小单位，磁道还要进一步划分为扇区（Sector）。磁道很窄，也看不见，但在想象中，它仍呈带状，占有一定的宽度。将它划分许多分段之后，每一部分都呈扇形，这就是扇区的由来。\n每条磁道能够划分为几个扇区，取决于磁盘的制造者，但通常为63 个。而且，每个扇区都有一个编号，与磁头和磁道不同，扇区的编号是从1 开始的。\n扇区与扇区之间以间隙（空白）间隔开来，每个扇区以扇区头开始，然后是512 个字节的数据区。扇区头包含了每个扇区自己的信息，主要有本扇区的磁道号、磁头号和扇区号，用来供硬盘定位机构使用。现代的硬盘还会在扇区头部包括一个指示扇区是否健康的标志，以及用来替换该扇区的扇区地址。用于替换扇区的，是一些保留和隐藏的磁道。\n","description":"硬盘的构造及其工作原理","id":13,"section":"article","tags":null,"title":"硬盘到底是什么！","uri":"https://2110833194.github.io/article/computer/hard_disk/"},{"content":"1.创建仓库命令 1.创建版本库(初始化仓库) \u0026mdash;\u0026mdash; git init\n2.拷贝一份远程仓库，也就是下载一个项目 \u0026mdash;\u0026mdash; git clone\n2.提交与修改 1.添加文件到暂存区 \u0026mdash;\u0026mdash; git add\n2.查看仓库当前的状态，显示有变更的文件 \u0026mdash;\u0026mdash; git status\n3.比较文件的不同，即暂存区和工作区的区别 \u0026mdash;\u0026mdash; git diff\n4.提交暂存区到本地仓库 \u0026mdash;\u0026mdash; git commit\n7.回退版本 \u0026mdash;\u0026mdash; git reset\n8.删除工作区的文件 \u0026mdash;\u0026mdash; git rm\n9.移动或者重命名工作区的文件 \u0026mdash;\u0026mdash; git mv\n2.1提交日志 1.查看历史提交记录 \u0026mdash;\u0026mdash; git log\n2.以列表形式查看指定文件的历史修改记录 \u0026mdash;\u0026mdash; git blame \n2.2远程操作 1.远程仓库操作 \u0026mdash;\u0026mdash; git remote\n2.从远程获取代码库 \u0026mdash;\u0026mdash; git fetch\n3.下载远程代码并合并 \u0026mdash;\u0026mdash; git pull\n4.上传远程代码并合并 \u0026mdash;\u0026mdash; git push\n3.git 分支管理 1.列出分支 \u0026mdash;\u0026mdash; git branch(无参数时)\n2.创建新分支 \u0026mdash;\u0026mdash; git branch branchname(branchname为想要创建的分支名)\n3.切换到分支 \u0026mdash;\u0026mdash; git checkout branchname(branchname为想要切换到的分支名)\n4.创建新分支并切换到该分支下 \u0026mdash;\u0026mdash; git checkout -b branchname(branchname为想要创建的分支名)\n5.删除分支 \u0026mdash;\u0026mdash; git branch -d branchname(branchname为想要删除的分支名)\n6.合并分支 \u0026mdash;\u0026mdash; git merge /git rebase\nrebase优缺点 优点： Rebase 使你的提交树变得很干净, 所有的提交都在一条线上 缺点： Rebase 修改了提交树的历史 merge优缺点 优点: merge可以保留提交历史 缺点： merge使你的提交树变得复杂，提交由多条线相连 7.解决冲突 \u0026mdash;\u0026mdash; 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。\n4.git 查看提交历史 1.查看历史提交记录 \u0026mdash;\u0026mdash; git log\n2.以列表形式查看指定文件的历史修改记录 \u0026mdash;\u0026mdash; git blame \n5.git 标签 1.查看所有标签 \u0026mdash;\u0026mdash; git tag\n2.为当前分支创建标签 \u0026mdash;\u0026mdash; git tag -a v1.0(不带\u0026quot;-a\u0026quot;也行,但建议带上)\n3.创建带有说明的标签 \u0026mdash;\u0026mdash; git tag -a v0.1 -m \u0026ldquo;runoob.com标签\u0026rdquo;（用-a指定标签名，-m指定说明文字：）\n4.查看标签说明文字 \u0026mdash;\u0026mdash; git show v0.1\n(注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。) 6.git 远程仓库(Github) 1添加远程库 \u0026mdash;\u0026mdash; git remote add origin [url](origin 为给远程库取的一个别名) 由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息： 使用以下命令生成 SSH Key：ssh-keygen -t rsa -C \u0026ldquo;youremail@example.com\u0026rdquo; 后面的 your_email@youremail.com 改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在 ~/ 下生成 .ssh 文件夹，进去，打开 id_rsa.pub，复制里面的 key。回到 github 上，进入 Account =\u0026gt; Settings（账户配置）。左边选择 SSH and GPG keys，然后点击 New SSH key 按钮,title 设置标题，可以随便填，粘贴在你电脑上生成的 key 2查看当前的远程库 \u0026mdash;\u0026mdash; git remote -v 3拉取远程仓库 1.从远程仓库下载新分支与数据 \u0026mdash;\u0026mdash; git fetch\n2从远端仓库提取数据并尝试合并到当前分支 \u0026mdash;\u0026mdash; git merge\n4推送到远程仓库 \u0026mdash;\u0026mdash; git push origin branch(branch为远程仓库的分支名) 5删除远程仓库 \u0026mdash;\u0026mdash; git remote rm origin 7.git 服务器搭建 1.安装 git \u0026mdash;\u0026mdash;sudo apt-get install git(ubuntu下的下载,windows可上网查询) 接下来我们 创建一个用户用来运行git服务的用户 $ sudo adduser zhugeqing 2.创建证书登录 虽然是私有的Git服务器，但是也不能允许主机随意向Git服务器推送代码。因此，必须将需要使用Git服务器，即需要登录到Git服务器的主机的公钥（即id_rsa.pub文件）导入Git服务器的/home/git/.ssh/authorized_keys文件里，一行一个 ###3.初始化Git仓库\n如果我们使用/tmp/xingyouji.git做为远程仓库，则需要在/tmp目录下执行： sudo git init \u0026ndash;bare xingyouji.git 4.克隆仓库 git clone git@192.168.45.4:/home/gitrepo/xingyouji.git 192.168.45.4 为 Git 所在服务器 ip ，你需要将其修改为你自己的 Git 服务 ip，这样我们的 Git 服务器安装就完成。 8.Git Gitee（码云) 大家都知道国内访问 Github 速度比较慢，很影响我们的使用。如果你希望体验到 Git 飞一般的速度，可以使用国内的 Git 托管服务——Gitee（gitee.com）， Gitee 提供免费的 Git 仓库，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee 还提供了项目管理、代码托管、文档管理的服务，5 人以下小团队免费 。 1.我们先在 Gitee 上注册账号并登录后，然后上传自己的 SSH 公钥\n2.其他操作根据需求操作，与上述操作无大区别\n  ","description":"关于git 的使用","id":14,"section":"about","tags":null,"title":"git笔记","uri":"https://2110833194.github.io/about/git/"},{"content":" 此文章取自于微信公众号“低并发编程”\n正文开始：\n你是一台电脑，你的名字叫 A\n很久很久之前，你不与任何其他电脑相连接，孤苦伶仃。\n  直到有一天，你希望与另一台电脑 B 建立通信，于是你们各开了一个网口，用一根网线连接了起来。\n  用一根网线连接起来怎么就能\u0026quot;通信\u0026quot;了呢？我可以给你讲 IO、讲中断、讲缓冲区，但这不是研究网络时该关心的问题。\n如果你纠结，要么去研究一下操作系统是如何处理网络 IO 的，要么去研究一下包是如何被网卡转换成电信号发送出去的，要么就仅仅把它当做电脑里有个小人在开枪吧~\n  反正，你们就是连起来了，并且可以通信。\n  有一天，一个新伙伴 C 加入了，但聪明的你们很快发现，可以每个人开两个网口，用一共三根网线，彼此相连。\n  随着越来越多的人加入，你发现身上开的网口实在太多了，而且网线密密麻麻，混乱不堪。（而实际上一台电脑根本开不了这么多网口，所以这种连线只在理论上可行，所以连不上的我就用红色虚线表示了，就是这么严谨哈哈~）\n  于是你们发明了一个中间设备，你们将网线都插到这个设备上，由这个设备做转发，就可以彼此之间通信了，本质上和原来一样，只不过网口的数量和网线的数量减少了，不再那么混乱。\n  你给它取名叫集线器，它仅仅是无脑将电信号转发到所有出口（广播），不做任何处理，你觉得它是没有智商的，因此把人家定性在了物理层。\n  由于转发到了所有出口，那 BCDE 四台机器怎么知道数据包是不是发给自己的呢？\n首先，你要给所有的连接到集线器的设备，都起个名字。原来你们叫 ABCD，但现在需要一个更专业的，全局唯一的名字作为标识，你把这个更高端的名字称为MAC 地址\n你的 MAC 地址是 aa-aa-aa-aa-aa-aa，你的伙伴 b 的 MAC 地址是 bb-bb-bb-bb-bb-bb，以此类推，不重复就好。\n这样，A 在发送数据包给 B 时，只要在头部拼接一个这样结构的数据，就可以了。\n  B 在收到数据包后，根据头部的目标 MAC 地址信息，判断这个数据包的确是发给自己的，于是便收下。\n其他的 CDE 收到数据包后，根据头部的目标 MAC 地址信息，判断这个数据包并不是发给自己的，于是便丢弃。\n  虽然集线器使整个布局干净不少，但原来我只要发给电脑 B 的消息，现在却要发给连接到集线器中的所有电脑，这样既不安全，又不节省网络资源。\n  如果把这个集线器弄得更智能一些，只发给目标 MAC 地址指向的那台电脑，就好了\n  虽然只比集线器多了这一点点区别，但看起来似乎有智能了，你把这东西叫做交换机。也正因为这一点点智能，你把它放在了另一个层级，数据链路层。\n  如上图所示，你是这样设计的。\n交换机内部维护一张 MAC 地址表，记录着每一个 MAC 地址的设备，连接在其哪一个端口上。\n  假如你仍然要发给 B 一个数据包，构造了如下的数据结构从网口出去。\n  到达交换机时，交换机内部通过自己维护的 MAC 地址表，发现目标机器 B 的 MAC 地址 bb-bb-bb-bb-bb-bb 映射到了端口 1 上，于是把数据从 1 号端口发给了 B，完事~\n你给这个通过这样传输方式而组成的小范围的网络，叫做以太网。\n当然最开始的时候，MAC 地址表是空的，是怎么逐步建立起来的呢？\n假如在 MAC 地址表为空是，你给 B 发送了如下数据：\n  由于这个包从端口 4 进入的交换机，所以此时交换机就可以在 MAC地址表记录第一条数据：\n  交换机看目标 MAC 地址（bb-bb-bb-bb-bb-bb）在地址表中并没有映射关系，于是将此包发给了所有端口，也即发给了所有机器。\n之后，只有机器 B 收到了确实是发给自己的包，于是做出了响应，响应数据从端口 1 进入交换机，于是交换机此时在地址表中更新了第二条数据：\n  过程如下：\n  经过该网络中的机器不断地通信，交换机最终将 MAC 地址表建立完毕~\n  随着机器数量越多，交换机的端口也不够了，但聪明的你发现，只要将多个交换机连接起来，这个问题就轻而易举搞定~\n  你完全不需要设计额外的东西，只需要按照之前的设计和规矩来，按照上述的接线方式即可完成所有电脑的互联，所以交换机设计的这种规则，真的很巧妙。你想想看为什么（比如 A 要发数据给 F）。\n但是你要注意，上面那根红色的线，最终在 MAC 地址表中可不是一条记录呀，而是要把 EFGH 这四台机器与该端口（端口6）的映射全部记录在表中。\n最终，两个交换机将分别记录 A ~ H 所有机器的映射记录。\n左边的交换机\n  右边的交换机\n  这在只有 8 台电脑的时候还好，甚至在只有几百台电脑的时候，都还好，所以这种交换机的设计方式，已经足足支撑一阵子了。\n但很遗憾，人是贪婪的动物，很快，电脑的数量就发展到几千、几万、几十万。\n  交换机已经无法记录如此庞大的映射关系了。\n此时你动了歪脑筋，你发现了问题的根本在于，连出去的那根红色的网线，后面不知道有多少个设备不断地连接进来，从而使得地址表越来越大。\n那我可不可以让那根红色的网线，接入一个新的设备，这个设备就跟电脑一样有自己独立的 MAC 地址，而且同时还能帮我把数据包做一次转发呢？\n这个设备就是路由器，它的功能就是，作为一台独立的拥有 MAC 地址的设备，并且可以帮我把数据包做一次转发，你把它定在了网络层。\n  注意，路由器的每一个端口，都有独立的 MAC 地址。\n好了，现在交换机的 MAC 地址表中，只需要多出一条 MAC 地址 ABAB 与其端口的映射关系，就可以成功把数据包转交给路由器了，这条搞定。\n那如何做到，把发送给 C 和 D，甚至是把发送给 DEFGH\u0026hellip;. 的数据包，统统先发送给路由器呢？\n不难想到这样一个点子，假如电脑 C 和 D 的 MAC 地址拥有共同的前缀，比如分别是：\n  那我们就可以说，将目标 MAC 地址为 FFFF-FFFF-？开头的，统统先发送给路由器。\n这样是否可行呢？答案是否定的。\n我们先从现实中 MAC 地址的结构入手，MAC地址也叫物理地址、硬件地址，长度为 48 位，一般这样来表示：   它是由网络设备制造商生产时烧录在网卡的EPROM（一种闪存芯片，通常可以通过程序擦写）。其中前 24 位（00-16-EA）代表网络硬件制造商的编号，后 24 位（AE-3C-40）是该厂家自己分配的，一般表示系列号。只要不更改自己的 MAC 地址，MAC 地址在世界是唯一的。形象地说，MAC地址就如同身份证上的身份证号码，具有唯一性。\n那如果你希望向上面那样将目标 MAC 地址表示为 FFFF-FFFF-？开头的，统一从路由器出去发给某一群设备（后面会提到这其实是子网的概念），那你就需要要求某一子网下统统买一个厂商制造的设备，要么你就需要要求厂商在生产网络设备烧录 MAC 地址时，提前按照你规划好的子网结构来定 MAC 地址，并且日后这个网络的结构都不能轻易改变。\n这显然是不现实的。\n于是你发明了一个新的地址，给每一台机器一个 32 位的编号，如：\n11000000101010000000000000000001\n你觉得有些不清晰，于是把它分成四个部分，中间用点相连。\n11000000.10101000.00000000.00000001\n你还觉得不清晰，于是把它转换成 10 进制。\n192.168.0.1\n最后你给了这个地址一个响亮的名字，IP 地址。现在每一台电脑，同时有自己的 MAC 地址，又有自己的 IP 地址，只不过 IP 地址是软件层面上的，可以随时修改，MAC 地址一般是无法修改的。\n这样一个可以随时修改的 IP 地址，就可以根据你规划的网络拓扑结构，来调整了。\n  如上图所示，假如我想要发送数据包给 ABCD 其中一台设备，不论哪一台，我都可以这样描述，\u0026ldquo;将 IP 地址为 192.168.0 开头的全部发送给到路由器，之后再怎么转发，交给它！\u0026quot;，巧妙吧。\n那交给路由器之后，路由器又是怎么把数据包准确转发给指定设备的呢？\n别急我们慢慢来。\n我们先给上面的组网方式中的每一台设备，加上自己的 IP 地址。\n  现在两个设备之间传输，除了加上数据链路层的头部之外，还要再增加一个网络层的头部。\n假如 A 给 B 发送数据，由于它们直接连着交换机，所以 A 直接发出如下数据包即可，其实网络层没有体现出作用。\n  但假如 A 给 C 发送数据，A 就需要先转交给路由器，然后再由路由器转交给 C。由于最底层的传输仍然需要依赖以太网，所以数据包是分成两段的。\nA ~ 路由器这段的包如下：   路由器到 C 这段的包如下：\n  好了，上面说的两种情况（A-\u0026gt;B，A-\u0026gt;C），相信细心的读者应该会有不少疑问，下面我们一个个来展开。\nA 给 C 发数据包，怎么知道是否要通过路由器转发呢？\n答案：子网 \n如果源 IP 与目的 IP 处于一个子网，直接将包通过交换机发出去。\n如果源 IP 与目的 IP 不处于一个子网，就交给路由器去处理。\n好，那现在只需要解决，什么叫处于一个子网就好了。\n 192.168.0.1 和 192.168.0.2 处于同一个子网 192.168.0.1 和 192.168.1.1 处于不同子网  这两个是我们人为规定的，即我们想表示，对于 192.168.0.1 来说：\n192.168.0.xxx 开头的，就算是在一个子网，否则就是在不同的子网。 \n那对于计算机来说，怎么表达这个意思呢？于是人们发明了子网掩码的概念。\n假如某台机器的子网掩码定为 255.255.255.0。\n这表示，将源 IP 与目的 IP 分别同这个子网掩码进行与运算，相等则是在一个子网，不相等就是在不同子网，就这么简单。\n比如：\n  A电脑：192.168.0.1 \u0026amp; 255.255.255.0 = 192.168.0.0\n  B电脑：192.168.0.2 \u0026amp; 255.255.255.0 = 192.168.0.0\n  C电脑：192.168.1.1 \u0026amp; 255.255.255.0 = 192.168.1.0\n  D电脑：192.168.1.2 \u0026amp; 255.255.255.0 = 192.168.1.0\n那么 A 与 B 在同一个子网，C 与 D 在同一个子网，但是 A 与 C 就不在同一个子网，与 D 也不在同一个子网，以此类推。\n    所以如果 A 给 C 发消息，A 和 C 的 IP 地址分别 \u0026amp; A 机器配置的子网掩码，发现不相等，则 A 认为 C 和自己不在同一个子网，于是把包发给路由器，就不管了，之后怎么转发，A 不关心。\nA 如何知道，哪个设备是路由器？\n答案：在 A 上要设置默认网关 \n上一步 A 通过是否与 C 在同一个子网内，判断出自己应该把包发给路由器，那路由器的 IP 是多少呢？\n其实说发给路由器不准确，应该说 A 会把包发给默认网关。\n对 A 来说，A 只能直接把包发给同处于一个子网下的某个 IP 上，所以发给路由器还是发给某个电脑，对 A 来说也不关心，只要这个设备有个 IP 地址就行。\n所以默认网关，就是 A 在自己电脑里配置的一个 IP 地址，以便在发给不同子网的机器时，发给这个 IP 地址。\n  路由器如何知道C在哪里？\n答案：路由表 \n现在 A 要给 C 发数据包，已经可以成功发到路由器这里了，最后一个问题就是，路由器怎么知道，收到的这个数据包，该从自己的哪个端口出去，才能直接（或间接）地最终到达目的地 C 呢。\n路由器收到的数据包有目的 IP 也就是 C 的 IP 地址，需要转化成从自己的哪个端口出去，很容易想到，应该有个表，就像 MAC 地址表一样。\n这个表就叫路由表。\n至于这个路由表是怎么出来的，有很多路由算法，本文不展开，因为我也不会哈哈~\n不同于 MAC 地址表的是，路由表并不是一对一这种明确关系，我们下面看一个路由表的结构。\n  我们学习一种新的表示方法，由于子网掩码其实就表示前多少位表示子网的网段，所以如 192.168.0.0（255.255.255.0） 也可以简写为 192.168.0.0/24。\n  这就很好理解了，路由表就表示，这个子网下的，都转发到 0 号端口，192.168.1.xxx 这个子网下的，都转发到 1 号端口192.168.0.xxx 。下一跳列还没有值，我们先不管。\n配合着结构图来看（这里把子网掩码和默认网关都补齐了）结果应该是 0\n  刚才说的都是 IP 层，但发送数据包的数据链路层需要知道 MAC 地址，可是我只知道 IP 地址该怎么办呢？\n答案：arp \n假如你（A）此时不知道你同伴 B 的 MAC 地址（现实中就是不知道的，刚刚我们只是假设已知），你只知道它的 IP 地址，你该怎么把数据包准确传给 B 呢？\n答案很简单，在网络层，我需要把 IP 地址对应的 MAC 地址找到，也就是通过某种方式，找到192.168.0.2  对应的 MAC 地址 BBBB。\n这种方式就是 arp 协议，同时电脑 A 和 B 里面也会有一张 arp 缓存表，表中记录着 IP 与 MAC 地址的对应关系。\n  一开始的时候这个表是空的，电脑 A 为了知道电脑 B（192.168.0.2）的 MAC 地址，将会广播一条 arp 请求，B 收到请求后，带上自己的 MAC 地址给 A 一个响应。此时 A 便更新了自己的 arp 表。\n这样通过大家不断广播 arp 请求，最终所有电脑里面都将 arp 缓存表更新完整\n总结一下 好了，总结一下，到目前为止就几条规则：\n从各个节点的视角来看\n电脑视角：\n  首先我要知道我的 IP 以及对方的 IP\n  通过子网掩码判断我们是否在同一个子网\n  在同一个子网就通过 arp 获取对方 mac 地址直接扔出去\n  不在同一个子网就通过 arp 获取默认网关的 mac 地址直接扔出去\n  交换机视角：\n  我收到的数据包必须有目标 MAC 地址\n  通过 MAC 地址表查映射关系\n  查到了就按照映射关系从我的指定端口发出去\n  查不到就所有端口都发出去\n  路由器视角：\n  我收到的数据包必须有目标 IP 地址\n  通过路由表查映射关系\n  查到了就按照映射关系从我的指定端口发出去（不在任何一个子网范围，走其路由器的默认网关也是查到了）\n  查不到则返回一个路由不可达的数据包\n  如果你嗅觉足够敏锐，你应该可以感受到下面这句话：\n网络层（IP协议）本身没有传输包的功能，包的实际传输是委托给数据链路层（以太网中的交换机）来实现的。 涉及到的三张表分别是\n  交换机中有 MAC地址表用于映射 MAC 地址和它的端口\n  路由器中有路由表用于映射 IP 地址(段)和它的端口\n  电脑和路由器中都有 arp 缓存表用于缓存 IP 和 MAC 地址的映射关系\n  这三张表是怎么来的\n  MAC 地址表是通过以太网内各节点之间不断通过交换机通信，不断完善起来的。\n  路由表是各种路由算法 + 人工配置逐步完善起来的。\n  arp 缓存表是不断通过 arp 协议的请求逐步完善起来的。\n知道了以上这些，目前网络上两个节点是如何发送数据包的这个过程，就完全可以解释通了！\n  那接下来我们就放上本文 最后一个网络拓扑图吧，请做好 战斗准备！\n  这时路由器 1 连接了路由器 2，所以其路由表有了下一条地址这一个概念，所以它的路由表就变成了这个样子。如果匹配到了有下一跳地址的一项，则需要再次匹配，找到其端口，并找到下一跳 IP 的 MAC 地址。\n也就是说找来找去，最终必须能映射到一个端口号，然后从这个端口号把数据包发出去。\n  这时如果 A 给 F 发送一个数据包，能不能通呢？如果通的话整个过程是怎样的呢？\n  思考一分钟\u0026hellip;\n详细过程文字描述：\n1. 首先A（192.168.0.1） 通过子网掩码（255.255.255.0）计算出自己与F（192.168.2.2） 并不在同一个子网内，于是决定发送给默认网关（192.168.0.254） 。\n2. A 通过 ARP 找到默认网关 192.168.0.254 的 MAC 地址。\n3. A 将源 MAC 地址（AAAA）与网关 MAC 地址（ABAB）封装在数据链路层头部，又将源 IP 地址（192.168.0.1）和目的 IP 地址（192.168.2.2）（注意这里千万不要以为填写的是默认网关的 IP 地址，从始至终这个数据包的两个 IP 地址都是不变的，只有 MAC 地址在不断变化）封装在网络层头部，然后发包。\n  4. 交换机 1 收到数据包后，发现目标 MAC 地址是 ABAB，转发给路由器 1。\n5. 数据包来到了路由器 1，发现其目标 IP 地址是 192.168.2.2，查看其路由表，发现了下一跳的地址是 192.168.100.5。\n6. 所以此时路由器 1 需要做两件事，第一件是再次匹配路由表，发现匹配到了端口为 2，于是将其封装到数据链路层，最后把包从2 号口发出去。\n7. 此时路由器 2 收到了数据包，看到其目的地址是 192.168.2.2，查询其路由表，匹配到端口号为 1，准备从1 号口 把数据包送出去。\n8. 但此时路由器 2 需要知道192.168.2.2 的 MAC 地址了，于是查看其 arp 缓存，找到其 MAC 地址为FFFF ，将其封装在数据链路层头部，并从 1 号端口把包发出去。\n9.交换机 3 收到了数据包，发现目的 MAC 地址为FFFF ，查询其 MAC 地址表，发现应该从其6 号端口 出去，于是从 6 号端口把数据包发出去。\n10. F 最终收到了数据包！并且发现目的 MAC 地址就是自己，于是收下了这个包。\n  至此，经过物理层、数据链路层、网络层这前三层的协议，以及根据这些协议设计的各种网络设备（网线、集线器、交换机、路由器），理论上只要拥有对方的 IP 地址，就已经将地球上任意位置的两个节点连通了。\n  - 完 -\n","description":"了解网络","id":15,"section":"article","tags":["网络"],"title":"如果让你来设计网络，你会把它弄成啥样？","uri":"https://2110833194.github.io/article/netword/interesting/1/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":16,"section":"gallery","tags":null,"title":"Cartoon","uri":"https://2110833194.github.io/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":17,"section":"gallery","tags":null,"title":"Photo","uri":"https://2110833194.github.io/gallery/photo/"}]