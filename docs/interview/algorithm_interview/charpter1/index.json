[{"content":"题目：65,8,50,15,37,24,()。括号中的数字是()？ A. 25\nB. 26\nC. 22\nD. 27\n答案：\r65=8^2+1 这里将8作为65的特征\r8=3^2-1 这里得到3\r50=7^2+1 这里得到7\r15=4^2-1 这里得到4\r37=6^2+1 这里得到6\r24=5^2-1 这里得到5\r我们发现8,3,7,4,6,5 这组数的特点，以奇数项开始 奇数项加偶数项的和为11，\r以偶数项开始的话 偶数项+奇数项的和为10 8+3=7+4=6+5 3+7=4+6=5+x 这里得到x为5 特征为5 转换为5^2+1 得到26\r","description":"括号中的数字是什么?","id":2,"section":"intelligence","tags":null,"title":"智力题2.1","uri":"https://xing-you-ji.github.io/intelligence/niuke_part2/%E6%8B%AC%E5%8F%B7%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88_1/"},{"content":"题目：5 , 6 , 6 , 9 ,（）, 90。括号中的数字是()？ A. 12\nB. 15\nC. 18\nD. 21\n答案：整个数列规律为：\r（5-3）*（6-3）=6\r（6-3）*（6-3）=9\r（6-3）*（9-3）=18\r（9-3）*（18-3）=90\r规律很多，仅供参考，自我挖掘！\r","description":"括号中的数字是什么?","id":3,"section":"intelligence","tags":null,"title":"智力题2.2","uri":"https://xing-you-ji.github.io/intelligence/niuke_part2/%E6%8B%AC%E5%8F%B7%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88_2/"},{"content":"题目：2 ，3 ，10 ，15 ，26 ，35 ，( )。括号中的数字是是什么？ A. 40\nB. 45\nC. 50\nD. 55\n1^2+1=2 2^2-1=3 3^2+1=10 4^2-1=15 5^2+1+26 6^2-1=35 奇数项平方加一，偶数项平方减一\r","description":"括号中的数字是什么?","id":4,"section":"intelligence","tags":null,"title":"智力题2.3","uri":"https://xing-you-ji.github.io/intelligence/niuke_part2/%E6%8B%AC%E5%8F%B7%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88_3/"},{"content":"题目：一台指针式钟表的时针和分针指向的重合的时间间隔是？\n答案：\r由于分针总是比时针走的快，所以问题就转换成时针在一圈的范围内追击分针的问题：\r分针走的角速度是360°/60分 = 6°/分\r时针走的角速度是360°/720分 = 0.5°/分\r下一次追到比上一次追到，分针比时针多走过的角度是360°，\r那么在一圈的角度内 360°/(6°/分-0.5°/分) = 720/11 分钟，\r经过这么多时间 分针和时间重合一次，\r所以引申到一昼夜时间内分针 时针相遇多少次：24*60/(720/11) = 22 次\r","description":"时针和分针指向的重合的时间间隔是？","id":5,"section":"intelligence","tags":null,"title":"智力题1.3","uri":"https://xing-you-ji.github.io/intelligence/niuke_part1/%E6%97%B6%E9%92%88%E4%B8%8E%E5%88%86%E9%92%88%E9%87%8D%E5%90%88/"},{"content":"题目：对一批编号为1～100，全部开关朝上(开)的灯进行以下操作：\n凡是1的倍数反方向拨一次开关；2的倍数反方向又拨一次开关；\n3的倍数反方向又拨一次开关……100的倍数反方向又拨一次开关 ,\n问：最后为关熄状态的灯有几个?\n答案：分析：所有的灯都会根据它是否是某数的倍数来拨动开关，比如1是1的倍数，\r但它不是其他剩余99个数的倍数，故只拨动一次开关，初始状态为开，\r只要经过奇数次拨动开关，最终状态都会是关着的灯\r进一步分析：上述分析又可以根据题意来化解为只有这个编号含有奇数个因数的灯，\r在经过所有关灯操作之后，它的最终状态就是关闭的，所以2不是（1，2），\r3不是（1,3）,4是(1，2，4)，...9是（1,3,9）,...16是（1,2,4,8,16），\r发现规律的吧，1的平方，2的平方，3的平方，4的平方，\r所有1-100一共有10个最后为关熄状态的灯。\r","description":"最后为关熄状态的灯有几个?","id":6,"section":"intelligence","tags":null,"title":"智力题1.4","uri":"https://xing-you-ji.github.io/intelligence/niuke_part1/%E6%9C%80%E5%90%8E%E4%B8%BA%E5%85%B3%E7%86%84%E7%8A%B6%E6%80%81%E7%9A%84%E7%81%AF%E6%9C%89%E5%87%A0%E4%B8%AA/"},{"content":"题目：假设一个5位数字的180度旋转图像是另一个5位数字，并且这两个数字之间的差是78633，那么原始的5位数字是什么？\n答案：\r首先，只有0，1，2，6，8，9，6个数字反转仍有效。另外要注意，旋转180度，\r数字所在位也变了。考虑首位和末位，要求差为7和3，只有1和8满足。\r1xxx8和8xxx1。考虑倒数第二位3，由于末位退位，要求差4，只有0和6。\r所以是10x68和89x01。最后看中间，78633+10x68=89x01。\r所有原始数字是10968或者89601\r","description":"原始的5位数字是什么？","id":7,"section":"intelligence","tags":null,"title":"智力题1.5","uri":"https://xing-you-ji.github.io/intelligence/niuke_part1/%E5%8E%9F%E5%A7%8B%E7%9A%845%E4%BD%8D%E6%95%B0%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88/"},{"content":"题目：医院里的医务人员，包括我在内，总共是16名医生和护士。下面讲到的人员情况，无论是否把我计算在内，都不会有任何变化。在这些医务人员中： (1)护士多于医生;(2)男医生多于男护士;(3)男护士多於女护士;(4)至少有一位女医生。 这位说话的人是什么性别和职务？\n答案：\r先考虑不把说话者计算在内的情况，这时医生和护士共有15名。\r首先由条件（1）可知，则护士至少应有8名；再由条件（3）可知，\r则男护士至少有5名；接着由条件（2）可知，男医生至少有6名；\r结合条件（4）可知，医生至少有7名，则护士至多8名。所以，\r要满足条件，只能是护士8名，其中男护士5名，女护士3名，医生7名，\r其中男医生6名，女医生1名。加上说话者后，要仍满足这四个条件，\r由条件（1）可知，说话者是护士；由条件（2）可知，说话者不能是男护士，\r所以只能是女护士。\r","description":"题目：这位说话的人是什么性别和职务","id":8,"section":"intelligence","tags":null,"title":"智力题3.1","uri":"https://xing-you-ji.github.io/intelligence/niuke_part3/%E8%BF%99%E4%BD%8D%E8%AF%B4%E8%AF%9D%E7%9A%84%E4%BA%BA%E6%98%AF%E4%BB%80%E4%B9%88%E6%80%A7%E5%88%AB%E5%92%8C%E8%81%8C%E5%8A%A1/"},{"content":"题目：\n已知每个城市的用水需求相同，每月水库的进水速率恒定不变。现有一座水库供水，如果供应10个城市的话，一个月水库就会枯竭；如果供应8个城市的话，一个半月水库就会枯竭。当前城市化进程不断加快，新的城市不断产生，为了能够持续满足12个城市的供水，还至少需要建设几个这样的水库？\n假设水库库存的水量为M\r水库每月进水为X\r每个城市每月消耗水m\r由题意：\rM + X = 10 * m\rM + 1.5 * X = 8 * m * 1.5\r解得：\rX = 4m\r因此：\r要维持12个城市每月持续不断的供水，要满足：(?) * X = m * 12\r解得：(?) = 3\r题目问的是：\u0026quot;还至少需要建设几个这样的水库？\u0026quot;\r不应该是2个吗？(因为现在已经有一个水库了...)\r","description":"还至少需要建设几个这样的水库?","id":9,"section":"intelligence","tags":null,"title":"智力题4.1","uri":"https://xing-you-ji.github.io/intelligence/niuke_part4/%E8%BF%98%E8%87%B3%E5%B0%91%E9%9C%80%E8%A6%81%E5%BB%BA%E8%AE%BE%E5%87%A0%E4%B8%AA%E8%BF%99%E6%A0%B7%E7%9A%84%E6%B0%B4%E5%BA%93/"},{"content":"题目：把21、26、65、99、10、35、18、77分成若干组，要求每组中任意两个数都互质，至少要分成多少组。\n答案：1.首先把含有相同因数的数分到一组，或者是没有相同因数的质数分为一组\r2.列出来：含有因数3的：21，99，18。含有因数5的：10，35，65。\r是质数（77不是质数，但剩下的数里面没有和它有相同因数的，故分到一组）的：26，77\r3.然后把这些组组合起来，所以至少是三组。\r解惑（思路有很多，比如也可以在第一第二步选择将偶数分为一组，然后再细分）\r","description":"题目：至少要分为多少组？","id":10,"section":"intelligence","tags":null,"title":"智力题4.2","uri":"https://xing-you-ji.github.io/intelligence/niuke_part4/%E8%87%B3%E5%B0%91%E8%A6%81%E5%88%86%E4%B8%BA%E5%A4%9A%E5%B0%91%E7%BB%84/"},{"content":"题目：1000 个瓶子中有一瓶毒药，一只老鼠吃到毒药一周之内会死，如果要在一周之内检测出有毒药的一瓶，问至少需要几只老鼠？\nA:8\nB:10\nC:24\nD:999\n答案是十只 000=0\r001=1\r010=2\r011=3\r100=4\r101=5\r110=6\r111=7\r一位表示一个老鼠，0-7表示8个瓶子。\r也就是分别将1、3、5、7号瓶子的药混起来给老鼠1吃，\r2、3、6、7号瓶子的药混起来给老鼠2吃，\r4、5、6、7号瓶子的药混起来给老鼠3吃，\r哪个老鼠死了，相应的位标为1。\r如老鼠1死了、老鼠2没死、老鼠3死了，\r那么就是101=5号瓶子有毒。\r同样道理10个老鼠可以确定1000个瓶子\r","description":"问至少需要几只老鼠？","id":11,"section":"intelligence","tags":null,"title":"智力题1.1","uri":"https://xing-you-ji.github.io/intelligence/niuke_part1/%E8%80%81%E9%BC%A0%E6%B5%8B%E6%AF%92%E8%8D%AF/"},{"content":"1\n1 1\n2 1\n1 2 1 1\n1 1 1 2 2 1\n下一行是什么\nA:1111211\nB:312211\nC:312112\nD:213112\n微软的题\r答案：后一行数是前一行数的描述，把“个”字去掉组成新的数：\r-1：1个1 ——11\r- 11：2个1——21\r- 21：1个2，1个1——1211\r- 1211：1个1,1个2,2个1——111221\r- 111221：3个1，2个2，1个1——312211\r","description":"题目：下一行输出什么","id":12,"section":"intelligence","tags":null,"title":"智力题1.2","uri":"https://xing-you-ji.github.io/intelligence/niuke_part1/%E4%B8%8B%E4%B8%80%E8%A1%8C%E8%AF%A5%E8%BE%93%E5%87%BA%E4%BB%80%E4%B9%88/"},{"content":"此文章借鉴于微信公众号“小林coding”\n　Go语言之父Rob Pike大神曾吐槽：不能掌握正则表达式或浮点数就不配当码农！\nYou should not be permitted to write production code if you do not have an journeyman license in regular expressions or floating point math. 来看看一个有趣的问题，在编程语言中，0.1 + 0.2 == 0.3？，你认为是true还是false。\n来直接看看下面代码吧（下面只展示c和golang）\nc golang  1 2 3 4 5 6 7 8  #include \u0026lt;stdio.h\u0026gt; int main() { int bool_num = (0.1 + 0.2 == 0.3); printf(\u0026#34;%d\u0026#34;, bool_num); return 0; }    \r1 2 3 4 5 6 7 8 9 10  package main import( \u0026#34;fmt\u0026#34; ) func main(){ fmt.Printf(0.1+0.2==0.3) }    \r  'use strict'; var containerId = JSON.parse(\"\\\"5cdb15baa5b4cf80\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  结果出其所料，答案是false\n你可能会怀疑自己？我以前的数学老师教错了吗？或者是这计算机太蠢了吧，连这都算不清？\n别急，听我一一道来\n关于这个计算其实是两个问题了：\n1.我们日常或者说是人脑计算0.1+0.2，答案当然是0.3\n2.你把这个计算交给计算机，它得到的是0.30000000000000004（单精度）\n为什么会出现这个结果呢？这就需要一定计算机知识的人才会知道。\n什么是浮点数 我们知道，数学中并没有浮点数的概念，虽然小数看起来像浮点数，但从不这么叫。那为什么计算机中不叫小数而叫浮点数呢？\n因为资源的限制，数学中的小数无法直接在计算机中准确表示。为了更好地表示它，计算机科学家们发明了浮点数，这是对小数的近似表示。维基百科中关于浮点数的概念说明如下：\nThe term floating point refers to the fact that a number's radix point (decimal point, or, more commonly in computers, binary point) can float; that is, it can be placed anywhere relative to the significant digits of the number.（浮点数是指一个数字的小数点(小数点,或者更常见的在电脑、二进制点)可以浮动;也就是说,它可以放置在任何地方相对于数量的有效数字。\r） 具体来说，浮点数是指用符号、尾数、基数和指数这四部分来表示的小数。\n知道了浮点数的概念，但需要确定一套具体的表示、运算标准。其中最有名的就是 IEEE754 标准。William Kahan 正是因为浮点数标准化的工作获得了图灵奖。\n　标准中规定：\nfloat32位单精度浮点数在机器中表示用 1 位表示数字的符号，用 8 位表示指数，用 23 位表示尾数。\ndouble64位双精度浮点数，用 1 位表示符号，用 11 位表示指数，52 位表示尾数。\n今天，我们来一步一步思考下面这些问题，然后最后再来说说为什么计算机里 0.1 + 0.2 != 0.3。\n  为什么负数要用补码表示？\n  十进制小数怎么转成二进制？\n  计算机是怎么存小数的？\n  0.1 + 0.2 == 0.3 吗？\n  别看这些问题都看似简单，但是其实还是有点东西。\n为什么负数要用补码表示？ 十进制转换二进制的方法相信大家都熟能生巧了，如果你说你还不知道，我觉得你还是太谦虚，可能你只是忘记了，即使你真的忘记了，不怕，让我们一起来重新回顾一下\n十进制数转二进制采用的是除 2 取余法，比如数字 8 转二进制的过程如下图：\n  \n接着，我们看看「整数类型」的数字在计算机的存储方式，这其实很简单，也很直观，就是将十进制的数字转换成二进制即可。\n我们以 int 类型的数字作为例子，int 类型是 32 位的，其中最高位是作为「符号标志位」，正数的符号位是 0，负数的符号位是 1，剩余的 31 位则表示二进制数据。\n那么，对于 int 类型的数字 1 的二进制数表示如下：\n  \n而负数就比较特殊了点，负数在计算机中是以「补码」表示的，所谓的补码就是把正数的二进制全部取反再加 1，比如 -1 的二进制是把数字 1 的二进制取反后再加 1，如下图：\n  \n不知道你有没有想过，为什么计算机要用补码的方式来表示负数？在回答这个问题前，我们假设不用补码的方式来表示负数，而只是把最高位的符号标志位变为 1 表示负数，如下图过程：\n  \n如果采用这种方式来表示负数的二进制的话，试想一下 -2 + 1 的运算过程，如下图：\n  \n按道理，-2 + 1 = -1，但是上面的运算过程中得到结果却是 -3，所可以发现，这种负数的表示方式是不能用常规的加法来计算了，就需要特殊处理，要先判断数字是否为负数，如果是负数就要把加法操作变成减法操作才可以得到正确对结果。\n到这里，我们就可以回答前面提到的「负数为什么要用补码方式来表示」的问题了。\n如果负数不是使用补码的方式表示，则在做基本对加减法运算的时候，还需要多一步操作来判断是否为负数，如果为负数，还得把加法反转成减法，或者把减法反转成加法，这就非常不好了，毕竟加减法运算在计算机里是很常使用的，所以为了性能考虑，应该要尽量简化这个运算过程。\n而用了补码的表示方式，对于负数的加减法操作，实际上是和正数加减法操作一样的。你可以看到下图，用补码表示的负数在运算 -2 + 1 过程的时候，其结果是正确的：\n  \n十进制小数与二进制的转换 好了，整数十进制转二进制我们知道了，接下来看看小数是怎么转二进制的，小数部分的转换不同于整数部分，它采用的是乘 2 取整法，将十进制中的小数部分乘以 2 作为二进制的一位，然后继续取小数部分乘以 2 作为下一位，直到不存在小数为止。\n话不多说，我们就以 8.625转二进制作为例子，直接上图：\n  \n最后把「整数部分 + 小数部分」结合在一起后，其结果就是 1000.101。\n但是，并不是所有小数都可以用二进制表示，前面提到的 0.625 小数是一个特例，刚好通过乘 2 取整法的方式完整的转换成二进制。\n如果我们用相同的方式，来把 0.1 转换成二进制，过程如下：\n  \n可以发现，0.1 的二进制表示是无限循环的。\n由于计算机的资源是有限的，所以是没办法用二进制精确的表示 0.1，只能用「近似值」来表示，就是在有限的精度情况下，最大化接近 0.1 的二进制数，于是就会造成精度缺失的情况。\n对于二进制小数转十进制时，需要注意一点，小数点后面的指数幂是负数。\n比如，二进制 0.1 转成十进制就是 2^(-1)，也就是十进制 0.5，二进制 0.01转成十进制就是 2^-2，也就是十进制 0.25，以此类推。\n举个例子，二进制 1010.101 转十进制的过程，如下图：\n  \n计算机是怎么存小数的？ 1000.101 这种二进制小数是「定点数」形式，代表着小数点是定死的，不能移动，如果你移动了它的小数点，这个数就变了， 就不再是它原来的值了。\n然而，计算机并不是这样存储的小数的，计算机存储小数的采用的是浮点数，名字里的「浮点」表示小数点是可以浮动的。\n比如 1000.101 这个二进制数，可以表示成 1.000101 x 2^3，类似于数学上的科学记数法。\n既然提到了科学计数法，我再帮大家复习一下。\n比如有个很大的十进制数 1230000，我们可以也可以表示成 1.23 x 10^6，这种方式就称为科学记数法。\n该方法在小数点左边只有一个数字，而且把这种整数部分没有前导 0 的数字称为规格化，比如 1.0 x 10^(-9) 是规格化的科学记数法，而 0.1 x 10^(-9) 和 10.0 x 10^(-9) 就不是了。\n因此，如果二进制要用到科学记数法，同时要规范化，那么不仅要保证基数为 2，还要保证小数点左侧只有 1 位，而且必须为 1。\n所以通常将 1000.101 这种二进制数，规格化表示成 1.000101 x 2^3，其中，最为关键的是 000101 和 3 这两个东西，它就可以包含了这个二进制小数的所有信息：\n  000101 称为尾数，即小数点后面的数字；\n  3 称为指数，指定了小数点在数据中的位置；\n  现在绝大多数计算机使用的浮点数，一般采用的是 IEEE 制定的国际标准，这种标准形式如下图：\n  \n这三个重要部分的意义如下：\n  符号位：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；\n  指数位：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，指数位的长度越长则数值的表达范围就越大；\n  尾数位：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且尾数的长度决定了这个数的精度，因此如果要表示精度更高的小数，则就要提高尾数位的长度；\n  用 32 位来表示的浮点数，则称为单精度浮点数，也就是我们编程语言中的 float 变量，而用 64 位来表示的浮点数，称为双精度浮点数，也就是 double 变量，它们的结构如下：\n  \n可以看到：\n  double 的尾数部分是 52 位，float 的尾数部分是 23 位，由于同时都带有一个固定隐含位（这个后面会说），所以 double 有 53 个二进制有效位，float 有 24 个二进制有效位，所以所以它们的精度在十进制中分别是 log10(2^53)约等于 15.95和 log10(2^24)约等于 7.22 位，因此 double 的有效数字是 15~16 位，float 的有效数字是 7~8 位，这些是有效位是包含整数部分和小数部分；\n  double 的指数部分是 11 位，而 float 的指数位是 8 位，意味着 double 相比 float 能表示更大的数值范围；\n  那二进制小数，是如何转换成二进制浮点数的呢？\n我们就以 10.625作为例子，看看这个数字在 float 里是如何存储的。\n  \n首先，我们计算出 10.625 的二进制小数为 1010.101。\n然后把小数点，移动到第一个有效数字后面，即将 1010.101 右移 3 位成 1.010101，右移 3 位就代表 +3，左移 3 位就是 -3。\nfloat 中的「指数位」就跟这里移动的位数有关系，把移动的位数再加上「偏移量」，float 的话偏移量是 127，相加后就是指数位的值了，即指数位这 8 位存的是 10000010（十进制 130），因此你可以认为「指数位」相当于指明了小数点在数据中的位置。\n1.010101 这个数的小数点右侧的数字就是 float 里的「尾数位」，由于尾数位是 23 位，则后面要补充 0，所以最终尾数位存储的数字是 01010100000000000000000。\n在算指数的时候，你可能会有疑问为什么要加上偏移量呢？\n前面也提到，指数可能是正数，也可能是负数，即指数是有符号的整数，而有符号整数的计算是比无符号整数麻烦的，所以为了减少不必要的麻烦，在实际存储指数的时候，需要把指数转换成无符号整数。\nfloat 的指数部分是 8 位，IEEE 标准规定单精度浮点的指数取值范围是 -126 ~ +127，于是为了把指数转换成无符号整数，就要加个偏移量，比如 float 的指数偏移量是 127，这样指数就不会出现负数了。\n比如，指数如果是 8，则实际存储的指数是 8 + 127（偏移量）= 135，即把 135 转换为二进制之后再存储，而当我们需要计算实际的十进制数的时候，再把指数减去「偏移量」即可。\n细心的朋友肯定发现，移动后的小数点左侧的有效位（即 1）消失了，它并没有存储到 float 里。\n这是因为 IEEE 标准规定，二进制浮点数的小数点左侧只能有 1 位，并且还只能是 1，既然这一位永远都是 1，那就可以不用存起来了。\n于是就让 23 位尾数只存储小数部分，然后在计算时会自动把这个 1 加上，这样就可以节约 1 位的空间，尾数就能多存一位小数，相应的精度就更高了一点。\n那么，对于我们在从 float 的二进制浮点数转换成十进制时，要考虑到这个隐含的 1，转换公式如下：\n  \n举个例子，我们把下图这个 float 的数据转换成十进制，过程如下：\n  \n0.1 + 0.2 == 0.3 ? 前面提到过，并不是所有小数都可以用「完整」的二进制来表示的，比如十进制 0.1 在转换成二进制小数的时候，是一串无限循环的二进制数，计算机是无法表达无限循环的二进制数的，毕竟计算机的资源是有限。\n因此，计算机只能用「近似值」来表示该二进制，那么意味着计算机存放的小数可能不是一个真实值。\n现在基本都是用 IEEE 754 规范的「单精度浮点类型」或「双精度浮点类型」来存储小数的，根据精度的不同，近似值也会不同。\n那计算机是存储 0.1 是一个怎么样的二进制浮点数呢？\n偷个懒，我就不自己手动算了，可以使用 baseconvert 这个工具，将十进制 0.1 小数转换成 float 浮点数：\n  \n可以看到，8 位指数部分是 01111011，23 位的尾数部分是 10011001100110011001101，可以看到尾数部分是 0011 是一直循环的，只不过尾数是有长度限制的，所以只会显示一部分，所以是一个近似值，精度十分有限。\n接下来，我们看看 0.2 的 float 浮点数：\n  \n可以看到，8 位指数部分是 01111100，稍微和 0.1 的指数不同，23 位的尾数部分是 10011001100110011001101和 0.1 的尾数部分是相同的，也是一个近似值。\n0.1的二进制浮点数转换成十进制的结果是 0.100000001490116119384765625：\n  \n0.2 的二进制浮点数转换成十进制的结果是 0.20000000298023223876953125：\n  \n这两个结果相加就是 0.300000004470348358154296875：\n  \n所以，你会看到在计算机中 0.1 + 0.2 并不等于完整的 0.3。\n这主要是因为有的小数无法可以用「完整」的二进制来表示，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。\n总结 为什么负数要用补码表示？ 负数之所以用补码的方式来表示，主要是为了统一和正数的加减法操作一样，毕竟数字的加减法是很常用的一个操作，就不要搞特殊化，尽量以统一的方式来运算。\n十进制小数怎么转成二进制？ 十进制整数转二进制使用的是「除 2 取余法」，十进制小数使用的是「乘 2 取整法」。\n计算机是怎么存小数的？ 计算机是以浮点数的形式存储小数的，大多数计算机都是 IEEE 754 标准定义的浮点数格式，包含三个部分：\n  符号位：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；\n  指数位：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，指数位的长度越长则数值的表达范围就越大；\n  尾数位：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且尾数的长度决定了这个数的精度，因此如果要表示精度更高的小数，则就要提高尾数位的长度；\n  用 32 位来表示的浮点数，则称为单精度浮点数，也就是我们编程语言中的 float 变量，而用 64 位来表示的浮点数，称为双精度浮点数，也就是 double 变量。\n0.1 + 0.2 == 0.3 吗？ 不是的，0.1 和 0.2 这两个数字用二进制表达会是一个一直循环的二进制数，比如 0.1 的二进制表示为 0.0 0011 0011 0011… （0011 无限循环)，对于计算机而言，0.1 无法精确表达，这是浮点数计算造成精度损失的根源。\n因此，IEEE 754 标准定义的浮点数只能根据精度舍入，然后用「近似值」来表示该二进制，那么意味着计算机存放的小数可能不是一个真实值。\n0.1 + 0.2 并不等于完整的 0.3，这主要是因为这两个小数无法用「完整」的二进制来表示，只能根据精度舍入，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。\n学到的伙计顺便教一下身边的朋友吧（没学到的再看一遍）\n","description":"一篇文章带你了解浮点数","id":13,"section":"article","tags":["计算机"],"title":"你真的了解浮点数吗？","uri":"https://xing-you-ji.github.io/article/computer/float/"},{"content":"1\r此文章取自于微信公众号“低并发编程”\n正文开始：\n小宇：闪客，我最近在研究动态规划，但感觉就是想不明白，你能不能给我讲讲呀？ \n闪客：没问题，这个我擅长，你先说说提到动态规划，你最先想到的是什么？\n小宇：就什么子问题呀、状态转移方程呀乱七八糟的，哎呀不行不行，我一想到这些脑子又嗡嗡响了。\n闪客：你先别急，你先把所有的名词都抛在脑后，听我讲。\n小宇：好滴，你说吧。\n闪客：小宇我问你，从 1 一直加到 100 等于多少？\n1 + 2 + 3 + ... + 100 = ？\r小宇：5050！\n闪客：你这，怎么不按套路出牌呀，你应该说不知道。\n小宇：人家高斯早就算出来了，我还装不知道，这也太假了吧。\n全剧终...\r2\r闪客：好吧，那我再给你出一个题。\n小宇：行，你说吧，这回我肯定说不知道。\n闪客：一个楼梯有 10 级台阶，你从下往上走，每跨一步只能向上迈 1 级或者 2 级台阶，请问一共有多少种走法？\n小宇：额，这我真不知道了，我想想哈。\n  \n小宇：不行了不行了，实在想不明白，想了后面的就忘了前面的。\n闪客：你还是陷入了穷举的思想，你仔细想想我给你出的第一个题，看看有没有思路。\n小宇：啊！原来是有关联的呀。\n闪客：对呀，我本来想说假如我告诉你 1+\u0026hellip;+99 是多少，你是不是就直接能算出 1+\u0026hellip;+100 的值了。\n小宇：哦你这么一提示我有点感觉了！要想走到第 10 级台阶，要么是先走到第 9 级，然后再迈一步 1 级台阶上去，要么是先走到第 8 级，然后一次迈 2 级台阶上去。\n  闪客：太棒了！你找到感觉了！接着往下说。\n小宇：这样的话，走到 10 级台阶的走法数，就等于走到 9 级台阶的走法数，加上走到 8 级台阶的走法数。\n闪客：很好，那假如走到第 x 级台阶的走法数我们定义为 F(x)，那你能把刚刚的描述公式化么？\n小宇：那太简单了，公式就是：\nF(10) = F(9) + F(8)\r闪客：没错，而且不光是 10 级台阶如此，走到任何一级台阶的走法数，都符合这个逻辑，因此就可以得出一个通用公式：\nF(x) = F(x-1) + F(x-2)\r小宇：嗯嗯，这样计算 F(10)，只需要知道 F(9) 和 F(8) 就可以了，而计算 F(8)，就只需要知道 F(7) 和 F(6) 就可以了，依次类推。\n闪客：没错，那你想想看 F(2) 和 F(1) 怎么计算？\n小宇：简单，还是刚刚都逻辑被，想知道 F(2)，只需要知道 F(1) 和 F(0)，诶不对 F(0) 是什么鬼？还有 F(1) 的计算需要知道 F(0) 和 F(-1)，不行呀，这解释不通了。\n闪客：哈哈，别急，在这道题里，如果只迈到 1 级台阶，那一共就一种走法；如果只迈到 2 级台阶，就只有两种走法。可以直接很直观地得出，没必要推导。\n  小宇：哦哦我懂了，这道题里由于每一个递推项都需要前两项的支持，所以必须有最开头的两项作为已知，就是你说的 F(1) = 1 和 F(2) = 2。\n闪客：没错。\n小宇：嗯嗯，感觉这样就推出全部结果了！我写一下程序你看看。\n闪客：先别急，由于这道题是一道经典的动态规划题，所以我们以这道题为例子来定义动态规划的三要素，在本题中\nF(x-1) 和 F(x-2) 被称为 F(x) 的最优子结构\nF(x) = F(x-1) + F(x-2) 叫状态转移方程\nF(1) = 1, F(2) = 2 是问题的边界\n之后做动态规划问题，只要找好这三个要素就好了。\n小宇：哇，升华了诶，逼格瞬间高了不少呢。\n闪客：先别说这些废话了，那接下来你看看能不能写出程序，计算出 F(10) 的结果，这才是难点。\n小宇：编程的话这似乎是个递归问题，简单！\n c golang  1 2 3 4 5 6 7 8 9  int getWays(int n) { if (n == 1) { return 1; } if (n == 2) { return 2; } return getWays(n-1) + getWays(n-2); }    \r1 2 3 4 5 6 7 8 9  func getways(n int)int{ if n == 1 { return 1 } if n == 2 { return 2 } return getWays(n-1) + getways(n-2) }    \r  'use strict'; var containerId = JSON.parse(\"\\\"b059bc293d889ef1\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \n闪客：嗯不错，这样很简洁，但复杂度太高了，是 O(2^n)，具体你可以之后想想为什么。现在你看看能不能将复杂度降低。\n小宇：我想想看，计算 F(10) 时需要计算 F(9) 和 F(8)，而在递归计算 F(9) 时要计算 F(8) 和 F(7)，这样 F(8) 在这里重复计算了，浪费了时间。\n  \n闪客：没错，其实计算新一个阶段的值，只需要一直将其前两个阶段的值保存起来，就可以一直算到最终的结果了。比如定义两个变量 a 和 b 用于存储前两个阶段的值，在计算 F(3) 时。\n\n\r\r台阶\r1\r2\r3\r4\r...\r10\r\r\r走法\ra=1\rb=2\r3\r\r\r\r\r\r\n计算 F(4) 时，F(1) 的值就不用保存了，a 和 b 依次替换新值。\n\r\r台阶\r1\r2\r3\r4\r...\r10\r\r\r走法\r\ra=2\rb=3\r5\r\r\r\r\r\n依此类推，最终就算出了 F(10) 的值。\n\r\r台阶\r1\r2\r...\r8\r9\r10\r\r\r走法\r\r\r\ra=33\rb=55\r89\r\r\r\n当然你也可以把之前的值都保留，但这样就增加了空间复杂度，看你的需求了。\n小宇：好的，那这样代码也很好写，就这样。\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  int getWays2(int n) { if (n == 1) { return 1; } if (n == 2) { return 2; } int a = 1; int b = 2; int temp = 0; for (int i = 3; i \u0026lt;= n; i++) { temp = a + b; a = b; b = temp; } return temp; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func getWays2(int n)int{ if n == 1 { return 1 } if n == 2 { return 2 } var a int = 1 var b int = 2 var temp int = 0 for i := 3; i \u0026lt;= n; i++ { temp = a + b a = b b = temp } return temp }    \r  'use strict'; var containerId = JSON.parse(\"\\\"54d85b8113d2ff7d\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  闪客：不错，这就是这道题正确的动态规划解法，而且时间复杂度是 O(N)，空间复杂度是 O(1)\n小宇：哇，这就是动态规划呀，原来这么简单。\n3\r闪客：不错，动态规划理解起来不难，难在当需要考虑的因素，也就是变化的维度多起来的时候，有的人就会头脑发蒙，不好找递推公式了，而且这也确实是个难点。\n小宇：哦是吗？\n闪客：那当然，我再给你出一道题。\n小宇：来吧兄弟。\n闪客：咳咳，那你听好了。\n有一个背包，可以装载重量为 5kg 的物品。\r有 4 个物品，他们的重量和价值如下。\r\n  \n那么请问，在不得超过背包的承重的情况下，将哪些物品放入背包，可以使得总价值最大？\r小宇：明白了，就是我用这个背包最多能装走多少钱的东西。\n闪客：是的。\n小宇：哎呀不行，我又陷入走楼梯时的遍历思想了。\n闪客：没关系，这道题能想出遍历思想，其实也不容易了，你可以先说一下，找找感觉。\n小宇：嗯嗯，那就是每个物品都可以有放入背包和不放入背包两种选择。\n如果总重量超过了背包承重，那就不算，或者说将价值记为 0，然后将所有情况中价值最大的那个作为结果。\n这样的复杂度也很容易得出，就是 O(2^N)\n闪客：没错，这个复杂度很高的算法你已经说的很明白了，那接下来你想想看用动态规划思想，能不能解决这个问题。\n小宇：好的，你之前说过，动态规划的三要素是最优子结构、状态转移方程和边界\n闪客：没错，之前的变量很少所以比较简单，现在变量多了，定义就变得难了起来，我们先来几个定义方便描述。我们将 4 个物品的重量和价值分别表示为：w1，w2，w3，w4，v1，v2，v3，v4。\n  \n假如我们用\nF(W,i) \r表示\n用载重为 W 的背包，装前 i 件物品的最大价值\r那本题其实就是\nF(5,4) 其实就是求解 你能找到状态转移方程么？\n小宇：我想想，单看这个物品 4，有两种可能：\n第一种可能：如果选择把它装入背包，那已经得到了 6 元钱。\n此时背包剩余载重为 1kg（5kg-4kg），剩余物品是除去物品 4 后的前 3 件物品。\n那这部分能获取到的最大价值，相当于\n用一个载重为 1kg 的背包，装前 3 件物品的最大价值 \n哇，那这部分就是\nF(1,3) 闪客：哈哈，你这自己说着说着就说对啦！\n小宇：所以最终，如果选择将物品 4 放入背包，这种情况下，最大价值就等于二者之和。\nF(1, 3) + 6\r\n  \n闪客：太好了小宇，那另一种情况呢？\n小宇：第二种可能：如果选择不装这个物品 4，那更简单了，就直接等于用一个载重为 5 的背包装前 3 件物品的价值。\nF(5, 3)\r\n  \n闪客：没错，而且就只有这两种情况！所以你看看 F(5,4)是否能用这两种情况的值表示呢？\n小宇：哈哈，很简单，就等于这两种情况当中的最大值呗。\nF(5,4) = max { F(1, 3) + 6，F(5, 3) }\r闪客：太好了，现在状态转移方程出来了，此时我们画个表格。\n  我们的目标就是要计算右下角那个值，即背包载重 W = 5 时，选择前 4 件物品放入背包的最大价值 F(5,4)\n小宇：哇这个表格好清晰呀，根据上面的公式\nF(5,4) = max { F(1,3) + 6, F(5,3) }\r\n那也就是说只要知道 F(1,3) 和 F(5,3) 的值就可以了对吧？\n  闪客：没错，那你再看看 F(1,3) 怎么计算？\n小宇：好的，F(1,3) 此时背包重量为 1，如果选择放第三件物品的话，诶？好像不行，第三件物品根本放不下呀！\n闪客：是的，所以这种情况就没必要讨论放第三件物品的情况了，因为根本放不下，因此 F(1,3) 直接就等于 F(1,2)，所以只需要知道 F(1,2) 即可。\n  \n同理 F(1,2) 也直接等于 F(1,1)，因为在背包重量为 1 时第二件物品也放不下。\n闪客：小宇你想想看，那 F(1,1) 又等于什么呢？\n小宇：显然嘛，现在只有一件物品可以选了，那能放下当然就放咯，所以最大价值就是第一件物品的价值 3，即 F(1,1) = 3\n闪客：没错，这样我们就找到了一个边界值，小宇你想想看还有哪些边界值可以直接得出？你写在表格里吧。\n小宇：好的，首先第一列表示背包重量为 0 时的情况，那显然什么都装不了，就全都是 0 了。\n  \n然后第一行也比较好算，背包重量 \u0026gt;= 1 时可以放下第一件物品，所以最大价值都等于 3\n  \n闪客：很好，接下来，就依次把表格的所有项都填出来，自然就可以算出 F(5,4) 啦。\n  \n小宇：哇塞，这样看好清晰呀！\n闪客：是呀，不过刚刚我们用的都是具体的数字，那我们试着把这个问题抽象化，用一个载重为 W 的背包，装载 N 件物品，每件物品的重量和价值分别用 wi 和 vi 来表示，那刚刚的状态转移方程是什么呢？\n小宇：emm，刚刚 F(5,4) = max { F(1,3) + 6, F(5,3) }，如果都用变量表示的话，就是\n\nF(W,N) = max { F(W-wn, N-1) + vn，F(W, N-1) }\r闪客：很好，这就是状态转移方程。\nF(W-wn, N-1) 和 F(W, N-1) 就是 F(W,N) 的最优子结构。\n而刚刚表格中的第一行和第一列，即 F(0,\u0026hellip;) 和 F(\u0026hellip;,1) 就是边界值！\n小宇：哇塞我爱你闪客！终于有点理解动态规划的思想了呢！\n4\r闪客：别高兴太早，虽然过程看着清晰了，但代码写起来还是有难度的，你今天回去就把代码试着实现一下吧。\n小宇：好的，保证完成任务。\n闪客：快到晚饭时间了，旁边新开了家饺子馆，要不要一块去吃呀？\n小宇：哦不了，晚上想利用晚饭时间再去消化消化动态规划的知识，不是还得代码实现呢么，下次吧，\n闪客：哦好吧~\n后记\r本文通过直观演示 01 背包问题的解题思路，简单说明了动态规划思想的算法核心。可能不少人觉得动态规划难在理解，所以花很多时间在理解其思想上。但其实理解核心思想，这一篇文章就够了，更多的是通过不断做题，反过来帮助自己理解动态规划的思想。所以希望读者在读完本文后，和小宇一样，动手将其代码实现，并找来其他变种题目，继续巩固。\n","description":"了解什么是动态规划","id":14,"section":"article","tags":["算法"],"title":"图解 | 你管这破玩意叫动态规划","uri":"https://xing-you-ji.github.io/article/algorithm/dynamic-programming/"},{"content":"数值类型 整数类型 \r\r类型\r占用的存储空间（单位：字节）\r无符号数取值范围\r有符号数取值范围\r含义\r\r\rTINYINT\r1\r0 ~ 2⁸-1\r-2⁷ ~ 2⁷-1\r非常小的整数\r\r\rSMALLINT\r2\r0 ~ 2¹⁶-1\r-2¹⁵ ~ 2¹⁵-1\r小的整数\r\r\rMEDIUMINT\r3\r0 ~ 2²⁴-1\r-2²³ ~ 2²³-1\r中等大小的整\r\r\rINT（别名：INTEGER）\r4\r0 ~ 2³²-1\r-2³¹ ~ 2³¹-1\r标准的整数\r\r\rBIGINT\r8\r0 ~ 2⁶⁴-1\r-2⁶³ ~ 2⁶³-1\r大整数\r\r\r浮点数类型 关于浮点数如何在计算机中存储，请先阅读《你真的了解浮点数吗？》\n  设置最大位数和小数位数 在定义浮点数类型时，还可以在FLOAT或者DOUBLE后边跟上两个参数，就像这样：\nFLOAT(M, D)\nDOUBLE(M, D)\n M表示该小数最多需要的十进制有效数字个数。  注意是有效数字个数，比方说对于小数-2.3来说有效数字个数就是2，对于小数0.9来说有效数字个数就是1。\n D表示该小数的小数点后的十进制数字个数。  这个好理解，小数点后有几个十进制数字，D的值就是什么。\n举个例子看一下，设置了M和D的单精度浮点数的取值范围的变化：\n  \n可以看到，在D相同的情况下，M越大，该类型的取值范围越大；在M相同的情况下，D越大，该类型的取值范围越小。当然，M和D的取值也不是无限大的，M的取值范围是1~255，D的取值范围是0~30，而且D的值必须不大于M。M和D都是可选的，如果我们省略了它们，那它们的值按照机器支持的最大值来存储。\n定点数类型 正因为用浮点数表示小数可能会有不精确的情况，在一些情况下我们必须保证小数是精确的，所以设计MySQL的大叔们提出一种称之为定点数的数据类型，它也是存储小数的一种方式：\n  对于给定M、D值的DECIMAL(M, D)类型，比如DEMCIMAL(16, 4)来说：\n\n 首先确定小数点左边的整数最多需要存储的十进制位数是12位，小数点右边的整数需要存储的十进制位数是4位，如图所示：    \n从小数点位置出发，每个整数每隔9个十进制位划分为1组，效果就是这样：\n  \n从图中可以看出，如果不足9个十进制位，也会被划分成一组。\n 针对每个组中的十进制数字，将其转换为二进制数字进行存储，根据组中包含的十进制数字位数不同，所需的存储空间大小也不同，具体见下表：    \n所以DECIMAL(16, 4)共需要占用8个字节的存储空间大小，这8个字节由下边3个部分组成：\n 第1组包含3个十进制位，需要使用2个字节存储。 第2组包含9个十进制位，需要使用4个字节存储。 第3组包含4个十进制位，需要使用2个字节存储。  对于定点数类型DECIMAL(M, D)来说，M和D都是可选的，默认的M的值是10，默认的D的值是0，也就是说下列等式是成立的：\nDECIMAL = DECIMAL(10) = DECIMAL(10, 0)\nDECIMAL(n) = DECIMAL(n, 0)\n另外M的范围是1~65，D的范围是0~30，且D的值不能超过M。\n无符号数值类型的表示 数值类型 UNSIGNED\n小贴士： 在使用的存储空间大小相同的情况下，无符号整数可以表示的正整数范围比有符号整数能表示的正整数范围大一倍。不过受浮点数和定点数具体的存储格式影响，无符号浮点数和定点数并不能提升正数的表示范围。 日期和时间类型 我们有很多场景需要表示时间或日期，比如学生基本信息中的入学时间就需要用日期的格式保存。MySQL为我们提供了多种关于时间和日期的类型，各种类型能表示的范围如下：\n  \n在MySQL5.6.4这个版本之后，TIME、DATETIME、TIMESTAMP这几种类型添加了对毫秒、微秒的支持。由于毫秒、微秒都不到1秒，所以也被称为小数秒，MySQL最多支持6位小数秒的精度\n如果我们想让TIME、DATETIME、TIMESTAMP这几种类型支持小数秒，可以这样写：\n类型(小数秒位数)\n其中的小数秒位数可以在0、1、2、3、4、5、6中选择\n 比如DATETIME(0)表示精确到秒，DATETIME(3)表示精确到毫秒，DATETIME(5)表示精确到10微秒。如果你在选择TIME、DATETIME、TIMESTAMP这几种类型的时候添加了对小数秒的支持，那么所需的存储空间需要相应的扩大，保留不同的小数秒位数，那么增加的存储空间大小也不同，如下表：\n  \n也就是说如果你选择使用DATETIME(1)，那么需要的存储空间就是在DATETIME的空间上再加上小数秒需要的空间，就是8 + 1 = 9个字节，类似的，DATETIME(3)就需要8 + 2 = 10个字节。所以，MySQL5.6.4这个版本之后的各个类型需要的存储空间和取值范围就如下：\n  \n大家应该发现其中的在没有存储小数秒的情况下，DATETIME类型占用的存储空间从原来的8字节变成了5字节，这是因为设计MySQL的大叔背后做了些努力，使存储格式变得更紧凑了些。\nYEAR YEAR类型也可以写成YEAR(4)，它单纯表示一个年份值，取值范围为1901 ～ 2155，仅仅占用1个字节大小而已。因为可以存储的年份值有限，如果我们想存储更大范围的年份值，可以不使用MySQL自带的YEAR类型，换成SMALLINT（2字节）或者字符串类型啥的都可以。\nDATE、TIME和DATETIME 顾名思义，DATE表示日期，格式是YYYY-MM-DD；TIME表示时间，格式是hh:mm:ss[.uuuuuu]或者hhh:mm:ss[.uuuuuu]（有时候要存储的小时值是三位数），DATETIME表示日期+时间，格式是YYYY-MM-DD hh:mm:ss[.uuuuuu]。其中的YYYY、MM、DD、hh、mm、ss、uuuuuu分别表示年、月、日、时、分、秒、小数秒。\n需要注意的是，DATETIME中的时间部分表示的是一天内的时间(00:00:00 ~ 23:59:59)，而 TIME表示的是一段时间，而且可以表示负值。\nTIMESTAMP 1970-01-01 00:00:00注定是一个特殊的时刻，我们把某个时刻距离1970-01-01 00:00:00的秒数称为时间戳。比方说当前时间是2018-01-24 11:39:21，距离1970-01-01 00:00:00的秒数为1516765161，那么2018-01-24 11:39:21这个时刻的时间戳就是1516765161。不过在MySQL5.6.4之后，时间戳的值也可以加入小数秒。\n用时间戳存储时间的好处就是，它展示的值可以随着时区的变化而变化。比方说我们把2018-01-24 11:39:21这个时刻存储到一个TIMESTAMP的列中，那么在中国你看到的时间就是2018-01-24 11:39:21，如果你去了日本，他们哪里的使用的是东京时间，比北京时间早一个小时，所以他们那显示的就是2018-01-24 12:39:21。而如果你用DATETIME存储2018-01-24 11:39:21的话，那不同时区看到的时间值都是一样的。\n字符串类型 字符和字符串 字符可以大致分为两种，一种叫可见字符，一种叫不可见字符。顾名思义，可见字符就是打印出来后能看见的字符。比如\u0026lsquo;a\u0026rsquo;，\u0026lsquo;b\u0026rsquo;，\u0026lsquo;我\u0026rsquo;，'。' \u0026hellip; 这样的人眼能看见的单个的国家文字、标点符号、图形符号、数字等这样的东东，我们就叫做一个可见字符。不可见字符也好理解，就是打印机或者在黑框框里打印字符的时候有时候需要换行，打个制表符啥的，或者在输出某个字符的时候就发出嘟地一声，这种我们看不到，只是为了控制输出效果的字符叫做不可见字符。字符串就是把字符连起来的样子，比如\u0026rsquo;abc'，就是由\u0026rsquo;a'、\u0026lsquo;b\u0026rsquo;、\u0026lsquo;c\u0026rsquo;三个字符连起来的一个字符串\n字符编码简介 在具体分析MySQL中各个字符串类型之前，我们一定要先搞明白字符和字节的区别。字符是面向人的概念，字节是面向计算机的概念。如果你想在计算机中表示字符，那就需要将该字符与一个特定的字节序列对应起来，这个映射过程称之为编码。不幸的是，这种映射关系并不是唯一的，不同的人制作了不同的编码方案，根据表示一个字符使用的字节数量是不是固定的，编码方案可以分为下边两种：\n 固定长度的编码方案  表示不同的字符所需要的字节数量是相同的。比方说ASCII编码方案采用1个字节来编码一个字符，ucs2采用2个字节来编码一个字符。\n 变长的编码方案  表示不同的字符所需要的字节数量是不同的。比方说utf8编码方案采用1~3个字节来编码一个字符，gb2312采用1~2个字节来编码一个字符。\n对于不同的字符编码方案来说，同一个字符可能被编码成不同的字节序列。比如同样一个字符：我，在utf8和gb2312这两种编码方案下被映射成如下的字节序列：\n utf8编码方案  字符\u0026rsquo;我\u0026rsquo;被编码成：\n111001101000100010010001\n共占用3个字节，用十六进制表示就是：0xE68891。\n gb2312编码方案  字符\u0026rsquo;我\u0026rsquo;被编码成：\n1100111011010010\n共占用2个字节，用十六进制表示就是：0xCED2。\n小贴士： 正宗的utf8字符集是使用1~4个字节来编码一个字符的，不过MySQL中对utf8字符集做了阉割，编码一个字符最多使用3个字节。如果我们之后有存储使用4个字节来编码的字符的情景，可以使用一种称之为utf8mb4的字符集，它才是正宗的utf8字符集。 MySQL的字符串类型 现在我们可以看一下MySQL中提供的各种字符串类型（注：其中M代表该数据类型最多能存储的字符数量，L代表我们实际向该类型的属性中存储的字符串在特定字符集下所占的字节数，W代表在该特定字符集下，编码一个字符最多需要的字节数）\n  \nENUM类型和SET类型 ENUM和SET类型都是一种特殊的字符串类型，在从字符串列表中单选或多选元素的时候会用得到它们。\n二进制类型 BIT类型 有时候我们有存储单个或者多个比特位的需求，此时就可以用到下边这种类型：\n  \n其中M的取值范围为1~64，而且M可以省略，它的默认值为1，也就是说BIT(1)和BIT的意思是一样的。\nMySQL是以字节为单位存储数据的，一个字节拥有8个比特位。如果我们想存储的比特位个数不足整数个字节，那么MySQL会偷偷的填充满，比方说：\n  BIT(1)类型仅仅需要存储1个比特位的数据，但是MySQL会为其申请(1+7)/8 = 1个字节。\n  BIT(5)类型仅仅需要存储5个比特位的数据，但是MySQL会为其申请(5+7)/8 = 1个字节。\n  BIT(9)类型仅仅需要存储9个比特位的数据，但是MySQL会为其申请(9+7)/8 = 2个字节。\n  BINARY(M)与VARBINARY(M) BINARY(M)和VARBINARY(M)对应于我们前边提到的CHAR(M)和VARCHAR(M)，都是前者是固定长度的类型，后者是可变长度的类型，只不过BINARY(M)和VARBINARY(M)是用来存放字节的，其中的M代表该类型最多能存放的字节数量，而CHAR(M)和VARCHAR(M)是用来存储字符的，其中的M代表该类型最多能存放的字符数量。\n其他的二进制类型   \n","description":"从零蛋开始学习 MySQL","id":15,"section":"databases","tags":["mysql"],"title":"数据类型","uri":"https://xing-you-ji.github.io/databases/mysql/1/"},{"content":"在面对面试中的算法问题时，有一个合理的思考路径 1.1面对算法问题，不畏惧 1.2不代表能够“正确”回答每一个算法问题，但合理的思考方向其实更重要 1.3算法面试优秀不意味着技术面试优秀 1.4技术面试优秀不意味着能够拿到offer 1.5算法面试不是高考，把这个过程看作是和面试官一起探讨一个问题的解决方案，对于问题的细节和应用环境，可以和面试官沟通 比如：我们需要对一组数据进行排序\n看使用的具体环境：\n这组数据有什么样的特征：\n 有没有可能包含有大量重复的元素 如果有这种可能的话，三路快排（请自行百度）是更好的选择\n  这组数据有什么样的特征：\n 是否大部分数据离它正确的位置很近？是否近乎有序？ 如果是这样的话，插入排序（请自行百度）是更好的选择\n  这组数据有什么样的特征：\n 是否数据的取值范围非常有限？比如对学生成绩排序。 如果是这样的话，计数排序（请自行百度）是更好的选择\n  对排序有什么额外的要求？\n 是否需要稳定的排序 如果是的话，归并排序（请自行百度）是更好的选择\n  数据的存储状况是怎样的？\n 是否是使用链表存储的？ 如果是的话，归并排序（请自行百度）是更好的选择\n  数据的存储状况是怎样的？\n 数据的大小是否可以装载在内存里 数据量很大，或者内存很小，不足以装载在内存里，需要使用外排序算法\n  排序算法思考总结\n 有没有可能包含有大量重复的元素 是否大部分数据离它正确的位置很近？是否近乎有序？ 是否数据的取值范围非常有限？比如对学生成绩排序。 是否需要稳定的排序 是否是使用链表存储的？ 数据的大小是否可以装载在内存里  \r1.6“正确”的回答一个算法问题 1.6.1“正确”除了1.5还包含对问题的独到见解；优化；代码规范；容错性；关键在于你所表达出解决问题的思路。\n1.6.2通过表达解题思路的方向，得出结论：这个问题的解决方案，应该在哪一个领域，我可以通过查阅或者进一步学习解决问题。\n","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":16,"section":"interview","tags":["算法"],"title":"慕课算法视频第一章第一节","uri":"https://xing-you-ji.github.io/interview/algorithm_interview/charpter1/1/"},{"content":"到底什么是大O n表示数据规模\nO(f(n))表示运行算法所需要执行的指令数，和f(n)成正比\n举例：（其中a,b,c,d都为常数，不随n变化而变化）\n 二分查找法O(logn) 所需执行的指令数：a*logn 寻找数组中的最大/最小值O(n) 所需执行的指令数：b*n 归并排序算法O(nlogn) 所需执行的指令数：c*nlogn 选择排序法O(n^2) 所需执行的指令数：d*n^2  Tips：在学术界，严格地讲，O(f(n))表示算法执行的上界\n比如：归并排序的算法复杂度是O(nlogn)，同时也是O(n^2)\n在业界，我们就使用O来表示算法执行的最低上界\n我们一般不会说归并排序是O(n^2)的\n     ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":17,"section":"interview","tags":["算法"],"title":"慕课算法视频第二章第一节","uri":"https://xing-you-ji.github.io/interview/algorithm_interview/charpter2/1/"},{"content":"1.启动mysql服务 net start mysql(windows)　service mysqld start(linux)  2.关闭mysql服务 net stop mysql service mysqld stop(linux)\r 3.重启mysql服务 service mysqld restart\r 4.创建一个数据库（比如数据库的名字叫zhugeqing） 1 2  create database zhugeqing; create database if not exists zhugeqing;(如果并不清楚数据库是否存在，可以使用这条语句来创建数据库)   5.查看所有数据库 1  show databases;   information_schema：主要存储了系统中的一些数据库对象信息，比如用户表信息、列信息、权限信息、字符集信息、分区信息等。\ncluster：存储了系统的集群信息。\nmysql：存储了系统的用户权限信息。\ntest：系统自动创建的测试数据库，任何用户都可以使用。\n6.删除一个数据库（比如数据库的名字叫zhugeqing） 1 2  drop database zhugeqing; drop database if exists zhugeqing;(如果某个数据库并不存在，我们仍旧调用DROP DATABASE语句去删除它)   7.切换当前数据库（比如数据库的名字叫zhugeqing） 1  use zhugeqing;   其实我们在新启动客户端连接服务器时就可以指定连接建立成功后客户端的当前数据库，\n只要把数据库名称写在启动客户端的命令mysql -h 主机名 -u 用户名 -p密码后边就好，如下：\nmysql -h localhost -u root -p123456 zhugeqing\r ","description":"从零蛋开始学习 MySQL","id":18,"section":"databases","tags":["mysql"],"title":"数据库的基本操作","uri":"https://xing-you-ji.github.io/databases/mysql/2/"},{"content":"算法优秀不意味着技术面试优秀 2.1算法面试只是技术面试的一部分 根据你的简历和应聘职位的不同，势必要考察其他技术方面\n比如：\n1.项目经历和项目中遇到的实际问题\n2.你遇到的印象最深的bug是什么\n3.面向对象\n4.设计模式\n5.网络相关；安全相关；内存相关；并发相关；\u0026hellip;\n6.系统设计：scalability（近些年比较重视）\n技术面试优秀不意味着能够拿到offer 2.2技术面试只是面试的一部分，面试不仅仅是考察你的技术水平，还是了解你的过去以及形成的思考行为方式 比如：\n1.参与项目至关重要，对于本科生，毕业设计和其他的课程设计本身就是一个项目经历\n2.如何找到项目：实习，参与实战课程学习（慕课网，等等，我博客的推荐网站\u0026hellip;）\n3.创建自己的项目：自己做小应用：计划表，备忘录，播放器\u0026hellip;；自己解决小问题：爬虫，数据分析，词频统计\u0026hellip;；“不是项目”的项目：一本优秀的技术书籍的代码整理等\u0026hellip;；分享：自己的技术博客,github等等\n4.行为类问题：遇到的最大的挑战？犯过最大的错误？遭遇的失败？最享受的工作内容？遇到冲突的处理方式？做的最与众不同的事？\n2.3准备好合适的问题问面试官 比如：\n1.整个小组的大概运行模式是怎样的？\n2.整个项目的后续规划是如何的？\n3.这个产品的某个问题是如何解决的？\n4.为什么会选择某些技术？标准?来实现某个需求\n5.我对某个技术很感兴趣，在你的小组中我会有怎样的机会深入这种技术？\n","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":19,"section":"interview","tags":["算法"],"title":"慕课算法视频第一章第二节","uri":"https://xing-you-ji.github.io/interview/algorithm_interview/charpter1/2/"},{"content":"数据规模的概念 如果想要在1s之内解决问题：\nO(n^2)的算法可以处理大约10^4级别的数据；\nO(n)的算法可以处理大约10^8级别的数据；\nO(nlogn)的算法可以处理大约10^7的数据；\n空间复杂度 多开一个辅助的数组：O(n)\n多开一个辅助的二维数组：O(n^2)\n多开常数空间：O(1)\n递归的调用是有空间代价的\n","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":20,"section":"interview","tags":["算法"],"title":"慕课算法视频第二章第二节","uri":"https://xing-you-ji.github.io/interview/algorithm_interview/charpter2/2/"},{"content":"展示当前数据库中的表 1  show tables;   创建表 基本语法 创建一个表时至少需要完成下列事情：\n 给表起个名。 给表定义一些列，并且给这些列都起个名。 每一个列都需要定义一种数据类型。 如果有需要的话，可以给这些列定义一些列的属性，比如不许存储NULL，设置默认值等等。  1 2 3 4 5 6  CREATE TABLE 表名 ( 列名1 数据类型 [列的属性], 列名2 数据类型 [列的属性], ... 列名n 数据类型 [列的属性] );     在CREATE TABLE后写清楚我们要创建的表的名称。\n  然后在小括号()中定义上这个表的各个列的信息，包括列的名称、列的数据类型，如果有需要的话也可以定义这个列的属性（列的属性用中括号[]引起来的意思就是这部分是可选的，也就是可有可无的）。\n  列名、数据类型、列的属性之间用空白字符分开就好，然后各个列的信息之间用逗号,分隔开。\n  小贴士： 我们也可以把这个创建表的语句都放在单行中，而示例中将建表语句分成多行并且加上缩进仅仅是为了美观而已～ 例子如下\n1 2 3 4  CREATE TABLE first_table ( first_column INT, second_column VARCHAR(100) );   为建表语句添加注释 1 2 3  CREATE TABLE 表名 ( 各个列的信息 ... ) COMMENT \u0026#39;表的注释信息\u0026#39;;   例子如下\n1 2 3 4  CREATE TABLE first_table ( first_column INT, second_column VARCHAR(100) ) COMMENT \u0026#39;第一个表\u0026#39;;   和重复创建数据库一样，如果创建一个已经存在的表的话是会报错的，我们来试试重复创建一下first_table表：\n1 2 3 4 5 6 7  mysql\u0026gt; CREATE TABLE IF NOT EXISTS first_table ( -\u0026gt; first_column INT, -\u0026gt; second_column VARCHAR(100) -\u0026gt; ) COMMENT \u0026#39;第一个表\u0026#39;; Query OK, 0 rows affected, 1 warning (0.00 sec) mysql\u0026gt;   删除表 和删除数据库类似（一定要去医院看看自己有没有发烧再进行删除数据库和表的操作）\n1 2  DROP TABLE 表1, 表2, ..., 表n; DROP TABLE IF EXISTS 表名;(如果我们并不清楚表是否存在，可以使用这条语句来删除表)   例子如下\n1 2  mysql\u0026gt; DROP TABLE first_table; Query OK, 0 rows affected (0.01 sec)   和重复删除数据库一样，如果删除一个已经不存在的表的话是会报错的，我们来试试重复删除一下first_table表：\n例子如下\n1 2 3 4  mysql\u0026gt; DROP TABLE IF EXISTS first_table; Query OK, 0 rows affected, 1 warning (0.00 sec) mysql\u0026gt;   查看表结构 有时候我们可能忘记了自己定义的表的结构，可以使用下边这些语句来查看，它们起到的效果都是一样的：\n1 2 3 4 5  DESCRIBE 表名; DESC 表名; EXPLAIN 表名; SHOW COLUMNS FROM 表名; SHOW FIELDS FROM 表名;   换一种形式来查看表的结构\n1  SHOW CREATE TABLE 表名;   还可以把原来用于标记语句结束的分号;改为\\G，以垂直的方式展示每一列数据的效果可能好点\n1  SHOW CREATE TABLE 表名\\G   没有选择当前数据库时对表的操作 没有使用USE语句来选择当前数据库，来查看某数据库的表（数据库-zhugeqing）\n1  SHOW TABLES FROM zhugeqing;   没有使用USE语句来选择当前数据库，来查看某数据库的某个表的表结构（数据库-zhugeqing，表名-first_table）\n1  SHOW CREATE TABLE zhugeqing.first_table\\G   修改表 修改表名 1 2  ALTER TABLE 旧表名 RENAME TO 新表名; RENAME TABLE 旧表名1 TO 新表名1, 旧表名2 TO 新表名2, ... 旧表名n TO 新表名n;（同时修改多个表名）   把first_table表的名称修改为first_table1（当前数据库为zhugeqing）\n1  ALTER TABLE first_table RENAME TO first_table1;   把数据库zhugeqing下的first_table1表转移到这个zhuegqing2数据库下\n1 2  CREATE DATABASE zhugeqing2; ALTER TABLE first_table1 RENAME TO zhugeqing2.first_table1;   再用修改表名的第二种方法将数据库zhugeqing2下的first_table1转移到数据库zhugeqing下，并将其更名为first_table\n1  RENAME TABLE zhugeqing2.first_table1 TO zhugeqing.first_table   增加列 增加表中的列：\n1  ALTER TABLE 表名 ADD COLUMN 列名 数据类型 [列的属性];   比如再在first_table里添加一个名为third_column的列就可以这么写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  mysql\u0026gt; ALTER TABLE first_table ADD COLUMN third_column CHAR(4) ; Query OK, 0 rows affected (0.05 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql\u0026gt; SHOW CREATE TABLE first_table\\G *************************** 1. row *************************** Table: first_table Create Table: CREATE TABLE `first_table` ( `first_column` int(11) DEFAULT NULL, `second_column` varchar(100) DEFAULT NULL, `third_column` char(4) DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=\u0026#39;第一个表\u0026#39; 1 row in set (0.01 sec) mysql\u0026gt;   增加列到特定位置  添加到第一列：  1  ALTER TABLE 表名 ADD COLUMN 列名 列的类型 [列的属性] FIRST;   把fourth_column插入到第一列：\n1  ALTER TABLE first_table ADD COLUMN fourth_column CHAR(4) FIRST;    添加到指定列的后边：  1  ALTER TABLE 表名 ADD COLUMN 列名 列的类型 [列的属性] AFTER 指定列名;   插入一个fifth_column到first_column后边：\n1  ALTER TABLE first_table ADD COLUMN fifth_column CHAR(4) AFTER first_column;   删除列 可以使用下边的语句来删除表中的列：\n1  ALTER TABLE 表名 DROP COLUMN 列名;   删除添加的third_column、fourth_column、fifth_column这几个列:\n1 2 3 4 5 6 7 8 9 10 11  mysql\u0026gt; ALTER TABLE first_table DROP COLUMN third_column; Query OK, 0 rows affected (0.05 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql\u0026gt; ALTER TABLE first_table DROP COLUMN fourth_column; Query OK, 0 rows affected (0.05 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql\u0026gt; ALTER TABLE first_table DROP COLUMN fifth_column; Query OK, 0 rows affected (0.04 sec) Records: 0 Duplicates: 0 Warnings: 0   修改列信息  方式一：  1  ALTER TABLE 表名 MODIFY 列名 新数据类型 [新属性];   修改一下first_table表的second_column列，把它的数据类型修改为VARCHAR(2)：\n1 2 3  mysql\u0026gt; ALTER TABLE first_table MODIFY second_column VARCHAR(2); Query OK, 0 rows affected (0.04 sec) Records: 0 Duplicates: 0 Warnings: 0    方式二：  1  ALTER TABLE 表名 CHANGE 旧列名 新列名 新数据类型 [新属性];   修改second_column的列名为second_column1:\n1 2 3  mysql\u0026gt; ALTER TABLE first_table CHANGE second_column second_column1 VARCHAR(2)\\G Query OK, 0 rows affected (0.04 sec) Records: 0 Duplicates: 0 Warnings: 0   修改列排列位置  将列设为表的第一列：  1  ALTER TABLE 表名 MODIFY 列名 列的类型 列的属性 FIRST;   把second_column放在第一列：\n1 2 3  mysql\u0026gt; ALTER TABLE first_table MODIFY second_column1 VARCHAR(2) FIRST; Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0    将列放到指定列的后边：  1  ALTER TABLE 表名 MODIFY 列名 列的类型 列的属性 AFTER 指定列名;   把second_column1再放到first_column后边：\n1 2 3  mysql\u0026gt; ALTER TABLE first_table MODIFY second_column1 VARCHAR(2) AFTER first_column; Query OK, 0 rows affected (0.03 sec) Records: 0 Duplicates: 0 Warnings: 0   一条语句中包含多个修改操作 如果对同一个表有多个修改操作的话：\n1  ALTER TABLE 表名 操作1, 操作2, ..., 操作n;   ","description":"从零蛋开始学习 MySQL","id":21,"section":"databases","tags":["mysql"],"title":"表的基本操作","uri":"https://xing-you-ji.github.io/databases/mysql/3/"},{"content":"算法面试并没有那么难 远远不需要啃完一本《算法导论》   强理论证明\n高级数据结构和算法在面试时提及的概率很低\n红黑树 计算几何 B-Tree 数论 斐波那契堆 FFT\n  远远不需要到达信息学竞赛的水平\n  算法面试的准备范围 1.不要轻视基础算法和数据结构，而只关注“有意思”的题目\n 各种排序算法(特点与比较) 基础数据结构和算法的实现：如堆、二叉树、图\u0026hellip; 基础数据结构的使用：如链表、栈、队列、哈希表、图、Trie、并查集\u0026hellip; 基础算法：深度优先、广度优先、二分查找、递归\u0026hellip; 基本的算法思想：递归、分治、回溯搜索、贪心、动态规划\u0026hellip;  2.选择合适的OJ(online judge在线判题系统)\n LeetCode(http://www.leetcode.com)(专门为面试的一个OJ) HackerRank(http://www.hackerrank.com)(对问题的分类很详细)  （Tips:在学习和实践做题之间，要掌握平衡）\n","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":22,"section":"interview","tags":["算法"],"title":"慕课算法视频第一章第三节","uri":"https://xing-you-ji.github.io/interview/algorithm_interview/charpter1/3/"},{"content":"解决算法面试问题的整体思路 1.注意题目中的条件\n比如：\n给定一个有序的数组\u0026hellip;（二分查找）\n设计一个O(nlogn)的算法\n无需考虑额外的空间（开辟额外的空间来换取时间）\n数据规模大概是10000\n2.当没有思路的时候\n 自己给自己几个简单的测试用例，实验一下 不要忽视暴力解法。暴力解法通常是思考的起点  3.优化算法\n 遍历常见的算法思路 遍历常见的数据结构 空间与时间的交换（哈希表） 预处理信息（排序 ）  4.实际编写问题\n 极端条件的判断\n数组为空？字符串为空？数量为0？指针为NULL？ 变量名的撰写规范 模块化，复用性  5.对于基本问题，做到白板编程\n","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":23,"section":"interview","tags":["算法"],"title":"慕课算法视频第一章第四节","uri":"https://xing-you-ji.github.io/interview/algorithm_interview/charpter1/4/"},{"content":"简单的查询和插入的语句 简单的查询语句 查看某个表里已经存储了哪些数据，可以用下边这个语句：\n1  SELECT * FROM 表名;   简单插入语句 MySQL插入数据的时候是以行为单位的，语法格式如下：\n1  INSERT INTO 表名(列1, 列2, ...) VALUES(列1的值，列2的值, ...);   为first_table表插入第一行数据:\n1 2 3 4  mysql\u0026gt; INSERT INTO first_table(first_column, second_column) VALUES(1, \u0026#39;aaa\u0026#39;); Query OK, 1 row affected (0.00 sec) mysql\u0026gt;   批量插入 MySQL为我们提供了批量插入记录的语句：\n1  INSERT INTO 表名(列1,列2, ...) VAULES(列1的值，列2的值, ...), (列1的值，列2的值, ...), (列1的值，列2的值, ...), ...;   例子如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  mysql\u0026gt; INSERT INTO first_table(first_column, second_column) VALUES(4, \u0026#39;ddd\u0026#39;), (5, \u0026#39;eee\u0026#39;), (6, \u0026#39;fff\u0026#39;); Query OK, 3 rows affected (0.00 sec) Records: 3 Duplicates: 0 Warnings: 0 mysql\u0026gt; SELECT * FROM first_table; +--------------+---------------+ | first_column | second_column | +--------------+---------------+ | 1 | aaa | | 2 | NULL | | NULL | ccc | | 4 | ddd | | 5 | eee | | 6 | fff | +--------------+---------------+ 6 rows in set (0.01 sec) mysql\u0026gt;   列的属性 列的默认值为NULL，NULL的含义是这个列的值还没有被设置。如果我们不想让默认值为NULL，而是设置成某个有意义的值，可以在定义列的时候给该列增加一个DEFAULT属性，就像这样：\n1  列名 列的类型 DEFAULT 默认值   比如我们把first_table的second_column列的默认值指定为\u0026lsquo;abc\u0026rsquo;，创建一下这个表：\n1 2 3 4 5 6 7  mysql\u0026gt; CREATE TABLE first_table ( -\u0026gt; first_column INT, -\u0026gt; second_column VARCHAR(100) DEFAULT \u0026#39;abc\u0026#39; -\u0026gt; ); Query OK, 0 rows affected (0.02 sec) mysql\u0026gt;   NOT NULL属性 有时候我们需要要求表中的某些列中必须有值，不能存放NULL，那么可以用这样的语法来定义这个列：\n1  列名 列的类型 NOT NULL   比如我们把first_table表的first_column列定义一个NOT NULL属性。当然，我们在重新定义表之前需要把原来的表删掉：\n1 2 3 4 5 6 7 8 9 10  mysql\u0026gt; DROP TABLE first_table; Query OK, 0 rows affected (0.00 sec) mysql\u0026gt; CREATE TABLE first_table ( -\u0026gt; first_column INT NOT NULL, -\u0026gt; second_column VARCHAR(100) DEFAULT \u0026#39;abc\u0026#39; -\u0026gt; ); Query OK, 0 rows affected (0.02 sec) mysql\u0026gt;   一旦对某个列定义了NOT NULL属性，那这个列的默认值就不为NULL了。上边first_column并没有指定默认值，意味着我们在使用INSERT插入行时必须显式的指定这个列的值，而不能省略它，也不能插入NULL值，比如这样就会报错的：\n1 2 3  mysql\u0026gt; INSERT INTO first_table(second_column) VALUES(\u0026#39;aaa\u0026#39;); ERROR 1364 (HY000): Field \u0026#39;first_column\u0026#39; doesn\u0026#39;t have a default value mysql\u0026gt;   主键 一个表最多只能有一个主键，主键的值不能重复，通过主键可以找到唯一的一条记录。如果我们的表中有定义主键的需求可以选用下边这两种方式之一来指定主键：\n 1.如果主键只是单个列的话，可以直接在该列后声明PRIMARY KEY，比如我们把学生信息表student_info的学号列声明为主键可以这么写：  1 2 3 4 5 6 7 8 9  CREATE TABLE student_info ( number INT PRIMARY KEY, name VARCHAR(5), sex ENUM(\u0026#39;男\u0026#39;, \u0026#39;女\u0026#39;), id_number CHAR(18), department VARCHAR(30), major VARCHAR(30), enrollment_time DATE );    2.我们也可以把主键的声明单独提取出来，用这样的形式声明：  1  PRIMARY KEY (列名1, 列名2, ...)   比如student_info的学号列声明为主键也可以这么写：\n1 2 3 4 5 6 7 8 9 10  CREATE TABLE student_info ( number INT, name VARCHAR(5), sex ENUM(\u0026#39;男\u0026#39;, \u0026#39;女\u0026#39;), id_number CHAR(18), department VARCHAR(30), major VARCHAR(30), enrollment_time DATE, PRIMARY KEY (number) );   值得注意的是，对于多个列的组合作为主键的情况，必须使用这种单独声明的形式，比如student_score表里的学号,科目的列组合作为主键，可以这么写：\n1 2 3 4 5 6  CREATE TABLE student_score ( number INT, subject VARCHAR(30), score TINYINT, PRIMARY KEY (number, subject) );   另外，主键列默认是有NOT NULL属性，也就是必填的，如果填入NULL值会报错(先删除原来的student_info表，使用刚才所说的两种方式之一重新创建表之后仔执行下边的语句)：\n1 2 3  mysql\u0026gt; INSERT INTO student_info(number) VALUES(NULL); ERROR 1048 (23000): Column \u0026#39;number\u0026#39; cannot be null mysql\u0026gt;   UNIQUE属性 对于不是主键的其他候选键，如果也想让MySQL在我们向表中插入新记录的时候帮助我们校验一下某个列或者列组合的值是否重复，那么我们可以把这个列或列组合添加一个UNIQUE属性，表明该列或者列组合的值是不允许重复的。与我们在建表语句中声明主键的方式类似，为某个列声明UNIQUE属性的方式也有两种：\n 1.如果我们想为单个列声明UNIQUE属性，可以直接在该列后填写UNIQUE或者UNIQUE KEY，比如在学生信息表student_info中，我们不允许两条学生基本信息记录中的身份证号是一样的，那我们可以为id_number列添加UNIQUE属性：  1 2 3 4 5 6 7 8 9  CREATE TABLE student_info ( number INT PRIMARY KEY, name VARCHAR(5), sex ENUM(\u0026#39;男\u0026#39;, \u0026#39;女\u0026#39;), id_number CHAR(18) UNIQUE, department VARCHAR(30), major VARCHAR(30), enrollment_time DATE );    2.我们也可以把UNIQUE属性的声明单独提取出来，用这样的形式声明：  1  UNIQUE [约束名称] (列名1, 列名2, ...)   或者\n1  UNIQUE KEY [约束名称] (列名1, 列名2, ...)   约束名称是被中括号[]扩起来的，意味着我们写不写都可以，如果不写的话MySQL自己会帮我们起名。\n如果表中为某个列或者列组合定义了UNIQUE属性的话，MySQL会对我们插入的记录做校验，如果新插入记录在该列或者列组合的值已经在表中存在了，那就会报错！\n主键和UNIQUE约束的区别 主键和UNIQUE约束都能保证某个列或者列组合的唯一性，但是：\n一张表中只能定义一个主键，却可以定义多个UNIQUE约束！\n规定：主键列不允许存放NULL，而声明了UNIQUE属性的列可以存放NULL，而且NULL可以重复地出现在多条记录中！\n外键 插入到学生成绩表student_score中的number(学号)列中的值必须能在学生基本信息表student_info中的number列中找到，否则如果一个学号只在成绩表里出现，而在基本信息表里找不到相应的记录的话，就相当于插入了不知道是哪个学生的成绩，这显然是荒谬的。为了防止这样荒谬的情况出现，MySQL给我们提供了外键约束机制。定义外键的语法是这样的：\n1  CONSTRAINT [外键名称] FOREIGN KEY(列1, 列2, ...) REFERENCES 父表名(父列1, 父列2, ...);   如果A表中的某个列或者某些列依赖与B表中的某个列或者某些列，那么就称A表为子表，B表为父表。子表和父表可以使用外键来关联起来，上边例子中student_score表的number列依赖于student_info的number列，所以student_info就是一个父表，student_score就是子表。我们可以在student_score的建表语句中来定义一个外键：\n1 2 3 4 5 6 7  CREATE TABLE student_score ( number INT, subject VARCHAR(30), score TINYINT, PRIMARY KEY (number, subject), CONSTRAINT FOREIGN KEY(number) REFERENCES student_info(number) );   这样，在对student_score表插入数据的时候，MySQL都会为我们检查一下插入的学号是否能在student_info表中找到，如果找不到则会报错。\nAUTO_INCREMENT属性 AUTO_INCREMENT翻译成中文可以理解为自动增长，简称自增\n1  列名 列的类型 AUTO_INCREMENT   当我们把某个列设置了AUTO_INCREMENT属性之后，如果我们在插入新记录的时候不指定该列的值，或者将该列的值显式地指定为NULL或者0，那么新插入的记录在该列上的值就是当前该列的最大值加1后的值。\n在为列定义AUTO_INCREMENT属性的时候需要注意这几点：\n一个表中最多有一个具有AUTO_INCREMENT属性的列。\n  具有AUTO_INCREMENT属性的列必须建立索引。主键和具有UNIQUE属性的列会自动建立索引。\n  拥有AUTO_INCREMENT属性的列就不能再通过指定DEFAULT属性来指定默认值。\n  一般拥有AUTO_INCREMENT属性的列都是作为主键的属性，来自动生成唯一标识一条记录的主键值。\n  列的注释 可以在每一个列末尾添加COMMENT语句来为列来添加注释\n1 2 3 4 5  CREATE TABLE first_table ( id int UNSIGNED AUTO_INCREMENT PRIMARY KEY COMMENT \u0026#39;自增主键\u0026#39;, first_column INT COMMENT \u0026#39;第一列\u0026#39;, second_column VARCHAR(100) DEFAULT \u0026#39;abc\u0026#39; COMMENT \u0026#39;第二列\u0026#39; ) COMMENT \u0026#39;第一个表\u0026#39;;   ZEROFILL属性 为列添加ZEROFILL属性的在查询会自动在数值前面自动补0\n使用ZEROFILL属性时应该注意下边几点：\n1.在展示查询结果时，某列数据自动补0的条件有这几个：\n 该列必须是整数类型的 该列必须有UNSIGNED ZEROFILL的属性 该列的实际值的位数必须小于显示宽度  2.在创建表的时候，如果声明了ZEROFILL属性的列没有声明\u0026lt;font color=VioletRed si//ze=3 \u0026gt;UNSIGNED属性，那MySQL会为该列自动生成UNSIGNED属性。也就是说MySQL现在只支持对无符号整数进行自动补0的操作。\n3.每个整数类型都会有默认的显示宽度\n 比如TINYINT的默认显示宽度是4，INT的默认显示宽度是(11)\u0026hellip; 如果加了UNSIGNED属性，则该类型的显示宽度减1，比如TINYINT UNSIGNED的显示宽度是3，INT UNSIGNED的显示宽度是10。  \n4.显示宽度并不会影响实际类型的实际存储空间\n 显示宽度仅仅是在展示查询结果时，如果整数的位数不够显示宽度的情况下起作用的，并不影响该数据类型要求的存储空间以及该类型能存储的数据范围，也就是说INT(1)和INT(10)仅仅在展示时可能有区别，在别的方面没有任何区别。  \n5.只有列的实际值的位数小于显示宽度时才会补0，实际值的位数大于显示宽度时照原样输出。\n6.对于没有声明ZEROFILL属性的列，显示宽度没有一毛钱卵用。\n 只有在查询声明了ZEROFILL属性的列时，显示宽度才会起作用，否则忽略显示宽度这个东西的存在。  一个列同时具有多个属性 每个列可以同时具有多个属性，属性声明的顺序无所谓，各个属性之间用空白隔开就好了\n查看表结构时的列属性 来看一遍student_info表的结构:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  mysql\u0026gt; DESC student_info; +-----------------+-------------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-----------------+-------------------+------+-----+---------+-------+ | number | int(11) | NO | PRI | NULL | | | name | varchar(5) | YES | | NULL | | | sex | enum(\u0026#39;男\u0026#39;,\u0026#39;女\u0026#39;) | YES | | NULL | | | id_number | char(18) | YES | UNI | NULL | | | department | varchar(30) | YES | | NULL | | | major | varchar(30) | YES | | NULL | | | enrollment_time | date | YES | | NULL | | +-----------------+-------------------+------+-----+---------+-------+ 7 rows in set (0.00 sec) mysql\u0026gt;     NULL列代表该列是否可以存储NULL，值为NO时，表示不允许存储NULL，值为YES是表示可以存储NULL。\n  Key列存储关于所谓的键的信息，当值为PRI是PRIMARY KEY的缩写，代表主键；UNI是UNIQUE KEY的缩写，代表UNIQUE属性。\n  Default列代表该列的默认值。\n  Extra列展示一些额外的信息。比方说如果某个列具有AUTO_INCREMENT属性就会被展示在这个列里。\n  标识符的命名 像数据库名、表名、列名、约束名称或者我们之后会遇到的别的名称，这些名称统统被称为标识符。虽然MySQL中对标识符的命名没多少限制，但是却不欢迎下边的这几种命名：\n 1.名称中全都是数字 2.名称中有空白字符 3.名称使用了MySQL中的保留字(比方说CREATE、DATABASE、INT、DOUBLE、DROP、TABLE等等这些单词，这些单词都是供MySQL内部使用的，称之为保留字。如果你自己定义的名称用到了这些词儿也会导致歧义。比如名称create就是非法的。)  虽然某些名称可能会导致歧义，但是如果你坚持要使用的话，也不是不行，你可以使用反引号``来将你定义的名称括起来，这样MySQL的服务器就能检测到你提供的是一个名称而不是别的什么东西(以后列名尽量都用反引号括起来)\n由于MySQL是C语言实现的，所以在名称定义上还是尽量遵从C语言的规范吧，就是用小写字母、数字、下划线、美元符号等作为名称，如果有多个单词的话，各个单词之间用下划线连接起来，比如student、student_info啥的\n","description":"从零蛋开始学习 MySQL","id":24,"section":"databases","tags":["mysql"],"title":"列的操作","uri":"https://xing-you-ji.github.io/databases/mysql/4/"},{"content":"查询单个列 1  SELECT 列名 FROM 表名;   列的别名 为结果集中的列重新定义一个别名，命令格式如下：\n1  SELECT 列名 [AS] 列的别名 FROM 表名;(AS可有可无，别名只是在本次查询的到的结果集中展示，而不会改变真实表中的列名)   查询多个列 1  SELECT 列名1, 列名2, ... 列名n FROM 表名;(也可以加上别名)   查询所有列 1  SELECT * FROM 表名;   查询结果去重 去除单列的重复结果\n1  SELECT DISTINCT 列名 FROM 表名;   去除多列的重复结果\n1  SELECT DISTINCT 列名1, 列名2, ... 列名n FROM 表名;   限制查询结果条数 1  SELECT 列名 FROM 表名 LIMIT 开始行, 限制条数;   开始行指的是从第几行数据开始查询，限制条数是结果集中最多包含多少条记录。（计算机从零开始计数，第0条、第1条、第2条、第3条、第4条、第5条。如果指定的开始行大于结果中的行数，那查询结果就什么都没有。）\n使用默认的开始行 LIMIT后边也可以只有一个参数，那这个参数就代表着限制行数。\n1  SELECT 列名 FROM 表名 LIMIT 限制条数;   对查询结果排序 按照单个列的值进行排序 1  SELECT 列名 FROM 表名 ORDER BY 列名 ASC|DESC（ASC（ascending）和DESC（descending(）只能选一个，如果不加则默认ASC，前者是升序，后者是降序）   按照多个列的值进行排序 1  SELECT 列名 FROM 表名 ORDER BY 列1 ASC|DESC, 列2 ASC|DESC ...   ","description":"从零蛋开始学习 MySQL","id":25,"section":"databases","tags":["mysql"],"title":"简单查询","uri":"https://xing-you-ji.github.io/databases/mysql/5/"},{"content":"简单搜索条件 我们需要把搜索条件放在WHERE子句中，比如我们想查询student_info表中名字是范剑的学生的一些信息，可以这么写：\n1 2 3 4 5 6 7 8 9  mysql\u0026gt; SELECT number, name, id_number, major FROM student_info WHERE name = \u0026#39;范剑\u0026#39;; +----------+--------+--------------------+-----------------+ | number | name | id_number | major | +----------+--------+--------------------+-----------------+ | 20180105 | 范剑 | 181048199308156368 | 飞行器设计 | +----------+--------+--------------------+-----------------+ 1 row in set (0.01 sec) mysql\u0026gt;   设计MySQL的大叔还提供了很多别的比较操作符\n  \n 查询学号大于20180103的学生信息可以这么写：  1 2 3 4 5 6 7 8 9 10 11  mysql\u0026gt; SELECT number, name, id_number, major FROM student_info WHERE number \u0026gt; 20180103; +----------+-----------+--------------------+-----------------+ | number | name | id_number | major | +----------+-----------+--------------------+-----------------+ | 20180104 | 史珍香 | 141992199701078600 | 软件工程 | | 20180105 | 范剑 | 181048199308156368 | 飞行器设计 | | 20180106 | 朱逸群 | 197995199501078445 | 电子信息 | +----------+-----------+--------------------+-----------------+ 3 rows in set (0.01 sec) mysql\u0026gt;    查询专业不是计算机科学与工程的一些学生信息可以这么写：  1 2 3 4 5 6 7 8 9 10 11 12  mysql\u0026gt; SELECT number, name, id_number, major FROM student_info WHERE major != \u0026#39;计算机科学与工程\u0026#39;; +----------+-----------+--------------------+-----------------+ | number | name | id_number | major | +----------+-----------+--------------------+-----------------+ | 20180103 | 范统 | 17156319980116959X | 软件工程 | | 20180104 | 史珍香 | 141992199701078600 | 软件工程 | | 20180105 | 范剑 | 181048199308156368 | 飞行器设计 | | 20180106 | 朱逸群 | 197995199501078445 | 电子信息 | +----------+-----------+--------------------+-----------------+ 4 rows in set (0.00 sec) mysql\u0026gt;    查询学号在20180102~20180104间的学生信息，可以这么写：  1 2 3 4 5 6 7 8 9 10 11  mysql\u0026gt; SELECT number, name, id_number, major FROM student_info WHERE number BETWEEN 20180102 AND 20180104; +----------+-----------+--------------------+--------------------------+ | number | name | id_number | major | +----------+-----------+--------------------+--------------------------+ | 20180102 | 杜琦燕 | 151008199801178529 | 计算机科学与工程 | | 20180103 | 范统 | 17156319980116959X | 软件工程 | | 20180104 | 史珍香 | 141992199701078600 | 软件工程 | +----------+-----------+--------------------+--------------------------+ 3 rows in set (0.00 sec) mysql\u0026gt;    查询学号不在20180102~20180104这个区间内的所有学生信息，可以这么写：  1 2 3 4 5 6 7 8 9 10 11  mysql\u0026gt; SELECT number, name, id_number, major FROM student_info WHERE number NOT BETWEEN 20180102 AND 20180104; +----------+-----------+--------------------+--------------------------+ | number | name | id_number | major | +----------+-----------+--------------------+--------------------------+ | 20180101 | 杜子腾 | 158177199901044792 | 计算机科学与工程 | | 20180105 | 范剑 | 181048199308156368 | 飞行器设计 | | 20180106 | 朱逸群 | 197995199501078445 | 电子信息 | +----------+-----------+--------------------+--------------------------+ 3 rows in set (0.00 sec) mysql\u0026gt;   匹配列表中的元素 有时候搜索条件中指定的匹配值并不是单个值，而是一个列表，只要匹配到列表中的某一项就算匹配成功，这种情况可以使用IN操作符：\n  \n 比如我们想查询软件工程和飞行器设计专业的学生信息，可以这么写：  1 2 3 4 5 6 7 8 9 10 11  mysql\u0026gt; SELECT number, name, id_number, major FROM student_info WHERE major IN (\u0026#39;软件工程\u0026#39;, \u0026#39;飞行器设计\u0026#39;); +----------+-----------+--------------------+-----------------+ | number | name | id_number | major | +----------+-----------+--------------------+-----------------+ | 20180103 | 范统 | 17156319980116959X | 软件工程 | | 20180104 | 史珍香 | 141992199701078600 | 软件工程 | | 20180105 | 范剑 | 181048199308156368 | 飞行器设计 | +----------+-----------+--------------------+-----------------+ 3 rows in set (0.01 sec) mysql\u0026gt;    如果想查询不是这两个专业的学生的信息，可以这么写：  1 2 3 4 5 6 7 8 9 10 11  mysql\u0026gt; SELECT number, name, id_number, major FROM student_info WHERE major NOT IN (\u0026#39;软件工程\u0026#39;, \u0026#39;飞行器设计\u0026#39;); +----------+-----------+--------------------+--------------------------+ | number | name | id_number | major | +----------+-----------+--------------------+--------------------------+ | 20180101 | 杜子腾 | 158177199901044792 | 计算机科学与工程 | | 20180102 | 杜琦燕 | 151008199801178529 | 计算机科学与工程 | | 20180106 | 朱逸群 | 197995199501078445 | 电子信息 | +----------+-----------+--------------------+--------------------------+ 3 rows in set (0.00 sec) mysql\u0026gt;   匹配NULL值 代表没有值，意味着你并不知道该列应该填入什么数据，在判断某一列是否为NULL的时候并不能单纯的使用=操作符，而是需要专业判断值是否是NULL的操作符：\n 比如我们想看一下student_info表的name列是NULL的学生记录有哪些，可以这么写：  1 2 3 4  mysql\u0026gt; SELECT number, name, id_number, major FROM student_info WHERE name IS NULL; Empty set (0.00 sec) mysql\u0026gt;    由于所有记录的name列都不是NULL值，所以最后的结果集是空的，我们看一下查询name列不是NULL值的方式：  1 2 3 4 5 6 7 8 9 10 11 12 13 14  mysql\u0026gt; SELECT number, name, id_number, major FROM student_info WHERE name IS NOT NULL; +----------+-----------+--------------------+--------------------------+ | number | name | id_number | major | +----------+-----------+--------------------+--------------------------+ | 20180101 | 杜子腾 | 158177199901044792 | 计算机科学与工程 | | 20180102 | 杜琦燕 | 151008199801178529 | 计算机科学与工程 | | 20180103 | 范统 | 17156319980116959X | 软件工程 | | 20180104 | 史珍香 | 141992199701078600 | 软件工程 | | 20180105 | 范剑 | 181048199308156368 | 飞行器设计 | | 20180106 | 朱逸群 | 197995199501078445 | 电子信息 | +----------+-----------+--------------------+--------------------------+ 6 rows in set (0.00 sec) mysql\u0026gt;   再次强调一遍，不能直接使用普通的操作符来与NULL值进行比较，必须使用IS NULL或者IS NOT NULL！\n多个搜索条件的查询 AND操作符\n在给定多个搜索条件的时候，我们有时需要某条记录只在符合所有搜索条件的时候才将其加入结果集，这种情况我们可以使用AND操作符来连接多个搜索条件。比如我们想从student_score表中找出科目为\u0026rsquo;母猪的产后护理'并且成绩大于75分的记录，可以这么写：\n1 2 3 4 5 6 7 8 9 10  mysql\u0026gt; SELECT * FROM student_score WHERE subject = \u0026#39;母猪的产后护理\u0026#39; AND score \u0026gt; 75; +----------+-----------------------+-------+ | number | subject | score | +----------+-----------------------+-------+ | 20180101 | 母猪的产后护理 | 78 | | 20180102 | 母猪的产后护理 | 100 | +----------+-----------------------+-------+ 2 rows in set (0.00 sec) mysql\u0026gt;   \nOR操作符\n在给定多个搜索条件的时候，我们有时需要某条记录在符合某一个搜索条件的时候就将其加入结果集中，这种情况我们可以使用OR操作符来连接多个搜索条件。比如我们想从student_score表中找出成绩大于95分或者小于55分的记录，可以这么写：\n1 2 3 4 5 6 7 8 9 10 11  mysql\u0026gt; SELECT * FROM student_score WHERE score \u0026gt; 95 OR score \u0026lt; 55; +----------+-----------------------------+-------+ | number | subject | score | +----------+-----------------------------+-------+ | 20180102 | 母猪的产后护理 | 100 | | 20180102 | 论萨达姆的战争准备 | 98 | | 20180104 | 论萨达姆的战争准备 | 46 | +----------+-----------------------------+-------+ 3 rows in set (0.00 sec) mysql\u0026gt;   \n更复杂的搜索条件的组合\n 如果我们需要在某个查询中指定很多的搜索条件，比方说我们想从student_score表中找出课程为\u0026rsquo;论萨达姆的战争准备'，并且成绩大于95分或者小于55分的记录，那我们可能会这么写：  1 2 3 4 5 6 7 8 9 10 11  mysql\u0026gt; SELECT * FROM student_score WHERE score \u0026gt; 95 OR score \u0026lt; 55 AND subject = \u0026#39;论萨达姆的战争准备\u0026#39;; +----------+-----------------------------+-------+ | number | subject | score | +----------+-----------------------------+-------+ | 20180102 | 母猪的产后护理 | 100 | | 20180102 | 论萨达姆的战争准备 | 98 | | 20180104 | 论萨达姆的战争准备 | 46 | +----------+-----------------------------+-------+ 3 rows in set (0.00 sec) mysql\u0026gt;   为什么结果中仍然会有\u0026rsquo;母猪的产后护理\u0026rsquo;课程的记录呢？因为：AND操作符的优先级高于OR操作符，也就是说在判断某条记录是否符合条件时会先检测AND操作符两边的搜索条件。所以\n可以被看作下边这两个条件中任一条件成立则整个式子成立：\n  1.score \u0026gt; 95\n  2.score \u0026lt; 55 AND subject = \u0026lsquo;论萨达姆的战争准备\u0026rsquo;\n  在一个查询中有多个搜索条件时最好使用小括号()来显式的指定各个搜索条件的检测顺序比如上边的例子可以写成下边这样：\n1 2 3 4 5 6 7 8 9 10  mysql\u0026gt; SELECT * FROM student_score WHERE (score \u0026gt; 95 OR score \u0026lt; 55) AND subject = \u0026#39;论萨达姆的战争准备\u0026#39;; +----------+-----------------------------+-------+ | number | subject | score | +----------+-----------------------------+-------+ | 20180102 | 论萨达姆的战争准备 | 98 | | 20180104 | 论萨达姆的战争准备 | 46 | +----------+-----------------------------+-------+ 2 rows in set (0.00 sec) mysql\u0026gt;   通配符 有时候我们并不能精确的描述我们要查询的哪些结果，比方说我们只是想看看姓\u0026lsquo;杜\u0026rsquo;的学生信息，而不能精确的描述出这些姓\u0026lsquo;杜\u0026rsquo;的同学的完整姓名，我们称这种查询为模糊查询。MySQL中使用下边这两个操作符来支持模糊查询：\n  \n既然我们不能完整描述要查询的信息，那就用某个符号来替代这些模糊的信息，这个符号就被称为通配符。MySQL中支持下边这两个通配符：\n %：代表任意一个字符串。\n比方说我们想查询student_info表中name以\u0026rsquo;杜\u0026rsquo;开头的记录，我们可以这样写：  1 2 3 4 5 6 7 8 9 10  mysql\u0026gt; SELECT number, name, id_number, major FROM student_info WHERE name LIKE \u0026#39;杜%\u0026#39;; +----------+-----------+--------------------+--------------------------+ | number | name | id_number | major | +----------+-----------+--------------------+--------------------------+ | 20180101 | 杜子腾 | 158177199901044792 | 计算机科学与工程 | | 20180102 | 杜琦燕 | 151008199801178529 | 计算机科学与工程 | +----------+-----------+--------------------+--------------------------+ 2 rows in set (0.00 sec) mysql\u0026gt;   或者我们只知道学生名字里边包含了一个\u0026lsquo;香\u0026rsquo;字，那我们可以这么查：\n1 2 3 4 5 6 7 8 9  mysql\u0026gt; SELECT number, name, id_number, major FROM student_info WHERE name LIKE \u0026#39;%香%\u0026#39;; +----------+-----------+--------------------+--------------+ | number | name | id_number | major | +----------+-----------+--------------------+--------------+ | 20180104 | 史珍香 | 141992199701078600 | 软件工程 | +----------+-----------+--------------------+--------------+ 1 row in set (0.00 sec) mysql\u0026gt;    ：代表任意一个字符。\n有的时候我们知道要查询的字符串中有多少个字符，而使用%时匹配的范围太大，我们就可以用来做通配符。就像是支付宝的万能福卡，一张万能福卡能且只能代表任意一张福卡(也就是它不能代表多张福卡)。\n比方说我们想查询姓\u0026lsquo;范\u0026rsquo;，并且姓名只有2个字符的记录，可以这么写：  1 2 3 4 5 6 7 8 9 10  mysql\u0026gt; SELECT number, name, id_number, major FROM student_info WHERE name LIKE \u0026#39;范_\u0026#39;; +----------+--------+--------------------+-----------------+ | number | name | id_number | major | +----------+--------+--------------------+-----------------+ | 20180103 | 范统 | 17156319980116959X | 软件工程 | | 20180105 | 范剑 | 181048199308156368 | 飞行器设计 | +----------+--------+--------------------+-----------------+ 2 rows in set (0.00 sec) mysql\u0026gt;   小贴士： LIKE或者NOT LIKE操作符只用于字符串匹配。另外，通配符不能代表NULL，如果需要匹配NULL的话，需要使用IS NULL或者IS NOT NULL。 转义通配符  '\\%\u0026lsquo;代表普通字符\u0026rsquo;%' '\\_\u0026lsquo;代表普通字符\u0026rsquo;_'  ","description":"从零蛋开始学习 MySQL","id":26,"section":"databases","tags":["mysql"],"title":"带搜索条件的查询","uri":"https://xing-you-ji.github.io/databases/mysql/6/"},{"content":"表达式 将数字和运算符连接起来的组合称之为表达式\n操作数 MySQL中操作数可以是下边这几种类型：\n 常数\n平时用到的数字、字符串、时间值什么的都可以被称为常数，它是一个确定的值，比如数字1，字符串\u0026rsquo;abc'，时间值2019-08-16 17:10:43啥的。 列名\n针对某个具体的表，它的列名可以被当作表达式的一部分，比如对于student_info表来说，number、name都可以作为操作数。 函数调用\nMySQL中有函数的概念，比方说获取当前时间的函数NOW，而在函数后边加个小括号就算是一个函数调用，比如NOW()。 标量子查询或者行子查询 其他表达式\n一个表达式也可以作为一个操作数与另一个操作数来形成一个更复杂的表达式\n小贴士： 当然，可以作为操作数的东西不止这么几种，大家在熟练使用MySQL后再到文档中查看更多的操作数类型吧。  操作符 1.算术操作符\n  在使用MySQL中的算术操作符时需要注意，DIV和/都表示除法操作符，但是DIV只会取商的整数部分，/会保留商的小数部分。比如表达式 2 DIV 3的结果是0，而2 / 3的结果是0.6667。\n2.比较操作符\n    由比较操作符连接而成的表达式也称为布尔表达式，表示真或`者假，也可以称为TRUE或者FALSE。比如1 \u0026gt; 3就代表FALSE，3 != 2就代表TRUE。\n3.逻辑操作符\n逻辑操作符是用来将多个布尔表达式连接起来，我们需要了解这几个逻辑操作符：\n  表达式的使用 只要把这些操作数和操作符相互组合起来就可以组成一个表达式。表达式主要以下边这两种方式使用：\n1.放在查询列表中\n我们前边都是将列名放在查询列表中的(*号代表所有的列名～)。列名只是表达式中超级简单的一种，我们可以将任意一个表达式作为查询列表的一部分来处理，比方说我们可以在查询student_score表时把score字段的数据都加100，就像这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  mysql\u0026gt; SELECT number, subject, score + 100 FROM student_score; +----------+-----------------------------+-------------+ | number | subject | score + 100 | +----------+-----------------------------+-------------+ | 20180101 | 母猪的产后护理 | 178 | | 20180101 | 论萨达姆的战争准备 | 188 | | 20180102 | 母猪的产后护理 | 200 | | 20180102 | 论萨达姆的战争准备 | 198 | | 20180103 | 母猪的产后护理 | 159 | | 20180103 | 论萨达姆的战争准备 | 161 | | 20180104 | 母猪的产后护理 | 155 | | 20180104 | 论萨达姆的战争准备 | 146 | +----------+-----------------------------+-------------+ 8 rows in set (0.00 sec) mysql\u0026gt;   其中的number、subject、score + 100都是表达式，结果集中的列的名称也将默认使用这些表达式的名称，所以如果你觉得原名称不好，我们可以使用别名：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  mysql\u0026gt; SELECT number, subject, score + 100 AS score FROM student_score; +----------+-----------------------------+-------+ | number | subject | score | +----------+-----------------------------+-------+ | 20180101 | 母猪的产后护理 | 178 | | 20180101 | 论萨达姆的战争准备 | 188 | | 20180102 | 母猪的产后护理 | 200 | | 20180102 | 论萨达姆的战争准备 | 198 | | 20180103 | 母猪的产后护理 | 159 | | 20180103 | 论萨达姆的战争准备 | 161 | | 20180104 | 母猪的产后护理 | 155 | | 20180104 | 论萨达姆的战争准备 | 146 | +----------+-----------------------------+-------+ 8 rows in set (0.00 sec) mysql\u0026gt;   这样score + 100列就可以按照别名score来展示了！\n需要注意的是，放在查询列表的表达式也可以不涉及列名，就像这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  mysql\u0026gt; SELECT 1 FROM student_info; +---+ | 1 | +---+ | 1 | | 1 | | 1 | | 1 | | 1 | | 1 | +---+ 6 rows in set (0.01 sec) mysql\u0026gt;   因为student_info中有6条记录，所以结果集中也就展示了6条结果，不过我们的查询列表处只有一个常数1，所以所有的结果的值也都是常数1。这种查询列表中不涉及列名的情况下，我们甚至可以省略掉FROM子句后边的表名，就像这样：\n1 2 3 4 5 6 7 8 9  mysql\u0026gt; SELECT 1; +---+ | 1 | +---+ | 1 | +---+ 1 row in set (0.00 sec) mysql\u0026gt;   可是这么写有什么现实用处么？好像有的，可以做个计算器[偷笑]～(比如select 52*10 from first;)\n2.作为搜索条件\n我们在介绍搜索条件的时候介绍的都是带有列名的表达式，搜索条件也可以不带列名，比如这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  mysql\u0026gt; SELECT number, name, id_number, major FROM student_info WHERE 2 \u0026gt; 1; +----------+-----------+--------------------+--------------------------+ | number | name | id_number | major | +----------+-----------+--------------------+--------------------------+ | 20180101 | 杜子腾 | 158177199901044792 | 计算机科学与工程 | | 20180102 | 杜琦燕 | 151008199801178529 | 计算机科学与工程 | | 20180103 | 范统 | 17156319980116959X | 软件工程 | | 20180104 | 史珍香 | 141992199701078600 | 软件工程 | | 20180105 | 范剑 | 181048199308156368 | 飞行器设计 | | 20180106 | 朱逸群 | 197995199501078445 | 电子信息 | +----------+-----------+--------------------+--------------------------+ 6 rows in set (0.00 sec) mysql\u0026gt;   由于我们的搜索条件是2 \u0026gt; 1，这个条件对于表中的每一条记录都成立，所以最后的查询结果就是全部的记录。不过这么写有点儿傻哈，没有一毛钱卵用，没一点实际意义～ 所以通常情况下搜索条件中都会包含列名的。\n函数 我们在使用MySQL过程中经常会有一些需求，比方说将给定文本中的小写字母转换成大写字母，把某个日期数据中的月份值提取出来等等。为了解决这些常遇到的问题，设计MySQL的大叔贴心的为我们提供了很多所谓的函数，比方说：\n  UPPER函数是用来把给定的文本中的小写字母转换成大写字母。\n  MONTH函数是用来把某个日期数据中的月份值提取出来。\n  NOW函数用来获取当前的日期和时间。\n  如果我们想使用这些函数，可以在函数名后加一个小括号()就好，表示调用一下这个函数，简称函数调用。比方说NOW()就代表调用NOW函数来获取当前日期和时间。针对某些包含参数的函数，我们也可以在小括号()里将参数填入，比方说UPPER('abc')表示将字符串'abc'转换为大写格式。\n下边来介绍一些常用的MySQL内置函数：\n文本处理函数   我们以SUBSTRING函数为例试一下：\n1 2 3 4 5 6 7 8 9  mysql\u0026gt; SELECT SUBSTRING(\u0026#39;abc123\u0026#39;, 2, 3); +---------------------------+ | SUBSTRING(\u0026#39;abc123\u0026#39;, 2, 3) | +---------------------------+ | bc1 | +---------------------------+ 1 row in set (0.00 sec) mysql\u0026gt;   函数调用也算是一种表达式的操作数，它可以和其他操作数用操作符连接起来组成一个表达式来作为查询列表的一部分或者放到搜索条件中。我们来以CONCAT函数为例来看一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  mysql\u0026gt; SELECT CONCAT(\u0026#39;学号为\u0026#39;, number, \u0026#39;的学生在《\u0026#39;, subject, \u0026#39;》课程的成绩是：\u0026#39;, score) AS 成绩描述 FROM student_score; +---------------------------------------------------------------------------------------+ | 成绩描述 | +---------------------------------------------------------------------------------------+ | 学号为20180101的学生在《母猪的产后护理》课程的成绩是：78 | | 学号为20180101的学生在《论萨达姆的战争准备》课程的成绩是：88 | | 学号为20180102的学生在《母猪的产后护理》课程的成绩是：100 | | 学号为20180102的学生在《论萨达姆的战争准备》课程的成绩是：98 | | 学号为20180103的学生在《母猪的产后护理》课程的成绩是：59 | | 学号为20180103的学生在《论萨达姆的战争准备》课程的成绩是：61 | | 学号为20180104的学生在《母猪的产后护理》课程的成绩是：55 | | 学号为20180104的学生在《论萨达姆的战争准备》课程的成绩是：46 | +---------------------------------------------------------------------------------------+ 8 rows in set (0.00 sec) mysql\u0026gt;   日期和时间处理函数   \n\n 在使用DATE_ADD和DATE_SUB这两个函数时需要注意，增加或减去的时间间隔单位可以自己定义，下边是MySQL支持的一些时间单位     时间单位 描述   MICROSECOND 毫秒   SECOND 秒   MINUTE 分钟   HOUR 小时   DAY 天   WEEK 星期   MONTH 月   QUARTER 季度   YEAR 年   例：让1949-10-1 00:00:00这个时间值增加100年，可以这么写：\n1 2 3 4 5 6 7 8 9 10  mysql\u0026gt; SELECT DATE_ADD(\u0026#39;1949-10-1 00:00:00\u0026#39;, INTERVAL 100 YEAR); +----------------------------------------------------+ | DATE_ADD(\u0026#39;1949-10-1 00:00:00\u0026#39;, INTERVAL 100 YEAR) | +----------------------------------------------------+ | 2049-10-1 00:00:00 | +----------------------------------------------------+ 1 row in set (0.00 sec) mysql\u0026gt;   *在使用DATE_FORMAT函数时需要注意，我们可以通过一些所谓的格式符来自定义日期和时间的显示格式，下边是MySQL中常用的一些日期和时间的格式符以及它们对应的含义：   格式符 描述   %b 简写的月份名称（Jan、Feb、...、Dec)   %D 带有英文后缀的月份中的日期（0th、1st、2nd、...、31st)）   %d 数字格式的月份中的日期(00、01、02、...、31)   %f 微秒（000000-999999）   %H 二十四小时制的小时 (00-23)   %h 十二小时制的小时 (01-12)   %i 数值格式的分钟(00-59)   %M 月份名（January、February、...、December）   %m 数值形式的月份(00-12)   %p 上午或下午（AM代表上午、PM代表下午）   %S 秒（00-59）   %s 秒（00-59）   %W 星期名（Sunday、Monday、...、Saturday）   %w 周内第几天 （0=星期日、1=星期一、 6=星期六）   %Y 4位数字形式的年（例如2021）   %y 2位数字形式的年（例如21）   例子如下：\n1 2 3 4 5 6 7 8 9  mysql\u0026gt; select date_format(now(),\u0026#34;%Y-%m-%d %H:%i:%s\u0026#34;); +----------------------------------------+ | date_format(now(),\u0026#34;%Y-%m-%d %H:%i:%s\u0026#34;) | +----------------------------------------+ | 2020-10-22 13:01:20 | +----------------------------------------+ 1 row in set (0.00 sec) mysql\u0026gt;   数值处理函数   聚集函数 如果将上边介绍的那些函数以函数调用的形式放在查询列表中，那么会为表中符合WHERE条件的每一条记录调用一次该函数。比方说这样：\nmysql\u0026gt; SELECT number, SUBSTRING(name,2) FROM student_info WHERE number \u0026lt; 20180106;\n+\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\n| number | SUBSTRING(name,2) |\n+\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\n| 20180101 | 子腾 |\n| 20180102 | 琦燕 |\n| 20180103 | 统 |\n| 20180104 | 珍香 |\n| 20180105 | 剑 |\n+\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\n5 rows in set (0.00 sec)\nmysql\u0026gt;\nstudent_info表中符合number \u0026lt; 20180106搜索条件的每一条记录的name字段会依次被当作SUBSTRING函数的参数，结果就是把这些人的名字的首个字符给提取出来了。但是有些函数是用来统计数据的，比方说统计一下表中的行数，某一列数据的最大值是什么，我们把这种函数称之为聚集函数，下边介绍MySQL中常用的几种聚集函数\n  函数名 描述   COUNT 返回某列的行数   MAX 返回某列的最大值   MIN 数字格式的月份中的日期(00、01、02、...、31)   SUM 返回某列值之和   AVG 返回某列的平均值   小贴士： 聚集函数这个名儿不太直观，把它理解为统计函数可能更符合中国人的理解习惯。 COUNT函数 COUNT函数使用来统计行数的，它有下边两种使用方式：\n 1.COUNT(*)：对表中行的数目进行计数，不管列的值是不是NULL。 2.COUNT(列名)：对特定的列进行计数，会忽略掉该列为NULL的行。  1 2 3 4 5 6 7 8 9  mysql\u0026gt; SELECT COUNT(*) FROM student_info; +----------+ | COUNT(*) | +----------+ | 6 | +----------+ 1 row in set (0.00 sec) mysql\u0026gt;   ###　MAX函数\nMAX函数是用来查询某列中数据的最大值，以student_score表中的score列为例来看一下：\n1 2 3 4 5 6 7 8 9  mysql\u0026gt; SELECT MAX(score) FROM student_score; +------------+ | MAX(score) | +------------+ | 100 | +------------+ 1 row in set (0.00 sec) mysql\u0026gt;   MIN函数 MIN函数是用来查询某列中数据的最小值，以student_score表中的score列为例来看一下：\n1 2 3 4 5 6 7 8 9  mysql\u0026gt; SELECT MIN(score) FROM student_score; +------------+ | MIN(score) | +------------+ | 46 | +------------+ 1 row in set (0.00 sec) mysql\u0026gt;   SUM函数 SUM函数是用来计算某列数据的和，还是以student_score表中的score列为例来看一下：\n1 2 3 4 5 6 7 8 9  mysql\u0026gt; SELECT SUM(score) FROM student_score; +------------+ | SUM(score) | +------------+ | 585 | +------------+ 1 row in set (0.01 sec) mysql\u0026gt;   AVG函数 AVG函数是用来计算某列数据的平均数，还是以student_score表中的score列为例来看一下:\n1 2 3 4 5 6 7 8 9  mysql\u0026gt; SELECT AVG(score) FROM student_score; +------------+ | AVG(score) | +------------+ | 73.1250 | +------------+ 1 row in set (0.00 sec) mysql\u0026gt;   给定搜索条件下聚集函数的使用 1 2 3 4 5 6 7 8 9  mysql\u0026gt; SELECT AVG(score) FROM student_score WHERE subject = \u0026#39;母猪的产后护理\u0026#39;; +------------+ | AVG(score) | +------------+ | 73.0000 | +------------+ 1 row in set (0.00 sec) mysql\u0026gt;   聚集函数中DISTINCT的使用 默认情况下，聚集函数将计算指定列的所有非NULL数据，如果我们指定的列中有重复数据的话，可以选择使用DISTINCT来过滤掉这些重复数据。比方说我们想查看一下student_info表中存储了多少个专业的学生信息，就可以这么写：\n1 2 3 4 5 6 7 8 9  mysql\u0026gt; SELECT COUNT(DISTINCT major) FROM student_info; +-----------------------+ | COUNT(DISTINCT major) | +-----------------------+ | 4 | +-----------------------+ 1 row in set (0.01 sec) mysql\u0026gt;   组合聚集函数 聚集函数也可以集中在一个查询中使用，比如这样：\n1 2 3 4 5 6 7 8 9  mysql\u0026gt; SELECT COUNT(*) AS 成绩记录总数, MAX(score) AS 最高成绩, MIN(score) AS 最低成绩, AVG(score) AS 平均成绩 FROM student_score; +--------------------+--------------+--------------+--------------+ | 成绩记录总数 | 最高成绩 | 最低成绩 | 平均成绩 | +--------------------+--------------+--------------+--------------+ | 8 | 100 | 46 | 73.1250 | +--------------------+--------------+--------------+--------------+ 1 row in set (0.00 sec) mysql\u0026gt;   隐式类型转换  1.把操作数类型转换为适合操作符计算的相应类型。  1 2 3 4 5 6 7 8 9  mysql\u0026gt; SELECT 1 + 2, \u0026#39;1\u0026#39; + 2, \u0026#39;1\u0026#39; + \u0026#39;2\u0026#39;; +-------+---------+-----------+ | 1 + 2 | \u0026#39;1\u0026#39; + 2 | \u0026#39;1\u0026#39; + \u0026#39;2\u0026#39; | +-------+---------+-----------+ | 3 | 3 | 3 | +-------+---------+-----------+ 1 row in set (0.00 sec) mysql\u0026gt;    2.将函数参数转换为该函数期望的类型。  1 2 3 4 5 6 7 8 9  mysql\u0026gt; SELECT CONCAT(\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;), CONCAT(\u0026#39;1\u0026#39;, 2), CONCAT(1, 2); +------------------+----------------+--------------+ | CONCAT(\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;) | CONCAT(\u0026#39;1\u0026#39;, 2) | CONCAT(1, 2) | +------------------+----------------+--------------+ | 12 | 12 | 12 | +------------------+----------------+--------------+ 1 row in set (0.00 sec) mysql\u0026gt;    3.存储数据时，把某个值转换为某个列需要的类型。  1 2 3 4 5 6 7 8 9 10  CREATE TABLE t ( i1 TINYINT, i2 TINYINT, s VARCHAR(100) ); mysql\u0026gt; INSERT INTO t(i1, i2, s) VALUES(\u0026#39;100\u0026#39;, \u0026#39;100\u0026#39;, 200); Query OK, 1 row affected (0.01 sec) mysql\u0026gt;   类型转换的注意事项   1.MySQL会尽量把值转换为表达式中需要的类型，而不是产生错误。\n  2.在运算时会自动提升操作数的类型。\n  小贴士： 有隐式类型转换，自然也有显式类型转换。在MySQL中，可以使用CAST函数完成显式地类型转换 ","description":"从零蛋开始学习 MySQL","id":27,"section":"databases","tags":["mysql"],"title":"表达式和函数","uri":"https://xing-you-ji.github.io/databases/mysql/7/"},{"content":"1.创建仓库命令 1.创建版本库(初始化仓库) \u0026mdash;\u0026mdash; git init\n2.拷贝一份远程仓库，也就是下载一个项目 \u0026mdash;\u0026mdash; git clone\n2.提交与修改 1.添加文件到暂存区 \u0026mdash;\u0026mdash; git add\n2.查看仓库当前的状态，显示有变更的文件 \u0026mdash;\u0026mdash; git status\n3.比较文件的不同，即暂存区和工作区的区别 \u0026mdash;\u0026mdash; git diff\n4.提交暂存区到本地仓库 \u0026mdash;\u0026mdash; git commit\n7.回退版本 \u0026mdash;\u0026mdash; git reset\n8.删除工作区的文件 \u0026mdash;\u0026mdash; git rm\n9.移动或者重命名工作区的文件 \u0026mdash;\u0026mdash; git mv\n2.1提交日志 1.查看历史提交记录 \u0026mdash;\u0026mdash; git log\n2.以列表形式查看指定文件的历史修改记录 \u0026mdash;\u0026mdash; git blame \n2.2远程操作 1.远程仓库操作 \u0026mdash;\u0026mdash; git remote\n2.从远程获取代码库 \u0026mdash;\u0026mdash; git fetch\n3.下载远程代码并合并 \u0026mdash;\u0026mdash; git pull\n4.上传远程代码并合并 \u0026mdash;\u0026mdash; git push\n3.git 分支管理 1.列出分支 \u0026mdash;\u0026mdash; git branch(无参数时)\n2.创建新分支 \u0026mdash;\u0026mdash; git branch branchname(branchname为想要创建的分支名)\n3.切换到分支 \u0026mdash;\u0026mdash; git checkout branchname(branchname为想要切换到的分支名)\n4.创建新分支并切换到该分支下 \u0026mdash;\u0026mdash; git checkout -b branchname(branchname为想要创建的分支名)\n5.删除分支 \u0026mdash;\u0026mdash; git branch -d branchname(branchname为想要删除的分支名)\n6.合并分支 \u0026mdash;\u0026mdash; git merge /git rebase\nrebase优缺点 优点： Rebase 使你的提交树变得很干净, 所有的提交都在一条线上 缺点： Rebase 修改了提交树的历史 merge优缺点 优点: merge可以保留提交历史 缺点： merge使你的提交树变得复杂，提交由多条线相连 7.解决冲突 \u0026mdash;\u0026mdash; 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。\n4.git 查看提交历史 1.查看历史提交记录 \u0026mdash;\u0026mdash; git log\n2.以列表形式查看指定文件的历史修改记录 \u0026mdash;\u0026mdash; git blame \n5.git 标签 1.查看所有标签 \u0026mdash;\u0026mdash; git tag\n2.为当前分支创建标签 \u0026mdash;\u0026mdash; git tag -a v1.0(不带\u0026quot;-a\u0026quot;也行,但建议带上)\n3.创建带有说明的标签 \u0026mdash;\u0026mdash; git tag -a v0.1 -m \u0026ldquo;runoob.com标签\u0026rdquo;（用-a指定标签名，-m指定说明文字：）\n4.查看标签说明文字 \u0026mdash;\u0026mdash; git show v0.1\n(注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。) 6.Git 修改本地和查看本地属性 1.git config \u0026ndash;local \u0026ndash;list(查看本地设置) 2.git config \u0026ndash;global user.name/email(修改本地属性,加不加\u0026ndash;global区别在于是否是修改全局变量) 7.git 远程仓库(Github) 1添加远程库 \u0026mdash;\u0026mdash; git remote add origin [url](origin 为给远程库取的一个别名) 由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息： 使用以下命令生成 SSH Key：ssh-keygen -t rsa -C \u0026ldquo;youremail@example.com\u0026rdquo; 后面的 your_email@youremail.com 改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在 ~/ 下生成 .ssh 文件夹，进去，打开 id_rsa.pub，复制里面的 key。回到 github 上，进入 Account =\u0026gt; Settings（账户配置）。左边选择 SSH and GPG keys，然后点击 New SSH key 按钮,title 设置标题，可以随便填，粘贴在你电脑上生成的 key 2查看当前的远程库 \u0026mdash;\u0026mdash; git remote -v 3拉取远程仓库 1.从远程仓库下载新分支与数据 \u0026mdash;\u0026mdash; git fetch\n2从远端仓库提取数据并尝试合并到当前分支 \u0026mdash;\u0026mdash; git merge\n4推送到远程仓库 \u0026mdash;\u0026mdash; git push origin branch(branch为远程仓库的分支名) 5删除远程仓库 \u0026mdash;\u0026mdash; git remote rm origin 8.git 服务器搭建 1.安装 git \u0026mdash;\u0026mdash;sudo apt-get install git(ubuntu下的下载,windows可上网查询) 接下来我们 创建一个用户用来运行git服务的用户 $ sudo adduser zhugeqing 2.创建证书登录 虽然是私有的Git服务器，但是也不能允许主机随意向Git服务器推送代码。因此，必须将需要使用Git服务器，即需要登录到Git服务器的主机的公钥（即id_rsa.pub文件）导入Git服务器的/home/git/.ssh/authorized_keys文件里，一行一个 ###3.初始化Git仓库\n如果我们使用/tmp/xingyouji.git做为远程仓库，则需要在/tmp目录下执行： sudo git init \u0026ndash;bare xingyouji.git 4.克隆仓库 git clone git@192.168.45.4:/home/gitrepo/xingyouji.git 192.168.45.4 为 Git 所在服务器 ip ，你需要将其修改为你自己的 Git 服务 ip，这样我们的 Git 服务器安装就完成。 9.Git Gitee（码云) 大家都知道国内访问 Github 速度比较慢，很影响我们的使用。如果你希望体验到 Git 飞一般的速度，可以使用国内的 Git 托管服务——Gitee（gitee.com）， Gitee 提供免费的 Git 仓库，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee 还提供了项目管理、代码托管、文档管理的服务，5 人以下小团队免费 。 1.我们先在 Gitee 上注册账号并登录后，然后上传自己的 SSH 公钥\n2.其他操作根据需求操作，与上述操作无大区别\n  ","description":"关于git 的使用","id":28,"section":"about","tags":null,"title":"git笔记","uri":"https://xing-you-ji.github.io/about/git/"},{"content":"题目入口\n难度：简单\n找出数组中重复的数字。\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n示例 1：\n输入：\n[2, 3, 1, 0, 2, 5, 3]\n输出：2 或 3\n解题思路：使用哈希表来记录每一个数组出现的次数，如果有一个索引的值超过1，就是重复元素元素，则返回该索引\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  //时间复杂度o(n)，空间复杂度o(n) int findRepeatNumber(int* nums, int numsSize){ int hash[numsSize];//定义哈希表  memset(hash,0,sizeof(hash));//初始化为零  for(int i=0;i\u0026lt;numsSize;i++) { if(++(hash[nums[i]]) == 2){ return nums[i]; } } return nums[numsSize-1]; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  //时间复杂度o(n),空间复杂度o(n) func findRepeatNumber(nums []int) int { if len(nums) \u0026lt;=1 { return 0 } hash := make([]int,len(nums))//定义哈希表  for i:=0;i\u0026lt;len(nums);i++{ hash[nums[i]]++ if hash[nums[i]] \u0026gt;= 2{ return nums[i] } } return 0 }    \r  'use strict'; var containerId = JSON.parse(\"\\\"461c122e7357e92c\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":29,"section":"interview","tags":["算法"],"title":"剑指 Offer 03. 数组中重复的数字","uri":"https://xing-you-ji.github.io/interview/algorithm/offer/03/"},{"content":"题目入口\n难度：中等\n在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n示例:\n现有矩阵 matrix 如下：\n[\n[1, 4, 7, 11, 15],\n[2, 5, 8, 12, 19],\n[3, 6, 9, 16, 22],\n[10, 13, 14, 17, 24],\n[18, 21, 23, 26, 30]\n]\n给定 target = 5，返回 true。\n给定 target = 20，返回 false。\n限制：\n0 \u0026lt;= n \u0026lt;= 1000\n0 \u0026lt;= m \u0026lt;= 1000\n解题思路：从左下角开始找，利用递增关系，大于往右边找，小于往上找，超出返回false。\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  bool findNumberIn2DArray(int** matrix, int matrixSize, int* matrixColSize, int target){ //时间复杂度o(m+n)，空间复杂度o(1)  int x = matrixSize-1;//行标  int y = 0;//列标  while(x\u0026gt;=0 \u0026amp;\u0026amp; y\u0026lt;*(matrixColSize+x)){ if(target == matrix[x][y]){ return true ; } if (target \u0026gt; matrix[x][y]){ y++; }else if(target \u0026lt; matrix[x][y]){ x--; } } return false; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  func findNumberIn2DArray(matrix [][]int, target int) bool { //时间复杂度o(m+n)，空间复杂度o(1)  xindex := len(matrix) - 1 yindex := 0 for xindex \u0026gt;= 0 \u0026amp;\u0026amp; yindex \u0026lt;= len(matrix[0])-1 { if target == matrix[xindex][yindex] { return true } if target \u0026gt; matrix[xindex][yindex] { yindex++ }else if target \u0026lt; matrix[xindex][yindex] { xindex-- } } return false }    \r  'use strict'; var containerId = JSON.parse(\"\\\"310c70690e2451d0\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":30,"section":"interview","tags":["算法"],"title":"剑指 Offer 04. 二维数组中的查找","uri":"https://xing-you-ji.github.io/interview/algorithm/offer/04/"},{"content":"题目入口\n难度：简单\n请实现一个函数，把字符串 s 中的每个空格替换成\u0026quot;%20\u0026quot;。\n示例 1：\n输入：s = \u0026ldquo;We are happy.\u0026rdquo; 输出：\u0026ldquo;We%20are%20happy.\u0026rdquo;\n限制：\n0 \u0026lt;= s 的长度 \u0026lt;= 10000\n解题思路：构建一个长度为3*len(s)的返回数组res，遍历字符串s，遇到等于' \u0026lsquo;的字符就进行替换，并赋给res。\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  char* replaceSpace(char* s){ int n = 0; for(int i = 0; s[i] != \u0026#39;\\0\u0026#39;; ++i) { ++n; } // printf(\u0026#34;%d\u0026#34;, n);  char* res; res = (char*)malloc(3 * (n + 3) * sizeof(char)); int k = 0; for(int i = 0; i \u0026lt; n; ++i) { if(s[i] != \u0026#39; \u0026#39;){ res[k++] = s[i]; }else { res[k++] = \u0026#39;%\u0026#39;; res[k++] = \u0026#39;2\u0026#39;; res[k++] = \u0026#39;0\u0026#39;; } } res[k] = \u0026#39;\\0\u0026#39;;//c语言字符串需要在末尾加上\u0026#39;\\0\u0026#39;  return res; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  func replaceSpace(s string) string { //时间复杂度o(n)，空间复杂度o(3*n)  res := make([]rune, 3*len(s)) //乘以三的目的是为了假设s字符串都是空格,就使用3个字符%20替换  i := 0 for _, v := range s { if v == \u0026#39; \u0026#39; { res[i] = \u0026#39;%\u0026#39; res[i+1] = \u0026#39;2\u0026#39; res[i+2] = \u0026#39;0\u0026#39; i += 3 //下标移到后三位  } else { res[i] = v i++ } } return string(res[:i]) }    \r  'use strict'; var containerId = JSON.parse(\"\\\"b4ba0e16f761d543\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":31,"section":"interview","tags":["算法"],"title":"剑指 Offer 05. 替换空格","uri":"https://xing-you-ji.github.io/interview/algorithm/offer/05/"},{"content":"题目入口\n难度：简单\n输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。\n示例 1：\n输入：head = [1,3,2]\n输出：[2,3,1]\n限制：\n0 \u0026lt;= 链表长度 \u0026lt;= 10000\n解题思路：1.构建数组，存储到数组中，然后倒置数组2.递归法\n第一种方法：\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  int* reversePrint(struct ListNode* head, int* returnSize){ //时间复杂度o(n)，空间复杂度o(n)  //先确定数组长度，再倒序存储  struct ListNode *p; int *res; p=head; int j=0; while(p!=NULL) { p=p-\u0026gt;next; j++; } res=(int *)malloc(sizeof(int)*j); p=head; *returnSize=j; j=j-1; while(j\u0026gt;=0) { res[j]=p-\u0026gt;val; p=p-\u0026gt;next; j--; } return res; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  func reversePrint(head *ListNode) []int { //时间复杂度o(n)，空间复杂度o(n)  //先用数组存起来，然后逆转数组  if head == nil { return make([]int, 0) } res := make([]int, 0) for head != nil { res = append(res, head.Val) head = head.Next } //倒置数组  len_s := len(res) for i := 0; i \u0026lt; len_s/2; i++ { res[i], res[len_s-i-1] = res[len_s-i-1], res[i] } return res }    \r  'use strict'; var containerId = JSON.parse(\"\\\"6edea2b534f8ef16\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \n第二种方法\nc golang  1 2 3 4 5 6 7 8 9 10  int* reversePrint(struct ListNode* head, int* returnSize){ //递归，直到最后一个节点的下一个节点为空时，存储值并返回上一个栈  if(head == NULL){ *returnSize = 0; return malloc(sizeof(int) * 10000); } int *ans = reversePrint(head-\u0026gt;next, returnSize); ans[(*returnSize)++] = head-\u0026gt;val; return ans; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14  func reversePrint(head *ListNode) []int { var dfs func(head *ListNode) res := make([]int, 0) dfs = func(head *ListNode) { if head == nil { return } dfs(head.Next) res = append(res, head.Val) } dfs(head) return res }    \r  'use strict'; var containerId = JSON.parse(\"\\\"caea30a3ed2070ac\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \n","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":32,"section":"interview","tags":["算法"],"title":"剑指 Offer 06. 从尾到头打印链表","uri":"https://xing-you-ji.github.io/interview/algorithm/offer/06/"},{"content":"题目入口\n难度：中等\n输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n例如，给出\n前序遍历 preorder = [3,9,20,15,7]\n中序遍历 inorder = [9,3,15,20,7]\n返回如下的二叉树：\n  限制：\n0 \u0026lt;= 节点个数 \u0026lt;= 5000\n解题思路：递归：\n对于任意一颗树而言，前序遍历的形式总是[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]\n即根节点总是前序遍历中的第一个节点。\n而中序遍历的形式总是[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]\n只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。\n这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。\n\rc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  //1.先看前序遍历数组第一个位置得到根节点，再到中序遍历数组得到根节点在中序遍历中的位置 //2.求出左右子树节点数，而左子树节点数对应了[0,left),右子树节点对应[left,left+right) //不断缩小前序 中序遍历数组区间; struct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize){ //递归终止条件  if(preorderSize == 0 || inorderSize == 0) return NULL; //根节点：  struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode)); root-\u0026gt;val = preorder[0]; //在中序遍历数组中寻找index  int left; for(left=0;left\u0026lt;inorderSize;left++) { if(inorder[left]==root-\u0026gt;val)//从中序遍历里面找到与前序遍历子节点值相同的节点  break; } int right = inorderSize-left-1;//右边区间长度  //前序数组左子树首地址为preorder+1，意为在根节点的基础上加一，left为前序数组当前根节点的左子树数组的首地址  //中序数组左子树首地址依然不变，可重看解题思路，下同  root-\u0026gt;left = buildTree(preorder+1,left,inorder,left); root-\u0026gt;right = buildTree(preorder+left+1,right,inorder+left+1,right); return root; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder) == 0 { return nil } root := \u0026amp;TreeNode{preorder[0], nil, nil} i := 0 for ; i \u0026lt; len(inorder); i++ { if inorder[i] == preorder[0] { break } } root.Left = buildTree(preorder[1:i+1], inorder[:i]) root.Right = buildTree(preorder[i+1:], inorder[i+1:]) return root }    \r  'use strict'; var containerId = JSON.parse(\"\\\"fb11dbd9df4800df\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":33,"section":"interview","tags":["算法"],"title":"剑指 Offer 07. 重建二叉树","uri":"https://xing-you-ji.github.io/interview/algorithm/offer/07/"},{"content":"题目入口\n难度：中等\n用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )\n示例 1：\n输入：\n[\u0026ldquo;CQueue\u0026rdquo;,\u0026ldquo;appendTail\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;]\n[[],[3],[],[]]\n输出：[null,null,3,-1]\n示例 2：\n输入：\n[\u0026ldquo;CQueue\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;,\u0026ldquo;appendTail\u0026rdquo;,\u0026ldquo;appendTail\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;]\n[[],[],[5],[2],[],[]]\n输出：[null,-1,null,null,5,2]\n提示：\n 1 \u0026lt;= values \u0026lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用  解题思路：栈的性质：先进后出，只能在栈顶进行操作。\n队列的性质：先进先出，之只能在队头进行删除（出队）操作，在队尾进行插入（入队）操作。\n本题是用两个栈来构建一个队列，使得一个队列具有队列尾部插入整数（队尾入队）和在队列头部删除整数（队头出队），考虑到栈的性质，所以构建两个栈，一个入队栈，一个出队栈，入队栈负责队尾入队操作，出队栈负责对头出队操作。\n1.初始化，实例化一个队列，并将两个栈顶赋值为-1。\n2.队尾入队，直接将入队栈栈顶（top_in）加1，并插入数值。\n3.队头出队：首先判断是否两个栈均为空，若为空，则返回-1，然后有两种情况，入队栈为空 or 出队栈为空，若只是入队栈为空，则无需理会，直接删除出队栈的一个栈顶元素，top_out减一;若是出队栈为空，则需要将入队栈的元素移至出队栈，然后再进行出队栈出队，top_out减一。\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  typedef struct { int out_stack[500];//出队栈（进行出队操作-队列头部） int top_out;//出队栈栈顶 int in_stack[500];//入队栈（进行入队操作-队列尾部） int top_in;//入队栈栈顶 } CQueue; CQueue* cQueueCreate() { CQueue* res = (CQueue*)malloc(sizeof(CQueue));//队列实例化  res-\u0026gt;top_out = -1;//初始化出队栈栈顶  res-\u0026gt;top_in = -1;//初始化入队栈栈顶  return res; } void cQueueAppendTail(CQueue* obj, int value) { obj-\u0026gt;top_in++;//入队栈栈顶加1  obj-\u0026gt;in_stack[obj-\u0026gt;top_in] = value;//入队 } int cQueueDeleteHead(CQueue* obj) { if(obj-\u0026gt;top_out == -1 \u0026amp;\u0026amp; obj-\u0026gt;top_in == -1){//如果两个栈都为空，返回-1  return -1; }else if(obj-\u0026gt;top_out == -1){//出队栈为空，把入队栈的数移到出队栈  while(obj-\u0026gt;top_in \u0026gt;=0){ obj-\u0026gt;out_stack[++obj-\u0026gt;top_out] = obj-\u0026gt;in_stack[obj-\u0026gt;top_in--]; } return obj-\u0026gt;out_stack[obj-\u0026gt;top_out--];//出队  }else{//入队栈为空，直接对出队栈进行出队操作  return obj-\u0026gt;out_stack[obj-\u0026gt;top_out--];//出队  } } void cQueueFree(CQueue* obj) { free(obj); } /** * Your CQueue struct will be instantiated and called as such: * CQueue* obj = cQueueCreate(); * cQueueAppendTail(obj, value); * int param_2 = cQueueDeleteHead(obj); * cQueueFree(obj); */    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  //剑指 Offer 09. 用两个栈实现队列 type CQueue struct { IntStack []int //入队栈  OutStack []int //出队栈  } func Constructor() CQueue { return CQueue{} //队列初始化 } func (this *CQueue) AppendTail(value int) { this.IntStack = append(this.IntStack, value) //对入队栈进行入队操作 } func (this *CQueue) DeleteHead() int { if len(this.OutStack) == 0 { //判断出队栈是否有数据，如果没有就把入队栈的数据移到出队上来  if len(this.IntStack) == 0 { return -1 //如果入队栈也没有数，那就返回-1  } //如果有,那就把入队栈的数据全部转移到出队栈（而且是转移所有数据）  for len(this.IntStack) \u0026gt; 0 { value := this.IntStack[len(this.IntStack)-1] //找到出队栈的栈顶  this.IntStack = this.IntStack[:len(this.IntStack)-1] //移除一个栈顶元素  this.OutStack = append(this.OutStack, value) //将元素添加到出队栈里面  } } //如果出队栈当中有数据则出栈  res := this.OutStack[len(this.OutStack)-1] //选中出队栈最后一个元素  this.OutStack = this.OutStack[:len(this.OutStack)-1] //出队栈移除一个栈顶元素  return res }    \r  'use strict'; var containerId = JSON.parse(\"\\\"6df9c9c6d7ed2fbf\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":34,"section":"interview","tags":["算法"],"title":"剑指 Offer 09. 用两个栈实现队列","uri":"https://xing-you-ji.github.io/interview/algorithm/offer/09/"},{"content":"题目入口\n难度：简单\n写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：\nF(0) = 0, F(1) = 1\nF(N) = F(N - 1) + F(N - 2), 其中 N \u0026gt; 1.\n斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n示例 1：\n输入：n = 2\n输出：1\n示例 2：\n输入：n = 5\n输出：5\n提示：\n 0 \u0026lt;= n \u0026lt;= 100  解题思路：1.递归，地球人都知道，就不解答了。2.动态规划（递推，这里可以讲成是迭代，递推：一个主观意志选择的第k个计算值，或者每一个计算值。迭代：不是第k个，也不是第k+1个，而是最终收敛的那一个，），已知斐波拉契数由之前两数相加得出，即f(n) = f(n-1) + f(n-2)，最优子结构：dp[i]表示第斐波拉契数列第i个数的值，动态转移方程：dp[n] = dp[n-1]+dp[n-2]，边界：dp[0]=0,dp[1]=1\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  int fib(int n){ //动态规划  if (n==0 || n==1){ return n; } int dp1 = 0;//为了节省空间，可以理解为dp[n-2]  int dp2 = 1;//dp[n-1]  int res = 0;//dp[n]  for(int i=2;i\u0026lt;=n;i++){ res = (dp1 + dp2) % (1000000007);//dp[n] = dp[n-1]+dp[n-2]  dp1 = dp2;//记录数列下一个数的值  dp2 = res;//同上  } return res; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func fib(n int) int { //动态规划  if n == 0 || n == 1 { return n } dp1 := 0//为了节省空间，可以理解为dp[n-2]  dp2 := 1//dp[n-1]  res := 0//dp[n]  for i := 2; i \u0026lt;= n; i++ { res = (dp1 + dp2) % (1000000007)//dp[n] = dp[n-1]+dp[n-2]  dp1 = dp2 //记录数列下一个数的值  dp2 = res //同上  } return res }    \r  'use strict'; var containerId = JSON.parse(\"\\\"b24cbf0fe42fff03\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":35,"section":"interview","tags":["算法"],"title":"剑指 Offer 10- I. 斐波那契数列","uri":"https://xing-you-ji.github.io/interview/algorithm/offer/10-1/"},{"content":"题目入口\n难度：简单\n一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n示例 1：\n输入：n = 2\n输出：2\n示例 2：\n输入：n = 7\n输出：21\n示例 3：\n输入：n = 0\n输出：1\n提示：\n 0 \u0026lt;= n \u0026lt;= 100  解题思路：不了解动态规划的第一想法肯定是穷举，比如到第一级台阶有一种方法（跳一阶），到第二级台阶有两种（跳一阶，或者跳两阶），第三级有三种（(1,1,1),(1,2),(2,1)），第四级有\u0026hellip;，虽然计算机最擅长的就是穷举，但是我们人脑不行（至少，数大了，我不行），所以动态规划请先学习图解 | 你管这破玩意叫动态规划，\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  int numWays(int n){ if(n==0 || n==1){ return 1; } if(n==2){ return 2; } //类似于斐波拉契的动态规划  int dp1 = 1;//dp[n-2]  int dp2 = 2;//dp[n-1]  int res = 2; for(int i=3;i\u0026lt;=n;i++){ res = (dp1 + dp2) % (1000000007);//状态转移方程  dp1 = dp2; dp2 = res; } return res; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  func numWays(n int) int { //动态规划  //1.最优子结构  //f(n)表示n级台阶共有f(n)种跳法  //f(n) = f(n-1) + f(n-2) + 2  //2.边界  //f(1) = 1,f(2) = 2  if n == 1 || n == 2 { return n } dp1 := 1 dp2 := 2 res := 1 for i := 3; i \u0026lt;= n; i++ { res = (dp1 + dp2) % (1e9 + 7) dp1 = dp2 dp2 = res } return res }    \r  'use strict'; var containerId = JSON.parse(\"\\\"4b51c7cb376a0437\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":36,"section":"interview","tags":["算法"],"title":"剑指 Offer 10- II. 青蛙跳台阶问题","uri":"https://xing-you-ji.github.io/interview/algorithm/offer/10-2/"},{"content":"题目入口\n难度：简单\n把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例 1：\n输入：[3,4,5,1,2]\n输出：1\n示例 2：\n输入：[2,2,2,0,1]\n输出：0\n解题思路：二分法，参考力扣官方题解\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  int minArray(int* numbers, int numbersSize){ int low = 0; int high = numbersSize-1; int center = (low+high)/2; if(numbers[low]\u0026lt;numbers[high]){//只要low下标的数小于high下标的数即可返回  return numbers[low]; } while(low \u0026lt; high){ if(numbers[low]\u0026lt;numbers[high]){ return numbers[low]; } center = (low+high)/2; if(numbers[low] == numbers[high]){ low++; continue; } if(numbers[center] \u0026lt;= numbers[high]){//若相等，也是向左缩小区间  high = center; low ++; }else{//向右缩小区间  low = center+1; } } return numbers[low]; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  func minArray(numbers []int) int { //二分法  //旋转之后有三种情况：  //1.最小值在数组中间，  //2.最小值在数组中心的左边，  //3.最小值在数组中心的右边  low,high := 0,len(numbers)-1 if numbers[low] \u0026lt; numbers[high]{ return numbers[low]//旋转之后若第一个数仍然小于最后一个数，则是旋转之后仍然与原数组相同  } for low \u0026lt; high{ if numbers[low] \u0026lt; numbers[high]{ return numbers[low] } if numbers[low] == numbers[high]{ low++ //跳过  continue } private := (low+high)/2 if numbers[private] \u0026gt; numbers[high]{ //说明最小数在中心的右边  low = private+1//加1因为privat已经不可能是最小的了  }else { //说明最小数在中心的左边  high = private } } return numbers[low] }    \r  'use strict'; var containerId = JSON.parse(\"\\\"601ea4a5c76cf542\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":37,"section":"interview","tags":["算法"],"title":"剑指 Offer 11. 旋转数组的最小数字","uri":"https://xing-you-ji.github.io/interview/algorithm/offer/11/"},{"content":"题目入口\n难度：中等\n给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n例如，在下面的 3×4 的矩阵中包含单词 \u0026ldquo;ABCCED\u0026rdquo;（单词中的字母已标出）。\n  示例 1：\n输入：board = [[\u0026ldquo;A\u0026rdquo;,\u0026ldquo;B\u0026rdquo;,\u0026ldquo;C\u0026rdquo;,\u0026ldquo;E\u0026rdquo;],[\u0026ldquo;S\u0026rdquo;,\u0026ldquo;F\u0026rdquo;,\u0026ldquo;C\u0026rdquo;,\u0026ldquo;S\u0026rdquo;],[\u0026ldquo;A\u0026rdquo;,\u0026ldquo;D\u0026rdquo;,\u0026ldquo;E\u0026rdquo;,\u0026ldquo;E\u0026rdquo;]], word = \u0026ldquo;ABCCED\u0026rdquo;\n输出：true\n示例 2：\n输入：board = [[\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;],[\u0026ldquo;c\u0026rdquo;,\u0026ldquo;d\u0026rdquo;]], word = \u0026ldquo;abcd\u0026rdquo;\n输出：false\n 提示：\n 1 \u0026lt;= board.length \u0026lt;= 200 1 \u0026lt;= board[i].length \u0026lt;= 200 board 和 word 仅由大小写英文字母组成  \n解题思路：dfs（深度优先搜索），首先逐个遍历矩阵，找到起点（不过所有数都得进入search函数），然后进入search函数，递归true终止条件：当递归遍历word的下标k等于word长度时，则终止递归，递归false终止条件：超出矩阵边界；搜索过程\n\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  bool dfs(char** board, int boardSize,int* boardColSize,char* word,int i,int j,int k) { if(k == strlen(word)){ return true; } //递归终止条件  if(i\u0026lt;0 || j\u0026lt;0 || i== boardSize || j == *boardColSize) { return false;//超出边界，直接返回false  } if(word[k] == board[i][j]){ //匹配成功，往下递归  int temp = board[i][j]; board[i][j] = \u0026#39; \u0026#39;;//记录当前字符，防止向下递归重复遍历  if (dfs(board,boardSize,boardColSize,word,i-1,j,k+1)|| //向上递归 dfs(board,boardSize,boardColSize,word,i+1,j,k+1) || //向下递归 dfs(board,boardSize,boardColSize,word,i,j-1,k+1) || //向左递归 dfs(board,boardSize,boardColSize,word,i,j+1,k+1)) //向右递归  { return true; }else{ board[i][j] = temp;//还原字符  } } return false; } bool exist(char** board, int boardSize, int* boardColSize, char* word) { for(int i=0;i\u0026lt;boardSize;i++){ for(int j=0;j\u0026lt;*boardColSize;j++){ if(dfs(board,boardSize,boardColSize,word,i,j,0)) { return true; } } } return false; }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  func exist(board [][]byte, word string) bool { m,n := len(board), len(board[0]) for i := 0; i \u0026lt; m; i++ {//行范围  for j := 0; j \u0026lt; n; j++ {//列范围  //如果在数组中找得到第一个数，就执行下一步，否则返回false  if search(board, i, j, 0,word) { //dsf深度优先搜索，从一个起点开始搜索，若搜索到，则返回true，否则，下一个矩阵单元  return true } } } return false } func search(board [][]byte, i,j,k int, word string) bool { //如果找到最后一个数，则返回true,搜索成功  if k == len(word) { //k表示word当前遍历下标  return true } //i,j的约束条件  if i \u0026lt; 0 || j \u0026lt; 0 || i == len(board) || j == len(board[0]) { return false } //进入DFS深度优先搜索  //先把正在遍历的该值重新赋值，如果在该值的周围都搜索不到目标字符，则再把该值还原  //如果在数组中找到第一个字符，则进入下一个字符的查找  if board[i][j] == word[k] { temp := board[i][j] board[i][j] = \u0026#39; \u0026#39;//防止递归重复搜索  //下面这个if语句，如果成功进入，说明找到该字符，然后进行下一个字符的搜索,直到所有的搜索都成功，  //即k == len(word) - 1 的大小时，会返回true，进入该条件语句，然后返回函数true值。  if search(board, i, j + 1, k + 1, word) || //向下搜索  search(board, i, j - 1, k + 1, word) || //向上搜索  search(board, i + 1, j, k + 1, word) || //向右搜索  search(board, i - 1, j, k + 1, word) { //向左搜索  return true }else { //没有找到目标字符，还原之前重新赋值的board[i][j]  board[i][j] = temp } } return false }    \r  'use strict'; var containerId = JSON.parse(\"\\\"a12d40f1e642a5c8\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":38,"section":"interview","tags":["算法"],"title":"剑指 Offer 12. 矩阵中的路径","uri":"https://xing-you-ji.github.io/interview/algorithm/offer/12/"},{"content":"题目入口\n难度：中等\n地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、\n上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格\n[35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？\n示例 1：\n输入：m = 2, n = 3, k = 1\n输出：3\n示例 2：\n输入：m = 3, n = 1, k = 0\n输出：1\n提示：\n 1 \u0026lt;= n,m \u0026lt;= 100 0 \u0026lt;= k \u0026lt;= 20  解题思路：\n1.三个函数，第一个movingCount用来调用dfs函数，初始化，第二个dfs函数用来深度优先搜索来递归，第三个getDigGitSum函数用来求i，j的各位数之和\n2.额外空间flag来判断是否遍历过该方格\n3.继续向下向右dfs（深度优先搜索）\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  int digitSum(int i, int j) { int res = 0; while (i \u0026gt; 0 || j \u0026gt; 0) { res += i % 10; res += j % 10; i /= 10; j /= 10; } return res; } int dfsTraversal(int i, int j, int m, int n, int **visited, int k) { /* 特判，返回0表示不能到达。 * 1、超出边界 * 2、位数和不满足小于等于k的条件 * 3、当前节点已经访问过 */ if (i \u0026gt;= m || j \u0026gt;= n || digitSum(i, j) \u0026gt; k || visited[i][j] == 1) { return 0; } /* 标记当前节点已到达 */ visited[i][j] = 1; /* 再次进入下一层递归 * 这里只遍历了右、下，左、上不需要遍历， * 因为是从左上开始的，到右n下结束，所以当前节点都是从左上来的 */ return 1 + dfsTraversal(i, j + 1, m, n, visited, k) + dfsTraversal(i + 1, j, m, n, visited, k); } int movingCount(int m, int n, int k) { /* 路径数组，用于存放遍历结果 */ int **visited = (int **)calloc(m, sizeof(int *)); for (int i = 0; i \u0026lt; m; i++) { *(visited + i) = (int *)calloc(sizeof(int), n); } /* dfs深度搜索 */ return dfsTraversal(0, 0, m, n, visited, k); }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  var flag [][]int //全局变量数组，记录机器人是否曾访问过此方格  func movingCount(m int, n int, k int) int { //也不能进入行坐标和列坐标的数位之和大于k的格子  //递归深度搜索  if k == 0 { //机器人不移动，只访问一个方格  return 1 } var getDigGitSum func(i int, j int) int //用来计算行列坐标的数位之和  getDigGitSum = func(i int, j int) int { //求各位数之和的函数  res := 0 //返回结果  for i \u0026gt; 0 || j \u0026gt; 0 { res += i % 10 //求个位数值  res += j % 10 i /= 10 //整除  j /= 10 } return res } var dfs func(i, j int) int //用深度优先搜索  dfs = func(i, j int) int { //一个flag数组  //递归终止条件  //1.行标超出边界，列标超出边界  //2.行坐标和列坐标的数位之和大于k的格子  //3.方格已经被遍历过  if i \u0026gt;= m || j \u0026gt;= n || getDigGitSum(i, j) \u0026gt; k { return 0 } if flag[i][j] == 1 { //判断该方格是否被遍历过  return 0 } flag[i][j] = 1 //设置遍历位  return 1 + dfs(i+1, j) + dfs(i, j+1) //深度优先搜索（向右递归向下递归）  } flag = make([][]int, m) //初始化flag数组  for i := range flag { flag[i] = make([]int, n)//初始化各一维数组  } return 1 + dfs(1, 0) + dfs(0, 1) //  }    \r  'use strict'; var containerId = JSON.parse(\"\\\"fdf46ef6fa1c71c9\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":39,"section":"interview","tags":["算法"],"title":"剑指 Offer 13. 机器人的运动范围","uri":"https://xing-you-ji.github.io/interview/algorithm/offer/13/"},{"content":" 此文章取自于微信公众号“低并发编程”\n你是一台电脑，你的名字叫 A\r\n  \n经过《如果让你来设计网络》这篇文章中的一番折腾，只要你知道另一位伙伴 B 的 IP 地址，且你们之间的网络是通的，无论多远，你都可以将一个数据包发送给你的伙伴 B\n  \n这就是物理层、数据链路层、网络层这三层所做的事情。\n站在第四层的你，就可以不要脸地利用下三层所做的铺垫，随心所欲地发送数据，而不必担心找不到对方了。\n\n  \n虽然你此时还什么都没干，但你还是给自己这一层起了个响亮的名字，叫做传输层。\n你本以为自己所在的第四层万事大吉，啥事没有，但很快问题就接踵而至。\n问题来了\r\n前三层协议只能把数据包从一个主机搬到另外一台主机，但是，到了目的地以后，数据包具体交给哪个程序（进程）呢？\n  \n所以，你需要把通信的进程区分开来，于是就给每个进程分配一个数字编号，你给它起了一个响亮的名字：端口号。\n  \n然后你在要发送的数据包上，增加了传输层的头部，源端口号与目标端口号。\n  \nOK，这样你将原本主机到主机的通信，升级为了进程和进程之间的通信。\n你没有意识到，你不知不觉实现了 UDP 协议！\n（当然 UDP 协议中不光有源端口和目标端口，还有数据包长度和校验值，我们暂且略过）\n就这样，你用 UDP 协议无忧无虑地同 B 进行着通信，一直没发生什么问题。\n  \n但很快，你发现事情变得非常复杂......\r\n丢包问题\r\n由于网络的不可靠，数据包可能在半路丢失，而 A 和 B 却无法察觉。\n\n  \n对于丢包问题，只要解决两个事就好了。\n第一个，A 怎么知道包丢了？\n答案：让 B 告诉 A \n第二个，丢了的包怎么办？\n答案：重传 \n于是你设计了如下方案，A 每发一个包，都必须收到来自 B 的确认（ACK），再发下一个，否则在一定时间内没有收到确认，就重传这个包。\n  \n你管它叫停止等待协议。只要按照这个协议来，虽然 A 无法保证 B 一定能收到包，但 A 能够确认 B 是否收到了包，收不到就重试，尽最大努力让这个通信过程变得可靠，于是你们现在的通信过程又有了一个新的特征，可靠交付。\n效率问题\r\n停止等待虽然能解决问题，但是效率太低了，A 原本可以在发完第一个数据包之后立刻开始发第二个数据包，但由于停止等待协议，A 必须等数据包到达了 B ，且 B 的 ACK 包又回到了 A，才可以继续发第二个数据包，这效率慢得可不是一点两点。\n于是你对这个过程进行了改进，采用流水线（Pipelining）的方式，不再傻傻地等。\n\n顺序问题\r\n但是网路是复杂的、不可靠的。\n有的时候 A 发出去的数据包，分别走了不同的路由到达 B，可能无法保证和发送数据包时一样的顺序。\n  在流水线中有多个数据包和ACK包在乱序流动，他们之间对应关系就乱掉了。\n难道还回到停止等待协议？A 每收到一个包的确认（ACK）再发下一个包，那就根本不存在顺序问题。应该有更好的办法！\nA 在发送的数据包中增加一个序号（seq），同时 B 要在 ACK 包上增加一个确认号（ack），这样不但解决了停止等待协议的效率问题，也通过这样标序号的方式解决了顺序问题。\n  而 B 这个确认号意味深长：比如 B 发了一个确认号为 ack = 3，它不仅仅表示 A 发送的序号为 2 的包收到了，还表示 2 之前的数据包都收到了。这种方式叫累计确认或累计应答。\n  \n注意，实际上 ack 的号是收到的最后一个数据包的序号 seq + 1，也就是告诉对方下一个应该发的序号是多少。但图中为了便于理解，ack 就表示收到的那个序号，不必纠结。  \n流量问题\r\n有的时候，A 发送数据包的速度太快，而 B 的接收能力不够，但 B 却没有告知 A 这个情况。\n  怎么解决呢？\n很简单，B 告诉 A 自己的接收能力，A 根据 B 的接收能力，相应控制自己的发送速率，就好了。\nB 怎么告诉 A 呢？B 跟 A 说\u0026quot;我很强\u0026quot;这三个字么？那肯定不行，得有一个严谨的规范。\n于是 B 决定，每次发送数据包给 A 时，顺带传过来一个值，叫窗口大小（win)，这个值就表示 B 的接收能力。同理，每次 A 给 B 发包时也带上自己的窗口大小，表示 A 的接收能力。\n\n  \nB 告诉了 A 自己的窗口大小值，A 怎么利用它去做 A 这边发包的流量控制呢？\n很简单，假如 B 给 A 传过来的窗口大小 win = 5，那 A 根据这个值，把自己要发送的数据分成这么几类。\n  \n图片过于清晰，就不再文字解释了。\n当 A 不断发送数据包时，已发送的最后一个序号就往右移动，直到碰到了窗口的上边界，此时 A 就无法继续发包，达到了流量控制。\n\n  \n但是当 A 不断发包的同时，A 也会收到来自 B 的确认包，此时整个窗口会往右移动，因此上边界也往右移动，A 就能发更多的数据包了。\n\n  \n以上都是在窗口大小不变的情况下，而 B 在发给 A 的 ACK 包中，每一个都可以重新设置一个新的窗口大小，如果 A 收到了一个新的窗口大小值，A 会随之调整。\n如果 A 收到了比原窗口值更大的窗口大小，比如 win = 6，则 A 会直接将窗口上边界向右移动 1 个单位。\n  如果 A 收到了比原窗口值小的窗口大小，比如 win = 4，则 A 暂时不会改变窗口大小，更不会将窗口上边界向左移动，而是等着 ACK 的到来，不断将左边界向右移动，直到窗口大小值收缩到新大小为止。\n\n  \nOK，终于将流量控制问题解决得差不多了，你看着上面一个个小动图，给这个窗口起了一个更生动的名字，滑动窗口(一种算法)。\n拥塞问题\r\n但有的时候，不是 B 的接受能力不够，而是网络不太好，造成了网络拥塞。\n  \n拥塞控制与流量控制有些像，但流量控制是受 B 的接收能力影响，而拥塞控制是受网络环境的影响。\n拥塞控制的解决办法依然是通过设置一定的窗口大小，只不过，流量控制的窗口大小是 B 直接告诉 A 的，而拥塞控制的窗口大小按理说就应该是网络环境主动告诉 A。\n但网络环境怎么可能主动告诉 A 呢？只能 A 单方面通过试探，不断感知网络环境的好坏，进而确定自己的拥塞窗口的大小。\n\n  \n拥塞窗口大小的计算有很多复杂的算法，就不在本文中展开了，假如拥塞窗口的大小为 cwnd，上一部分流量控制的滑动窗口的大小为 rwnd，那么窗口的右边界受这两个值共同的影响，需要取它俩的最小值。\n窗口大小 = min(cwnd, rwnd)\r\n含义很容易理解，当 B 的接受能力比较差时，即使网络非常通畅，A 也需要根据 B 的接收能力限制自己的发送窗口。当网络环境比较差时，即使 B 有很强的接收能力，A 也要根据网络的拥塞情况来限制自己的发送窗口。正所谓受其短板的影响嘛~\n连接问题\r\n有的时候，B 主机的相应进程还没有准备好或是挂掉了，A 就开始发送数据包，导致了浪费。\n\n  \n这个问题在于，A 在跟 B 通信之前，没有事先确认 B 是否已经准备好，就开始发了一连串的信息。就好比你和另一个人打电话，你还没有\u0026quot;喂\u0026quot;一下确认对方有没有在听，你就巴拉巴拉说了一堆。\n这个问题该怎么解决呢？\n地球人都知道，三次握手嘛！\n* A：我准备好了(SYN)\n* B：我知道了(ACK)，我也准备好了(SYN)\n* A：我知道了(ACK)\n\n  \nA 与 B 各自在内存中维护着自己的状态变量，三次握手之后，双方的状态都变成了连接已建立（ESTABLISHED）。\n虽然就只是发了三次数据包，并且在各自的内存中维护了状态变量，但这么说总觉得太 low，你看这个过程相当于双方建立连接的过程，于是你灵机一动，就叫它面向连接吧。\n注意：这个连接是虚拟的，是由 A 和 B 这两个终端共同维护的，在网络中的设备根本就不知道连接这回事儿！  \n但凡事有始就有终，有了建立连接的过程，就要考虑释放连接的过程，又是地球人都知道，四次挥手嘛！\n* A：再见，我要关闭了(FIN)\n* B：我知道了(ACK)\n给 B 一段时间把自己的事情处理完\u0026hellip;\n* B：再见，我要关闭了(FIN)\n* A：我知道了(ACK)\n  \n总结\r\n以上讲述的，就是 TCP 协议的核心思想，上面过程中需要传输的信息，就体现在 TCP 协议的头部，这里放上最常见的 TCP 协议头解读的图。\n  \n不知道你现在再看下面这句话，是否能理解：\nTCP 是\n面向连接的、可靠的、基于字节流的\n传输层通信协议  \n面向连接、可靠，这两个词通过上面的讲述很容易理解，那什么叫做基于字节流呢？\n很简单，TCP 在建立连接时，需要告诉对方 MSS（最大报文段大小）。\n也就是说，如果要发送的数据很大，在 TCP 层是需要按照 MSS 来切割成一个个的TCP 报文段 的。\n切割的时候我才不管你原来的数据表示什么意思，需要在哪里断句啥的，我就把它当成一串毫无意义的字节，在我想要切割的地方咔嚓就来一刀，标上序号，只要接收方再根据这个序号拼成最终想要的完整数据就行了。\n在我 TCP 传输这里，我就把它当做一个个的字节，也就是基于字节流的含义了。\n  \n最后留给大家一个作业，模拟 A 与 B 建立一个 TCP 连接。\n第一题：A 给 B 发送 \"aaa\" ，然后 B 给 A 回复一个简单的字符串 \"success\"，并将此过程抓包。 第二题：A 给 B 发送 \"aaaaaa ... a\" 超过最大报文段大小，然后 B 给 A 回复一个简单的字符串 \"success\"，并将此过程抓包。 下面是我抓的包（第二题）\n三次握手阶段\rA -\u0026gt; B\t[SYN] Seq=0 Win=64240 Len=0\rMSS=1460 WS=256\rB - \u0026gt;A\t[SYN, ACK] Seq=0 Ack=1 Win=29200 Len=0\rMSS=1424 WS=512\rA -\u0026gt; B\t[ACK] Seq=1 Ack=1 Win=132352 Len=0\r数据发送阶段\rA -\u0026gt; B\t[ACK] Seq=1 Ack=1 Win=132352 Len=1424\rA -\u0026gt; B\t[ACK] Seq=1425 Ack=1 Win=132352 Len=1424\rA -\u0026gt; B\t[PSH, ACK] Seq=2849 Ack=1 Win=132352 Len=1247\rB -\u0026gt; A\t[ACK] Seq=1 Ack=1425 Win=32256 Len=0\rB -\u0026gt; A\t[ACK] Seq=1 Ack=2849 Win=35328 Len=0\rB -\u0026gt; A\t[ACK] Seq=1 Ack=4096 Win=37888 Len=0\rB -\u0026gt; A\t[PSH, ACK] Seq=1 Ack=4096 Win=37888 Len=7\r四次挥手阶段\rB -\u0026gt; A\t[FIN, ACK] Seq=8 Ack=4096 Win=37888 Len=0\rA -\u0026gt; B\t[ACK] Seq=4096 Ack=9 Win=132352 Len=0\rA -\u0026gt; B\t[FIN, ACK] Seq=4096 Ack=9 Win=132352 Len=0（下面少复制了一行ACK，抱歉）\r后记\r一提到 TCP，可能很多人都想起被三次握手和四次挥手所支配的恐惧。但其实你跟着文中的思路你就会发现，三次握手与四次挥手只占 TCP 所解决的核心问题中很小的一部分，只是因为它在面试中很适合作为知识点进行考察，所以在很多人的印象中就好像 TCP 的核心就是握手和挥手似的。\n本文希望你能从问题出发，真正理解 TCP 所想要解决的问题，你会发现很多原理就好像生活常识一样顺其自然，并不复杂，希望你有收获～\n","description":"了解tcp","id":40,"section":"article","tags":["网络"],"title":"图解 | 你管这破玩意儿叫TCP？","uri":"https://xing-you-ji.github.io/article/network/interesting/2/"},{"content":" 此文章取自于微信公众号“低并发编程”\n正文开始：\n你是一台电脑，你的名字叫 A\n很久很久之前，你不与任何其他电脑相连接，孤苦伶仃。\n  直到有一天，你希望与另一台电脑 B 建立通信，于是你们各开了一个网口，用一根网线连接了起来。\n  用一根网线连接起来怎么就能\u0026quot;通信\u0026quot;了呢？我可以给你讲 IO、讲中断、讲缓冲区，但这不是研究网络时该关心的问题。\n如果你纠结，要么去研究一下操作系统是如何处理网络 IO 的，要么去研究一下包是如何被网卡转换成电信号发送出去的，要么就仅仅把它当做电脑里有个小人在开枪吧~\n  反正，你们就是连起来了，并且可以通信。\n  有一天，一个新伙伴 C 加入了，但聪明的你们很快发现，可以每个人开两个网口，用一共三根网线，彼此相连。\n  随着越来越多的人加入，你发现身上开的网口实在太多了，而且网线密密麻麻，混乱不堪。（而实际上一台电脑根本开不了这么多网口，所以这种连线只在理论上可行，所以连不上的我就用红色虚线表示了，就是这么严谨哈哈~）\n  于是你们发明了一个中间设备，你们将网线都插到这个设备上，由这个设备做转发，就可以彼此之间通信了，本质上和原来一样，只不过网口的数量和网线的数量减少了，不再那么混乱。\n  你给它取名叫集线器，它仅仅是无脑将电信号转发到所有出口（广播），不做任何处理，你觉得它是没有智商的，因此把人家定性在了物理层。\n  由于转发到了所有出口，那 BCDE 四台机器怎么知道数据包是不是发给自己的呢？\n首先，你要给所有的连接到集线器的设备，都起个名字。原来你们叫 ABCD，但现在需要一个更专业的，全局唯一的名字作为标识，你把这个更高端的名字称为MAC 地址\n你的 MAC 地址是 aa-aa-aa-aa-aa-aa，你的伙伴 b 的 MAC 地址是 bb-bb-bb-bb-bb-bb，以此类推，不重复就好。\n这样，A 在发送数据包给 B 时，只要在头部拼接一个这样结构的数据，就可以了。\n  B 在收到数据包后，根据头部的目标 MAC 地址信息，判断这个数据包的确是发给自己的，于是便收下。\n其他的 CDE 收到数据包后，根据头部的目标 MAC 地址信息，判断这个数据包并不是发给自己的，于是便丢弃。\n  虽然集线器使整个布局干净不少，但原来我只要发给电脑 B 的消息，现在却要发给连接到集线器中的所有电脑，这样既不安全，又不节省网络资源。\n  如果把这个集线器弄得更智能一些，只发给目标 MAC 地址指向的那台电脑，就好了\n  虽然只比集线器多了这一点点区别，但看起来似乎有智能了，你把这东西叫做交换机。也正因为这一点点智能，你把它放在了另一个层级，数据链路层。\n  如上图所示，你是这样设计的。\n交换机内部维护一张 MAC 地址表，记录着每一个 MAC 地址的设备，连接在其哪一个端口上。\n  假如你仍然要发给 B 一个数据包，构造了如下的数据结构从网口出去。\n  到达交换机时，交换机内部通过自己维护的 MAC 地址表，发现目标机器 B 的 MAC 地址 bb-bb-bb-bb-bb-bb 映射到了端口 1 上，于是把数据从 1 号端口发给了 B，完事~\n你给这个通过这样传输方式而组成的小范围的网络，叫做以太网。\n当然最开始的时候，MAC 地址表是空的，是怎么逐步建立起来的呢？\n假如在 MAC 地址表为空是，你给 B 发送了如下数据：\n  由于这个包从端口 4 进入的交换机，所以此时交换机就可以在 MAC地址表记录第一条数据：\n  交换机看目标 MAC 地址（bb-bb-bb-bb-bb-bb）在地址表中并没有映射关系，于是将此包发给了所有端口，也即发给了所有机器。\n之后，只有机器 B 收到了确实是发给自己的包，于是做出了响应，响应数据从端口 1 进入交换机，于是交换机此时在地址表中更新了第二条数据：\n  过程如下：\n  经过该网络中的机器不断地通信，交换机最终将 MAC 地址表建立完毕~\n  随着机器数量越多，交换机的端口也不够了，但聪明的你发现，只要将多个交换机连接起来，这个问题就轻而易举搞定~\n  你完全不需要设计额外的东西，只需要按照之前的设计和规矩来，按照上述的接线方式即可完成所有电脑的互联，所以交换机设计的这种规则，真的很巧妙。你想想看为什么（比如 A 要发数据给 F）。\n但是你要注意，上面那根红色的线，最终在 MAC 地址表中可不是一条记录呀，而是要把 EFGH 这四台机器与该端口（端口6）的映射全部记录在表中。\n最终，两个交换机将分别记录 A ~ H 所有机器的映射记录。\n左边的交换机\n  右边的交换机\n  这在只有 8 台电脑的时候还好，甚至在只有几百台电脑的时候，都还好，所以这种交换机的设计方式，已经足足支撑一阵子了。\n但很遗憾，人是贪婪的动物，很快，电脑的数量就发展到几千、几万、几十万。\n  交换机已经无法记录如此庞大的映射关系了。\n此时你动了歪脑筋，你发现了问题的根本在于，连出去的那根红色的网线，后面不知道有多少个设备不断地连接进来，从而使得地址表越来越大。\n那我可不可以让那根红色的网线，接入一个新的设备，这个设备就跟电脑一样有自己独立的 MAC 地址，而且同时还能帮我把数据包做一次转发呢？\n这个设备就是路由器，它的功能就是，作为一台独立的拥有 MAC 地址的设备，并且可以帮我把数据包做一次转发，你把它定在了网络层。\n  注意，路由器的每一个端口，都有独立的 MAC 地址。\n好了，现在交换机的 MAC 地址表中，只需要多出一条 MAC 地址 ABAB 与其端口的映射关系，就可以成功把数据包转交给路由器了，这条搞定。\n那如何做到，把发送给 C 和 D，甚至是把发送给 DEFGH\u0026hellip;. 的数据包，统统先发送给路由器呢？\n不难想到这样一个点子，假如电脑 C 和 D 的 MAC 地址拥有共同的前缀，比如分别是：\n  那我们就可以说，将目标 MAC 地址为 FFFF-FFFF-？开头的，统统先发送给路由器。\n这样是否可行呢？答案是否定的。\n我们先从现实中 MAC 地址的结构入手，MAC地址也叫物理地址、硬件地址，长度为 48 位，一般这样来表示：   它是由网络设备制造商生产时烧录在网卡的EPROM（一种闪存芯片，通常可以通过程序擦写）。其中前 24 位（00-16-EA）代表网络硬件制造商的编号，后 24 位（AE-3C-40）是该厂家自己分配的，一般表示系列号。只要不更改自己的 MAC 地址，MAC 地址在世界是唯一的。形象地说，MAC地址就如同身份证上的身份证号码，具有唯一性。\n那如果你希望向上面那样将目标 MAC 地址表示为 FFFF-FFFF-？开头的，统一从路由器出去发给某一群设备（后面会提到这其实是子网的概念），那你就需要要求某一子网下统统买一个厂商制造的设备，要么你就需要要求厂商在生产网络设备烧录 MAC 地址时，提前按照你规划好的子网结构来定 MAC 地址，并且日后这个网络的结构都不能轻易改变。\n这显然是不现实的。\n于是你发明了一个新的地址，给每一台机器一个 32 位的编号，如：\n11000000101010000000000000000001\n你觉得有些不清晰，于是把它分成四个部分，中间用点相连。\n11000000.10101000.00000000.00000001\n你还觉得不清晰，于是把它转换成 10 进制。\n192.168.0.1\n最后你给了这个地址一个响亮的名字，IP 地址。现在每一台电脑，同时有自己的 MAC 地址，又有自己的 IP 地址，只不过 IP 地址是软件层面上的，可以随时修改，MAC 地址一般是无法修改的。\n这样一个可以随时修改的 IP 地址，就可以根据你规划的网络拓扑结构，来调整了。\n  如上图所示，假如我想要发送数据包给 ABCD 其中一台设备，不论哪一台，我都可以这样描述，\u0026ldquo;将 IP 地址为 192.168.0 开头的全部发送给到路由器，之后再怎么转发，交给它！\u0026quot;，巧妙吧。\n那交给路由器之后，路由器又是怎么把数据包准确转发给指定设备的呢？\n别急我们慢慢来。\n我们先给上面的组网方式中的每一台设备，加上自己的 IP 地址。\n  现在两个设备之间传输，除了加上数据链路层的头部之外，还要再增加一个网络层的头部。\n假如 A 给 B 发送数据，由于它们直接连着交换机，所以 A 直接发出如下数据包即可，其实网络层没有体现出作用。\n  但假如 A 给 C 发送数据，A 就需要先转交给路由器，然后再由路由器转交给 C。由于最底层的传输仍然需要依赖以太网，所以数据包是分成两段的。\nA ~ 路由器这段的包如下：   路由器到 C 这段的包如下：\n  好了，上面说的两种情况（A-\u0026gt;B，A-\u0026gt;C），相信细心的读者应该会有不少疑问，下面我们一个个来展开。\nA 给 C 发数据包，怎么知道是否要通过路由器转发呢？\n答案：子网 \n如果源 IP 与目的 IP 处于一个子网，直接将包通过交换机发出去。\n如果源 IP 与目的 IP 不处于一个子网，就交给路由器去处理。\n好，那现在只需要解决，什么叫处于一个子网就好了。\n 192.168.0.1 和 192.168.0.2 处于同一个子网 192.168.0.1 和 192.168.1.1 处于不同子网  这两个是我们人为规定的，即我们想表示，对于 192.168.0.1 来说：\n192.168.0.xxx 开头的，就算是在一个子网，否则就是在不同的子网。 \n那对于计算机来说，怎么表达这个意思呢？于是人们发明了子网掩码的概念。\n假如某台机器的子网掩码定为 255.255.255.0。\n这表示，将源 IP 与目的 IP 分别同这个子网掩码进行与运算，相等则是在一个子网，不相等就是在不同子网，就这么简单。\n比如：\n  A电脑：192.168.0.1 \u0026amp; 255.255.255.0 = 192.168.0.0\n  B电脑：192.168.0.2 \u0026amp; 255.255.255.0 = 192.168.0.0\n  C电脑：192.168.1.1 \u0026amp; 255.255.255.0 = 192.168.1.0\n  D电脑：192.168.1.2 \u0026amp; 255.255.255.0 = 192.168.1.0\n那么 A 与 B 在同一个子网，C 与 D 在同一个子网，但是 A 与 C 就不在同一个子网，与 D 也不在同一个子网，以此类推。\n    所以如果 A 给 C 发消息，A 和 C 的 IP 地址分别 \u0026amp; A 机器配置的子网掩码，发现不相等，则 A 认为 C 和自己不在同一个子网，于是把包发给路由器，就不管了，之后怎么转发，A 不关心。\nA 如何知道，哪个设备是路由器？\n答案：在 A 上要设置默认网关 \n上一步 A 通过是否与 C 在同一个子网内，判断出自己应该把包发给路由器，那路由器的 IP 是多少呢？\n其实说发给路由器不准确，应该说 A 会把包发给默认网关。\n对 A 来说，A 只能直接把包发给同处于一个子网下的某个 IP 上，所以发给路由器还是发给某个电脑，对 A 来说也不关心，只要这个设备有个 IP 地址就行。\n所以默认网关，就是 A 在自己电脑里配置的一个 IP 地址，以便在发给不同子网的机器时，发给这个 IP 地址。\n  路由器如何知道C在哪里？\n答案：路由表 \n现在 A 要给 C 发数据包，已经可以成功发到路由器这里了，最后一个问题就是，路由器怎么知道，收到的这个数据包，该从自己的哪个端口出去，才能直接（或间接）地最终到达目的地 C 呢。\n路由器收到的数据包有目的 IP 也就是 C 的 IP 地址，需要转化成从自己的哪个端口出去，很容易想到，应该有个表，就像 MAC 地址表一样。\n这个表就叫路由表。\n至于这个路由表是怎么出来的，有很多路由算法，本文不展开，因为我也不会哈哈~\n不同于 MAC 地址表的是，路由表并不是一对一这种明确关系，我们下面看一个路由表的结构。\n  我们学习一种新的表示方法，由于子网掩码其实就表示前多少位表示子网的网段，所以如 192.168.0.0（255.255.255.0） 也可以简写为 192.168.0.0/24。\n  这就很好理解了，路由表就表示，这个子网下的，都转发到 0 号端口，192.168.1.xxx 这个子网下的，都转发到 1 号端口192.168.0.xxx 。下一跳列还没有值，我们先不管。\n配合着结构图来看（这里把子网掩码和默认网关都补齐了）结果应该是 0\n  刚才说的都是 IP 层，但发送数据包的数据链路层需要知道 MAC 地址，可是我只知道 IP 地址该怎么办呢？\n答案：arp 假如你（A）此时不知道你同伴 B 的 MAC 地址（现实中就是不知道的，刚刚我们只是假设已知），你只知道它的 IP 地址，你该怎么把数据包准确传给 B 呢？\n答案很简单，在网络层，我需要把 IP 地址对应的 MAC 地址找到，也就是通过某种方式，找到192.168.0.2  对应的 MAC 地址 BBBB。\n这种方式就是 arp 协议，同时电脑 A 和 B 里面也会有一张 arp 缓存表，表中记录着 IP 与 MAC 地址的对应关系。\n  一开始的时候这个表是空的，电脑 A 为了知道电脑 B（192.168.0.2）的 MAC 地址，将会广播一条 arp 请求，B 收到请求后，带上自己的 MAC 地址给 A 一个响应。此时 A 便更新了自己的 arp 表。\n这样通过大家不断广播 arp 请求，最终所有电脑里面都将 arp 缓存表更新完整\n总结一下 好了，总结一下，到目前为止就几条规则：\n从各个节点的视角来看\n电脑视角：\n  首先我要知道我的 IP 以及对方的 IP\n  通过子网掩码判断我们是否在同一个子网\n  在同一个子网就通过 arp 获取对方 mac 地址直接扔出去\n  不在同一个子网就通过 arp 获取默认网关的 mac 地址直接扔出去\n  交换机视角：\n  我收到的数据包必须有目标 MAC 地址\n  通过 MAC 地址表查映射关系\n  查到了就按照映射关系从我的指定端口发出去\n  查不到就所有端口都发出去\n  路由器视角：\n  我收到的数据包必须有目标 IP 地址\n  通过路由表查映射关系\n  查到了就按照映射关系从我的指定端口发出去（不在任何一个子网范围，走其路由器的默认网关也是查到了）\n  查不到则返回一个路由不可达的数据包\n  如果你嗅觉足够敏锐，你应该可以感受到下面这句话：\n网络层（IP协议）本身没有传输包的功能，包的实际传输是委托给数据链路层（以太网中的交换机）来实现的。 涉及到的三张表分别是\n  交换机中有 MAC地址表用于映射 MAC 地址和它的端口\n  路由器中有路由表用于映射 IP 地址(段)和它的端口\n  电脑和路由器中都有 arp 缓存表用于缓存 IP 和 MAC 地址的映射关系\n  这三张表是怎么来的\n  MAC 地址表是通过以太网内各节点之间不断通过交换机通信，不断完善起来的。\n  路由表是各种路由算法 + 人工配置逐步完善起来的。\n  arp 缓存表是不断通过 arp 协议的请求逐步完善起来的。\n知道了以上这些，目前网络上两个节点是如何发送数据包的这个过程，就完全可以解释通了！\n  那接下来我们就放上本文 最后一个网络拓扑图吧，请做好 战斗准备！\n  这时路由器 1 连接了路由器 2，所以其路由表有了下一条地址这一个概念，所以它的路由表就变成了这个样子。如果匹配到了有下一跳地址的一项，则需要再次匹配，找到其端口，并找到下一跳 IP 的 MAC 地址。\n也就是说找来找去，最终必须能映射到一个端口号，然后从这个端口号把数据包发出去。\n  这时如果 A 给 F 发送一个数据包，能不能通呢？如果通的话整个过程是怎样的呢？\n  思考一分钟\u0026hellip;\n详细过程文字描述：\n1. 首先A（192.168.0.1） 通过子网掩码（255.255.255.0）计算出自己与F（192.168.2.2） 并不在同一个子网内，于是决定发送给默认网关（192.168.0.254） 。\n2. A 通过 ARP 找到默认网关 192.168.0.254 的 MAC 地址。\n3. A 将源 MAC 地址（AAAA）与网关 MAC 地址（ABAB）封装在数据链路层头部，又将源 IP 地址（192.168.0.1）和目的 IP 地址（192.168.2.2）（注意这里千万不要以为填写的是默认网关的 IP 地址，从始至终这个数据包的两个 IP 地址都是不变的，只有 MAC 地址在不断变化）封装在网络层头部，然后发包。\n  4. 交换机 1 收到数据包后，发现目标 MAC 地址是 ABAB，转发给路由器 1。\n5. 数据包来到了路由器 1，发现其目标 IP 地址是 192.168.2.2，查看其路由表，发现了下一跳的地址是 192.168.100.5。\n6. 所以此时路由器 1 需要做两件事，第一件是再次匹配路由表，发现匹配到了端口为 2，于是将其封装到数据链路层，最后把包从2 号口发出去。\n7. 此时路由器 2 收到了数据包，看到其目的地址是 192.168.2.2，查询其路由表，匹配到端口号为 1，准备从1 号口 把数据包送出去。\n8. 但此时路由器 2 需要知道192.168.2.2 的 MAC 地址了，于是查看其 arp 缓存，找到其 MAC 地址为FFFF ，将其封装在数据链路层头部，并从 1 号端口把包发出去。\n9.交换机 3 收到了数据包，发现目的 MAC 地址为FFFF ，查询其 MAC 地址表，发现应该从其6 号端口 出去，于是从 6 号端口把数据包发出去。\n10. F 最终收到了数据包！并且发现目的 MAC 地址就是自己，于是收下了这个包。\n  至此，经过物理层、数据链路层、网络层这前三层的协议，以及根据这些协议设计的各种网络设备（网线、集线器、交换机、路由器），理论上只要拥有对方的 IP 地址，就已经将地球上任意位置的两个节点连通了。\n  - 完 -\n","description":"了解网络","id":41,"section":"article","tags":["网络"],"title":"如果让你来设计网络，你会把它弄成啥样？","uri":"https://xing-you-ji.github.io/article/network/interesting/1/"},{"content":"如果递归函数中，只进行一次递归调用，递归深度为depth；在每个递归函数中，时间复杂度为T;则总体的时间复杂度为O(T*depth)\n力扣 50. Pow(x, n)\n实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，x^n）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  func myPow(x float64, n int) float64 { if x == 0{ return 0 }else if x \u0026gt; 0{ return pre(x,n) }else{ return 1/pre(x,n) } } func pre(x float64, n int) float64{ if n == 0{ return 1 } if n == 1{ return x } y := pre(x,n/2) if n % 2 == 0{ //说明n是偶数幂,递归整除2不丢数  return y * y }else { //说明n是奇数幂,递归整除2丢一个x  return x * y * y } }   递归深度：logn\n时间复杂度：O(logn)\n","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":42,"section":"interview","tags":["算法"],"title":"慕课算法视频第二章第三节","uri":"https://xing-you-ji.github.io/interview/algorithm_interview/charpter2/3/"},{"content":"如何写出正确的程序】  ``正确地处理边界  例：二分查找法（边界处理）\nc golang  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  int binarySearch(int arr[],int n,int target) { //n为数组的长度，target为需要查找的目标  int l = 0 , r = n;//在[l...r)的 范围内查找target  while(l\u0026lt;r){ //int mid = (l+r)/2;//可能含有Bug，整形溢出  //要明确l,r的取值意义，搜索区间的访问，进行循环搜索，缩小区间时也要保证不越界，也不丢界  int mid = l + (r - l) / 2; if(arr[mid] == taget){ return mid; } if arr[mid] \u0026gt; target{ l = mid + 1; }else { r = mid;//target在[l..mid)中  } } return -1; }     1 2 3 4 5 6 7 8 9 10 11 12 13 14  func binarySearch(arr []int,target int)int{ l,r := 0,len(arr) //在[l...r)的 范围内查找target  for l \u0026lt; r{ //mid := (l + r ) / 2可能含有Bug，整形溢出  mid := l + (r - l)/2 if target \u0026gt; arr[mid]{ l = mid+1 }else{ r = mid //target在[l...mid)中  } } return -1 }       'use strict'; var containerId = JSON.parse(\"\\\"b415f5a4eee7f430\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \n 明确变量的含义 循环不变量（不改变含义） 小数据调试（要有耐心调试的习惯，技术员的核心竞争力） 大数据调试（扩展程序的正确性，测试程序的性能）  小练习(力扣官网)  283题 27题 26题 80题  ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":43,"section":"interview","tags":["算法"],"title":"慕课算法视频第三章第一节","uri":"https://xing-you-ji.github.io/interview/algorithm_interview/charpter3/1/"},{"content":"两类查找问题\n  1.查找有无\n-元素\u0026rsquo;a\u0026rsquo;是否存在？set（集合）\n  2.查找对应关系（键值对应）\n-元素\u0026rsquo;a\u0026rsquo;出现了几次？map（字典）\n  练习\n349. 两个数组的交集\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func intersection(nums1 []int, nums2 []int) []int { hash := make(map[int]bool) res := make([]int, 0) for _, v := range nums1 { hash[v] = true } for _, v := range nums2 { if hash[v] == true { res = append(res, v) hash[v] = false } } return res }   242. 有效的字母异位词\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  func isAnagram(s string, t string) bool { if len(s) != len(t){ //长度不等，直接返回false  return false } //建立一个与两个字符串有关的映射，初始值为0，map[s[i]]就加1，map[t[i]]就减1，如果map里面出现了值不为0的key就说明  //不是异位词  hash := make(map[byte]int) for i:=0;i\u0026lt;len(s);i++{ hash[s[i]-\u0026#39;a\u0026#39;]++ hash[t[i]-\u0026#39;a\u0026#39;]-- } for _,v := range hash{ if v != 0{ return false } } return true }   202.快乐数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  func isHappy(n int) bool { hash := make(map[int]bool) res := n for{ if res == 1{ return true }else if hash[res] == true{ return false } hash[res] = true res = getSquareSUm(res) } return false } func getSquareSUm(n int)int{ res := 0 for n \u0026gt; 0{ res += (n%10) * (n%10) n = n / 10 } return res }   290. 单词规律\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  func wordPattern(pattern string, s string) bool { //双映射，字符-\u0026gt;字符串，字符串-\u0026gt;字符  word2ch := make(map[string]byte) ch2word := make(map[byte]string) stringSlice := strings.Split(s, \u0026#34; \u0026#34;) if len(stringSlice) != len(pattern){ return false } //双映射，对应的字符有着对应的字符串，对应的字符串有着对应的字符  for i:=0;i\u0026lt;len(pattern);i++{ if word2ch[stringSlice[i]] != 0 \u0026amp;\u0026amp; word2ch[stringSlice[i]] != pattern[i]{ return false } if ch2word[pattern[i]] != \u0026#34;\u0026#34; \u0026amp;\u0026amp; ch2word[pattern[i]] != stringSlice[i]{ return false } word2ch[stringSlice[i]] = pattern[i] ch2word[pattern[i]] = stringSlice[i] } return true }   451. 根据字符出现频率排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  //第一种写法 func frequencySort(s string) string { if len(s) == 1 || s == \u0026#34;\u0026#34;{ return s } freq := make(map[byte]int) //记录字符的出现频率 \tret := make([]byte,0) //记录不同的字符 \tres := make([]byte,0) //返回结果 \tfor i:=0;i\u0026lt;len(s);i++{ if freq[s[i]] == 0{ ret = append(ret,s[i]) } freq[s[i]]++ } //sort.Slice(ret, func(i, j int) bool { \t//\treturn freq[ret[i]] \u0026gt; freq[ret[j]] \t//}) \tquickSort(ret,freq) for i:=0;i\u0026lt;len(ret);i++{ for j:=0;j\u0026lt;freq[ret[i]];j++{ res = append(res,ret[i]) } } return string(res) } func quickSort(ret []byte,freq map[byte]int){ partition(ret,freq,0,len(ret)-1) } func partition(ret []byte,freq map[byte]int,low,high int){ if low \u0026gt;= high{ return } pivot := ret[low] l := low r := high for l \u0026lt; r{ for l \u0026lt; r \u0026amp;\u0026amp; freq[ret[r]] \u0026lt; freq[pivot]{ r-- } if l \u0026lt; r{ ret[l] = ret[r] l++ } for l \u0026lt; r \u0026amp;\u0026amp; freq[ret[l]] \u0026gt;= freq[pivot]{ l++ } if l \u0026lt; r { ret[r] = ret[l] r-- } } ret[l] = pivot partition(ret,freq,low,l-1) partition(ret,freq,l+1,high) }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  //第二种写法 func frequencySort(s string) string { if len(s) == 1 || s == \u0026#34;\u0026#34;{ return s } freq := make(map[byte]int) //记录字符的出现频率 \tret := make([]byte,0) //记录不同的字符 \tres := make([]byte,0) //返回结果 \tfor i:=0;i\u0026lt;len(s);i++{ if freq[s[i]] == 0{ ret = append(ret,s[i]) } freq[s[i]]++ } //sort.Slice(ret, func(i, j int) bool { \t//\treturn freq[ret[i]] \u0026gt; freq[ret[j]] \t//}) \tsort.Slice(ret,func(i,j int)bool{ return freq[ret[i]] \u0026gt; freq[ret[j]] }) for i:=0;i\u0026lt;len(ret);i++{ for j:=0;j\u0026lt;freq[ret[i]];j++{ res = append(res,ret[i]) } } return string(res) }   1. 两数之和\n1 2 3 4 5 6 7 8 9 10 11 12  func twoSum(nums []int, target int) []int { hashMap := map[int]int{} //实例化一个map  for i:=0;i\u0026lt;len(nums);i++{ if v,ok := hashMap[target-nums[i]];ok{//如果存在就放回hashMap的值  return []int{i,v} } hashMap[nums[i]] = i //添加  } return []int{} //没找到 }   15. 三数之和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  func threeSum(nums []int) [][]int { res := make([][]int, 0) // 先对原始数组进行排序，排序后一来可以过滤很多重复结果，二来可以让twoSum以O(n)处理 \tsort.Ints(nums) for i := 0; i \u0026lt; len(nums); i++ { //if nums[i] == nums[i+1] \u0026amp;\u0026amp; nums[i+1] == nums[i+2] { \t//\tcontinue \t//} \t// 从向后判断改为向前判断相等，那么第一次的结果就一定要加入结果列表里面，然后后面如果有和前面相同的枚举就跳过 \tif i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1] { continue } twoSumTarget := nums[i] * -1 l, r := i+1, len(nums)-1 for l \u0026lt; r { // 这里需要确保前指针后移不能越过后指针，然后是向前判断相等 \tif l \u0026gt; i+1 \u0026amp;\u0026amp; nums[l] == nums[l-1] { l++ continue } twoSum := nums[l] + nums[r] if twoSum == twoSumTarget { // 这样的情况就是twoSum符合目标值，记录这个三元组 \tres = append(res, []int{nums[i], nums[l], nums[r]}) // 然后找到三元组后前后指针一起移动 \tr-- l++ } // twoSum比目标值大，后指针要向前移 \tif twoSum \u0026gt; twoSumTarget { //去重 \tr-- continue } if twoSum \u0026lt; twoSumTarget { //去重 \t// twoSum小于目标值，前指针后移 \tl++ continue } } } return res }   16. 最接近的三数之和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  func abs(a int)int{ if a \u0026gt;= 0{ return a }else{ return -a } } func threeSumClosest(nums []int, target int) int { sub := math.MaxInt64 //记录与目标值的差值 \tres := math.MaxInt64 //记录最接近目标的和 \tsort.Ints(nums) for i:=0;i\u0026lt;len(nums);i++{ //去重 \tif i \u0026gt; 0 \u0026amp;\u0026amp; nums[i-1] == nums[i]{ continue //有相同元素可以直接跳过考虑，因为在第一次已经考虑 \t} l := i+1 r := len(nums)-1 // \tfor l \u0026lt; r{ //寻找最接近的三数之和 \tcurr := nums[i] + nums[l] + nums[r] //临时记录和 \tcurrSub := abs(curr - target) //临时的差值 \tif curr \u0026lt; target { //当前的差值小于最少的差值 \tl++ if currSub \u0026lt; sub{ sub = currSub //当前最接近的差值 \tres = curr //当前最接近的结果 \t} }else if curr \u0026gt; target { //差值大于sub，说明和太大了或者太小了 \tr-- if currSub \u0026lt; sub{ sub = currSub //当前最接近的差值 \tres = curr //当前最接近的结果 \t} }else{ //目标值想等，一定是最接近的数，直接返回 \treturn curr } } } return res }   454. 四数相加 II\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  func fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int { //建立一个查找表（采用map，键为nums3和nums4和的可能性，值为出现的频率）  hash1 := make(map[int]int) //nums1 + nums2  hash2 := make(map[int]int) //nums3 + nums4  res := 0 //返回结果  for i:=0;i\u0026lt;len(nums1);i++{ for j:=0;j\u0026lt;len(nums2);j++{ hash1[nums1[i]+nums2[j]]++ //统计频率  } } for i:=0;i\u0026lt;len(nums3);i++{ for j:=0;j\u0026lt;len(nums4);j++{ hash2[nums3[i]+nums4[j]]++ //统计频率  } } for i,v := range hash1{ if hash2[0-i] != 0{ res += v * hash2[0-i] } } return res }   ","description":"如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路","id":44,"section":"interview","tags":["算法"],"title":"慕课算法视频第四章第一节","uri":"https://xing-you-ji.github.io/interview/algorithm_interview/charpter4/1/"},{"content":"基础算法思路的应用（对撞指针，双指针） 力扣75. 颜色分类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  func sortColors(nums []int) { n := len(nums) //划分三个区间，扫描一次数组，放入三个区间  //0在区间[0,zero]从0开始不断扩大区间  //2在区间[two,n-1]从n-1开始不断缩小区间  //1在区间[zero+1,two-1]从zero+1开始不断扩大区间  //设置初始值zero,two  zero := -1 //最开始0元素的个数为0，从-1开始  two := n //最开始2元素的个数为0，从n开始  for i:=0;i\u0026lt;two;{//扫描到two就行，因为two到n-1的区间已经确定为2元素  if nums[i] == 1{ i++ //1的范围是由two和zero决定的，所以继续扫描就行  }else if nums[i] == 2{ two-- //先减一扩大two范围,再交换到two  nums[two],nums[i] = nums[i],nums[two] //i++ two所在元素未确定，i不能继续前进  }else {//为0的情况  zero++ nums[zero],nums[i] = nums[i],nums[zero] i++ //zero找到正确的位置，i继续前进  } } }   力扣88. 合并两个有序数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  func merge(nums1 []int, m int, nums2 []int, n int) { //双指针,一个指针指向nums1,一个指针指向nums2  if m == 0{ //  for i:=0;i\u0026lt;len(nums2);i++{ nums1[i] = nums2[i] } return } if n == 0{ return } for m \u0026gt; 0 \u0026amp;\u0026amp; n \u0026gt; 0{ if nums2[n-1] \u0026gt;= nums1[m-1]{ nums1[n+m-1] = nums2[n-1] n-- }else{ nums1[n+m-1] = nums1[m-1] m-- } } for n \u0026gt; 0{//将nums2数组的数补到nums1数组里  nums1[n+m-1] = nums2[n-1] n-- } }   力扣215. 数组中的第K个最大元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  func findKthLargest(nums []int, k int) int { //快排 \tif len(nums) == 1 { return nums[0] } return quickSort(nums, 0, len(nums)-1, len(nums)-k) } func quickSort(nums []int, start, end, k int) int { middle := partition(nums, start, end, k) if middle == k { return nums[middle] } else if middle \u0026lt; k { return quickSort(nums, middle+1, end, k) } else { return quickSort(nums, start, middle-1, k) } } func partition(nums []int, start, end, k int) int { //为基数寻找最佳位置 \tif start \u0026gt;= end { return start } selectMedium(nums,start,end) pivot := nums[start] low := start high := end //挖坑法  for low \u0026lt; high{ for low \u0026lt; high \u0026amp;\u0026amp; nums[high] \u0026gt;= pivot{ high-- } if low \u0026lt; high{ nums[low],nums[high] = nums[high],nums[low] low++ } for low \u0026lt; high \u0026amp;\u0026amp; nums[low] \u0026lt;= pivot{ low++ } if low \u0026lt; high{ nums[high],nums[low] = nums[low],nums[high] high-- } } nums[high] = pivot return high } func selectMedium(nums []int, i, j int){ medium := (i + j) / 2 //直接按照中，小，大排序 \tif nums[i] \u0026lt; nums[medium] { nums[i], nums[medium] = nums[medium], nums[i] } if nums[i] \u0026gt; nums[j] { nums[i], nums[j] = nums[j], nums[i] } if nums[medium] \u0026gt; nums[j] { nums[j], nums[medium] = nums[medium], nums[j] } }   力扣167. 两数之和 II - 输入有序数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func twoSum(numbers []int, target int) []int { //对撞指针O(n)  i,j := 0,len(numbers)-1 // 两个指针的索引  for i != j{ if numbers[i] + numbers[j] == target{ //相等找到，直接返回  return []int{i+1,j+1} }else if numbers[i] + numbers[j] \u0026gt; target{ //如果大于，就缩小j  j-- }else{ //小于，i++  i++ } } return []int{} //不存在 }   力扣125. 验证回文串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  func isalnum(ch byte) bool { return (ch \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;Z\u0026#39;) || (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) } func isPalindrome(s string) bool { temp := []byte(strings.ToUpper(s)) //对撞指针 \tl, r := 0, len(temp)-1 for l \u0026lt; r { if !isalnum(temp[l]) { l++ //跳过该字符 \tcontinue } if !isalnum(temp[r]) { r-- //跳过该字符 \tcontinue } if temp[r] == temp[l] { //进行比较，不相等返回false \tl++ r-- } else { return false } } return true }   力扣344. 反转字符串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  func reverseString(s []byte) { //对撞指针  if len(s) == 0 || len(s) == 1{ return } l,r := 0,len(s)-1 //左右指针  for l \u0026lt; r{ //交换  if s[l] != s[r]{ s[l],s[r] = s[r],s[l] } l++ r-- } }   力扣345. 反转字符串中的元音字母\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  func judege(v byte) bool { //判断是不是元音字母 \tif v == \u0026#39;a\u0026#39; || v == \u0026#39;e\u0026#39; || v == \u0026#39;i\u0026#39; || v == \u0026#39;o\u0026#39; || v == \u0026#39;u\u0026#39; { return true } if v == \u0026#39;A\u0026#39; || v == \u0026#39;E\u0026#39; || v == \u0026#39;I\u0026#39; || v == \u0026#39;O\u0026#39; || v == \u0026#39;U\u0026#39; { return true } return false } func reverseVowels(s string) string { res := []byte(s) //先转换成byte切片，方便交换数据 \tl, r := 0, len(s)-1 //对撞指针 \tfor l \u0026lt; r { for !judege(res[l]) \u0026amp;\u0026amp; l \u0026lt; r { //若不是元音字母，就后移指针 \tl++ } for !judege(res[r]) \u0026amp;\u0026amp; l \u0026lt; r{ // 若不是元音字母，就前移指针 \tr-- } //交换只有两种情况  //1.l,r分别指向两个元音字母  //2.l,r两个指针相遇  //所以不需要考虑交换错字母  res[l],res[r] = res[r],res[l]//交换两个元音字母  l++ r-- } return string(res) }   力扣11. 盛最多水的容器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  func maxArea(height []int) int { //采用对撞指针  l,r := 0,len(height)-1 res := 0 //记录最大的容器容量  curr := 0 //记录遍历的容器容量  for l \u0026lt; r{ if height[l] \u0026lt;= height[r]{//如果某一边直线要短一点就从那边开始移动指针，  curr = height[l] * (r-l) l++ }else{ curr = height[r] * (r-l) r-- } if res \u0026lt; curr{ //如果当前容量大于最大记录容量，则更新最大容量  res = curr } } return res }   总结：涉及知识点——对撞指针 ","description":"对撞指针","id":45,"section":"interview","tags":["算法"],"title":"慕课算法视频第三章第二节","uri":"https://xing-you-ji.github.io/interview/algorithm_interview/charpter3/2/"},{"content":"基础算法思路的应用（双索引技术——滑动窗口） 209. 长度最小的子数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  func minSubArrayLen(target int, nums []int) int { //滑动窗口  l,r := 0,-1 //nums[l,r]为滑动窗口  sum := 0 //窗口内数的数值之和  res := len(nums) + 1 //窗口内数的个数之和(最优解为个数最少且满足res\u0026gt;=target)  for l \u0026lt; len(nums){//滑动范围  if (r+1) \u0026lt; len(nums) \u0026amp;\u0026amp; sum \u0026lt; target{ //不满足条件，扩大窗口(r++)并考虑边界  r++ sum += nums[r] }else{ //满足条件，缩小窗口(l++)寻找最优解  sum -= nums[l] l++ } if sum \u0026gt;= target { //如果满足条件，判断res与当前区间的大小  if res \u0026gt; (r-l+1){ res = r-l+1 } } } if res == len(nums)+1{//说明不存在  return 0 } return res }   3. 无重复字符的最长子串\n先考虑如下点（通用字符串题）：\n-字符集？只有字母？数字+字母？ASCII？\n-大小写是否敏感？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  func lengthOfLongestSubstring(s string) int { //滑动窗口  var freq[128]int //字符出现频率  l,r := 0,-1 //窗口[l...r]  res := 0 for l \u0026lt; len(s){ if r+1 \u0026lt; len(s) \u0026amp;\u0026amp; freq[s[r+1]] == 0{ //注意边界，如果窗口的下一个字符符合，就加入窗口  r++//扩大窗口  freq[s[r]]++ //频率加一  }else{ //不符合要求，缩小窗口  freq[s[l]]-- l++ //缩小窗口  } if res \u0026lt; (r-l+1){ //更新结果  res = r-l+1 } } return res }   仔细咀嚼上面的代码（知道处理滑动窗口的边界问题，滑动窗口求值的更新问题，窗口扩大与缩小的情况）\n练习题：\n438. 找到字符串中所有字母异位词\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  func findAnagrams(s string, p string) []int { var freq [26]int //统计字符出现的频率  var need [26]int //统计p字符串各字符出现的频率  l,r := 0,-1 //[l...r]窗口  res := make([]int,0) for i:=0;i\u0026lt;len(p);i++{ need[p[i]-\u0026#39;a\u0026#39;]++ //频率++  } for l \u0026lt; len(s) { //窗口滑动范围  if r+1 \u0026lt; len(s) \u0026amp;\u0026amp; r-l+1\u0026lt;len(p){//len(p)大小为一个窗口  r++ //扩大窗口  freq[s[r]-\u0026#39;a\u0026#39;]++ //窗口内字符频率增加  }else{ freq[s[l]-\u0026#39;a\u0026#39;]-- //窗口内字符频率减少（准备缩小窗口）  l++ //缩小窗口  } if r - l + 1 == len(p) \u0026amp;\u0026amp; freq == need{ //判断窗口是否满足条件，若满足则更新结果  res = append(res, l) } } return res }   下面这题很值得多刷几遍\n76. 最小覆盖子串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  func minWindow(s string, t string) string { //优化滑动窗口  var freq [58]int var need [58]int valid := 0 //记录t字符串不同字符的个数  res := \u0026#34;\u0026#34; //返回结果  for i:=0;i\u0026lt;len(t);i++{ if need[t[i]-\u0026#39;A\u0026#39;] == 0{ valid++ //不同字符数量增加  } need[t[i]-\u0026#39;A\u0026#39;]++ } curr := 0 //记录当前窗口里面包含t中不同字符的个数  l,r := 0,-1 //窗口大小[l...r]  for l \u0026lt; len(s){ if (r+1)\u0026lt;len(s) \u0026amp;\u0026amp; valid != curr{ //保证r在扩大窗口之后不会越界  r++ //扩大窗口  freq[s[r]-\u0026#39;A\u0026#39;]++ //增大频率  if freq[s[r]-\u0026#39;A\u0026#39;] == need[s[r]-\u0026#39;A\u0026#39;]{ curr++ //若两个表的值想等，则curr加一  } }else{ freq[s[l]-\u0026#39;A\u0026#39;] -- //减少频率  if freq[s[l]-\u0026#39;A\u0026#39;] \u0026lt; need[s[l]-\u0026#39;A\u0026#39;]{ //更新匹配条件curr  curr-- } l++ //缩小窗口  } if curr == valid{ //更新结果的两种情况：  //1.结果仍然为空字符串  //2.结果比当前成功匹配的窗口大小要大  if res == \u0026#34;\u0026#34; || len(res) \u0026gt; (r-l+1){ res = s[l:r+1] //切片切取的方式来更新  } } } return res }   ","description":"滑动窗口","id":46,"section":"interview","tags":["算法"],"title":"慕课算法视频第三章第三节","uri":"https://xing-you-ji.github.io/interview/algorithm_interview/charpter3/3/"},{"content":"冒泡排序是入门级的算法，但也有一些有趣的玩法。通常来说，冒泡排序有三种写法：\n 一边比较一边向后两两交换，将最大值 / 最小值冒泡到最后一位； 经过优化的写法：使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序； 进一步优化的写法：除了使用变量记录当前轮次是否发生交换外，再使用一个变量记录上次发生交换的位置，下一轮排序时到达上次交换的位置就停止比较。  先来看看冒泡排序的动图吧！\n  冒泡排序的第一种写法 golang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  //升序排序 func swap(arr []int, i, j int) { //交换元素（异或） \tarr[i] = arr[i] ^ arr[j] arr[j] = arr[j] ^ arr[i] arr[i] = arr[i] ^ arr[j] } func bubbleSort(arr []int) { for i := 0; i \u0026lt; len(arr)-1; i++ { for j := 0; j \u0026lt; len(arr)-i-1; j++ { if arr[j] \u0026gt; arr[j+1] { swap(arr, j, j+1) } } } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public static void bubbleSort(int[] arr) { for (int i = 0; i \u0026lt; arr.length - 1; i++) { for (int j = 0; j \u0026lt; arr.length - 1 - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { // 如果左边的数大于右边的数，则交换，保证右边的数字最大  swap(arr, j, j + 1); } } } } // 交换元素 private static void swap(int[] arr, int i, int j) { arr[i] = arr[i] ^ arr[j]; arr[j] = arr[j] ^ arr[i]; arr[i] = arr[i] ^ arr[j]; }    \r  'use strict'; var containerId = JSON.parse(\"\\\"11d40e291bbe59e4\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  冒泡排序的第二种写法 golang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  func swap(arr []int, i, j int) { //交换元素（异或）  arr[i] = arr[i] ^ arr[j] arr[j] = arr[j] ^ arr[i] arr[i] = arr[i] ^ arr[j] } //经过优化的写法：使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序； func bubbleSort(arr []int) { swapped := true //记录是否发生交换  for i := 0; i \u0026lt; len(arr)-1; i++ { if !swapped { //若上一轮未发生交换，就退出排序  break } swapped = false for j := 0; j \u0026lt; len(arr)-i-1; j++ { if arr[j] \u0026gt; arr[j+1] { swap(arr, j, j+1) swapped = true //发生交换  } } } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  public static void bubbleSort(int[] arr) { // 初始时 swapped 为 true，否则排序过程无法启动  boolean swapped = true; for (int i = 0; i \u0026lt; arr.length - 1; i++) { // 如果没有发生过交换，说明剩余部分已经有序，排序完成  if (!swapped) break; // 设置 swapped 为 false，如果发生交换，则将其置为 true  swapped = false; for (int j = 0; j \u0026lt; arr.length - 1 - i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { // 如果左边的数大于右边的数，则交换，保证右边的数字最大  swap(arr, j, j + 1); // 表示发生了交换  swapped = true; } } } } // 交换元素 private static void swap(int[] arr, int i, int j) { arr[i] = arr[i] ^ arr[j]; arr[j] = arr[j] ^ arr[i]; arr[i] = arr[i] ^ arr[j]; }    \r  'use strict'; var containerId = JSON.parse(\"\\\"cb7ba0884cd42a5f\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  冒泡排序的第三种写法 golang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  func swap(arr []int, i, j int) { //交换元素（异或）  arr[i] = arr[i] ^ arr[j] arr[j] = arr[j] ^ arr[i] arr[i] = arr[i] ^ arr[j] } //进一步优化的写法：除了使用变量记录当前轮次是否发生交换外， //再使用一个变量记录上次发生交换的位置，下一轮排序时到达上次交换的位置就停止比较 func bubbleSort(arr []int) { swapped := true //记录是否发生交换  indexOfLastUnsortedElement := len(arr) - 1 // 上次发生交换的位置  swappedIndex := -1 for swapped { swapped = false for i := 0; i \u0026lt; indexOfLastUnsortedElement; i++ { if arr[i] \u0026gt; arr[i+1] { swap(arr, i, i+1) swapped = true //发生交换  swappedIndex = i } } indexOfLastUnsortedElement = swappedIndex } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  public static void bubbleSort(int[] arr) { boolean swapped = true; // 最后一个没有经过排序的元素的下标  int indexOfLastUnsortedElement = arr.length - 1; // 上次发生交换的位置  int swappedIndex = -1; while (swapped) { swapped = false; for (int i = 0; i \u0026lt; indexOfLastUnsortedElement; i++) { if (arr[i] \u0026gt; arr[i + 1]) { // 如果左边的数大于右边的数，则交换，保证右边的数字最大  swap(arr, i, i + 1); // 表示发生了交换  swapped = true; // 更新交换的位置  swappedIndex = i; } } // 最后一个没有经过排序的元素的下标就是最后一次发生交换的位置  indexOfLastUnsortedElement = swappedIndex; } } // 交换元素 private static void swap(int[] arr, int i, int j) { arr[i] = arr[i] ^ arr[j]; arr[j] = arr[j] ^ arr[i]; arr[i] = arr[i] ^ arr[j]; }    \r  'use strict'; var containerId = JSON.parse(\"\\\"5576f180133eaf72\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  时间复杂度 \u0026amp; 空间复杂度 冒泡排序从 1956 年就有人开始研究，之后经历过多次优化。它的空间复杂度为 O(1)，时间复杂度为 O(n^2)，第二种、第三种冒泡排序由于经过优化，最好的情况下只需要 O(n)的时间复杂度。\n最好情况：在数组已经有序的情况下，只需遍历一次，由于没有发生交换，排序结束。\n最差情况：数组顺序为逆序，每次比较都会发生交换。\n但优化后的冒泡排序平均时间复杂度仍然是 O(n^2)，所以这些优化对算法的性能并没有质的提升。正如 Donald E. Knuth（1974 年图灵奖获得者）所言：“冒泡排序法除了它迷人的名字和导致了某些有趣的理论问题这一事实外，似乎没有什么值得推荐的。”\n不管怎么说，冒泡排序法是所有排序算法的老祖宗，如同程序界经典的 「Hello, world」 一般经久不衰，总是出现在各类算法书刊的首个章节。但面试时如果你说你只会冒泡排序可就太掉价了，下一节我们就来认识一下他的继承者们。\n稳定性 冒泡排序是稳定的。\n","description":"战略上藐视技术，战术上重视技术——闪客","id":47,"section":"interview","tags":["排序算法"],"title":"冒泡排序","uri":"https://xing-you-ji.github.io/interview/sort/bub/"},{"content":"选择排序的思想是：双重循环遍历数组，每经过一轮比较，找到最小元素的下标，将其交换至首位。\n选择排序就好比第一个数字站在擂台上，大吼一声：“还有谁比我小？”。剩余数字来挨个打擂，如果出现比第一个数字小的数，则新的擂主产生。每轮打擂结束都会找出一个最小的数，将其交换至首位。经过 n-1 轮打擂，所有的数字就按照从小到大排序完成了。\n先来看看选择排序的动图吧！\n  \n图中可以看出，每一轮排序都找到了当前的最小值，这个最小值就是被选中的数字，将其交换至本轮首位。这就是「选择排序法」名称的由来。\n正是由于它比较容易理解，许多初学者在排序时非常喜欢使用选择排序法。\n现在让我们思考一下，冒泡排序和选择排序有什么异同？\n相同点：\n 都是两层循环，时间复杂度都为 O(n^2); 都只使用有限个变量，空间复杂度 O(1)。  不同点：\n 冒泡排序在比较过程中就不断交换；而选择排序增加了一个变量保存最小值 / 最大值的下标，遍历完成后才交换，减少了交换次数。  事实上，冒泡排序和选择排序还有一个非常重要的不同点，那就是：\n 冒泡排序法是稳定的，选择排序法是不稳定的。  想要理解这点不同，我们先要知道什么是排序算法的稳定性。\n排序算法的稳定性 假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i] = r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的。 理解了稳定性的定义后，我们就能分析出：冒泡排序中，只有左边的数字大于右边的数字时才会发生交换，相等的数字之间不会发生交换，所以它是稳定的。\n而选择排序中，最小值和首位交换的过程可能会破坏稳定性。比如数列：[2, 2, 1]，在选择排序中第一次进行交换时，原数列中的两个 2 的相对顺序就被改变了，因此，我们说选择排序是不稳定的。\n那么排序算法的稳定性有什么意义呢？其实它只在一种情况下有意义：当要排序的内容是一个对象的多个属性，且其原本的顺序存在意义时，如果我们需要在二次排序后保持原有排序的意义，就需要使用到稳定性的算法。\n举个例子，如果我们要对一组商品排序，商品存在两个属性：价格和销量。当我们按照价格从高到低排序后，要再按照销量对其排序，这时，如果要保证销量相同的商品仍保持价格从高到低的顺序，就必须使用稳定性算法。\n当然，算法的稳定性与具体的实现有关。在修改比较的条件后，稳定性排序算法可能会变成不稳定的。如冒泡算法中，如果将「左边的数大于右边的数，则交换」这个条件修改为「左边的数大于或等于右边的数，则交换」，冒泡算法就变得不稳定了。\n同样地，不稳定排序算法也可以经过修改，达到稳定的效果。思考一下，选择排序算法如何实现稳定排序呢？\n实现的方式有很多种，这里给出一种最简单的思路：新开一个数组，将每轮找出的最小值依次添加到新数组中，选择排序算法就变成稳定的了。\n但如果将寻找最小值的比较条件由arr[minIndex] \u0026gt; arr[j]修改为arr[minIndex] \u0026gt;= arr[j]，即使新开一个数组，选择排序算法依旧是不稳定的。所以分析算法的稳定性时，需要结合具体的实现逻辑才能得出结论，我们通常所说的算法稳定性是基于一般实现而言的。\n选择排序的一般写法 golang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  func swap(arr []int, i, j int) { //交换元素（异或）  arr[i] = arr[i] ^ arr[j] arr[j] = arr[j] ^ arr[i] arr[i] = arr[i] ^ arr[j] } func selectionSort(arr []int) { for i := 0; i \u0026lt; len(arr)-1; i++ { minIndex := i for j := i + 1; j \u0026lt; len(arr); j++ { //因为minIndex起始是i，所有j比较从i+1开始  if arr[j] \u0026lt; arr[minIndex] { minIndex = j//记录最小数的下标  } } if minIndex != i { //因为采取的异或交换，若两个值相等，会变成0，所有进行判断  swap(arr, i, minIndex) } } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public static void selectionSort(int[] arr) { int minIndex; for (int i = 0; i \u0026lt; arr.length - 1; i++) { minIndex = i; for (int j = i + 1; j \u0026lt; arr.length; j++) { if (arr[minIndex] \u0026gt; arr[j]) { // 记录最小值的下标  minIndex = j; } } // 将最小元素交换至首位  int temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; } }    \r  'use strict'; var containerId = JSON.parse(\"\\\"07e37bc99face2db\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  二元选择排序 选择排序算法也是可以优化的，既然每轮遍历时找出了最小值，何不把最大值也顺便找出来呢？这就是二元选择排序的思想。\n使用二元选择排序，每轮选择时记录最小值和最大值，可以把数组需要遍历的范围缩小一倍。\n二元选择排序的一般写法 golang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  func swap(arr []int, i, j int) { //交换元素（异或）  arr[i] = arr[i] ^ arr[j] arr[j] = arr[j] ^ arr[i] arr[i] = arr[i] ^ arr[j] } func selectionSort(arr []int) { // i 只需要遍历一半  for i := 0; i \u0026lt; len(arr)/2; i++ { maxIndex := i minIndex := i for j := i + 1; j \u0026lt; len(arr)-i; j++ { if arr[j] \u0026lt; arr[minIndex] { minIndex = j } if arr[j] \u0026gt; arr[maxIndex] { maxIndex = j } } //如果 minIndex 和 maxIndex 都相等，那么他们必定都等于 i，且后面的所有数字都与 arr[i] 相等，此时已经排序完成  if minIndex == maxIndex { break } if arr[i] != arr[minIndex] { //因为采取的异或交换，若两个值相等，会变成0，所有进行判断  swap(arr, i, minIndex) // 将最小元素交换至首位  } if maxIndex == i { // 如果最大值的下标刚好是 i，由于 arr[i] 和 arr[minIndex] 已经交换了，所以这里要更新 maxIndex 的值。  maxIndex = minIndex } lastIndex := len(arr) - i - 1 //末尾下标  if arr[maxIndex] != arr[lastIndex] {//因为采取的异或交换，若两个值相等，会变成0，所有进行判断s  swap(arr, maxIndex, lastIndex) // 将最大元素交换至末尾  } } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  public static void selectionSort2(int[] arr) { int minIndex, maxIndex; // i 只需要遍历一半  for (int i = 0; i \u0026lt; arr.length / 2; i++) { minIndex = i; maxIndex = i; for (int j = i + 1; j \u0026lt; arr.length - i; j++) { if (arr[minIndex] \u0026gt; arr[j]) { // 记录最小值的下标  minIndex = j; } if (arr[maxIndex] \u0026lt; arr[j]) { // 记录最大值的下标  maxIndex = j; } } // 如果 minIndex 和 maxIndex 都相等，那么他们必定都等于 i，且后面的所有数字都与 arr[i] 相等，此时已经排序完成  if (minIndex == maxIndex) break; // 将最小元素交换至首位  int temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; // 如果最大值的下标刚好是 i，由于 arr[i] 和 arr[minIndex] 已经交换了，所以这里要更新 maxIndex 的值。  if (maxIndex == i) maxIndex = minIndex; // 将最大元素交换至末尾  int lastIndex = arr.length - 1 - i; temp = arr[lastIndex]; arr[lastIndex] = arr[maxIndex]; arr[maxIndex] = temp; } }    \r  'use strict'; var containerId = JSON.parse(\"\\\"e5b1191859abc166\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  我们使用 minIndex 记录最小值的下标，maxIndex 记录最大值的下标。每次遍历后，将最小值交换到首位，最大值交换到末尾，就完成了排序。\n由于每一轮遍历可以排好两个数字，所以最外层的遍历只需遍历一半即可。\n二元选择排序中有一句很重要的代码，它位于交换最小值和交换最大值的代码中间：\ngolang java  1 2 3  if maxIndex == i{ maxIndex = minIndex }    \r1  if (maxIndex == i) maxIndex = minIndex;    \r  'use strict'; var containerId = JSON.parse(\"\\\"3f962e8c68331abb\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  这行代码的作用处理了一种特殊情况：如果最大值的下标等于 i，也就是说 arr[i] 就是最大值，由于 arr[i] 是当前遍历轮次的首位，它已经和 arr[minIndex] 交换了，所以最大值的下标需要跟踪到 arr[i] 最新的下标 minIndex。\n二元选择排序的效率 在二元选择排序算法中，数组需要遍历的范围缩小了一倍。那么这样可以使选择排序的效率提升一倍吗？\n从代码可以看出，虽然二元选择排序最外层的遍历范围缩小了，但 for 循环内做的事情翻了一倍。也就是说二元选择排序无法将选择排序的效率提升一倍。但实测会发现二元选择排序的速度确实比选择排序的速度快一点点，它的速度提升主要是因为两点：\n 在选择排序的外层 for 循环中，i 需要加到 arr.length - 1 ，二元选择排序中 i 只需要加到 arr.length / 2 在选择排序的内层 for 循环中，j 需要加到 arr.length ，二元选择排序中 j 只需要加到 arr.length - i  时间复杂度 \u0026amp; 空间复杂度 前文已经说到，选择排序使用两层循环，时间复杂度为 O(n^2)，只使用有限个变量，空间复杂度 O(1)。二元选择排序虽然比选择排序要快，但治标不治本，二元选择排序中做的优化无法改变其时间复杂度，二元选择排序的时间复杂度仍然是 O(n^2)只使用有限个变量，空间复杂度 O(1)。\n稳定性 选择排序和二元选择排序都是不稳定的。\nTips：排序算法的稳定性与效率、可靠性都无关。 ","description":"战略上藐视技术，战术上重视技术——闪客","id":48,"section":"interview","tags":["排序算法"],"title":"选择排序","uri":"https://xing-you-ji.github.io/interview/sort/sel/"},{"content":"插入排序的思想非常简单，生活中有一个很常见的场景：在打扑克牌时，我们一边抓牌一边给扑克牌排序，每次摸一张牌，就将它插入手上已有的牌中合适的位置，逐渐完成整个排序。\n插入排序有两种写法：\n 交换法：在新数字插入过程中，不断与前面的数字交换，直到找到自己合适的位置。 移动法：在新数字插入过程中，与前面的数字不断比较，前面的数字不断向后挪出位置，当新数字找到自己的位置后，插入一次即可。  先来看看选择排序的动图吧！\n  交换法插入排序 当数字少于两个时，不存在排序问题，当然也不需要插入，所以我们直接从第二个数字开始往前插入。\n整个过程就像是已经有一些数字坐成了一排，这时一个新的数字要加入，这个新加入的数字原本坐在这一排数字的最后一位，然后它不断地与前面的数字比较，如果前面的数字比它大，它就和前面的数字交换位置。\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  func swap(arr []int, i, j int) { //交换元素（异或）  arr[i] = arr[i] ^ arr[j] arr[j] = arr[j] ^ arr[i] arr[i] = arr[i] ^ arr[j] } //交换法插入排序 func insertSort(arr []int) { // 从第二个数开始，往前插入数字  for i := 1; i \u0026lt; len(arr); i++ { // j 记录当前数字下标  j := i // 当前数字比前一个数字小，则将当前数字与前一个数字交换  for j \u0026gt;= 1 \u0026amp;\u0026amp; arr[j-1] \u0026gt; arr[j] { swap(arr, j-1, j) // 更新当前数字下标  j-- } } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public static void insertSort(int[] arr) { // 从第二个数开始，往前插入数字  for (int i = 1; i \u0026lt; arr.length; i++) { // j 记录当前数字下标  int j = i; // 当前数字比前一个数字小，则将当前数字与前一个数字交换  while (j \u0026gt;= 1 \u0026amp;\u0026amp; arr[j] \u0026lt; arr[j - 1]) { swap(arr, j, j - 1); // 更新当前数字下标  j--; } } } private static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; }    \r  'use strict'; var containerId = JSON.parse(\"\\\"1b30e58d3603c2c7\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  移动法插入排序 我们发现，在交换法插入排序中，每次交换数字时，swap 函数都会进行三次赋值操作。但实际上，新插入的这个数字并不一定适合与它交换的数字所在的位置。也就是说，它刚换到新的位置上不久，下一次比较后，如果又需要交换，它马上又会被换到前一个数字的位置。\n由此，我们可以想到一种优化方案：让新插入的数字先进行比较，前面比它大的数字不断向后移动，直到找到适合这个新数字的位置后，新数字只做一次插入操作即可。\n这种方案我们需要把新插入的数字暂存起来，代码如下：\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  func insertSort(arr []int) { // 从第二个数开始，往前插入数字  for i := 1; i \u0026lt; len(arr); i++ { currentNumber := arr[i] j := i - 1 // 寻找插入位置的过程中，不断地将比 currentNumber 大的数字向后挪  for j \u0026gt;= 0 \u0026amp;\u0026amp; currentNumber \u0026lt; arr[j] { arr[j+1] = arr[j] //更新下标  j-- } // 两种情况会跳出循环：1. 遇到一个小于或等于 currentNumber 的数字，跳出循环，currentNumber 就坐到它后面。  // 2. 已经走到数列头部，仍然没有遇到小于或等于 currentNumber 的数字，也会跳出循环，此时 j 等于 -1，currentNumber 就坐到数列头部。  arr[j+1] = currentNumber }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public static void insertSort(int[] arr) { // 从第二个数开始，往前插入数字  for (int i = 1; i \u0026lt; arr.length; i++) { int currentNumber = arr[i]; int j = i - 1; // 寻找插入位置的过程中，不断地将比 currentNumber 大的数字向后挪  while (j \u0026gt;= 0 \u0026amp;\u0026amp; currentNumber \u0026lt; arr[j]) { arr[j + 1] = arr[j]; j--; } // 两种情况会跳出循环：1. 遇到一个小于或等于 currentNumber 的数字，跳出循环，currentNumber 就坐到它后面。  // 2. 已经走到数列头部，仍然没有遇到小于或等于 currentNumber 的数字，也会跳出循环，此时 j 等于 -1，currentNumber 就坐到数列头部。  arr[j + 1] = currentNumber; } }    \r  'use strict'; var containerId = JSON.parse(\"\\\"2f1251652e6dcf40\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  整个过程就像是已经有一些数字坐成了一排，这时一个新的数字要加入，所以这一排数字不断地向后腾出位置，当新的数字找到自己合适的位置后，就可以直接坐下了。重复此过程，直到排序结束。\n时间复杂度 \u0026amp; 空间复杂度 插入排序过程需要两层循环，时间复杂度为 O(n^2)，只需要常量级的临时变量，空间复杂度为 O(1)。\n稳定性 插入排序的过程不会破坏原有数组中相同关键字的相对次序，所以插入排序是一种稳定的排序算法。\n","description":"战略上藐视技术，战术上重视技术——闪客","id":49,"section":"interview","tags":["排序算法"],"title":"插入排序","uri":"https://xing-you-ji.github.io/interview/sort/ins/"},{"content":"冒泡排序 冒泡排序有两种优化方式：\n 记录当前轮次是否发生过交换，没有发生过交换表示数组已经有序； 记录上次发生交换的位置，下一轮排序时只比较到此位置。  选择排序 选择排序可以演变为二元选择排序：\n 二元选择排序：一次遍历选出两个值——最大值和最小值； 二元选择排序剪枝优化：当某一轮遍历出现最大值和最小值相等，表示数组中剩余元素已经全部相等。  插入排序 插入排序有两种写法：\n 交换法：新数字通过不断交换找到自己合适的位置； 移动法：旧数字不断向后移动，直到新数字找到合适的位置。  相同点  时间复杂度都是 O(n^2),空间复杂度都是 O(1)。 都需要采用两重循环。  不同点  选择排序是不稳定的，冒泡排序、插入排序是稳定的； 在这三个排序算法中，选择排序交换的次数是最少的； 在数组几乎有序的情况下，插入排序的时间复杂度接近线性级别。  ","description":"战略上藐视技术，战术上重视技术——闪客","id":50,"section":"interview","tags":["排序算法"],"title":"O(n^2)排序算法的小结","uri":"https://xing-you-ji.github.io/interview/sort/conclusion1/"},{"content":"1959 年 77 月，美国辛辛那提大学的数学系博士 Donald Shell 在 《ACM 通讯》上发表了希尔排序算法，成为首批将时间复杂度降到 O(n^2)以下的算法之一。虽然原始的希尔排序最坏时间复杂度仍然是 O(n^2) ，但经过优化的希尔排序可以达到 O(n^(1.3))甚至 O(n^(7/6))。\n略为遗憾的是，所谓「一将功成万骨枯」，希尔排序和冒泡、选择、插入等排序算法一样，逐渐被快速排序所淘汰，但作为承上启下的算法，不可否认的是，希尔排序身上始终闪耀着算法之美。\n希尔排序本质上是对插入排序的一种优化，它利用了插入排序的简单，又克服了插入排序每次只交换相邻两个元素的缺点。它的基本思想是：\n 将待排序数组按照一定的间隔分为多个子数组，每组分别进行插入排序。这里按照间隔分组指的不是取连续的一段数组，而是每跳跃一定间隔取一个值组成一组 逐渐缩小间隔进行下一轮排序 最后一轮时，取间隔为 1，也就相当于直接使用插入排序。但这时经过前面的「宏观调控」，数组已经基本有序了，所以此时的插入排序只需进行少量交换便可完成  举个例子，对数组 [84, 83, 88, 87, 61, 50, 70, 60, 80, 99]进行希尔排序的过程如下：\n 第一遍（5间隔排序）：按照间隔 5分割子数组，共分成五组，分别[84, 50], [83, 70], [88, 60], [87, 80], [61, 99] 。对它们进行插入排序，排序后它们分别变成：[50, 84], [70, 83], [60, 88], [80, 87], [61, 99]。此时整个数组变成 [50, 70, 60, 80, 61, 84, 83, 88, 87, 99]。 第二遍（2间隔排序）：按照间隔 2分割子数组，共分成两组，分别是 [50, 60, 61, 83, 87], [70, 80, 84, 88, 99]。对他们进行插入排序，排序后它们分别变成： [50, 60, 61, 83, 87], [70, 80, 84, 88, 99]，此时整个数组变成[50, 70, 60, 80, 61, 84, 83, 88, 87, 99]。这里有一个非常重要的性质：当我们完成2间隔排序后，这个数组仍然是保持 5间隔有序的。也就是说，更小间隔的排序没有把上一步的结果变坏。 第三遍（1间隔排序，等于直接插入排序）：按照间隔 1分割子数组，分成一组，也就是整个数组。对其进行插入排序，经过前两遍排序，数组已经基本有序了，所以这一步只需经过少量交换即可完成排序。排序后数组变成 [50, 60, 61, 70, 80, 83, 84, 87, 88, 99]，整个排序完成。  先来看看希尔排序的动图吧！\n  \n其中，每一遍排序的间隔在希尔排序中被称之为增量，所有的增量组成的序列称之为增量序列，也就是本例中的 [5, 2, 1][5,2,1]。增量依次递减，最后一个增量必须为 11，所以希尔排序又被称之为「缩小增量排序」。要是以专业术语来描述希尔排序，可以分为以下两个步骤：\n  定义增量序列 D_m \u0026gt; D_{m-1} \u0026gt; D_{m-2} \u0026gt; \u0026hellip; \u0026gt; D_1 = 1\n  对每个 D_k进行[D_k间隔排序]\n  有一条非常重要的性质保证了希尔排序的效率：\n [D_{k+1}间隔]有序的序列，在经过[D_k间隔]排序后，仍然是 [D_{k+1}间隔]有序的\n  增量序列的选择会极大地影响希尔排序的效率，我们采用的增量序列为 D_m = N/2, D_k = D_{k+1} / 2,这个序列正是当年希尔发表此算法的论文时选用的序列，所以也被称之为希尔增量序列\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  func shellSort(arr []int){ //生成间隔序列，在希尔排序中我们称之为增量序列  for gap:=len(arr)/2;gap\u0026gt;0;gap/=2{ //将一个数组转换成gap个数组（每一个数组各个元素之间的距离相差gap）  for groupStartIndex:=0;groupStartIndex\u0026lt;gap;groupStartIndex++{\t//插入排序(i:=groupStartIndex+gap就相当于插入排序的i:=1)  for i:=groupStartIndex+gap;i\u0026lt;len(arr);i+=gap{ currentNumber:=arr[i] j:=i-gap for j \u0026gt;=0 \u0026amp;\u0026amp; currentNumber \u0026lt; arr[j]{ arr[j+gap] = arr[j] j -= gap } arr[j+gap] = currentNumber }\t} } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public static void shellSort(int[] arr) { // 间隔序列，在希尔排序中我们称之为增量序列  for (int gap = arr.length / 2; gap \u0026gt; 0; gap /= 2) { // 分组  for (int groupStartIndex = 0; groupStartIndex \u0026lt; gap; groupStartIndex++) { // 插入排序  for (int currentIndex = groupStartIndex + gap; currentIndex \u0026lt; arr.length; currentIndex += gap) { // currentNumber 站起来，开始找位置  int currentNumber = arr[currentIndex]; int preIndex = currentIndex - gap; while (preIndex \u0026gt;= groupStartIndex \u0026amp;\u0026amp; currentNumber \u0026lt; arr[preIndex]) { // 向后挪位置  arr[preIndex + gap] = arr[preIndex]; preIndex -= gap; } // currentNumber 找到了自己的位置，坐下  arr[preIndex + gap] = currentNumber; } } } }    \r  'use strict'; var containerId = JSON.parse(\"\\\"3d319c5eac986c42\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  这段代码可以优化一下。我们现在的处理方式是：处理完一组间隔序列后，再回来处理下一组间隔序列，这非常符合人类思维。但对于计算机来说，它更喜欢从第 gap 个元素开始，按照顺序将每个元素依次向前插入自己所在的组这种方式。虽然这个过程看起来是在不同的间隔序列中不断跳跃，但站在计算机的角度，它是在访问一段连续数组。\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func shellSort(arr []int){ //创建 间隔序列（增量序列）  for gap:=len(arr)/2;gap\u0026gt;0;gap/=2{ for i:=gap;i\u0026lt;len(arr);i++{ currentNumber := arr[i]//记录当前需要插入的数  j := i-gap//记录当前下标的前一个下标  for j\u0026gt;=0 \u0026amp;\u0026amp; arr[j] \u0026gt; currentNumber{ arr[j+gap] = arr[j] //后移元素  j -= gap //更新下标  } arr[j+gap] = currentNumber } } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public static void shellSort(int[] arr) { // 间隔序列，在希尔排序中我们称之为增量序列  for (int gap = arr.length / 2; gap \u0026gt; 0; gap /= 2) { // 从 gap 开始，按照顺序将每个元素依次向前插入自己所在的组  for (int i = gap; i \u0026lt; arr.length; i++) { // currentNumber 站起来，开始找位置  int currentNumber = arr[i]; // 该组前一个数字的索引  int preIndex = i - gap; while (preIndex \u0026gt;= 0 \u0026amp;\u0026amp; currentNumber \u0026lt; arr[preIndex]) { // 向后挪位置  arr[preIndex + gap] = arr[preIndex]; preIndex -= gap; } // currentNumber 找到了自己的位置，坐下  arr[preIndex + gap] = currentNumber; } } }    \r  'use strict'; var containerId = JSON.parse(\"\\\"55228ab2717acfc6\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  经过优化之后，这段代码看起来就和插入排序非常相似了，区别仅在于希尔排序最外层嵌套了一个缩小增量的 for 循环；并且插入时不再是相邻数字挪动，而是以增量为步长挪动。\n增量序列 增量序列的选择会极大地影响希尔排序的效率。增量序列如果选得不好，希尔排序的效率可能比插入排序效率还要低，举个例子：\n  \n在这个例子中，我们发现，原数组 8 间隔、4 间隔、2 间隔都已经有序了，使用希尔排序时，真正起作用的只有最后一轮 1 间隔排序，也就是直接插入排序。希尔排序反而比直接使用插入排序多执行了许多无用的逻辑。\n于是人们发现：增量元素不互质，则小增量可能根本不起作用。\n事实上，希尔排序的增量序列如何选择是一个数学界的难题，但它也是希尔排序算法的核心优化点。数学界有不少的大牛做过这方面的研究。比较著名的有 Hibbard 增量序列、Knuth 增量序列、Sedgewick 增量序列。\n  Hibbard 增量序列：D_k = 2^k - 1,也就是1, 3, 7, 15,\u0026hellip;。数学界猜想它最坏的时间复杂度为 O(n^(3/2))，平均时间复杂度为 O(n^(5/4));\n  Knuth 增量序列：D_1 = 1; D_{k+1} = 3 * D_{k + 1},也就是1, 4, 13, 40, \u0026hellip;,数学界猜想它的平均时间复杂度为 O(n^(3/2))\n  Sedgewick 增量序列：1,5,19,41,109,\u0026hellip;,这个序列的元素有的是通过 9 * 4^k - 9 * 2^k + 1 计算出来的，有的是通过 4^k - 3 * 2^k + 1 计算出来的。数学界猜想它最坏的时间复杂度为 O(n^(4/3)),平均时间复杂度为 O(n^(7/6)).\n  使用 Knuth 序列进行希尔排序的代码如下：\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  func shellSort(arr []int){ // 找到当前数组需要用到的 Knuth 序列中的最大值  maxKnuthNumber := 1; for maxKnuthNumber \u0026lt;= len(arr) / 3 { maxKnuthNumber = maxKnuthNumber * 3 + 1 } //创建 间隔序列（增量序列）  for gap:=maxKnuthNumber;gap\u0026gt;0;gap = (gap-1)/3{ // 从 gap 开始，按照顺序将每个元素依次向前插入自己所在的组  for i:=gap;i\u0026lt;len(arr);i++{ currentNumber := arr[i] j := i - gap //记录当前元素下标的上一个下标  for j\u0026gt;=0 \u0026amp;\u0026amp; arr[j] \u0026gt; currentNumber{ arr[j+gap] = arr[j] //后移元素  j -= gap //更新下标  } arr[j+gap] = currentNumber } } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  public static void shellSortByKnuth(int[] arr) { // 找到当前数组需要用到的 Knuth 序列中的最大值  int maxKnuthNumber = 1; while (maxKnuthNumber \u0026lt;= arr.length / 3) { maxKnuthNumber = maxKnuthNumber * 3 + 1; } // 增量按照 Knuth 序列规则依次递减  for (int gap = maxKnuthNumber; gap \u0026gt; 0; gap = (gap - 1) / 3) { // 从 gap 开始，按照顺序将每个元素依次向前插入自己所在的组  for (int i = gap; i \u0026lt; arr.length; i++) { // currentNumber 站起来，开始找位置  int currentNumber = arr[i]; // 该组前一个数字的索引  int preIndex = i - gap; while (preIndex \u0026gt;= 0 \u0026amp;\u0026amp; currentNumber \u0026lt; arr[preIndex]) { // 向后挪位置  arr[preIndex + gap] = arr[preIndex]; preIndex -= gap; } // currentNumber 找到了自己的位置，坐下  arr[preIndex + gap] = currentNumber; } } }    \r  'use strict'; var containerId = JSON.parse(\"\\\"db6f142b4472f6ce\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  先根据数组的长度，计算出需要用到的 Knuth 序列中的最大增量值，然后根据 Knuth 序列的规则依次缩小增量，从高增量到低增量分别进行排序。\n使用 Knuth 序列的希尔排序，时间复杂度已经降到了 O(n^2)以下。但具体时间复杂度是多少，尚未有明确的证明，数学界仅仅是猜想它的平均时间复杂度为 O(n^(3/2))\n时间复杂度 \u0026amp; 空间复杂度 事实上，希尔排序时间复杂度非常难以分析，它的平均复杂度界于 O(n) 到 O(n^2)之间，普遍认为它最好的时间复杂度为 O(n^(1.3))，希尔排序的空间复杂度为O(1)只需要常数级的临时变量。\n稳定性 虽然插入排序是稳定的排序算法，但希尔排序是不稳定的。在增量较大时，排序过程可能会破坏原有数组中相同关键字的相对次序。\n希尔排序与 O(n^2)级排序算法的本质区别 相对于前面介绍的冒泡排序、选择排序、插入排序来说，希尔排序的排序过程显得较为复杂，希望读者还没有被绕晕。接下来我们来分析一个有趣的问题：希尔排序凭什么可以打破时间复杂度O(n^2)的魔咒呢？它和之前介绍的O(n^2)级排序算法的本质区别是什么？\n只要理解了这一点，我们就能知道为什么希尔排序能够承上启下，启发出之后的一系列 O(n^2)级以下的排序算法。\n这个问题我们可以用逆序对来理解。\n当我们从小到大排序时，在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。 排序算法本质上就是一个消除逆序对的过程。\n对于随机数组，逆序对的数量是 O(n^2)级的，如果采用「交换相邻元素」的办法来消除逆序对，每次最多只能消除一组逆序对，因此必须执行 O(n^2)级的交换次数，这就是为什么冒泡、插入、选择算法只能到 O(n^2)级的原因。反过来说，基于交换元素的排序算法要想突破 O(n^2)级，必须通过一些比较，交换间隔比较远的元素，使得一次交换能消除一个以上的逆序对。\n希尔排序算法就是通过这种方式，打破了在空间复杂度为 O(1)的情况下，时间复杂度为 O(n^2)的魔咒，此后的快排、堆排等等算法也都是基于这样的思路实现的。\n注：\n1.虽然约翰·冯·诺伊曼在 1945 年提出的归并排序已经达到了O(nlogn) 的时间复杂度，但归并排序的空间复杂度为 O(n)，采用的是空间换时间的方式突破 O(n^2)。\n2.希尔排序在面试或是实际应用中都很少遇到，读者仅需了解即可。\n ","description":"战略上藐视技术，战术上重视技术——闪客","id":51,"section":"interview","tags":["排序算法"],"title":"希尔排序","uri":"https://xing-you-ji.github.io/interview/sort/she/"},{"content":"数组、链表都是一维的数据结构，相对来说比较容易理解，而堆是二维的数据结构，对抽象思维的要求更高，所以许多程序员「谈堆色变」。但堆又是数据结构进阶必经的一步，我们不妨静下心来，将其梳理清楚。\n堆：符合以下两个条件之一的完全二叉树：\n 根节点的值 ≥ 子节点的值，这样的堆被称之为最大堆，或大顶堆（用于升序排序）； 根节点的值 ≤ 子节点的值，这样的堆被称之为最小堆，或小顶堆（用于降序排序）。     堆排序是由罗伯特·弗洛伊德(Robert W．Floyd）和威廉姆斯(J．Williams） 在1964年发明的。\n堆排序过程如下：\n 用数列构建出一个大顶堆，取出堆顶的数字； 调整剩余的数字，构建出新的大顶堆，再次取出堆顶的数字； 循环往复，完成整个排序。  整体的思路就是这么简单，我们需要解决的问题有两个：\n 如何用数列构建出一个大顶堆； 取出堆顶的数字后，如何将剩余的数字调整成新的大顶堆。  构建大顶堆 \u0026amp; 调整堆 构建大顶堆有两种方式：\n 方案一：从 0 开始，将每个数字依次插入堆中，一边插入，一边调整堆的结构，使其满足大顶堆的要求； 方案二：将整个数列的初始状态视作一棵完全二叉树，自底向上调整树的结构，使其满足大顶堆的要求。  方案二更为常用，动图演示如下：\n    \n在介绍堆排序具体实现之前，我们先要了解完全二叉树的几个性质。将根节点的下标视为 0，则完全二叉树有如下性质：\n 对于完全二叉树中的第 i 个数，它的左子节点下标：left = 2i + 1 对于完全二叉树中的第 i 个数，它的右子节点下标：right = left + 1 对于有 n 个元素的完全二叉树(n≥2)(n≥2)，它的最后一个非叶子结点的下标：n/2 - 1  \n堆排序代码如下：\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  func swap(arr []int, i, j int) { //交换元素（异或）  arr[i] = arr[i] ^ arr[j] arr[j] = arr[j] ^ arr[i] arr[i] = arr[i] ^ arr[j] } func heapSort(arr []int){ //如何用数列构建出一个大顶堆；  //取出堆顶的数字后，如何将剩余的数字调整成新的大顶堆。  // 构建初始大顶堆  buildMaxHeap(arr) for i:=len(arr)-1;i\u0026gt;0;i--{ swap(arr,0,i) //交换元素，使得当前堆最大的元素交换到堆的末尾  maxHeapify(arr,0,i) //从0第一个非叶子节点开始调整堆,用i是因为初建堆已经把堆的大小-1了  } } func buildMaxHeap(arr []int){ // 从最后一个非叶子结点开始调整大顶堆，最后一个非叶子结点的下标就是 arr.length / 2-1  for i := len(arr) / 2 - 1; i \u0026gt;= 0; i--{ //i--是为了不断从前面的非叶子节点调整堆  maxHeapify(arr,i,len(arr)) } } func maxHeapify(arr []int,index ,heapSize int){ // 左子结点下标  l := index*2+1 //当前调整堆节点的左子节点  // 右子结点下标  r := l+1 //当前调整堆节点的右子节点  // 记录根结点、左子树结点、右子树结点三者中的最大值下标  largest := index // 记录最大数的下标  // 与左子树结点比较  if l\u0026lt;heapSize \u0026amp;\u0026amp; arr[l]\u0026gt;arr[largest]{ largest = l } // 与右子树结点比较  if r\u0026lt;heapSize \u0026amp;\u0026amp; arr[r]\u0026gt;arr[largest]{ largest = r } //递归向下调整  if largest != index {//若不相等就说明  swap(arr,largest,index)//交换元素，使其符合大顶堆的性质  maxHeapify(arr,largest,heapSize) //递归，把最大元素和他的子树节点相比较，找出最大元素，  } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  public static void heapSort(int[] arr) { // 构建初始大顶堆  buildMaxHeap(arr); for (int i = arr.length - 1; i \u0026gt; 0; i--) { // 将最大值交换到数组最后  swap(arr, 0, i); // 调整剩余数组，使其满足大顶堆  maxHeapify(arr, 0, i); } } // 构建初始大顶堆 private static void buildMaxHeap(int[] arr) { // 从最后一个非叶子结点开始调整大顶堆，最后一个非叶子结点的下标就是 arr.length / 2-1  for (int i = arr.length / 2 - 1; i \u0026gt;= 0; i--) { maxHeapify(arr, i, arr.length); } } // 调整大顶堆，第三个参数表示剩余未排序的数字的数量，也就是剩余堆的大小 private static void maxHeapify(int[] arr, int i, int heapSize) { // 左子结点下标  int l = 2 * i + 1; // 右子结点下标  int r = l + 1; // 记录根结点、左子树结点、右子树结点三者中的最大值下标  int largest = i; // 与左子树结点比较  if (l \u0026lt; heapSize \u0026amp;\u0026amp; arr[l] \u0026gt; arr[largest]) { largest = l; } // 与右子树结点比较  if (r \u0026lt; heapSize \u0026amp;\u0026amp; arr[r] \u0026gt; arr[largest]) { largest = r; } if (largest != i) { // 将最大值交换为根结点  swap(arr, i, largest); // 再次调整交换数字后的大顶堆  maxHeapify(arr, largest, heapSize); } } private static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; }    \r  'use strict'; var containerId = JSON.parse(\"\\\"1538b94d2f08f3e9\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  堆排序的第一步就是构建大顶堆，对应代码中的buildMaxHeap 函数。我们将数组视作一颗完全二叉树，从它的最后一个非叶子结点开始，调整此结点和其左右子树，使这三个数字构成一个大顶堆。\n需要注意的是，如果根结点和左右子树结点任何一个数字发生了交换，则还需要保证调整后的子树仍然是大顶堆，所以子树会执行一个递归的调整过程。\n注：在有的文章中，作者将堆的根节点下标视为 1，这样做的好处是使得第 i 个结点的左子结点下标为 2i，右子结点下标为 2i + 1，与 2i + 1 和 2i + 2 相比，计算量会少一点，本文未采取这种实现，但两种实现思路的核心思想都是一致的。 时间复杂度 \u0026amp; 空间复杂度 堆排序分为两个阶段：初始化建堆（buildMaxHeap）和重建堆（maxHeapify，直译为大顶堆化）。所以时间复杂度要从这两个方面分析。\n根据数学运算可以推导出初始化建堆的时间复杂度为O(n)，重建堆的时间复杂度为O(nlogn)，所以堆排序总的时间复杂度为O(nlogn)。\n堆排序的空间复杂度为 O(1)O(1)，只需要常数级的临时变量。\n稳定性 堆排序在进行层层比较的时候可能会破坏原有数组中相同关键字的相对次序，所以堆排序是不稳定的排序算法。\n","description":"战略上藐视技术，战术上重视技术——闪客","id":52,"section":"interview","tags":["排序算法"],"title":"堆排序","uri":"https://xing-you-ji.github.io/interview/sort/heap/"},{"content":"快速排序算法由 C. A. R. Hoare 在 1960 年提出。它的时间复杂度也是 O(nlogn)，但它在时间复杂度为O(nlogn)级的几种排序算法中，大多数情况下效率更高，所以快速排序的应用非常广泛。再加上快速排序所采用的分治思想非常实用，使得快速排序深受面试官的青睐，所以掌握快速排序的思想尤为重要。\n快速排序算法的基本思想是：\n 从数组中取出一个数，称之为基数（pivot） 遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域 将左右两个区域视为两个数组，重复前两个步骤，直到排序完成  \n事实上，快速排序的每一次遍历，都将基数摆到了最终位置上。第一轮遍历排好 1 个基数，第二轮遍历排好 2 个基数（每个区域一个基数，但如果某个区域为空，则此轮只能排好一个基数），第三轮遍历排好 4 个基数（同理，最差的情况下，只能排好一个基数），以此类推。总遍历次数为 logn～n 次，每轮遍历的时间复杂度为O(n)，所以很容易分析出快速排序的时间复杂度为 O(nlogn)～ O(n^2)平均时间复杂度为O(nlogn)。\n让我们来看一下快速排序的动图吧  快速排序递归框架 根据我们分析出的思路，先搭出快速排序的架子：\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14  func quickSort(arr []int) { quickSortRecursion(arr, 0, len(arr) - 1); } func quickSortRecursion(arr []int, start, end int) { // 将数组分区，并获得中间值的下标  middle := partition(arr, start, end); // 对左边区域快速排序  quickSort(arr, start, middle - 1); // 对右边区域快速排序  quickSort(arr, middle + 1, end); } partition(arr []int,start,end int)int{ // TODO: 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标 }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14  public static void quickSort(int[] arr) { quickSort(arr, 0, arr.length - 1); } public static void quickSort(int[] arr, int start, int end) { // 将数组分区，并获得中间值的下标  int middle = partition(arr, start, end); // 对左边区域快速排序  quickSort(arr, start, middle - 1); // 对右边区域快速排序  quickSort(arr, middle + 1, end); } public static int partition(int[] arr, int start, int end) { // TODO: 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标 }    \r  'use strict'; var containerId = JSON.parse(\"\\\"c1a1b6b331f34219\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  partition 意为“划分”，我们期望 partition 函数做的事情是：将 arr 从 start 到 end 这一区间的值分成两个区域，左边区域的每个数都比基数小，右边区域的每个数都比基数大，然后返回中间值的下标。\n只要有了这个函数，我们就能写出快速排序的递归函数框架。首先调用 partition 函数得到中间值的下标 middle，然后对左边区域执行快速排序，也就是递归调用 quickSort(arr, start, middle - 1)，再对右边区域执行快速排序，也就是递归调用 quickSort(arr, middle + 1, end)。\n现在还有一个问题，何时退出这个递归函数呢？\n退出递归的边界条件 很容易想到，当某个区域只剩下一个数字的时候，自然不需要排序了，此时退出递归函数。实际上还有一种情况，就是某个区域只剩下 0 个数字时，也需要退出递归函数。当 middle 等于 start 或者 end 时，就会出现某个区域剩余数字为 0。\n所以我们可以通过这种方式退出递归函数：\ngolang java  1 2 3 4 5 6 7 8 9  func quickSortRecurison(arr []int,start,end int){ middle := partition(arr,start,end) if start != middle \u0026amp;\u0026amp; start != middle-1{ quickSortRecurison(arr,start,middle-1) } if end != middle \u0026amp;\u0026amp; end != middle+1{ quickSortRecurison(arr,middle+1,end) } }    \r1 2 3 4 5 6 7 8  public static void quickSort(int[] arr, int start, int end) { // 将数组分区，并获得中间值的下标  int middle = partition(arr, start, end); // 当左边区域中至少有 2 个数字时，对左边区域快速排序  if (start != middle \u0026amp;\u0026amp; start != middle - 1) quickSort(arr, start, middle - 1); // 当右边区域中至少有 2 个数字时，对右边区域快速排序  if (middle != end \u0026amp;\u0026amp; middle != end - 1) quickSort(arr, middle + 1, end); }    \r  'use strict'; var containerId = JSON.parse(\"\\\"c97cffbc7a1581cd\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \n在递归之前，先判断此区域剩余数字是否为 0 个或者 1 个，当数字至少为 2 个时，才执行这个区域的快速排序。因为我们知道 middle \u0026gt;= start \u0026amp;\u0026amp; middle \u0026lt;= end 必然成立，所以判断剩余区域的数字为 0 个或者 1 个也就是指 start 或 end 与 middle 相等或相差 1。\n我们来分析一下这四个判断条件：\n当 start == middle 时，相当于 quickSort(arr, start, middle - 1) 中的 start == end + 1\n当 start == middle - 1 时，相当于 quickSort(arr, start, middle - 1) 中的 start == end\n当 middle == end时，相当于 quickSort(arr, middle + 1, end) 中的 start == end + 1\n当 middle == end -1时，相当于 quickSort(arr, middle + 1, end) 中的 start == end\n综上，我们可以将此边界条件统一移到 quickSort 函数之前：\ngolang java  1 2 3 4 5 6 7 8  func quickSortRecurison(arr []int,start,end int){ if start == end || start = end + 1{ return } middle = partition(arr,start,end) quickSortRecurison(arr,start,middle-1) qucikSortRecurison(arr,midlle+1,end) }    \r1 2 3 4 5 6 7 8 9 10  public static void quickSort(int[] arr, int start, int end) { // 如果区域内的数字少于 2 个，退出递归  if (start == end || start == end + 1) return; // 将数组分区，并获得中间值的下标  int middle = partition(arr, start, end); // 对左边区域快速排序  quickSort(arr, start, middle - 1); // 对右边区域快速排序  quickSort(arr, middle + 1, end); }    \r  'use strict'; var containerId = JSON.parse(\"\\\"bc4ed1210b4bd485\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  更进一步，由上文所说的 middle \u0026gt;= start \u0026amp;\u0026amp; middle \u0026lt;= end 可以推出，除了start == end || start == end + 1这两个条件之外，其他的情况下 start 都小于 end。所以我们可以将这个判断条件再次简写为：\ngolang java  1 2 3 4 5 6 7 8  func quickSortRecurison(arr []int,start,end int){ if start \u0026gt;= end{ return } middle := partition(arr,start,end) quickSortRecurison(arr,start,middle-1) quickSortRecursion(arr,midlle+1,end) }    \r1 2 3 4 5 6 7 8 9 10  public static void quickSort(int[] arr, int start, int end) { // 如果区域内的数字少于 2 个，退出递归  if (start \u0026gt;= end) return; // 将数组分区，并获得中间值的下标  int middle = partition(arr, start, end); // 对左边区域快速排序  quickSort(arr, start, middle - 1); // 对右边区域快速排序  quickSort(arr, middle + 1, end); }    \r  'use strict'; var containerId = JSON.parse(\"\\\"2574f54bc72e9da3\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \n这样我们就写出了最简洁版的边界条件，我们需要知道，这里的 start \u0026gt;= end 实际上只有两种情况：\n start == end: 表明区域内只有一个数字 start == end + 1: 表明区域内一个数字也没有  不会存在 start 比 end 大 2 或者大 3 之类的。\n分区算法实现 快速排序中最重要的便是分区算法，也就是 partition 函数。大多数人都能说出快速排序的整体思路，但实现起来却很难一次写对。主要问题就在于分区时存在的各种边界条件，需要读者亲自动手实践才能加深体会。\n上文已经说到，partition 函数需要做的事情就是将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标。那么首先我们要做的事情就是选择一个基数，基数我们一般称之为 pivot，意为“轴”。整个数组就像围绕这个轴进行旋转，小于轴的数字旋转到左边，大于轴的数字旋转到右边。\n基数的选择 基数的选择没有固定标准，随意选择区间内任何一个数字做基数都可以。通常来讲有三种选择方式：\n 选择第一个元素作为基数 选择最后一个元素作为基数 选择区间内一个随机元素作为基数  选择的基数不同，算法的实现也不同。实际上第三种选择方式的平均时间复杂度是最优的，待会分析时间复杂度时我们会详细说明。\n本文通过第一种方式来讲解快速排序：\ngolang java  1 2 3 4 5 6 7 8  func partition(arr []int,start,end int){ //取第一个数为基数  pivot := arr[start] //从第二个数开始分区  left = start + 1 //右边界  right = end }    \r1 2 3 4 5 6 7 8 9 10  // 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标 public static int partition(int[] arr, int start, int end) { // 取第一个数为基数  int pivot = arr[start]; // 从第二个数开始分区  int left = start + 1; // 右边界  int right = end; // TODO }    \r  'use strict'; var containerId = JSON.parse(\"\\\"92007bc1eade3654\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  最简单的分区算法 分区的方式也有很多种，最简单的思路是：从 left 开始，遇到比基数大的数，就交换到数组最后，并将 right 减一，直到 left 和 right 相遇，此时数组就被分成了左右两个区域。再将基数和中间的数交换，返回中间值的下标即可。\n按照这个思路，我们敲出了如下代码：\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  func swap(arr []int,i,j int){ arr[i] = arr[i] ^ arr[j] arr[j] = arr[j] ^ arr[i] arr[i] = arr[i] ^ arr[j] } func quickSort(arr []int){ quickSortRecursion(arr,0,len(arr)-1) } func quickSortRecursion(arr []int,start,end int){ if start \u0026gt;= end { return } middle := partition(arr,start,end) quickSortRecursion(arr,start,middle-1) quickSortRecursion(arr,middle+1,end) } func partition(arr []int,start,end int)int{ pivot := start left = start + 1 right = end for left \u0026lt; right{ for arr[left] \u0026lt;= pivot \u0026amp;\u0026amp; left \u0026lt; right{ left ++ } //left找到大于基数的数，停下来  if left != right{ swap(arr,left,right) right-- } } if left == right \u0026amp;\u0026amp; arr[right] \u0026gt; pivot{ right-- } if left != start{ swap(arr,left,start) } return right }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  public static void quickSort(int[] arr) { quickSort(arr, 0, arr.length - 1); } public static void quickSort(int[] arr, int start, int end) { // 如果区域内的数字少于 2 个，退出递归  if (start \u0026gt;= end) return; // 将数组分区，并获得中间值的下标  int middle = partition(arr, start, end); // 对左边区域快速排序  quickSort(arr, start, middle - 1); // 对右边区域快速排序  quickSort(arr, middle + 1, end); } // 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标 public static int partition(int[] arr, int start, int end) { // 取第一个数为基数  int pivot = arr[start]; // 从第二个数开始分区  int left = start + 1; // 右边界  int right = end; // left、right 相遇时退出循环  while (left \u0026lt; right) { // 找到第一个大于基数的位置  while (left \u0026lt; right \u0026amp;\u0026amp; arr[left] \u0026lt;= pivot) left++; // 交换这两个数，使得左边分区都小于或等于基数，右边分区大于或等于基数  if (left != right) { exchange(arr, left, right); right--; } } // 如果 left 和 right 相等，单独比较 arr[right] 和 pivot  if (left == right \u0026amp;\u0026amp; arr[right] \u0026gt; pivot) right--; // 将基数和中间数交换  if (right != start) exchange(arr, start, right); // 返回中间值的下标  return right; } private static void exchange(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; }    \r  'use strict'; var containerId = JSON.parse(\"\\\"0211b7149bac9f69\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  因为我们选择了数组的第一个元素作为基数，并且分完区后，会执行将基数和中间值交换的操作，这就意味着交换后的中间值会被分到左边区域。所以我们需要保证中间值的下标是分区完成后，最后一个比基数小的值，这里我们用 right 来记录这个值。\n这段代码有一个细节。首先，在交换 left 和 right 之前，我们判断了 left != right，这是因为如果剩余的数组都比基数小，则 left 会加到 right 才停止，这时不应该发生交换。因为 right 已经指向了最后一个比基数小的值。\n但这里的拦截可能会拦截到一种错误情况，如果剩余的数组只有最后一个数比基数大，left 仍然加到 right 停止了，但我们并没有发生交换。所以我们在退出循环后，单独比较了 arr[right] 和 pivot。\n实际上，这行单独比较的代码非常巧妙，一共处理了三种情况：\n 一是刚才提到的剩余数组中只有最后一个数比基数大的情况 二是 left 和 right 区间内只有一个值，则初始状态下， left == right，所以 while (left \u0026lt; right) 根本不会进入，所以此时我们单独比较这个值和基数的大小关系 三是剩余数组中每个数都比基数大，此时 right 会持续减小，直到和 left 相等退出循环，此时 left 所在位置的值还没有和 pivot 进行比较，所以我们单独比较 left 所在位置的值和基数的大小关系  双指针分区算法 除了上述的分区算法外，还有一种双指针的分区算法更为常用：从 left 开始，遇到比基数大的数，记录其下标；再从 right 往前遍历，找到第一个比基数小的数，记录其下标；然后交换这两个数。继续遍历，直到 left 和 right 相遇。然后就和刚才的算法一样了，交换基数和中间值，并返回中间值的下标。\n代码如下：\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  func quickSort(arr []int){ quickSortRescursion(arr,0,len(arr)-1) } func quickSortRescursion(arr []int,start,end int){ if start \u0026gt;= end { return } //求分区中轴，把数组分区  middle := partition(arr,start,end) //向左分区递归，对左分区进行排序  quickSortRescursion(arr,start,middle-1) //向右分区递归，对右分区进行排序  quickSortRescursion(arr,middle+1,end) } func partition(arr []int,start,end int)int{ //基数  pivot := arr[start] left := start+1 right := end for left \u0026lt; right{ for left \u0026lt; right \u0026amp;\u0026amp; arr[left] \u0026lt;= pivot{ left++ } for left \u0026lt; right \u0026amp;\u0026amp; arr[right] \u0026gt;= pivot{ right-- } if left \u0026lt; right{ swap(arr,left,right) left++ right-- } } // 如果 left 和 right 相等，单独比较 arr[right] 和 pivot  if left == right \u0026amp;\u0026amp; arr[right] \u0026gt; pivot{ right-- } // 将基数和轴交换  if right != start{ swap(arr,right,start) } return right }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  public static void quickSort(int[] arr) { quickSort(arr, 0, arr.length - 1); } public static void quickSort(int[] arr, int start, int end) { // 如果区域内的数字少于 2 个，退出递归  if (start \u0026gt;= end) return; // 将数组分区，并获得中间值的下标  int middle = partition(arr, start, end); // 对左边区域快速排序  quickSort(arr, start, middle - 1); // 对右边区域快速排序  quickSort(arr, middle + 1, end); } // 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标 public static int partition(int[] arr, int start, int end) { // 取第一个数为基数  int pivot = arr[start]; // 从第二个数开始分区  int left = start + 1; // 右边界  int right = end; while (left \u0026lt; right) { // 找到第一个大于基数的位置  while (left \u0026lt; right \u0026amp;\u0026amp; arr[left] \u0026lt;= pivot) left++; // 找到第一个小于基数的位置  while (left \u0026lt; right \u0026amp;\u0026amp; arr[right] \u0026gt;= pivot) right--; // 交换这两个数，使得左边分区都小于或等于基数，右边分区大于或等于基数  if (left \u0026lt; right) { exchange(arr, left, right); left++; right--; } } // 如果 left 和 right 相等，单独比较 arr[right] 和 pivot  if (left == right \u0026amp;\u0026amp; arr[right] \u0026gt; pivot) right--; // 将基数和轴交换  exchange(arr, start, right); return right; } private static void exchange(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; }    \r  'use strict'; var containerId = JSON.parse(\"\\\"31cecda667b33bb3\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  同样地，我们需要在退出循环后，单独比较 left 和 right 的值。\n时间复杂度 \u0026amp; 空间复杂度 平均时间复杂度为O(nlogn)，最坏的时间复杂度为O(n^2)，空间复杂度与递归的层数有关，每层递归会生成一些临时变量，所以空间复杂度为 O(logn)~ O(n)，平均空间复杂度为O(logn)\n为什么说随机选择剩余数组中的一个元素作为基数的方案平均复杂度是最优的呢？什么情况下快速排序算法的时间复杂度最高，一共有两种情况。\n 数组为正序 数组为逆序  理想中的快速排序在第 k 轮遍历中，可以排好 2^(k-1)个基数。但从图中我们发现，当数组原本为正序或逆序时，我们将第一个数作为基数的话，每轮分区后，都有一个区域是空的，也就是说数组中剩下的数字都被分到了同一个区域！这就导致了每一轮遍历只能排好一个基数。所以总的比较次数为 (n - 1) + (n - 2) + (n - 3) + \u0026hellip; + 1 次，由等差数列求和公式可以计算出总的比较次数为 n(n - 1)/2 次，此时快速排序的时间复杂度达到了 O(n^2)级。\n稳定性 从代码实现中可以分析出，快速排序是一种不稳定的排序算法，在分区过程中，相同数字的相对顺序可能会被修改。\n快速排序的优化思路  1.每轮选择基数时，从剩余的数组中随机选择一个数字作为基数。这样每轮都选到最大或最小值的概率就会变得很低了。所以我们才说用这种方式选择基数，其平均时间复杂度是最优的 2.三数取中，待排序序列中low、mid、high三个位置上数据进行排序，取他们中间的那个数据作为枢轴，并用0下标元素存储枢轴。  ","description":"战略上藐视技术，战术上重视技术——闪客","id":53,"section":"interview","tags":["排序算法"],"title":"快速排序","uri":"https://xing-you-ji.github.io/interview/sort/qui/"},{"content":"约翰·冯·诺伊曼在 1945 年提出了归并排序。在讲解归并排序之前，我们先一起思考一个问题：如何将两个有序的列表合并成一个有序的列表？\n将两个有序的列表合并成一个有序的列表 这太简单了，首先想到的思路就是，将两个列表拼接成一个列表，然后之前学的冒泡、选择、插入、希尔、堆、快排都可以派上用场了。\n觉得太暴力了一点？那我们换个思路。\n既然列表已经有序了，通过前几章的学习，我们已经知道，插入排序的过程中，被插入的数组也是有序的。这就好办了，我们将其中一个列表中的元素逐个插入另一个列表中即可。\n但是按照这个思路，我们只需要一个列表有序就行了，另一个列表不管是不是有序的，都会被逐个取出来，插入第一个列表中。那么，在两个列表都已经有序的情况下，还可以有更优的合并方案吗？\n深入思考之后，我们发现，在第二个列表向第一个列表逐个插入的过程中，由于第二个列表已经有序，所以后续插入的元素一定不会在前面插入的元素之前。在逐个插入的过程中，每次插入时，只需要从上次插入的位置开始，继续向后寻找插入位置即可。这样一来，我们最多只需要将两个有序数组遍历一次就可以完成合并。\n思路很接近了，如何实现它呢？我们发现，在向数组中不断插入新数字时，原数组需要不断腾出位置，这是一个比较复杂的过程，而且这个过程必然导致增加一轮遍历。\n但好在我们有一个替代方案：只要开辟一个长度等同于两个数组长度之和的新数组，并使用两个指针来遍历原有的两个数组，不断将较小的数字添加到新数组中，并移动对应的指针即可。\n根据这个思路，我们可以写出合并两个有序列表的代码：\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // 将两个有序数组合并为一个有序数组 func merge(arr1,arr2 []int)[]int{ //返回的有序的结果数组  res := make([]int,len(arr1)+len(arr2)) //遍历两个数组的指针  index1,index2 := 0,0 //遍历\t for index1 \u0026lt; len(arr1) \u0026amp;\u0026amp; index2 \u0026lt; len(arr2){ if arr1[index1]\u0026lt;=arr2[index2]{ res[index1+index2] = arr1[index1] index1++ }else{ res[index1+index2] = arr2[index2] index2++ } } // 将剩余数字补到结果数组之后  for index1 \u0026lt; len(arr1){ res[index1+index2] = arr1[index1] index1++ } for index2 \u0026lt; len(arr2){ res[index1+index2] = arr2[index2] index2++ } return res }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // 将两个有序数组合并为一个有序数组 private static int[] merge(int[] arr1, int[] arr2) { int[] result = new int[arr1.length + arr2.length]; int index1 = 0, index2 = 0; while (index1 \u0026lt; arr1.length \u0026amp;\u0026amp; index2 \u0026lt; arr2.length) { if (arr1[index1] \u0026lt;= arr2[index2]) { result[index1 + index2] = arr1[index1]; index1++; } else { result[index1 + index2] = arr2[index2]; index2++; } } // 将剩余数字补到结果数组之后  while (index1 \u0026lt; arr1.length) { result[index1 + index2] = arr1[index1]; index1++; } while (index2 \u0026lt; arr2.length) { result[index1 + index2] = arr2[index2]; index2++; } return result; }    \r  'use strict'; var containerId = JSON.parse(\"\\\"ed9323cabef53f64\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \n合并有序数组的问题解决了，但我们排序时用的都是无序数组，那么上哪里去找这两个有序的数组呢？\n答案是 —— 自己拆分，我们可以把数组不断地拆成两份，直到只剩下一个数字时，这一个数字组成的数组我们就可以认为它是有序的。\n然后通过上述合并有序列表的思路，将 1 个数字组成的有序数组````合并成一个包含 2 个数字的有序数组，再将 2 个数字组成的有序数组合并成包含 4 个数字的有序数组...直到整个数组排序完成，这就是归并排序（Merge Sort）的思想。\n将数组拆分成有序数组 拆分过程使用了二分的思想，这是一个递归的过程，归并排序使用的递归框架如下：\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  //归并排序 func mergeSort(arr []int){ if len(arr) \u0026lt;= 1{ return } //把结果存入res中  res := mergeRescurison(arr,0,len(arr)-1) for i:=0;i\u0026lt;len(arr);i++{ arr[i] = res[i] } } //拆分数组 func mergeRescurison(arr []int,start,end int)[]int{ if start \u0026gt;= end{//递归终止条件  return []int{arr[start]} } //左区间递归  left := mergeRescurison(arr,start,(start+end)/2) //右区间递归  right := mergeRescurison(arr,(start+end)/2+1,end) //将两个有序数组合并  return merge(left,right) }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public static void mergeSort(int[] arr) { if (arr.length == 0) return; int[] result = mergeSort(arr, 0, arr.length - 1); // 将结果拷贝到 arr 数组中  for (int i = 0; i \u0026lt; result.length; i++) { arr[i] = result[i]; } } // 对 arr 的 [start, end] 区间归并排序 private static int[] mergeSort(int[] arr, int start, int end) { // 只剩下一个数字，停止拆分，返回单个数字组成的数组  if (start == end) return new int[]{arr[start]}; int middle = (start + end) / 2; // 拆分左边区域  int[] left = mergeSort(arr, start, middle); // 拆分右边区域  int[] right = mergeSort(arr, middle + 1, end); // 合并左右区域  return merge(left, right); }    \r  'use strict'; var containerId = JSON.parse(\"\\\"94198f6446b82191\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  可以看到，我们在这个函数中，将原有数组不断地二分，直到只剩下最后一个数字。此时嵌套的递归开始返回，一层层地调用merge函数，也就是我们刚才写的将两个有序数组合并为一个有序数组的函数。\n这就是最经典的归并排序，只需要一个二分拆数组的递归函数和一个合并两个有序列表的函数即可。\n归并排序分成两步:\n 一是拆分数组 二是合并数组  但这份代码还有一个缺点，那就是在递归过程中，开辟了很多临时空间，接下来我们就来看下它的优化过程。\n归并排序的优化：减少临时空间的开辟 为了减少在递归过程中不断开辟空间的问题，我们可以在归并排序之前，先开辟出一个临时空间，在递归过程中统一使用此空间进行归并即可。\n代码如下：\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  func mergeSort(arr []int){ if len(arr) \u0026lt;= 1{ return } //辅助数组  res := make([]int,len(arr)) mergeRescurison(arr,0,len(arr)-1,res) } func mergeRescurison(arr []int,start,end int,res []int){ if start \u0026gt;= end{ return } middle := (start+end)/2 // 拆分左边区域，并将归并排序的结果保存到 result 的 [start, middle] 区间  mergeRescurison(arr,start,middle,res) // 拆分右边区域，并将归并排序的结果保存到 result 的 [middle + 1, end] 区间  mergeRescurison(arr,middle+1,end,res) // 合并左右区域到 result 的 [start, end] 区间  merge(arr,start,end,res) } // 将 result 的 [start, middle] 和 [middle + 1, end] 区间合并 func merge(arr []int,start,end int,res []int){ middle := (start+end)/2 // 数组 1 的首尾位置  start1,end1 := start,middle // 数组 2 的首尾位置  start2,end2 := middle+1,end // 用来遍历数组的指针  index1 := start1 index2 := start2 // 结果数组的指针  resIndex := start for index1 \u0026lt;= end1 \u0026amp;\u0026amp; index2 \u0026lt;= end2{ if arr[index1] \u0026lt;= arr[index2]{ res[resIndex] = arr[index1] index1++ resIndex++ }else{ res[resIndex] = arr[index2] index2++ resIndex++ } } //把剩余的数字移到数组里面去  for index1 \u0026lt;= end1{ res[resIndex] = arr[index1] index1++ resIndex++ } for index2 \u0026lt;= end2{ res[index1+index2-start2] = arr[index2] index2++ resIndex++ } // 将 result 操作区间的数字拷贝到 arr 数组中，以便下次比较  for i := start; i \u0026lt;= end; i++{ arr[i] = res[i] } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  public static void mergeSort(int[] arr) { if (arr.length == 0) return; int[] result = new int[arr.length]; mergeSort(arr, 0, arr.length - 1, result); } // 对 arr 的 [start, end] 区间归并排序 private static void mergeSort(int[] arr, int start, int end, int[] result) { // 只剩下一个数字，停止拆分  if (start == end) return; int middle = (start + end) / 2; // 拆分左边区域，并将归并排序的结果保存到 result 的 [start, middle] 区间  mergeSort(arr, start, middle, result); // 拆分右边区域，并将归并排序的结果保存到 result 的 [middle + 1, end] 区间  mergeSort(arr, middle + 1, end, result); // 合并左右区域到 result 的 [start, end] 区间  merge(arr, start, end, result); } // 将 result 的 [start, middle] 和 [middle + 1, end] 区间合并 private static void merge(int[] arr, int start, int end, int[] result) { int middle = (start + end) / 2; // 数组 1 的首尾位置  int start1 = start; int end1 = middle; // 数组 2 的首尾位置  int start2 = middle + 1; int end2 = end; // 用来遍历数组的指针  int index1 = start1; int index2 = start2; // 结果数组的指针  int resultIndex = start1; while (index1 \u0026lt;= end1 \u0026amp;\u0026amp; index2 \u0026lt;= end2) { if (arr[index1] \u0026lt;= arr[index2]) { result[resultIndex++] = arr[index1++]; } else { result[resultIndex++] = arr[index2++]; } } // 将剩余数字补到结果数组之后  while (index1 \u0026lt;= end1) { result[resultIndex++] = arr[index1++]; } while (index2 \u0026lt;= end2) { result[resultIndex++] = arr[index2++]; } // 将 result 操作区间的数字拷贝到 arr 数组中，以便下次比较  for (int i = start; i \u0026lt;= end; i++) { arr[i] = result[i]; } }    \r  'use strict'; var containerId = JSON.parse(\"\\\"85f8dbd38a224b90\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  在这份代码中，我们统一使用result 数组作为递归过程中的临时数组，所以merge 函数接收的参数不再是两个数组，而是 result 数组中需要合并的两个数组的首尾下标。根据首尾下标可以分别计算出两个有序数组的首尾下标 start1、end1、start2、end2，之后的过程就和之前合并两个有序数组的代码类似了。\n这份代码还可以再精简一下，我们可以去掉一些不会改变的临时变量。比如 start1 始终等于 start，end2 始终等于 end，end1 始终等于 middle。并且分析可知，resultIndex 的值始终等于 start 加上 index1 和 index2 移动的距离。即：\ngolang java  1  resultIndex = start + (index1 - start1) + (index2 - start2)    \r1  resultIndex = start + (index1 - start1) + (index2 - start2)    \r  'use strict'; var containerId = JSON.parse(\"\\\"e6bd416b23b4dd26\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  将 start1 == start 代入，化简得：\ngolang java  1  resultIndex = index1 + index2 - start2    \r1  resultIndex = index1 + index2 - start2    \r  'use strict'; var containerId = JSON.parse(\"\\\"4f5114b05b9c3070\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  所以最终的归并排序代码如下：\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  func mergeSort(arr []int){ if len(arr) \u0026lt;= 1{ return } //辅助数组  res := make([]int,len(arr)) mergeRescurison(arr,0,len(arr)-1,res) } func mergeRescurison(arr []int,start,end int,res []int){ if start \u0026gt;= end{ return } middle := (start+end)/2 // 拆分左边区域，并将归并排序的结果保存到 result 的 [start, middle] 区间  mergeRescurison(arr,start,middle,res) // 拆分右边区域，并将归并排序的结果保存到 result 的 [middle + 1, end] 区间  mergeRescurison(arr,middle+1,end,res) // 合并左右区域到 result 的 [start, end] 区间  merge(arr,start,end,res) } func merge(arr []int,start,end int,res []int){ end1 := (start+end)/2 start2 := end1 + 1 index1,index2:= start,start2 //数组指针为start + (index1-start1) + (index2 -(middlex+1))  for index1 \u0026lt;= end1 \u0026amp;\u0026amp; index2 \u0026lt;= end{ if arr[index1] \u0026lt;= arr[index2]{ res[index1+index2-start2] = arr[index1] index1++ }else{ res[index1+index2-start2] = arr[index2] index2++ } } //把剩余的数字移到数组里面去  for index1 \u0026lt;= end1{ res[index1+index2-start2] = arr[index1] index1++ } for index2 \u0026lt;= end{ res[index1+index2-start2] = arr[index2] index2++ } //将合并排序后的数组给arr  for start \u0026lt;= end{ arr[start] = res[start] start++ } }    \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  public static void mergeSort(int[] arr) { if (arr.length == 0) return; int[] result = new int[arr.length]; mergeSort(arr, 0, arr.length - 1, result); } // 对 arr 的 [start, end] 区间归并排序 private static void mergeSort(int[] arr, int start, int end, int[] result) { // 只剩下一个数字，停止拆分  if (start == end) return; int middle = (start + end) / 2; // 拆分左边区域，并将归并排序的结果保存到 result 的 [start, middle] 区间  mergeSort(arr, start, middle, result); // 拆分右边区域，并将归并排序的结果保存到 result 的 [middle + 1, end] 区间  mergeSort(arr, middle + 1, end, result); // 合并左右区域到 result 的 [start, end] 区间  merge(arr, start, end, result); } // 将 result 的 [start, middle] 和 [middle + 1, end] 区间合并 private static void merge(int[] arr, int start, int end, int[] result) { int end1 = (start + end) / 2; int start2 = end1 + 1; // 用来遍历数组的指针  int index1 = start; int index2 = start2; while (index1 \u0026lt;= end1 \u0026amp;\u0026amp; index2 \u0026lt;= end) { if (arr[index1] \u0026lt;= arr[index2]) { result[index1 + index2 - start2] = arr[index1++]; } else { result[index1 + index2 - start2] = arr[index2++]; } } // 将剩余数字补到结果数组之后  while (index1 \u0026lt;= end1) { result[index1 + index2 - start2] = arr[index1++]; } while (index2 \u0026lt;= end) { result[index1 + index2 - start2] = arr[index2++]; } // 将 result 操作区间的数字拷贝到 arr 数组中，以便下次比较  while (start \u0026lt;= end) { arr[start] = result[start++]; } }    \r  'use strict'; var containerId = JSON.parse(\"\\\"948b69e0ddd16125\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \n牺牲了一些可读性，代码变得精简了不少。动图演示如下：\n  时间复杂度 \u0026amp; 空间复杂度 归并排序的复杂度比较容易分析，拆分数组的过程中，会将数组拆分logn次，每层执行的比较次数都约等于n次，所以时间复杂度是 O(nlogn)。\n空间复杂度是 O(n)，主要占用空间的就是我们在排序前创建的长度为 n 的 result 数组。\n稳定性 分析归并的过程可知，归并排序是一种稳定的排序算法。其中，对算法稳定性非常重要的一行代码是：\n golang java  1 2 3 4  if arr[index1] \u0026lt;= arr[index2]{ res[index1 + index2 - start2] = arr[index1] index1++ }    \r1 2 3  if (arr[index1] \u0026lt;= arr[index2]) { result[index1 + index2 - start2] = arr[index1++]; }    \r  'use strict'; var containerId = JSON.parse(\"\\\"6b21f2096e15865b\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } \n在这里我们通过arr[index1] \u0026lt;= arr[index2]来合并两个有序数组，保证了原数组中，相同的元素相对顺序不会变化，如果这里的比较条件写成了arr[index1] \u0026lt; arr[index2]，则归并排序将变得不稳定。\n","description":"战略上藐视技术，战术上重视技术——闪客","id":54,"section":"interview","tags":["排序算法"],"title":"归并排序","uri":"https://xing-you-ji.github.io/interview/sort/mer/"},{"content":"希尔排序 希尔排序是一个承上启下的算法，通过交换间隔较远的元素，使得一次交换能消除一个以上的逆序对，打破了在空间复杂度为 O(1)的情况下，时间复杂度 O(n^2)的魔咒。它启发出了后续一系列时间复杂度为O(nlogn)，空间复杂度为O(1) 的排序算法\n希尔排序本质上是插入排序的优化，先对间隔较大的元素进行插入排序，完成宏观调控，然后逐步缩小间隔，最后一轮一定是间隔为 1 的排序，也就是插入排序。间隔在希尔排序中被称为「增量」，增量序列不同，希尔排序的效率也不同。\n堆排序 堆排序分为两步：初始化建堆、重建堆。排序过程是：\n 用数列构建出一个大顶堆，取出堆顶的数字； 调整剩余的数字，构建出新的大顶堆，再次取出堆顶的数字； 循环往复，完成整个排序。  快速排序 快速排序算法是面试中考察的重点，也是应用最广泛的排序算法。排序过程是：\n 从数组中取出一个数，称之为基数（pivot）； 遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域； 将左右两个区域视为两个数组，重复前两个步骤，直到排序完成。  快速排序中最重要的是分区算法，最常用的分区算法是双指针分区算法，优点是一次交换可以完成两个数的分区。\n归并排序 归并排序分为两步：二分拆数组、不断合并两个有序列表。\n归并的优化主要在于减少临时空间的开辟。\n不存在空间复杂度为O(1) 的归并排序。\n相同点 平均时间复杂度都在 O(n)到O(n^2)\n不同点  希尔排序、堆排序、快速排序是不稳定的，归并排序是稳定的。 希尔排序的平均复杂度界于 O(n)到 O(n^2)之间，普遍认为它最好的时间复杂度为 O(n^1.3)，希尔排序的空间复杂度为 O(1)；堆排序和快速排序的时间复杂度为 O(nlogn)，空间复杂度为 O(1)；归并排序的时间复杂度是O(nlogn)，空间复杂度是 O(n)。  ","description":"战略上藐视技术，战术上重视技术——闪客","id":55,"section":"interview","tags":["排序算法"],"title":"O(nlogn)排序算法的小结","uri":"https://xing-you-ji.github.io/interview/sort/conclusion2/"},{"content":"想一下我们是怎么对日期进行排序的。比如对这样三个日期进行排序：2014 年 1 月 7 日，2020 年 1 月 9 日，2020 年 7 月 10日。\n我们大脑中对日期排序的思维过程是：\n 先看年份，2014比2020 要小，所以 2014 年这个日期应该放在其他两个日期前面。 另外两个日期年份相等，所以我们比较一下月份，1 比 7 要小，所以 1 月这个日期应该放在 7 月这个日期前面  这种利用多关键字进行排序的思想就是基数排序，和计数排序一样，这也是一种线性时间复杂度的排序算法。其中的每个关键字都被称作一个基数。\n比如我们对 999, 997, 866, 666 这四个数字进行基数排序，过程如下：\n先看第一位基数：6 比 8 小，8 比 9 小，所以 666 是最小的数字，866 是第二小的数字，暂时无法确定两个以 9 开头的数字的大小关系\n再比较 9 开头的两个数字，看他们第二位基数：9 和 9 相等，暂时无法确定他们的大小关系\n再比较 99 开头的两个数字，看他们的第三位基数：7 比 9 小，所以 997 小于 999\n基数排序有两种实现方式。本例属于「最高位优先法」，简称 MSD (Most significant digital)，思路是从最高位开始，依次对基数进行排序。\n与之对应的是「最低位优先法」，简称 LSD (Least significant digital)。思路是从最低位开始，依次对基数进行排序。使用 LSD 必须保证对基数进行排序的过程是稳定的。\n通常来讲，LSD 比 MSD 更常用。以上述排序过程为例，因为使用的是 MSD，所以在第二步比较两个以 9 开头的数字时，其他基数开头的数字不得不放到一边。体现在计算机中，这里会产生很多临时变量。\n但在采用 LSD 进行基数排序时，每一轮遍历都可以将所有数字一视同仁，统一处理。所以 LSD 的基数排序更符合计算机的操作习惯。\n基数排序最早是用在卡片排序机上的，一张卡片有 80 列，类似一个 80 位的整数。机器通过在卡片不同位置上穿孔表示当前基数的大小。卡片排序机的排序过程就是采用的 LSD 的基数排序。\n动图演示\n简单起见，我们先只考虑对非负整数排序的情况。\n  基数排序可以分为以下三个步骤：\n 找出数组中最大的数字的位数 maxDigitLength 获取数组中每个数字的基数 遍历 maxDigitLength 轮数组，每轮按照基数对其进行排序  找出数组中最大的数字的位数 首先找到数组中的最大值：\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12  func radixSort(arr []int){ if len(arr) == 0{ return } max := 0 for _,v:=range arr{ if v \u0026gt; max{ max = v } } //... }     1 2 3 4 5 6 7 8 9 10  public static void radixSort(int[] arr) { if (arr == null) return; int max = 0; for (int value : arr) { if (value \u0026gt; max) { max = value; } } // ... }       'use strict'; var containerId = JSON.parse(\"\\\"4b686bb57b49a186\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  通过遍历一次数组，找到了数组中的最大值 max，然后我们计算这个最大值的位数：\ngolang java  1 2 3 4 5 6  maxDigitLength = 0 for max != 0{ maxDigitLength++//记录最大遍历次数  max /= 10 }     1 2 3 4 5  int maxDigitLength = 0; while (max != 0) { maxDigitLength++; max /= 10; }       'use strict'; var containerId = JSON.parse(\"\\\"ba6134569d3b4c36\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  将 maxDigitLength 初始化为 0，然后不断地除以10，每除一次，maxDigitLength 就加一，直到 max 为0。\n读者可能会有疑惑，如果 max 初始值就是 0 呢？严格来讲，0 在数学上属于 1 位数。\n但实际上，基数排序时我们无需考虑 max 为 0 的场景，因为 max 为 0 只有一种可能，那就是数组中所有的数字都为 0，此时数组已经有序，我们无需再进行后续的排序过程。\n获取基数 获取基数有两种做法：\n第一种：\ngolang java  1 2 3 4 5 6 7 8 9 10  mod := 10 dev := 1 for i:=0;i\u0026lt;maxDigitLength;i++{ for _,v := range arr{ radix := v % mod / dev //对基数进行排序  } mod *= 10 dev *= 10 }     1 2 3 4 5 6 7 8 9 10  int mod = 10; int dev = 1; for (int i = 0; i \u0026lt; maxDigitLength; i++) { for (int value : arr) { int radix = value % mod / dev; // 对基数进行排序  } mod *= 10; dev *= 10; }       'use strict'; var containerId = JSON.parse(\"\\\"97fe5c79be49bf2f\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  第二种：\ngolang java  1 2 3 4 5 6 7 8  dev := 1 for i:=0;i\u0026lt;maxDigitLength;i++{ for _,v := range arr{ radix := v / dev % 10 //对基数进行排序  } dev *= 10 }     1 2 3 4 5 6 7 8  int dev = 1; for (int i = 0; i \u0026lt; maxDigitLength; i++) { for (int value : arr) { int radix = value / dev % 10; // 对基数进行排序  } dev *= 10; }       'use strict'; var containerId = JSON.parse(\"\\\"02012d2d0b265685\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  两者的区别是先做除法运算还是先做模运算，推荐使用第二种写法，因为它可以节省一个变量\n对基数进行排序 golang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  func radixSort(arr []int) { //第一步，先确定基数个数  if len(arr) == 0 { return } max := 0 for _, v := range arr { if v \u0026gt; max { max = v } } maxLength := 0 for max != 0 { maxLength++ max /= 10 } //结果暂存  res := make([]int, len(arr)) dev := 1 //从1开始  for i := 0; i \u0026lt; maxLength; i++ { //记录各基数个数  count := make([]int, 10) for _, v := range arr { radix := v / dev % 10 //求当前数的基数  count[radix]++ //记录基数个数  } //counting[i] 更新为数字 i 在最终排序结果中的起始下标位置。  //这个位置等于前面比自己小的数字的总数  fmt.Println(count) for i := 1; i \u0026lt; len(count); i++ { count[i] += count[i-1] } fmt.Println(count) for i := len(arr) - 1; i \u0026gt;= 0; i-- { radix := arr[i] / dev % 10 count[radix]-- res[count[radix]] = arr[i] } for i, v := range res { arr[i] = v } dev *= 10 fmt.Println(arr) } }     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  public class RadixSort { public static void radixSort(int[] arr) { if (arr == null) return; // 找出最大值  int max = 0; for (int value : arr) { if (value \u0026gt; max) { max = value; } } // 计算最大数字的长度  int maxDigitLength = 0; while (max != 0) { maxDigitLength++; max /= 10; } // 使用计数排序算法对基数进行排序  int[] counting = new int[10]; int[] result = new int[arr.length]; int dev = 1; for (int i = 0; i \u0026lt; maxDigitLength; i++) { for (int value : arr) { int radix = value / dev % 10; counting[radix]++; } for (int j = 1; j \u0026lt; counting.length; j++) { counting[j] += counting[j - 1]; } // 使用倒序遍历的方式完成计数排序  for (int j = arr.length - 1; j \u0026gt;= 0; j--) { int radix = arr[j] / dev % 10; result[--counting[radix]] = arr[j]; } // 计数排序完成后，将结果拷贝回 arr 数组  System.arraycopy(result, 0, arr, 0, arr.length); // 将计数数组重置为 0  Arrays.fill(counting, 0); dev *= 10; } } }       'use strict'; var containerId = JSON.parse(\"\\\"550c6c09198ed424\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  首先我们将每位元素出现的次数记录到 counting 数组中\n然后将 counting[i] 更新为数字 i 在最终排序结果中的起始下标位置。这个位置等于前面比自己小的数字的总数。\n我们将 result 数组的值拷贝回 arr 数组，并且将 counting 数组中的元素都置为 0，以便在下一轮中复用。\n对包含负数的数组进行基数排序 如果数组中包含负数，如何进行基数排序呢？\n我们很容易想到一种思路：将数组中的每个元素都加上一个合适的正整数，使其全部变成非负整数，等到排序完成后，再减去之前加的这个数就可以了。\n但这种方案有一个缺点：加法运算可能导致数字越界，所以必须单独处理数字越界的情况。\n事实上，有一种更好的方案解决负数的基数排序。那就是在对基数进行计数排序时，申请长度为 19 的计数数组，用来存储 [-9, 9] 这个区间内的所有整数。在把每一位基数计算出来后，加上 9，就能对应上 counting 数组的下标了。也就是说，counting 数组的 下标 [0, 18] 对应基数 [−9,9]。\ngolang java  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  func radixSort(arr []int) { //第一步，先确定基数个数  if len(arr) == 0 { return } max := 0 for _, v := range arr { if v \u0026lt; 0 { v = -v } if v \u0026gt; max { max = v } } maxLength := 0 for max != 0 { maxLength++ max /= 10 } //结果暂存  res := make([]int, len(arr)) dev := 1 //从1开始  for i := 0; i \u0026lt; maxLength; i++ { //记录各基数个数  count := make([]int, 19) for _, v := range arr { radix := v/dev%10 + 9 //求当前数的基数  count[radix]++ //记录基数个数  } //counting[i] 更新为数字 i 在最终排序结果中的起始下标位置。  //这个位置等于前面比自己小的数字的总数  fmt.Println(count) for i := 1; i \u0026lt; len(count); i++ { count[i] += count[i-1] } fmt.Println(count) for i := len(arr) - 1; i \u0026gt;= 0; i-- { radix := arr[i]/dev%10 + 9 count[radix]-- res[count[radix]] = arr[i] } for i, v := range res { arr[i] = v } dev *= 10 fmt.Println(arr) } }     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  public class RadixSort { public static void radixSort(int[] arr) { if (arr == null) return; // 找出最长的数  int max = 0; for (int value : arr) { if (Math.abs(value) \u0026gt; max) { max = Math.abs(value); } } // 计算最长数字的长度  int maxDigitLength = 0; while (max != 0) { maxDigitLength++; max /= 10; } // 使用计数排序算法对基数进行排序，下标 [0, 18] 对应基数 [-9, 9]  int[] counting = new int[19]; int[] result = new int[arr.length]; int dev = 1; for (int i = 0; i \u0026lt; maxDigitLength; i++) { for (int value : arr) { // 下标调整  int radix = value / dev % 10 + 9; counting[radix]++; } for (int j = 1; j \u0026lt; counting.length; j++) { counting[j] += counting[j - 1]; } // 使用倒序遍历的方式完成计数排序  for (int j = arr.length - 1; j \u0026gt;= 0; j--) { // 下标调整  int radix = arr[j] / dev % 10 + 9; result[--counting[radix]] = arr[j]; } // 计数排序完成后，将结果拷贝回 arr 数组  System.arraycopy(result, 0, arr, 0, arr.length); // 将计数数组重置为 0  Arrays.fill(counting, 0); dev *= 10; } } }       'use strict'; var containerId = JSON.parse(\"\\\"483aa95d94a7f557\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  代码中主要做了两处修改：\n 当数组中存在负数时，我们就不能简单的计算数组的最大值了，而是要计算数组中绝对值最大的数，也就是数组中最长的数 在获取基数的步骤，将计算出的基数加上 99，使其与 counting 数组下标一一对应  时间复杂度 \u0026amp; 空间复杂度 无论 LSD 还是 MSD，基数排序时都需要经历 maxDigitLength 轮遍历，每轮遍历的时间复杂度为 O(n + k) ，其中 k 表示每个基数可能的取值范围大小。如果是对非负整数排序，则 k = 10，如果是对包含负数的数组排序，则 k = 19。\n所以基数排序的时间复杂度为 O(d(n + k))表示最长数字的位数，k 表示每个基数可能的取值范围大小)。\n稳定性 基数排序是一种稳定的排序算法\n","description":"战略上藐视技术，战术上重视技术——闪客","id":56,"section":"interview","tags":["排序算法"],"title":"基数排序","uri":"https://xing-you-ji.github.io/interview/sort/rad/"},{"content":"《上部分》 这似乎是一个很凝重的话题，但是它真的很有趣。\n1. 指针是指向某一类型的东西，任何一个整体，只要能称为整体就能拥有它自己的独一无二的指针类型，所以指针的类型其实是近似无穷无尽的\n2. 函数名在表达式中总是以函数指针的身份呈现，除了取地址运算符以及sizeof\n3. C语言最晦涩难明的就是它复杂的声明: void (signal(int sig, void (func)(int)))(int),\n试试着把它改写成容易理解的形式\n4. 对于指针，尽最大的限度使用const保护它，无论是传递给函数，还是自己使用\n先来看看一个特殊的指针，姑且称它为指针，因为它依赖于环境: NULL，是一个神奇的东西。先附上定义，在编译器中会有两种NULL(每种环境都有唯一确定的NULL):\n1 2  #define NULL 0 #define NULL ((void*)0)   有什么区别吗？看起来没什么区别都是0，只不过一个是常量，一个是地址为0的指针。\n当它们都作为指针的值时并不会报错或者警告，即编译器或者说C标准认为这是合法的:\n1 2 3  int* temp_int_1 = 0; //无警告 int* temp_int_2 = (void*)0; //无警告 int* temp_int_3 = 10; //出现警告   为什么？为什么0可以赋值给指针，但是10却不行？他们都是常量。\n因为C语言规定当处理上下文的编译器发现常量0出现在指针赋值的语句中，它就作为指针使用，似乎很扯淡，可是却是如此。\n回到最开始，对于NULL的两种情况，会有什么区别？拿字符串来说，实际上我是将字符数组看作是C风格字符串。\n在C语言中，字符数组是用来存储一连串有意义的字符，默认在这些字符的结尾添加'\\0'，好这里又出现了一个0值。\n对于某些人，在使用字符数组的时候总是分不清楚NULL与'\\0\u0026rsquo;的区别而误用，在字符数组的末尾使用NULL是绝对错误的！虽然它们的本质都是常量0，但由于位置不同所以含义也不同。\n开胃菜已过\n对于一个函数，我们进行参数传递，参数有两种形式: 形参与实参\n1 2 3 4 5 6  int function(int value) { /*...*/ } //... function(11);   其中，value是形参，11是实参，我们知道场面上，C语言拥有两种传递方式:按值传递和按址传递，但是你是否有认真研究过？这里给出一个实质，其实C语言只有按值传递，所谓按址传递只不过是按值传递的一种假象。至于原因稍微一想便能明白。\n对于形参和实参而言两个关系紧密，可以这么理解总是实参将自己的一份拷贝传递给形参，这样形参便能安全的使用实参的值，但也带给我们一些麻烦，最经典的交换两数\n1 2 3 4 5 6 7  void swap_v1(int* val_1, int* val_2) { int temp = *val_1; *val_1 = *val_2; *val_2 = *val_1; }   这就是所谓的按址传递，实际上只是将外部指针(实参)的值做一个拷贝，传递给形参val_1与val_2，实际上我们使用:\n1 2  #define SWAP_V2(a, b) (a += b, b = a - b, a -= b) #define SWAP_V3(x, y) {x ^= y; y ^= x; x ^= y}   试一试是不是很神奇，而且省去了函数调用的时间，空间开销。上述两种写法的原理实质是一样的。\n但是，动动脑筋想一想，这种写法真的没有瑕疵吗？如果输入的两个参数本就指向同一块内存，会发生什么？\n1 2 3 4 5 6 7 8  ... int test_1 = 10, test_2 = 100; SWAP_V2(test_1, test_2); printf(\u0026#34;Now the test_1 is %d, test_2 is %d\\n\u0026#34;, test_1, test_2); .../*恢复原值*/ SWAP_V2(test_1, test_1); printf(\u0026#34;Now the test_1 is %d\\n\u0026#34;, test_1);   会输出什么？:\n1 2  $: Now the test_1 is 100, test_2 is 10 $: Now the test_1 is 0   对，输出了0，为什么？稍微动动脑筋就能相通，那么对于后面的SWAP_V3亦是如此，所以在斟酌之下，解决方案应该尽可能短小精悍:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  static inline void swap_final(int* val_1, int* val_2) { if(val_1 == val_2) return; *val_1 ^= *val_2; *val_2 ^= *val_1; *val_1 ^= *val_2; } #define SWAP(x, y) do{ if(\u0026amp;x == \u0026amp;y) break; x ^= y; y ^= x; x ^= y; }while(0)   这便是目前能找到最好的交换函数，我们在此基础上可以考虑的更深远一些，如何让这个交换函数更加通用？即适用范围更大？暂不考虑浮点类型。\n提示：可用void*\n与上面的情况类似，偶尔的不经意就会造成严重的后果:\n1 2 3 4 5 6 7 8 9 10 11  int combine_1(int* dest, int* add) { *dest += *add; *dest += *add; return *dest; } int combine_2(int* dest, int* add) { *dest += 2 * (*add);//在不确定优先级时用括号是一个明智的选择  return *dest; }   上述两个函数的功能一样吗？恩看起来是一样的\n1 2 3 4 5 6  int test_3 = 10, test_4 = 100; combine_1(\u0026amp;test_3, \u0026amp;test_4); printf(\u0026#34;After combine_1, test_3 = %d\\n\u0026#34;,test_3); .../*恢复原值*/ combine_2(\u0026amp;test_3, \u0026amp;test_4); printf(\u0026#34;After combine_2, test_3 = %d\\n\u0026#34;,test_3);   输出\n1 2 3 4  $: After combine_1, test_3 = 210 $: After combine_2, test_3 = 210   如果传入两个同一对象呢？\n1 2 3 4 5 6  ... /*恢复test_3原值*/ combine_1(\u0026amp;test_3, \u0026amp;test_3); printf(\u0026#34;After second times combine_1, test_3 = %d\\n\u0026#34;,test_3); ... combine_2(\u0026amp;test_3, \u0026amp;test_3); printf(\u0026#34;After second times combine_2, test_3 = %d\\n\u0026#34;,test_3);   输出\n1 2 3  $: After second times combine_1, test_3 = 40 $: After second times combine_2, test_3 = 30   知道真相总是令人吃惊，指针也是那么令人又爱又恨。\n C99 标准之后出现了一个新的关键字， restrict，被用于修饰指针，它并没有太多的显式作用，甚至加与不加，在 你自己 看来，效果毫无区别。但是反观标准库的代码中，许多地方都使用了该关键字，这是为何\n首先这个关键字是写给编译器看的\n其次这个关键字的作用在于辅助编译器更好的优化该程序(后方文章会有介绍)\n最后，如果不熟悉，绝对不要乱用这个关键字  关于数组的那些事\n数组和指针一样吗？\n不一样!\n要时刻记住，数组与指针是不同的东西。但是为什么下面代码是正确的？\n1 2  int arr[10] = {10, 9, 8, 7}; int* parr = arr;   我们还是那句话，结合上下文，编译器推出 arr处于赋值操作符的右侧，默默的将他转换为对应类型的指针，而我们在使用arr时也总是将其当成是指向该数组内存块首位的指针。\n1 2 3 4 5 6 7 8 9 10  //int function2(const int test_arr[10] //int function2(const int test_arr[]) 考虑这三种写法是否一样 int function2(const int* test_arr) { return sizeof(test_arr); } int size_out = sizeof(arr); int size_in = function2(arr); printf(\u0026#34;size_out = %d, size_in = %d\\n\u0026#34;, size_out, size_in);   1  输出: size_out = 40, size_in = 8   这就是为什么数组与指针不同的原因所在，在外部即定义数组的代码块中，编译器通过上下文发觉此处arr是一个数组，而arr代表的是一个指向10个int类型的数组的指针，只所谓最开始的代码是正确的，只是因为这种用法比较多，就成了标准的一部分。就像世上本没有路，走的多了就成了路。”正确”的该怎么写\n1  int (*p)[10] = \u0026amp;arr;   此时p的类型就是一个指向含有10个元素的数组的指针,此时(*p)[0]产生的效果是arr[0]，也就是parr[0]，但是(*p)呢？这里不记录，结果是会溢出，为什么？\n这就是数组与指针的区别与联系，但是既然我们可以使用像parr这样的指针，又为什么要写成int (*p)[10]这样丑陋不堪的模式呢？原因如下:\n回到最开始说过的传递方式，按值传递在传递arr时只是纯粹的将其值进行传递，而丢失了上下文的它只是一个普通指针，只不过我们程序员知道它指向了一块有意义的内存的起始位置，我想要将数组的信息一起传递，除了额外增加一个参数用来记录数组的长度以外，也可以使用这个方法，传递一个指向数组的指针\n这样我们就能只传递一个参数而保留所有信息。但这么做的也有限制:对于不同大小，或者不同存储类型的数组而言，它们的类型也有所不同\n1 2 3 4  int arr_2[5]; int (*p_2)[5] = \u0026amp;arr_2; float arr_3[5]; float (*p_3)[5] = \u0026amp;arr_3;   如上所示，指向数组的指针必须明确指定数组的大小，数组存储类型，这就让指向数组的指针有了比较大的限制。\n这种用法在多维数组中使用的比较多，但总体来说平常用的并不多，就我而言，更倾向于使用一维数组来表示多维数组，实际上诚如前面所述，C语言是一个非常简洁的语言，它没有太多的废话，就本质而言C语言并没有多维数组，因为内存是一种线性存在，即便是多维数组也是实现成一维数组的形式。\n就多维数组在这里解释一下。所谓多维数组就是将若干个降一维的数组组合在一起，降一维的数组又由若干个更降一维的数组组合在一起，直到最低的一维数组，举个例子:\n1  int dou_arr[5][3];   就这个二维数组而言，将5个每个为3个int类型的数组组合在一起，要想指向这个数组该怎么做？\n1 2 3  int (*p)[3] = \u0026amp;dou_arr[0]; int (*dou_p)[5][3] = \u0026amp;dou_arr; int (*what_p)[3] = dou_arr;   实际上多维数组只是将多个降一维的数组组合在一起，令索引时比较直观而已。当真正理解了内存的使用，反而会觉得多维数组带给自己更多限制\n对于第三句的解释，当数组名出现在赋值号右侧时，它将是一个指针，类型则是 指向该数组元素的类型，而对于一个多维数组来说，其元素类型则是其降一维数组，即指向该降一维数组的指针类型。这个解释有点绕，自己动手写一写就好很多。\n对于某种形式下的操作，我们总是自然的将相似的行为结合在一起考虑。考虑如下代码:\n1 2 3  int* arr_3[5] = {1, 2, 3, 4, 5}; int* p_4 = arr_3; printf(\u0026#34;%d == %d == %d ?\\n\u0026#34;, arr_3[2], *(p_4 + 2), *(arr_3 + 2));     输出: 3 == 3 == 3 ?\n  实际上对于数组与指针而言， []操作在大多数情况下都能有相同的结果，对于指针而言*(p_4 + 2)相当于p_4[2]，也就是说[]便是指针运算的语法糖，有意思的是2[p_4]也相当于p_4[2]，\u0026ldquo;Iamastring\u0026rdquo;[2] == \u0026rsquo;m'，但这只是娱乐而已，实际中请不要这么做，除非是代码混乱大赛或者某些特殊用途。\n在此处，应该声明的是这几种写法的执行效率完全一致，并不存在一个指针运算便快于[]运算，这些说法都是上个世纪的说法了，随着时代的发展，我们应该更加注重代码整洁之道\n  在此处还有一种奇异又实用的技巧，在char数组中使用指针运算进行操作，提取不同类型的数据，或者是在不同类型数组中，使用char*指针抽取其中内容，才是显示指针运算的用途。但在使用不同类型指针操作内存块的时候需要注意，不要操作无意义的区域或者越界操作。\n  实际上，最简单的安全研究之一，便是利用溢出进行攻击。\n Advance:对于一个函数中的某个数组的增长方向，总是向着返回地址的，中间可能隔着许多其他自动变量，我们只需要一直进行溢出试验，直到某一次，该函数无法正常返回了！那就证明我们找到了该函数的返回地址存储地区，这时候我们可以进行一些操作，例如将我们想要的返回地址覆盖掉原先的返回地址，这就是所谓的溢出攻击中的一种。  《下部分》 内存的使用的那些事儿\n你一直以为你操作的是真实物理内存，实际上并不是，你操作的只是操作系统为你分配的资格虚拟地址，但这并不意味着我们可以无限使用内存，那内存卖那么贵干嘛，实际上存储数据的还是物理内存，只不过在操作系统这个中介的介入情况下，不同程序窗口(可以是相同程序)可以共享使用同一块内存区域，一旦某个傻大个程序的使用让物理内存不足了，我们就会把某些没用到的数据写到你的硬盘上去，之后再使用时，从硬盘读回。这个特性会导致什么呢？假设你在Windows上使用了多窗口，打开了两个相同的程序:\n1 2 3 4 5 6 7 8 9 10 11 12 13  ... int stay_here; char tran_to_int[100]; printf(\u0026#34;Address: %p\\n\u0026#34;,\u0026amp;stay_here); fgets(tran_to_int,sizeof(tran_to_int), stdin); sscanf(tran_to_int,\u0026#34;%d\u0026#34;,\u0026amp;stay_here); for(;;) { printf(\u0026#34;%d\\n\u0026#34;, stay_here); getchar(); ++stay_here; } ...   对此程序(引用前桥和弥的例子)，每敲击一次回车，值加1。当你同时打开两个该程序时，你会发现，两个程序的stay_here都是在同一个地址，但对它进行分别操作时，产生的结果是独立的！这在某一方面验证了虚拟地址的合理性。虚拟地址的意义就在于，即使一个程序出现了错误，导致所在内存完蛋了，也不会影响到其他进程。对于程序中部的两个读取语句，是一种理解C语言输入流本质的好例子，建议查询用法，这里稍微解释一下:\n通俗地说，fgets将输入流中由调用起，stdin输入的东西存入起始地址为tran_to_int的地方，并且最多读取sizeof(tran_to_int)个，并在后方sscanf函数中将刚才读入的数据按照%d的格式存入stay_here，这就是C语言一直在强调的流概念的意义所在，这两个语句组合看起来也就是读取一个数据这么简单，但是我们要知道一个问题，一个关于scanf的问题\nscanf(\u0026quot;%d\u0026quot;,\u0026amp;stay_here);\n这个语句将会读取键盘输入，直到回车之前的所有数据，什么意思？就是回车会留在输入流中，被下一个输入读取或者丢弃。这就有可能会影响我们的程序，产生意料之外的结果。而使用上当两句组合则不会。\n函数与函数指针的那些事\n事实上，函数名出现在赋值符号右边就代表着函数的地址\n1 2 3 4 5  intfunction(int argc){/*...*/ } ... int(*p_fun)(int)=function; int(*p_fuc)(int)=\u0026amp;function;//和上一句意义一致   上述代码即声明并初始化了函数指针，p_fun的类型是指向一个返回值是int类型，参数是int类型的函数的指针\n1 2 3  p_fun(11); (*p_fun)(11); function(11);   上述三个代码的意义也相同，同样我们也能使用函数指针数组这个概念\nint(*p_func_arr[])(int)={func1, func2,};\r其中func1,func2都是返回值为int参数为int的函数，接着我们能像数组索引一样使用这个函数了。\nTips: 我们总是忽略函数声明，这并不是什么好事。\n在C语言中，因为编译器并不会对有没有函数声明过分深究，甚至还会放纵，当然这并不包含内联函数(inline)，因为它本身就只在本文件可用。\n比如，当我们在某个地方调用了一个函数，但是并没有声明它：\n1  CallWithoutDeclare(100);//参数100为 int 型   那么，C编译器就会推测，这个使用了int型参数的函数，一定是有一个int型的参数列表，一旦函数定义中的参数列表与之不符合，将会导致参数信息传递错误(编译器永远坚信自己是对的！)，我们知道C语言是强类型语言，一旦类型不正确，会导致许多意想不到的结果(往往是Bug)发生。\n对函数指针的调用同样如此\nC语言中malloc的那些事儿\n我们常常见到这种写法:\n1  int* pointer =(int*)malloc(sizeof(int));   这有什么奇怪的吗？看下面这个例子:\nint* pointer_2 = malloc(sizeof(int));\n哪个写法是正确的？两个都正确，这是为什么呢，这又要追求到远古C语言时期，在那个时候， void* 这个类型还没有出现的时候，malloc 返回的是 char* 的类型，于是那时的程序员在调用这个函数时总要加上强制类型转换，才能正确使用这个函数，但是在标准C出现之后，这个问题不再拥有，由于任何类型的指针都能与 void* 互相转换，并且C标准中并不赞同在不必要的地方使用强制类型转换，故而C语言中比较正统的写法是第二种。\n题外话: C++中的指针转换需要使用强制类型转换，而不能像第二种例子，但是C++中有一种更好的内存分配方法，所以这个问题也不再是问题。\nTips:\nC语言的三个函数malloc, calloc, realloc都是拥有很大风险的函数，在使用的时候务必记得对他们的结果进行校验，最好的办法还是对他们进行再包装，可以选择宏包装，也可以选择函数包装。\nrealloc函数是最为人诟病的一个函数，因为它的职能过于宽广，既能分配空间，也能释放空间，虽然看起来是一个好函数，但是有可能在不经意间会帮我们做一些意料之外的事情，例如多次释放空间。正确的做法就是，应该使用再包装阉割它的功能，使他只能进行扩展或者缩小堆内存块大小。\n指针与结构体\n1 2 3 4 5 6 7 8 9 10 11  typedefstruct tag{ int value; long vari_store[1]; }vari_struct; ```c 乍一看，似乎是一个很中规中矩的结构体 ```c ... vari_struct vari_1; vari_struct* vari_p_1 =\u0026amp;vari_1; vari_struct* vari_p_2 = malloc(sizeof(vari_struct))(   似乎都是这么用的，但总有那么一些人想出了一些奇怪的用法\n1 2  int what_spa_want =10; vari_struct* vari_p_3 = malloc(sizeof(vari_struct)+sizeof(long)*what_spa_want);    这么做是什么意思呢？这叫做可变长结构体，即便我们超出了结构体范围，只要在分配空间内，就不算越界。what_spa_want解释为你需要多大的空间，即在一个结构体大小之外还需要多少的空间，空间用来存储long类型，由于分配的内存是连续的，故可以直接使用数组vari_store直接索引。\n而且由于C语言中，编译器并不对数组做越界检查，故对于一个有N个数的数组arr，表达式\u0026amp;arr[N]是被标准允许的行为，但是要记住arr[N]却是非法的。\n这种用法并非是娱乐，而是成为了标准(C99)的一部分，运用到了实际中  对于内存的理解\n在内存分配的过程中，我们使用 malloc 进行分配，用 free 进行释放，但这是我们理解中的分配与释放吗？\n在调用 malloc 时，该函数或使用 brk() 或使用 mmap() 向操作系统申请一片内存，在使用时分配给需要的地方，与之对应的是 free，与我们硬盘删除东西一样，实际上:\n1 2 3 4  int* value = malloc(sizeof(int)*5); ... free(value); printf(\u0026#34;%d\\n\u0026#34;, value[0]);   代码中，为什么在 free 之后，我又继续使用这个内存呢？因为 free 只是将该内存标记上释放的标记，示意分配内存的函数，我可以使用，但并没有破坏当前内存中的内容，直到有操作对它进行写入。\n这便引申出几个问题:\nBug更加难以发现，让我们假设，如果我们有两个指针p1,p2指向同一个内存，如果我们对其中某一个指针使用了 free(p1); 操作，却忘记了还有另一个指针指向它，那这就会导致很严重的安全隐患，而且这个隐患十分难以发现，原因在于这个Bug并不会在当时显露出来，而是有可能在未来的某个时刻，不经意的让你的程序崩溃。\n有可能会让某些问题更加简化，例如释放一个条条相连的链表域。\n某些大哥提到说，free并不是什么都不做，而是将该段地址空间的前面一小部分置零\n但是如果地址空间很长的话，依旧有误用的风险，希望大家还是警惕\n实际上之所以库作者不让free操作将地址空间清空，有一部分原因是为了性能考虑，因为置零操作是一个消耗性能的行为，具体可以自行尝试，所谓双刃剑就在于此。\n 总的来说，还是那句话C语言是一把双刃剑。     所以，指针其实就是一个存放了另外一个存储空间的地址的存储空间，从而可以由本指针存储空间访问到另外一个存储空间！      \u0026mdash;\u0026ndash;摘抄自《c语言进阶》一书\n","description":"都2020年了，还搞不懂c语言指针是什么？","id":59,"section":"article","tags":null,"title":"c语言指针！","uri":"https://xing-you-ji.github.io/article/program/c/c_pointer/"},{"content":"历史上，有多种辅助存储设备，比如软盘、光盘、硬盘、U 盘等，相对于内存，它们就是人们常说的“外存”，即外存储器（设备）。\n从软盘（Floppy Disk）启动计算机，这已经是过去的事了。软盘的尺寸比烟盒稍大一点，但是比较薄，采用塑料作为基片，上面是一层磁性物质，可以用来记录二进制位。这种塑料介质比较柔软，所以称为软盘。\n在数据记录原理上和软盘很相似的设备是硬盘（Hard Disk，HDD），而且它们几乎是同一个时代的产物。但是，与软盘不同，硬盘是多盘片、密封、高转速的，采用铝合金作为基片，并在表面涂上磁性物质来记录二进制位。这就使得它的盘片具有较高的硬度，故称为硬盘。\n   图1-1 一块被拆开密封盖的硬盘\r 如图1-1 所示，这是一块被拆开的硬盘，中间是用于记录数据的铝合金盘片，固定在中心的轴上，由一个高速旋转的马达驱动。附着在盘片表面的扁平锥状物，就是用于在盘片上读写数据的磁头。\n为了进一步搞清楚硬盘的内部构造，图1-2 给出了更为详细的图示。\n硬盘可以只有一个盘片（这称为单碟），也可能有好几个盘片。但无论如何，它们都串在同一个轴上，由电动机带动着一起高速旋转。一般来说，转速可以达到每分钟3600 转或者7200转，有的能达到一万多转，这个参数就是我们常说的“转/分钟”（Round Per Minute，RPM）。\n   图1-2 硬盘的结构示意图\r 每个盘片都有两个磁头（Head），上面一个，下面一个，所以经常用磁头来指代盘面。磁头都有编号，第1 个盘片，上面的磁头编号为0，下面的磁头编号为1；第2 个盘片，上面的磁头编号为2，下面的磁头编号为3，以此类推。\n每个磁头不是单独移动的。相反，它们都通过磁头臂固定在同一个支架上，由步进电动机带动着一起在盘片的中心和边缘之间来回移动。也就是说，它们是同进退的。步进电动机由脉冲驱动，每次可以旋转一个固定的角度，即可以步进一次。\n可以想象，当盘片高速旋转时，磁头每步进一次，都会从它所在的位置开始，绕着圆心“画”出一个看不见的圆圈，这就是磁道（Track）。磁道是数据记录的轨迹。因为所有磁头都是联动的，故每个盘面上的同一条磁道又可以形成一个虚拟的圆柱，称为柱面（Cylinder）。\n磁道，或者柱面，也要编号。编号是从盘面最边缘的那条磁道开始，向着圆心的方向，从0开始编号。\n柱面是一个用来优化数据读写的概念。初看起来，用硬盘来记录数据时，应该先将一个盘面填满后，再填写另一个盘面。实际上，移动磁头是一个机械动作，看似很快，但对处理器来说，却很后，再填写另一个盘面。实际上，移动磁头是一个机械动作，看似很快，但对处理器来说，却很漫长，这就是寻道时间。为了加速数据在硬盘上的读写，最好的办法就是尽量不移动磁头。这样，当0 面的磁道不足以容纳要写入的数据时，应当把剩余的部分写在1 面的同一磁道上。如果还写不下，那就继续把剩余的部分写在2 面的同一磁道上。换句话说，在硬盘上，数据的访问是以柱面来组织的。\n实际上，磁道还不是硬盘数据读写的最小单位，磁道还要进一步划分为扇区（Sector）。磁道很窄，也看不见，但在想象中，它仍呈带状，占有一定的宽度。将它划分许多分段之后，每一部分都呈扇形，这就是扇区的由来。\n每条磁道能够划分为几个扇区，取决于磁盘的制造者，但通常为63 个。而且，每个扇区都有一个编号，与磁头和磁道不同，扇区的编号是从1 开始的。\n扇区与扇区之间以间隙（空白）间隔开来，每个扇区以扇区头开始，然后是512 个字节的数据区。扇区头包含了每个扇区自己的信息，主要有本扇区的磁道号、磁头号和扇区号，用来供硬盘定位机构使用。现代的硬盘还会在扇区头部包括一个指示扇区是否健康的标志，以及用来替换该扇区的扇区地址。用于替换扇区的，是一些保留和隐藏的磁道。\n","description":"硬盘的构造及其工作原理","id":60,"section":"article","tags":null,"title":"硬盘到底是什么！","uri":"https://xing-you-ji.github.io/article/computer/hard_disk/"}]